<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>Reader Q&#38;A &#8211; Sutter’s Mill</title>
	<atom:link href="https://herbsutter.com/category/reader-qa/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Fri, 23 Nov 2018 09:32:07 +0000	</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='herbsutter.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>Reader Q&#038;A &#8211; Sutter’s Mill</title>
		<link>https://herbsutter.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://herbsutter.com/osd.xml" title="Sutter’s Mill" />
	<atom:link rel='hub' href='https://herbsutter.com/?pushpress=hub'/>
	<item>
		<title>Reader Q&#038;A: volatile (again)</title>
		<link>https://herbsutter.com/2012/10/16/reader-qa-volatile-again/</link>
				<comments>https://herbsutter.com/2012/10/16/reader-qa-volatile-again/#comments</comments>
				<pubDate>Tue, 16 Oct 2012 15:53:44 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Effective Concurrency]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1631</guid>
				<description><![CDATA[Sarmad Asgher asked a variant of a perennial question: I am implementing multi producer single consumer problem. I have shared variables like m_currentRecordsetSize which tells the current size of the buffer. I am using m_currentRecordsetSize in a critical section do i need to declare it as volatile. If you’re in C or C++, and the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Sarmad Asgher asked a variant of a perennial question:</p>
<blockquote>
<p>I am implementing multi producer single consumer problem. I have shared variables like m_currentRecordsetSize which tells the current size of the buffer. I am using m_currentRecordsetSize in a critical section do i need to declare it as volatile.</p>
</blockquote>
<p>If you’re in C or C++, and the variable is not already being protected by a mutex or similar, then you need to declare it <em>atomic</em> (e.g., if it’s an <em>int</em>, then <em>atomic_int</em> in C or <em>atomic&lt;int&gt;</em> in C++. Not <em>volatile</em>.</p>
<blockquote>
<p>Also is there any article by you on this topic. Please do reply.</p>
</blockquote>
<p>There is! See my article <a href="https://herbsutter.com/2009/01/12/effective-concurrency-volatile-vs-volatile/"><strong>“volatile vs. volatile”</strong></a> for the difference and why C/C++ <em>volatile</em> has nothing to do with inter-thread communication.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/10/16/reader-qa-volatile-again/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: Why don&#8217;t modern smart pointers implicitly convert to *?</title>
		<link>https://herbsutter.com/2012/06/21/reader-qa-why-dont-modern-smart-pointers-implicitly-convert-to/</link>
				<comments>https://herbsutter.com/2012/06/21/reader-qa-why-dont-modern-smart-pointers-implicitly-convert-to/#comments</comments>
				<pubDate>Thu, 21 Jun 2012 20:58:35 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1574</guid>
				<description><![CDATA[Today a reader asked a common question: Why doesn&#8217;t unique_ptr (and the ilk) appear to have an operator overload somewhat as follows: operator T*() { return get(); }; The reason I ask is because we have reams of old code wanting raw pointers (as function parms), and I would like to replace the outer layers [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Today a reader asked a common question:</p>
<blockquote>
<p>Why doesn&#8217;t <em>unique_ptr</em> (and the ilk) appear to have an operator overload somewhat as follows:</p>
<p><em>operator T*() { return get(); };</em></p>
<p>The reason I ask is because we have reams of old code wanting raw pointers (as function parms), and I would like to replace the outer layers of the code which deal with the allocation and deallocation with <em>unique_ptr</em>s without having to either ripple <em>unique_ptr</em>s through the entire system or explicitly call <em>.get() </em>every time the <em>unique_ptr </em>is a parm to a function which wants a raw pointer.</p>
<p>What my programmers are doing is creating a <em>unique_ptr</em> and immediately using <em>get()</em> to put it into a local raw pointer which is used from then on. Somehow that doesn&#8217;t feel right, but I don&#8217;t know what would be the best alternative.</p>
</blockquote>
<p>In the olden days, smart pointers often did provide the convenience of implicit conversion to *. It was by using those smart pointers that we learned it caused more problems than it solves, and that requiring people to write <em>.get()</em> was actually not a big deal.</p>
<p>For an example of the problems of implicit conversions, consider:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:8cba2f5e-981e-475e-9082-42b8b86c529f" class="wlWriterEditableSmartContent" style="float:none;margin:0;display:inline;padding:0;">
<pre style="white-space:normal;">
<pre class="brush: cpp; gutter: false; pad-line-numbers: true; title: ; notranslate">
unique_ptr p( new widget );
...
use( p + 42 ); // error (maybe he meant "*p + 42"?)
    // but if implicit conversion to * were allowed, would silently compile -- urk
...
delete p; // error
    // but if implicit conversion to * were allowed, would silently compile -- double urk
</pre>
</div>
<p>For more, see also Andrei’s <em>Modern C++ Design</em> <a href="http://www.informit.com/articles/article.aspx?p=31529&amp;seqNum=7">section 7.7, “Implicit Conversion to Raw Pointer Types.”</a></p>
<p>However, this really isn’t as bad as most people fear for several reasons, including but not limited to:</p>
<ul>
<li>The large majority of uses of the smart pointer, such as calling member functions on the object (e.g., <em>p-&gt;foo()</em>)&#160; just work naturally and effortlessly because we do have <em>operator-&gt;</em>.</li>
<li>You rarely if ever need to say <em>unique_ptr</em> on a local variable, because C++11’s <em>auto </em>is your friend – and “rarely” becomes “never” if you use <em>make_unique</em> which is described <a href="https://herbsutter.com/gotw/_102/">here</a> and should become standard in the future.</li>
<li>Parameters (which you mention) themselves should almost never be smart pointers, but should be normal pointers and references. So if you’re managing an object’s lifetime by smart pointer, you do write <em>.get()</em> – but only once at the top of each call tree. More on this in the current <a href="https://herbsutter.com/2012/06/05/gotw-105-smart-pointers-part-3-difficulty-710/">GotW #105</a> – solution coming soon, watch this space.</li>
</ul>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/06/21/reader-qa-why-dont-modern-smart-pointers-implicitly-convert-to/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: What about VC++ and C99?</title>
		<link>https://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/</link>
				<comments>https://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/#comments</comments>
				<pubDate>Thu, 03 May 2012 17:53:28 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1517</guid>
				<description><![CDATA[I occasionally get asked about whether, or how well, Visual C++ supports C99. This week, I just posted two replies to this questions on UserVoice (merged below). Last fall, I also answered it in an interview with Dr. Dobb’s (recommended for some rationale discussion). The short answer is that Visual C++’s focus is to support [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.files.wordpress.com/2012/05/image.png"><img title="image" style="border-top:0;border-right:0;background-image:none;border-bottom:0;float:right;padding-top:0;padding-left:0;margin:10px 0 10px 10px;border-left:0;display:inline;padding-right:0;" border="0" alt="image" align="right" src="https://herbsutter.files.wordpress.com/2012/05/image_thumb.png?w=320&#038;h=112" width="320" height="112" /></a>I occasionally get asked about whether, or how well, Visual C++ supports C99.</p>
<ul>
<li>This week, I <a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2089423-c99-support">just posted two replies to this questions on UserVoice</a> (merged below).</li>
<li>Last fall, I also <a href="http://www.drdobbs.com/cpp/231900562">answered it in an interview with Dr. Dobb’s</a> (recommended for some rationale discussion).</li>
</ul>
<p>The short answer is that Visual C++’s focus is to support ISO C code that is supported by ISO C90 or ISO C++ (98 or 11). For the longer answer, I’m combining my UserVoice answers below, plus an additional comment about <em>restrict</em> in particular.</p>
<hr />
<p>Our focus in Visual C++ is on making a world-class C++ compiler, and we&#8217;re heads-down on C++11 conformance. For C programmers, the good news is twofold:</p>
<p><strong>1. Our primary goal is to support &quot;most of C99/C11 that is a subset of ISO C++98/C++11.&quot;</strong></p>
<ul>
<li>VC++ 2010 already fully supports the C subset of C++98, including things like <strong>&lt;stdint.h&gt;</strong> and declarations in the middle of a block.[*] The C subset of C++98 is approximately C95 (with very few incompatibilities with C95; i.e., there are very few cases where legal C95 code has a different meaning or is invalid in C++98) plus a few C99 features like declaring variables in the middle of blocks).</li>
<li>VC++11 now in beta already adds partial support for the C11 subset of C++11 (e.g., it supports the new C11 <strong>atomic_int</strong> types for concurrency and parallelism).</li>
<li>Soon after VC++11 ships we have announced we will do out-of-band releases for additional C++11 conformance which will naturally also include more C11 features that are in the C subset of C++11. We intend to implement all of the C++11 standard, which includes much of C99 &#8212; roughly, it includes the C99 preprocessor and library extensions but not the language extensions like restrict.</li>
</ul>
<p>So we already support large subsets of C99 and some-and-soon-more of C11. Our immediate and long-term goal is to fully support the C subsets of ISO C++.</p>
<p><strong>2. We also for historical reasons ship a C90 compiler which accepts (only) C90 and not C++.</strong></p>
<p>For the (hopefully rare) cases where legal C90 code has a different meaning in C++98 and this matters to C developers, for backward compatibility with older C90 code we also continue to ship a C compiler that implements Standard C90 exactly (using /TC or naming files as something.c).</p>
<p>Granted, however, there is also bad news for C programmers:</p>
<p><strong>3. We do not plan to support ISO C features that are not part of either C90 or ISO C++.</strong></p>
<p>I understand C programmers may be disappointed or angry with this answer and I&#8217;m sorry to have to say no here. It&#8217;s true, and very quotable, that <a href="https://www.google.com/#sclient=psy-ab&amp;q=focus+means+saying+no">&quot;focus means saying no,&quot;</a> but that doesn&#8217;t make it easy to say &#8212; it is hard to say no to you, and I&#8217;m sorry to say it. But we have to choose a focus, and our focus is to implement (the standard) and innovate (with extensions like everyone but which we also contribute for potential standardization) in C++.</p>
<p><strong>Recommendations</strong></p>
<p>We recommend that C developers use the C++ compiler to compile C code (using /TP if the file is named something.c). This is the best choice for using Visual C++ to compile C code.</p>
<p>Alternatively, we recommend that C developers use the C90 compiler (using /TC or naming files as something.c) if you need to write C90 conforming code that exercises some of the rarer cases that in C++98 are illegal or have changed meaning. This is a fallback primarily intended to support historical C code.</p>
<p>If you really need either of the following:</p>
<ul>
<li>features in C95/C99/C11 that are not part of ISO C++; or</li>
<li>features in C that are in the C++ subset but without also enabling the writing of C++ code;</li>
</ul>
<p>then we recommend that you consider using a different compiler such as Intel or gcc (short-term) and/or pressure your standards committee representatives to have ISO C++ include more of the C standard (longer-term).</p>
<p>&#160; </p>
<p><font color="#666666">[*] Visual C++ also partly supports some C99 language features under a slightly different syntax and possibly with slightly different semantics. Notably, we support </font><a href="http://msdn.microsoft.com/en-us/library/5ft82fed(v=vs.80).aspx"><strong><font color="#666666">__restrict</font></strong></a><font color="#666666"> – we did (and could again) consider allowing the standard C99 spelling <strong>restrict</strong> here for this feature, but please understand that this is not as simple as it looks. Not only the VC++ team, but also the ISO C++ standards committee, considered adding <strong>restrict</strong> to VC++ and ISO C++, respectively. Although it was specifically suggested for ISO C++11, it was rejected, in part because it’s not always obvious how it extends to C++ code because C++ is a larger language with more options and we would want to make sure the feature works correctly across the entire language.</font></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/05/03/reader-qa-what-about-vc-and-c99/feed/</wfw:commentRss>
		<slash:comments>52</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2012/05/image_thumb.png" medium="image">
			<media:title type="html">image</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: Flash Redux</title>
		<link>https://herbsutter.com/2012/04/24/reader-qa-flash-redux/</link>
				<comments>https://herbsutter.com/2012/04/24/reader-qa-flash-redux/#comments</comments>
				<pubDate>Tue, 24 Apr 2012 21:30:01 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[Apple]]></category>
		<category><![CDATA[Microsoft]]></category>
		<category><![CDATA[Opinion & Editorial]]></category>
		<category><![CDATA[Reader Q&A]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Web]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1497</guid>
				<description><![CDATA[David Braun asked: @Tom @Herb: What’s so wrong with flash that it should be boycotted? Have I been being abused by it in some way I’m not aware of? Also,does HTML5 have any bearing on the subject? I’m not saying it should be boycotted, only that I avoid it. Here&#8217;s what I wrote two years [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>David Braun asked:</p>
<blockquote><p>@Tom @Herb: What’s so wrong with flash that it should be boycotted? Have I been being abused by it in some way I’m not aware of? Also,does HTML5 have any bearing on the subject?</p></blockquote>
<p>I’m not saying it should be boycotted, only that I avoid it. Here&#8217;s what I wrote two years ago: <a href="https://herbsutter.com/2010/03/30/flash-in-the-pan/">“Flash In the Pan”</a>.  Besides security issues and crashing a lot, Flash is a headache for servicing and seems to be architecturally unsuited for lower-power environments.</p>
<p>Since then, two more major developments:</p>
<h3>1. Even Adobe has given ground (if not given up).</h3>
<p>Adobe subsequently <a href="http://blogs.adobe.com/conversations/2011/11/flash-focus.html">abandoned Flash for mobile browsers</a> and started shipping <a href="http://html.adobe.com/">straight-to-HTML5 tools</a>.</p>
<p>Granted, Adobe says it’s abandoning Flash ‘only for new mobile device browsers while still supporting it for PC browsers.’ This is still a painful statement because:</p>
<ul>
<li>it’s obvious that ceding such <a href="http://www.zdnet.com/blog/networking/flash-is-dead-long-live-html5/1633">high-profile</a> and <a href="http://www.imore.com/2010/04/29/adobe-ceo-responds-steve-jobs-open-letter/">hard-fought</a> ground sends a message about overall direction; and</li>
<li>the distinction between mobile devices and PCs is quickly disappearing as of this year as PCs are becoming fully mobilized (more on this in my next blog post).</li>
</ul>
<h3>2. We’re moving toward plugin-avoiding browsing.</h3>
<p>Browsers are increasingly moving to reduce plugins, or eliminate them outright, for security/reliability/servicing reasons. Moving in that direction crease pressure or necessity to either:</p>
<ul>
<li>ban Flash (Mobile Safari, and <a href="http://news.cnet.com/8301-30685_3-20105870-264/microsoft-joins-the-anti-flash-crowd-with-ie10/">Metro style Internet Explorer 10</a>); or</li>
<li>deliver Flash built into the browser itself (even for plugin-allowing browsers <a href="http://support.google.com/chrome/bin/answer.py?hl=en&amp;answer=108086">like Chrome</a>).</li>
</ul>
<p>I’m not saying Flash will die off immediately or necessarily even die off entirely at all; there’s a lot of inertia, it’s still useful in many kinds of devices, and it may well hang on for some time. But its architectural problems and current trajectory are fairly clear, and it’s been months since I’ve heard someone complain that certain people were just <a href="http://www.apple.com/hotnews/thoughts-on-flash/">being unfair</a> – Jobs’ technical points are on the right side of history.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/24/reader-qa-flash-redux/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: What does it mean for [[attributes]] to affect language semantics?</title>
		<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/</link>
				<comments>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comments</comments>
				<pubDate>Thu, 05 Apr 2012 20:45:59 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442</guid>
				<description><![CDATA[Followup on this earlier question, @bilbothegravatar asked: @Alf, @Herb – I don’t quite get the [[noreturn]] example. While it may (not) compile on VC++, (as far as I understand) it does not carry any semantic meaning, and, what’s more, it is *perfectly* safe for any compiler that sees [[noreturn]] to just ignore it — the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Followup on <a href="https://herbsutter.com/2012/04/02/reader-qa-keywords-and-attributes">this earlier question</a>, <a href="https://herbsutter.com/2012/04/02/reader-qa-keywords-and-attributes/#comment-5100">@bilbothegravatar asked</a>:</p>
<blockquote><p>@Alf, @Herb – I don’t quite get the [[noreturn]] example. While it may (not) compile on VC++, (as far as I understand) it does not carry any semantic meaning, and, what’s more, it is *perfectly* safe for any compiler that sees [[noreturn]] to just ignore it — the runtime behaviour vs. VC++ shouldn’t be changed at all.</p>
<p>So how is [[noreturn]] in the same camp as “restrict” ??? (I agree it may(?) be in the same camp as final and override.)</p>
<p>I will quote Bjarne: (<a href="http://www2.research.att.com/~bs/C++0xFAQ.html#attributes">http://www2.research.att.com/~bs/C++0xFAQ.html#attributes</a>)<br />
&gt; There is a reasonable fear that attributes will be used to create language dialects.<br />
&gt; The recommendation is to use attributes to only control things that do not affect the meaning<br />
&gt; of a program but might help detect errors (e.g. [[noreturn]])<br />
&gt; or help optimizers (e.g. [[carries_dependency]]).</p></blockquote>
<p>Yes, this argument was used. I’m (even) more conservative than Bjarne on this one.</p>
<p>People spoke up for two main different views on the question, “what does it mean to say [[attributes]] should not affect language semantics?” For convenience I’ll label these as the “weak” and “strong” views. Both views agree that if a program is valid both with and without the attribute, it should have exactly the same meaning both ways. Where the two views/camps differ is on whether it counts as &#8220;changing the meaning of the program&#8221; if a program that is valid if the attribute is ignored is rejected (fails to compile) if the attribute is observed:</p>
<ul>
<li>The “weak” view says that&#8217;s okay because it didn’t really change the meaning of code that could ever execute, it just caused it to fail to compile. <span style="color:#a5a5a5;">(I know, [[noreturn]] seems like it’s doing that&#8230; but it actually doesn’t quite meet this definition in my opinion, see below.)</span></li>
<li>The “strong” view, which I strongly support, says that calling a program illegal not only is the most dramatic semantic change possible, but also should be considered a nonconforming extension because it rejects code that is legal in the standard. <span style="color:#a5a5a5;">(I know, [[noreturn]] in particular is standard&#8230; but it’s still problematic for this reason, see below.)</span></li>
</ul>
<p>On principle, I do not like opening the door to let compiler writers use [[attributes]] as an excuse to not respect legal ISO C++ programs. And I say that as someone who works on a C++ compiler team and actively does C++ language extension design, and having the excuse of disabling part of ISO C++ that I don’t like by throwing in an [[attribute]] could be useful. Don’t get me wrong, there are corner cases of C++ I would like to turn off, but I try hard (and so far successfully) to refrain from doing such a thing without ISO C++’s blessing because it would break source code portability. Encouraging the view that nonstandard [[attributes]] can be a legitimate excuse to reject conforming C++ programs strikes me as putting a live grenade in a public square with a &#8220;pull me&#8221; tag on the pin. The whole point and primary benefit of having an ISO standard for C++ is to guarantee source portability; this weakens that, and for that reason I view it as a dangerous position to take.</p>
<p>However, in general the “weak” interpretation prevailed, and on those grounds [[noreturn]] and [[carries_dependency]] remained an attribute. I didn’t fight it because at least we got to remove [[final]], [[override]] and [[base_check]] as attributes, which was my primary concern since those would see far more use, and as long as we fixed those I was happy to say I could live with the others in order to get a consensus standard.</p>
<h3>Post-Mortem: Assessing [[noreturn]]</h3>
<p><span style="color:#c0504d;"><strong>Disclaimer: </strong>The following is an informational analytical exercise, not a public lobbying for a change. I support where we ended up as a whole to get C++11, it is probably too late to tweak [[noreturn]], and I consciously didn’t pursue making the following arguments at the time because [[noreturn]] (and [[carries_dependency]] are so rarely used that I can live with them, and you have to be willing to give some ground to get a consensus standard – the important thing was to get [[final]], [[override]], and [[base_check]] out and then stop while you’re ahead.</span></p>
<p>With that disclaimer in place, let me present counterarguments to show why I believe that in an ideal world [[noreturn]] shouldn’t be an attribute because it really is a keyword in [[attributes]] clothing and doesn’t actually meet either the weak or the strong view:</p>
<ul>
<li>I don’t think that [[noreturn]] meets the bar set by the weak view, because it does more than just cause programs to fail to compile. In my opinion, adding [[noreturn]] <em>does </em>change the meaning of a conforming program, because the C++11 standard says in 7.6.3/2: <strong>“If a function f is called where f was previously declared with the noreturn attribute and f eventually returns, the behavior is undefined. &#8230; [Note: Implementations are encouraged to issue a warning if a function marked [[noreturn]] might return. —end note ]”</strong> – Even if respecting a [[noreturn]] did cause a compiler to reject some code (which is not required by the standard, and is not even mentioned even in the non-normative note which just talks about maybe issuing a warning), that means that <em>void f();</em> and <em>[[noreturn]] void f();</em> do not have the same semantics – returning from the first is always defined behavior (if you do it), and returning from the second is undefined behavior. This isn’t just a language-lawyerly argument either – the reason the standard says “undefined behavior” here is because that’s how the standard explicitly gives latitude to optimizers – it’s saying that “a compiler optimizer may assume the function doesn’t return, and optimize the code in ways that could cause different execution (even catch-fire semantics) if <em>f</em> ever actually does return.” Telling the compiler it may rely on this attribute to have meaning is, to me, clearly giving the attribute a language meaning and so changes the program’s semantics if it is present. So I don’t think it’s actually true that the presence of [[noreturn]] doesn’t affect language semantics.</li>
<li>It also doesn’t meet the strong view and discourages portability, by opening the door for using nonstandard attributes as a reason to reject conforming code. Now, it’s true that [[noreturn]] is in the standard itself, and so we might be tempted to say it’s not like a nonstandard attribute in this way that reduces portability, but it is – <strong>you cannot reliably write portable C++11 code under the assumption that [[noreturn]] has no semantic meaning and can be ignored.</strong> That’s because adding [[noreturn]] really does change the meaning of a function declaration (by adding guarantees that the optimizer can use, as described above) and so you really need to treat it as though it were a language keyword – because it is, just dressed in [[attributes]] clothing.</li>
</ul>
<p>So in my view [[noreturn]] is a keyword dressed in [[attributes]] clothing.</p>
<p>Having said all that, experts do disagree, and the two camps have simply had to agree to disagree on this question – we got unanimous consensus on the standard, even though [[noreturn]] and [[carries_dependency]] are a bit of a sore point, because everyone was satisfied enough that we at least averted having [[final]], [[override]] and [[base_check]].</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: auto and expression templates</title>
		<link>https://herbsutter.com/2012/04/03/reader-qa/</link>
				<comments>https://herbsutter.com/2012/04/03/reader-qa/#comments</comments>
				<pubDate>Tue, 03 Apr 2012 23:53:03 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437</guid>
				<description><![CDATA[Motti asked: While you’re dealing with reader’s Qs…. In your keynote in “Going Native” you mentioned that type inference should almost always be used, except for some obscure cases with expression templates. Yes. To give people context, the idea is when declaring local variables, prefer to use auto to deduce the type. For example: This [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.com/2012/04/02/reader-qa-keywords-and-attributes/#comment-5059">Motti asked</a>:</p>
<blockquote><p>While you’re dealing with reader’s Qs….</p>
<p>In <a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/C-11-VC-11-and-Beyond">your keynote in “Going Native”</a> you mentioned that type inference should almost always be used, except for some obscure cases with expression templates.</p></blockquote>
<p>Yes. To give people context, the idea is when declaring local variables, prefer to use <em>auto</em> to deduce the type. For example:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:888fd9d9-87d6-4162-8820-0f4d2e2802fa" class="wlWriterEditableSmartContent" style="margin:0;display:inline;float:none;padding:0;">
<pre class="brush: cpp; gutter: false; pad-line-numbers: true; title: ; notranslate">
auto x = begin(v);
</pre>
</div>
<blockquote><p>This seems like a rather serious wart on the language,</p></blockquote>
<p>It’s a wart, but I don’t know about “serious” – it doesn’t come up that often. Still, your question is quite apropos:</p>
<blockquote><p>part of the power of expression templates (to my understanding) is that they can be dropped in by a library implementer and thus improve the clients’ code without their knowledge.</p>
<p>Was there any discussion to allow type authors to opt-out of type inference? (e.g. by allowing an “operator auto()”). If this wasn’t discussed for C++11 is it being discussed for C++1y?</p></blockquote>
<p>Yes, and even exactly that spelling has been suggested. I’ll take that as a +1 for discoverability if we name it that!</p>
<blockquote><p>(For people reading this comment, if it doesn’t make any sense I wrote about it last year in my blog <a href="http://lanzkron.wordpress.com/2011/02/21/inferring-too-much/">http://lanzkron.wordpress.com/2011/02/21/inferring-too-much/</a>)</p></blockquote>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/03/reader-qa/feed/</wfw:commentRss>
		<slash:comments>10</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: When will better JITs save managed code?</title>
		<link>https://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/</link>
				<comments>https://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/#comments</comments>
				<pubDate>Tue, 03 Apr 2012 01:15:27 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1435</guid>
				<description><![CDATA[In the comments on last week’s interview, MichaelTK asked: @Herb: You mentioned two things I don’t fully understand in your talk. 1) Why would C++ be a better choice for very large scale applications than NET/Java? I mean the zero abstraction penalty (which is more a JIT compiler issue and not intrinsically hardwired into C#) [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>In the comments on <a href="https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/">last week’s interview</a>, MichaelTK asked:</p>
<blockquote>
<p>@Herb: You mentioned two things I don’t fully understand in your talk.</p>
<p>1) Why would C++ be a better choice for very large scale applications than NET/Java? I mean the zero abstraction penalty (which is more a JIT compiler issue and not intrinsically hardwired into C#) , okay, but besides that?</p>
<p>2) C++ really only has a few language features which actually let you write faster code in theory. In practice, JIT compilers are just not good enough, yet, to fully optimize on C++ pace and that’s one of the main reasons why C++ excels at efficiency. </p>
</blockquote>
<p>No, the reasons go deeper than that. I’m actually giving a talk at <a href="http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012">Lang.NEXT</a> on Wednesday which focuses exactly on the managed/native divide. I’ll post a link next week.</p>
<p>In the meantime, short answer: C++ and managed languages make different fundamental tradeoffs that opt for either performance or productivity when they are in tension.</p>
<blockquote>
<p>Why does Microsoft not put effort into a static C++ like compiler for C#/NET, say in manner of NGen, so that C# actually has even the slightest chance of being competitive with C++? </p>
</blockquote>
<p>Actually, Microsoft has been actively investing in that for over a decade. So have Java vendors. I expect those efforts to continue.</p>
<blockquote>
<p>Otherwise, saying C++ is more efficient than C# is not a theoretical issue, but caused by bad JIT compilers.</p>
</blockquote>
<p>This is a 199x/200x meme that’s hard to kill – “just wait for the next generation of (JIT or static) compilers and then managed languages will be as efficient.” Yes, I fully expect C# and Java compilers to keep improving – both JIT and NGEN-like static compilers. But no, they won’t erase the efficiency difference with native code, for two reasons.</p>
<p>First, JIT compilation isn’t the main issue. The root cause is much more fundamental: Managed languages made deliberate design tradeoffs to optimize for programmer productivity even when that was fundamentally in tension with, and at the expense of, performance efficiency. (This is the opposite of C++, which has added a lot of productivity-oriented features like auto and lambdas in the latest standard, but never at the expense of performance efficiency.) In particular, managed languages chose to incur costs even for programs that don’t need or use a given feature; the major examples are assumption/reliance on always-on or default-on garbage collection, a virtual machine runtime, and metadata. But there are other examples; for instance, managed apps are built around virtual functions as the default, whereas C++ apps are built around inlined functions as the default, and an ounce of inlining prevention is worth a pound of devirtualization optimization cure.</p>
<p>Second, even if JIT were the only big issue, a JIT can never be as good as a regular optimizing compiler because a JIT compiler is in the business of being fast, not in the business of generating optimal code. Yes, JITters can target the user’s actual hardware and theoretically take advantage of a specific instruction set and such, but at best that’s a theoretical advantage of NGEN approaches (specifically, installation-time compilation), not JIT, because a JIT has no time to take much advantage of that knowledge, or do much of anything besides translation and code gen.</p>
<p>More in the talk on Wednesday (for those who are at the conference) which will go live online next week&#8230; I’ll blog about it when it’s up.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/feed/</wfw:commentRss>
		<slash:comments>58</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: Keywords and Attributes</title>
		<link>https://herbsutter.com/2012/04/02/reader-qa-keywords-and-attributes/</link>
				<comments>https://herbsutter.com/2012/04/02/reader-qa-keywords-and-attributes/#comments</comments>
				<pubDate>Tue, 03 Apr 2012 00:45:14 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Reader Q&A]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1433</guid>
				<description><![CDATA[Referring to C++ AMP, a reader emailed me to ask: Are you going to replace restrict keyword with new C++11 attribute feature [[]] ? No, because restrict is a language feature and [[attributes]] are specifically designed to be ignorable and shouldn’t be used for things having language semantic meaning. During the ISO C++11 process, I [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Referring to <a href="http://blogs.msdn.com/b/nativeconcurrency/archive/2012/02/03/c-amp-open-spec-published.aspx">C++ AMP</a>, a reader emailed me to ask:</p>
<blockquote>
<p>Are you going to replace <b>restrict </b>keyword with new C++11 attribute feature [[]] ?</p>
</blockquote>
<p>No, because <em>restrict </em>is a language feature and [[attributes]] are specifically designed to be ignorable and shouldn’t be used for things having language semantic meaning. During the ISO C++11 process, I was heavily involved in a long battle to try to prevent keywords dressed in [[attributes]] clothing from sneaking into the standard; for example, C++11 <em>final </em>and <em>override </em>used to be <em>[[final]] </em>and <em>[[override]]</em> in pre-final* drafts and I led the charge against that, and with the help of likeminded people it was overturned.</p>
<p>&#160;</p>
<p>* pun intended</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/02/reader-qa-keywords-and-attributes/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
	</channel>
</rss>
