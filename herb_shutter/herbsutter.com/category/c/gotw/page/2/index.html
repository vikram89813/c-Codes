<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head profile="http://gmpg.org/xfn/11">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>GotW | Sutter’s Mill | Page 2</title>
<link rel="pingback" href="https://herbsutter.com/xmlrpc.php" />
<script type="text/javascript">
  WebFontConfig = {"typekit":{"id":"eyo0tqd"}};
  (function() {
    var wf = document.createElement('script');
    wf.src = 'https://s0.wp.com/wp-content/plugins/custom-fonts/js/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
	})();
</script><style id="jetpack-custom-fonts-css">.wf-active #header h1{font-size:2.12em;font-family:"ff-dagny-web-pro-1","ff-dagny-web-pro-2",sans-serif;font-style:normal;font-weight:400}.wf-active body{font-size:89.7%;font-family:"ff-basic-gothic-web-pro-1","ff-basic-gothic-web-pro-2",sans-serif}.wf-active #navigation{font-family:"ff-basic-gothic-web-pro-1","ff-basic-gothic-web-pro-2",sans-serif}.wf-active #navigation ul li.search{font-size:1.06em}.wf-active #navigation ul li.search input#searchsubmit{font-size:1.06em}.wf-active #content .post-info, .wf-active #content .postmetadata{font-size:1.06em}.wf-active #sidebar{font-size:1.06em}.wf-active #footer p.right{font-size:1.06em}.wf-active .commentnum{font-size:1.77em}.wf-active .commentlist li .cmtinfo{font-size:1.18em}.wf-active .commentlist li .cmtinfo em{font-size:1.06em}.wf-active #respond label{font-size:11.8px}.wf-active #respond .required{font-size:11.8px}.wf-active #respond .subscribe-label{font-size:14.2px}.wf-active #respond .comment-notes{font-size:13px}.wf-active .wp-caption p.wp-caption-text{font-size:13px}.wf-active #content h1, .wf-active h2, .wf-active h3, .wf-active h4, .wf-active h5, .wf-active h6{font-family:"ff-dagny-web-pro-1","ff-dagny-web-pro-2",sans-serif;font-style:normal;font-weight:400}.wf-active #header h2{font-size:1.18em;font-weight:400;font-family:"ff-dagny-web-pro-1","ff-dagny-web-pro-2",sans-serif;font-style:normal}.wf-active #content h3{font-size:1.65em;font-weight:400;font-style:normal}.wf-active #content h4{font-size:1.3em;font-style:normal;font-weight:400}.wf-active #content h5{font-size:1.18em;font-style:normal;font-weight:400}.wf-active #content .post h2{font-size:1.65em;font-weight:400;font-style:normal}.wf-active li.sidebox h2{font-weight:400;font-size:1.89em;font-style:normal}.wf-active .post h4{font-size:1.18em;font-weight:400;font-family:"ff-dagny-web-pro-1","ff-dagny-web-pro-2",sans-serif;font-style:normal}.wf-active .post h4 em{font-style:normal;font-weight:400}</style>
		<script src='https://r-login.wordpress.com/remote-login.php?action=js&amp;host=herbsutter.com&amp;id=3379246&amp;t=1542965503&amp;back=https%3A%2F%2Fherbsutter.com%2Fcategory%2Fc%2Fgotw%2Fpage%2F2%2F' type="text/javascript"></script>
		<script type="text/javascript">
		/* <![CDATA[ */
			if ( 'function' === typeof WPRemoteLogin ) {
				document.cookie = "wordpress_test_cookie=test; path=/";
				if ( document.cookie.match( /(;|^)\s*wordpress_test_cookie\=/ ) ) {
					WPRemoteLogin();
				}
			}
		/* ]]> */
		</script>
		<link rel='dns-prefetch' href='//s2.wp.com' />
<link rel='dns-prefetch' href='//s1.wp.com' />
<link rel='dns-prefetch' href='//s0.wp.com' />
<link rel='dns-prefetch' href='//herbsutter.wordpress.com' />
<link rel="alternate" type="application/rss+xml" title="Sutter’s Mill &raquo; Feed" href="https://herbsutter.com/feed/" />
<link rel="alternate" type="application/rss+xml" title="Sutter’s Mill &raquo; Comments Feed" href="https://herbsutter.com/comments/feed/" />
<link rel="alternate" type="application/rss+xml" title="Sutter’s Mill &raquo; GotW Category Feed" href="https://herbsutter.com/category/c/gotw/feed/" />
	<script type="text/javascript">
		/* <![CDATA[ */
		function addLoadEvent(func) {
			var oldonload = window.onload;
			if (typeof window.onload != 'function') {
				window.onload = func;
			} else {
				window.onload = function () {
					oldonload();
					func();
				}
			}
		}
		/* ]]> */
	</script>
			<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s0.wp.com\/wp-content\/mu-plugins\/wpcom-smileys\/twemoji\/2\/72x72\/","ext":".png","svgUrl":"https:\/\/s0.wp.com\/wp-content\/mu-plugins\/wpcom-smileys\/twemoji\/2\/svg\/","svgExt":".svg","source":{"concatemoji":"https:\/\/s1.wp.com\/wp-includes\/js\/wp-emoji-release.min.js?m=1532082729h&ver=4.9.8"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56760,9792,65039],[55358,56760,8203,9792,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel='stylesheet' id='all-css-0-1' href='https://s0.wp.com/_static/??-eJyNkN1uwjAMhV9onrUN1qtpz5K0JpjmT4kj1LfHpeoEglXcROck53Ns4zlDn6JQFAwNsm+OY0XPI1U8kWTTj3B1732tb/g8zvHAkWX6Ey+F5UhBf8nNYuAqk09p3AL7VEjvQzYyJwINbMhrjShbWMjfKzXLo060Ocw5axqszYVqBT0DtwBLsw/cCrmm1lJxMHeJtrEf0Pp03Z4tpkw4T0gPBZ4t4Z/obY88OJKKkjLkVFW9jNTUs/HAGrk3C8wYkyyPq9iq6iiBTmmEU7wzcPCGyxZaSPfjVDrU1I2dod/w87HffXZf3W7fnS4bTgAo?cssminify=yes' type='text/css' media='all' />
<link rel='stylesheet' id='print-css-1-1' href='https://s2.wp.com/wp-content/mu-plugins/global-print/global-print.css?m=1465851035h&cssminify=yes' type='text/css' media='print' />
<link rel='stylesheet' id='all-css-2-1' href='https://s0.wp.com/_static/??/wp-content/mu-plugins/actionbar/actionbar.css,/wp-content/themes/h4/global.css?m=1516985148j&cssminify=yes' type='text/css' media='all' />
<script type='text/javascript' src='https://s2.wp.com/_static/??-eJyF0G0KwjAMBuAL2dXJxP0Rz1Lr60hdP2zaDT29FSYiVIVAIHkISeQcBDk95hNYmhLXjHhbUmN4JX8BYWmIKqGx5F5Ye5fg0tNaf6QRIjOiGkqtDDr7iguekwVzQZXu50rkJsL8lxmkoPRFRDDdUTuEw3vn7x9Y1MHu267fbfp2263NA675cvs='></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="https://herbsutter.wordpress.com/xmlrpc.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="https://s1.wp.com/wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress.com" />
<link rel="shortcut icon" type="image/x-icon" href="https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=32" sizes="16x16" />
<link rel="icon" type="image/x-icon" href="https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=32" sizes="16x16" />
<link rel="apple-touch-icon-precomposed" href="https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=114" />
<link rel='openid.server' href='https://herbsutter.wordpress.com/?openidserver=1' />
<link rel='openid.delegate' href='https://herbsutter.wordpress.com/' />
<link rel="search" type="application/opensearchdescription+xml" href="https://herbsutter.com/osd.xml" title="Sutter’s Mill" />
<link rel="search" type="application/opensearchdescription+xml" href="https://s1.wp.com/opensearch.xml" title="WordPress.com" />
		<style id="wpcom-hotfix-masterbar-style">
			@media screen and (min-width: 783px) {
				#wpadminbar .quicklinks li#wp-admin-bar-my-account.with-avatar > a img {
					margin-top: 5px;
				}
			}
		</style>
		<script type="text/javascript" id="webfont-output">
  
  WebFontConfig = {"typekit":{"id":"cjs1oxc"}};
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
	})();
</script><style type="text/css">
.widget_twitter li {
	word-wrap: break-word;
}
</style>
<meta name="application-name" content="Sutter’s Mill" /><meta name="msapplication-window" content="width=device-width;height=device-height" /><meta name="msapplication-tooltip" content="Herb Sutter on software development" /><meta name="msapplication-task" content="name=Subscribe;action-uri=https://herbsutter.com/feed/;icon-uri=https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=16" /><meta name="msapplication-task" content="name=Sign up for a free blog;action-uri=http://wordpress.com/signup/;icon-uri=https://s1.wp.com/i/favicon.ico" /><meta name="msapplication-task" content="name=WordPress.com Support;action-uri=http://support.wordpress.com/;icon-uri=https://s1.wp.com/i/favicon.ico" /><meta name="msapplication-task" content="name=WordPress.com Forums;action-uri=http://forums.wordpress.com/;icon-uri=https://s1.wp.com/i/favicon.ico" /><meta name="description" content="Posts about GotW written by Herb Sutter" />
<style type="text/css">
			#header h1 a,
		#header h2 {
			color: #265E15 !important;
		}
				#headerimage {
			background: url('https://herbsutter.files.wordpress.com/2011/10/cropped-blog-header.jpg') no-repeat;
			height: 200px;
		}
	</style>
<style type="text/css" id="syntaxhighlighteranchor"></style>
		<link rel="stylesheet" id="custom-css-css" type="text/css" href="https://s2.wp.com/?custom-css=1&#038;csblog=eb5Y&#038;cscache=6&#038;csrev=60" />
		</head>
<body id="section-index" class="archive paged category category-gotw category-3867746 paged-2 category-paged-2 mp6 customizer-styles-applied highlander-enabled highlander-light infinite-scroll neverending">


<div id="navigation" class="clearfix">
		<div class="menu">
		<ul>
			<li ><a href="https://herbsutter.com/" title="Home">Home</a></li>
			<li class="page_item page-item-912"><a href="https://herbsutter.com/welcome-to-the-jungle/">Welcome to the&nbsp;Jungle</a></li>
<li class="page_item page-item-864 page_item_has_children"><a href="https://herbsutter.com/gotw/">GotW</a></li>
<li class="page_item page-item-761"><a href="https://herbsutter.com/elements-of-modern-c-style/">Elements of Modern C++&nbsp;Style</a></li>
<li class="page_item page-item-2 page_item_has_children"><a href="https://herbsutter.com/about/">About</a></li>
									<li class="search"><form method="get" id="searchform" action="https://herbsutter.com"><input type="text" class="textbox" value="" name="s" id="s" /><input type="submit" id="searchsubmit" value="Search" /></form></li>
					</ul>
	</div>
</div><!-- end id:navigation -->

<div id="container">

<div id="header">
<h1><a href="https://herbsutter.com/" title="Sutter’s Mill">Sutter’s Mill</a></h1>
<h2>Herb Sutter on software development</h2>
</div><!-- end id:header -->


	
		<div id="feedarea">
	<dl>
		<dt><strong>Feeds:</strong></dt>

			<dd><a href="https://herbsutter.com/feed/">Posts</a></dd>
	
			<dd><a href="https://herbsutter.com/comments/feed/">Comments</a></dd>
		</dl>
	</div><!-- end id:feedarea -->
	
	<div id="headerimage">
</div><!-- end id:headerimage -->

<div id="content">
<div id="content-main">
	              <h2 class="pagetitle">Archive for the &#8216;GotW&#8217; Category</h2>
      		
			<div class="post-2292 post type-post status-publish format-standard hentry category-gotw" id="post-2292">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/" rel="bookmark">GotW #7a Solution: Minimizing Compile-Time Dependencies, Part&nbsp;1</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-08-19|
													<a href="https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comments">16 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="color:#5a5a5a;"><em>Managing dependencies well is an essential part of writing solid code. C++ supports two powerful methods of abstraction: object-oriented programming and generic programming. Both of these are fundamentally tools to help manage dependencies, and therefore manage complexity. It&#8217;s telling that all of the common OO/generic buzzwords—including encapsulation, polymorphism, and type independence—along with most design patterns, are really about describing ways to manage complexity within a software system by managing the code&#8217;s interdependencies.<br />
</em></span></p>
<p><span style="color:#5a5a5a;"><em>When we talk about dependencies, we usually think of run-time dependencies like class interactions. In this Item, we will focus instead on how to analyze and manage compile-time dependencies. As a first step, try to identify (and root out) unnecessary headers.</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. For a function or a class, what is the difference between a forward declaration and a definition?</p>
<h2>Guru Question</h2>
<p>2. Many programmers habitually <span style="color:#2e74b5;">#include</span> many more headers than necessary. Unfortunately, doing so can seriously degrade build times, especially when a popular header file includes too many other headers.</p>
<p>In the following header file, what <span style="color:#2e74b5;">#include</span> directives could be immediately removed without ill effect? You may not make any changes other than removing or rewriting (including replacing) <span style="color:#2e74b5;">#include</span> directives. Note that the comments are important.</p>
<pre><code>//  x.h: original header
//
#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;list&gt;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include "a.h"  // class A
#include "b.h"  // class B
#include "c.h"  // class C
#include "d.h"  // class D
#include "e.h"  // class E

class X : public A, private B {
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
  };

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</code></pre>
<h1>Solution</h1>
<h2>1. For a function or class, what is the difference between a forward declaration and a definition?</h2>
<p>A forward declaration of a (possibly templated) function or class simply introduces a name. For example:</p>
<pre><code>class widget;  // "widget" names a class 

widget* p;     // ok: allocates sizeof(*) space typed as widget*

widget  w;     // error: wait, what? how big is that? does it have a
               //        default constructor?
</code></pre>
<p>Again, a forward declaration only <em>introduces a name</em>. It lets you do things that require only the name, such as declaring a pointer to it—all pointers to objects are the same size and have the same set of operations you can perform on them, and ditto for pointers to nonmember functions, so the name is all you need to make a strongly-typed and fully-usable variable that&#8217;s a pointer to class or pointer to function.</p>
<p>What a class forward declaration does <em>not</em> do is tell you anything about what you can do with the type itself, such as what constructors or member functions it has or how big it is if you want to allocate space for one. If you try to create a <span style="color:#2e74b5;">widget w;</span> with only the above code, you&#8217;ll get a compile-time error because <span style="color:#2e74b5;">widget</span> has no definition yet and so the compiler can&#8217;t know how much space to allocate or what functions the type has (including whether it has a default constructor).</p>
<p>A class definition has a body and lets you know the class&#8217;s size and know the names and types of its members:</p>
<pre><code>class widget { // "{" means definition
    widget();
    // ...
};

widget* p;     // ok: allocs sizeof(ptr) space typed as widget*

widget  w;     // ok: allocs sizeof(widget) space typed as widget
               //     and calls default constructor
</code></pre>
<h2>2. In the following header file, what #include directives could be immediately removed without ill effect?</h2>
<p>Of the first two standard headers mentioned in <span style="color:#2e74b5;">x.h</span>, one can be immediately removed because it&#8217;s not needed at all, and the second can be replaced with a smaller header:</p>
<h3>1. Remove iostream.</h3>
<pre><code>#include &lt;iostream&gt;
</code></pre>
<p>Many programmers <span style="color:#2e74b5;">#include &lt;iostream&gt;</span> purely out of habit as soon as they see anything resembling a stream nearby. Class <span style="color:#2e74b5;">X</span> does make use of streams, that&#8217;s true; but it doesn&#8217;t mention anything specifically from <span style="color:#2e74b5;">iostream</span>, which mainly declares the standard stream objects like <span style="color:#2e74b5;">cout</span>. At the most, <span style="color:#2e74b5;">X</span> needs <span style="color:#2e74b5;">ostream</span> alone for its <span style="color:#2e74b5;">basic_ostream</span> type, and even that can be whittled down as we will see.</p>
<blockquote><p><strong>Guideline:</strong> Never <strong>#include</strong> unnecessary header files.</p></blockquote>
<h3>2. Replace ostream with iosfwd.</h3>
<pre><code>#include &lt;ostream&gt;
</code></pre>
<p>Parameter and return types only need to be forward-declared, so instead of the full definition of <span style="color:#2e74b5;">ostream</span> we really only need its forward declaration.</p>
<p>However, you can&#8217;t write the forward declaration yourself using something like <span style="color:#2e74b5;">class ostream;</span>. First, <span style="color:#2e74b5;">ostream</span> lives in namespace <span style="color:#2e74b5;">std</span> in which you can&#8217;t redeclare existing standard types and objects. Second, <span style="color:#2e74b5;">ostream</span> is an alias for <span style="color:#2e74b5;">basic_ostream&lt;char&gt;</span> which you couldn&#8217;t reliably forward-declare even if you were allowed to because library implementations are allowed to do things like add their own extra template parameters beyond those required by the standard that of course your code wouldn&#8217;t know about—which is one of the primary reasons for the rule that programmers aren&#8217;t allowed to write their own declarations for things in namespace <span style="color:#2e74b5;">std</span>.</p>
<p>All is not lost, though: The standard library helpfully provides the header <span style="color:#2e74b5;">iosfwd</span>, which contains forward declarations for all of the stream templates and their standard aliases, including <span style="color:#2e74b5;">basic_ostream </span>and <span style="color:#2e74b5;">ostream</span>. So all we need to do is replace <span style="color:#2e74b5;">#include &lt;ostream&gt;</span> with <span style="color:#2e74b5;">#include &lt;iosfwd&gt;</span>.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to <strong>#include &lt;iosfwd&gt;</strong> when a forward declaration of a stream will suffice.</p></blockquote>
<p>Incidentally, once you see <span style="color:#2e74b5;">iosfwd</span>, one might think that the same trick would work for other standard library templates like <span style="color:#2e74b5;">string</span> and <span style="color:#2e74b5;">list</span>. There are, however, no comparable &#8220;stringfwd&#8221; or &#8220;listfwd&#8221; standard headers. The <span style="color:#2e74b5;">iosfwd</span> header was created to give streams special treatment for backwards compatibility, to avoid breaking code written in years past for the &#8220;old&#8221; non-templated version of the iostreams subsystem. It is hoped that a real solution will come in a future version of C++ that supports <em>modules</em>, but that&#8217;s a topic for a later time.</p>
<p>There, that was easy. We can now move on to…</p>
<p>… what? &#8220;Not so fast!&#8221; I hear some of you say. &#8220;This header does a lot more with <span style="color:#2e74b5;">ostream</span> than just mention it as a parameter or return type. The inlined <span style="color:#2e74b5;">operator&lt;&lt;</span> actually uses an <span style="color:#2e74b5;">ostream</span> object! So it must need <span style="color:#2e74b5;">ostream</span>&#8216;s definition, right?&#8221;</p>
<p>That&#8217;s a reasonable question. Happily, the answer is: No, it doesn&#8217;t. Consider again the function in question:</p>
<pre><code>std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</code></pre>
<p>This function mentions an <span style="color:#2e74b5;">ostream&amp;</span> as both a parameter and a return type, which most people know doesn&#8217;t require a definition. And it passes its <span style="color:#2e74b5;">ostream&amp;</span> parameter in turn as a parameter to another function, which many people <em>don&#8217;t</em> know doesn&#8217;t require a definition either—it&#8217;s the same as if it were a pointer, <span style="color:#2e74b5;">ostream*</span>, discussed above. As long as that&#8217;s all we&#8217;re doing with the <span style="color:#2e74b5;">ostream&amp;</span>, there&#8217;s no need for a full <span style="color:#2e74b5;">ostream</span> definition—we&#8217;re not really using an <span style="color:#2e74b5;">ostream</span> itself at all, such as by calling functions on it, we&#8217;re only using a reference to type for which we only need to know the name. Of course, we would need the full definition if we tried to call any member functions, for example, but we&#8217;re not doing anything like that here.</p>
<p>So, as I was saying, we can now move on to get rid of one of the other headers, but only one just yet:</p>
<h3>3. Replace e.h with a forward declaration.</h3>
<pre><code>#include "e.h"  // class E
</code></pre>
<p>Class <span style="color:#2e74b5;">E</span> is just being mentioned as a parameter and as a return type in function <span style="color:#2e74b5;">E h(E)</span>, so no definition is required and <span style="color:#2e74b5;">x.h</span> shouldn&#8217;t be pulling in <span style="color:#2e74b5;">e.h</span> in the first place because the caller couldn&#8217;t even be calling this function if he didn&#8217;t have the definition of <span style="color:#2e74b5;">E</span> already, so there&#8217;s no point in including it again. (Note this would not be true if <span style="color:#2e74b5;">E</span> were only a return type, such as if the signature were <span style="color:#2e74b5;">E h();</span>, because in that case it’s good style to include <span style="color:#2e74b5;">E</span>’s definition for the caller’s convenience so he can easily write code like <span style="color:#2e74b5;">auto val = x.h();</span>.) All we need to do is replace <span style="color:#2e74b5;">#include &#8220;e.h&#8221;</span> with <span style="color:#2e74b5;">class E;</span>.</p>
<blockquote><p><strong>Guideline: </strong>Never <strong>#include</strong> a header when a forward declaration will suffice.</p></blockquote>
<p>That’s it.</p>
<p>You may be wondering why we can’t get rid of the other headers yet. It’s because to define class <span style="color:#2e74b5;">X</span> means you need to know its size in order to know how much space to allocate for an <span style="color:#2e74b5;">X</span> object, and to know <span style="color:#2e74b5;">X</span>’s size you need to know at least the size of every base class and data member. So we need the definitions of <span style="color:#2e74b5;">A</span> and <span style="color:#2e74b5;">B</span> because they are base classes, and we need the header definitions of <span style="color:#2e74b5;">list</span>, <span style="color:#2e74b5;">C</span>, and <span style="color:#2e74b5;">D</span> because they are used to define the data members. How we can begin to address some of these is the subject of Part 2&#8230;</p>
<p>&nbsp;</p>
<h2>Acknowledgments</h2>
<p>Thanks to the following for their feedback to improve this article: Gennaro, Sebastien Redl, Emmanuel Thivierge.</p>
					<p><a href="https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/" rel="bookmark" title="Permanent Link to GotW #7a Solution: Minimizing Compile-Time Dependencies, Part&nbsp;1">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
			<div class="post-2277 post type-post status-publish format-standard hentry category-gotw" id="post-2277">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/" rel="bookmark">GotW #7a: Minimizing Compile-Time Dependencies, Part&nbsp;1</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-08-12|
													<a href="https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comments">21 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="font-size:28pt;">GotW #7a: Minimizing Compile-Time Dependencies, Part 1<br />
</span></p>
<p><span style="color:#5a5a5a;"><em>Managing dependencies well is an essential part of writing solid code. C++ supports two powerful methods of abstraction: object-oriented programming and generic programming. Both of these are fundamentally tools to help manage dependencies, and therefore manage complexity. It&#8217;s telling that all of the common OO/generic buzzwords—including encapsulation, polymorphism, and type independence—along with the lion&#8217;s share of design patterns, are really about describing ways to manage complexity within a software system by managing the code&#8217;s interdependencies.<br />
</em></span></p>
<p><span style="color:#5a5a5a;"><em>When we talk about dependencies, we usually think of run-time dependencies like class interactions. In this Item, we will focus instead on how to analyze and manage compile-time dependencies. As a first step, try to identify (and root out) unnecessary headers.</em></span>
	</p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. For a function or a class, what is the difference between a forward declaration and a definition?
</p>
<h2>Guru Question<br />
</h2>
<p>2. Many programmers habitually <span style="color:#2e74b5;">#include</span> many more headers than necessary. Unfortunately, doing so can seriously degrade build times, especially when a popular header file includes too many other headers.
</p>
<p>In the following header file, what <span style="color:#2e74b5;">#include</span> directives could be immediately removed without ill effect? You may not make any changes other than removing or rewriting <span style="color:#2e74b5;">#include</span> directives. Note that the comments are important.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: original header<br />//<br />#include &lt;iostream&gt;<br />#include &lt;ostream&gt;<br />#include &lt;list&gt;<br /><br />// None of A, B, C, D or E are templates.<br />// Only A and C have virtual functions.<br />#include "a.h"  // class A<br />#include "b.h"  // class B<br />#include "c.h"  // class C<br />#include "d.h"  // class D<br />#include "e.h"  // class E<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />  private:<br />    std::list&lt;C&gt; clist;<br />    D            d_;<br />  };<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre></p>
					<p><a href="https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/" rel="bookmark" title="Permanent Link to GotW #7a: Minimizing Compile-Time Dependencies, Part&nbsp;1">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
			<div class="post-2230 post type-post status-publish format-standard hentry category-gotw" id="post-2230">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/" rel="bookmark">GotW #94 Solution: AAA Style (Almost Always&nbsp;Auto)</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-08-12|
													<a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comments">67 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="color:#5a5a5a;"><em>Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation of its value.<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Questions</h2>
<p>1. What does this code do? What would be a good name for <span style="color:#2e74b5;">some_function</span>?</p>
<pre><code>template&lt;class Container, class Value&gt;
void some_function( Container&amp; c, const Value&amp; v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.emplace_back(v); 
    assert( !c.empty() );
}
</code></pre>
<p>2. What does &#8220;write code against interfaces, not implementations&#8221; mean, and why is it generally beneficial?</p>
<h2>Guru Questions</h2>
<p>3. What are some popular concerns about using <span style="color:#2e74b5;">auto</span> to declare variables? Are they valid? Discuss.</p>
<p>4. When declaring a new local variable <span style="color:#2e74b5;">x</span>, what advantages are there to declaring it using <span style="color:#2e74b5;">auto</span> and one of the two following syntaxes:</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">auto x = init;</span> when you don&#8217;t need to commit to a specific type? (Note: The expression <span style="color:#2e74b5;">init</span> might include calling a helper that performs partial type adjustment, such as <span style="color:#2e74b5;">as_signed</span>, while still not committing to a specific type.)</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">auto x = type{ init };</span> when you do want to commit to a specific type by naming a <span style="color:#2e74b5;">type</span>?</p>
<p>List as many as you can. (Hint: Look back to GotW #93.)</p>
<p>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:</p>
<p style="margin-left:36pt;">(a) Heap allocation syntax.</p>
<p style="margin-left:36pt;">(b) Literal suffixes, including user-defined literal operators.</p>
<p style="margin-left:36pt;">(c) Named lambda syntax.</p>
<p style="margin-left:36pt;">(d) Function declarations.</p>
<p style="margin-left:36pt;">(e) Template alias declarations.</p>
<p>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</p>
<h1>Solution</h1>
<h2>1. What does this code do? What would be a good name for some_function?</h2>
<pre><code>template&lt;class Container, class Value&gt;
void <span style="background-color:yellow;">append_unique</span>( Container&amp; c, const Value&amp; v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.emplace_back(v); 
    assert( !c.empty() );
}
</code></pre>
<p>Let&#8217;s call this function <span style="color:#2e74b5;">append_unique</span>. First, it checks to see whether the value <span style="color:#2e74b5;">v</span> is already in the container. If not, it appends it at the end. Finally, it asserts that <span style="color:#2e74b5;">c</span> is not empty, since by now it must contain one copy of the value <span style="color:#2e74b5;">v</span>.</p>
<p>You probably thought this question was fairly easy.</p>
<p>Maybe <em>too</em> easy.</p>
<p>If so, good. That&#8217;s the point of the example. Hold the thought, and we&#8217;ll come back to this in Question 3.</p>
<h2>2. What does &#8220;write code against interfaces, not implementations&#8221; mean, and why is it generally beneficial?</h2>
<p>It means we should care principally about &#8220;what,&#8221; not &#8220;how.&#8221; This separation of concerns applies at all levels in high-quality modern software—hiding <em>code</em>, hiding <em>data</em>, and hiding <em>type</em>. Each increases encapsulation and reduces coupling, which are essential for large-scale and robust software.</p>
<p>Please indulge a little repetition in the following paragraphs. It&#8217;s there to make a point about similarity.</p>
<p><strong>Hiding code.</strong> With the invention of separately compiled functions and structured programming, we gained &#8220;encapsulation to <em>hide code.</em>&#8221; The caller knows the signature only—the function&#8217;s internal code is not his concern and not accessible programmatically, even if the function is <span style="color:#2e74b5;">inline</span> and the body happens to be visible in source code. We try hard not to inadvertently leak implementation details, such as internal data structure types. The point is that the caller does not, and should not, commit to knowledge of the current internal code; if he did, it would create interdependencies and make separately compiled libraries impossible.</p>
<p><strong>Hiding data (and code).</strong> With object oriented styles (OO), we gained two new manifestations of this separation. First, we got &#8220;more encapsulation to <em>hide both code and data.</em>&#8221; The caller knows the class name, bases, and member function signatures only—the class&#8217;s internal data and internal code are hidden and not accessible programmatically, even though the <span style="color:#2e74b5;">private</span> class members are lexically visible in the class definition and <span style="color:#2e74b5;">inline</span> function bodies may also be visible. (In turn, dynamic libraries and the potential future-C++ modules work aim to accomplish the same thing at a still larger scale.) Again we try hard not to inadvertently leak implementation details, and again the point is that the caller does not, and should not, commit to knowledge of the current internal data or code, which would make the class difficult to ever change or to ship on its own as a library.</p>
<p><strong>Hiding type (run-time polymorphism).</strong> Second, OO also gave us &#8220;separation of interfaces to <em>hide type.</em>&#8221; A base class or interface can delegate work to a concrete derived implementation via virtual functions. Now the interface the caller sees and the implementation are actually different types, and the caller knows the base type only—he doesn&#8217;t know or care about the concrete type, including even its size. The point, once again, is that the caller does not, and should not, commit to a single concrete type, which would make the caller&#8217;s code less general and less able to be reused with new types.</p>
<p><strong>Hiding type (compile-time polymorphism).</strong> With templates, we gained a new compile-time form of this separation—and it&#8217;s still &#8220;separation of interfaces to <em>hide type</em>.&#8221; The caller knows an ad-hoc &#8220;duck typed&#8221; set of operations he wants to perform using a type, and any type that supports those operations will do just fine. The contemplated future C++ concepts feature will allow making this stricter and less ad-hoc, but still avoids committing to a concrete type at all. The whole point is still is that the caller does not, and should not, commit to a single concrete type, which would make the caller&#8217;s code less generic and less able to be reused with new types.</p>
<h2>3. What are some popular concerns about using auto to declare variables? Are they valid? Discuss.</h2>
<p>In many languages, not just C++, there are several reasons people commonly give for why they are reluctant to use <span style="color:#2e74b5;">auto</span> to declare variables (or the equivalent in another language, such as <span style="color:#2e74b5;">var</span> or <span style="color:#2e74b5;">let</span>). We could summarize them as: <em>laziness</em>, <em>commitment</em>, and <em>readability</em>. Let&#8217;s take them in order.</p>
<h3>Laziness and commitment</h3>
<p>First, laziness: One common concern is that &#8220;writing <span style="color:#2e74b5;">auto</span> to declare a variable is primarily about saving typing.&#8221; However, this is just a misunderstanding of <span style="color:#2e74b5;">auto</span>. As we saw in GotW #92 and #93 and will see again below, the main reasons to declare variables using <span style="color:#2e74b5;">auto</span> are for correctness, performance, maintainability, and robustness—and, yes, convenience, but that&#8217;s in last place on the list.</p>
<blockquote><p><strong>Guideline:</strong> Remember that preferring <strong>auto</strong> variables is motivated primarily by correctness, performance, maintainability, and robustness—and only lastly about typing convenience.</p></blockquote>
<p>Second, commitment: &#8220;But in some cases I do want to commit to a specific type, not automatically deduce it, so I can&#8217;t use <span style="color:#2e74b5;">auto</span>.&#8221; It&#8217;s true that sometimes you do want to commit to a specific type, but you can still use <span style="color:#2e74b5;">auto</span>. As demonstrated in GotW #92 and #93, not only can you still write declarations of the form <span style="color:#2e74b5;">auto x = type{ init };</span> (instead of <span style="color:#2e74b5;">type x{init};</span>) to commit to a specific type, but there are good reasons for doing so, such as that saying <span style="color:#2e74b5;">auto</span> means you can&#8217;t possibly forget to initialize the variable.</p>
<blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, it guarantees the variable will be initialized, and it won&#8217;t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use <strong>( )</strong> instead of <strong>{ }</strong>.</p></blockquote>
<h3>(Un)readability?</h3>
<p>The third and most common argument concerns readability: &#8220;My code gets unreadable quickly when I don&#8217;t know what exact type my variable is without hunting around to see what that function or expression returns, so I can&#8217;t just use <span style="color:#2e74b5;">auto</span> all the time.&#8221; There is truth to this, including losing the ability to search for occurrences of specific types when using the non-typed syntax <em>auto x = expr;</em> in 4(a) below, so this appears at first to be a strong argument. And it&#8217;s true that any feature can be overused. However, I think this argument is actually weaker than it first seems for four reasons, two minor and two major.</p>
<p>The two minor counterarguments are:</p>
<ul>
<li>The &#8220;can&#8217;t use <span style="color:#2e74b5;">auto</span>&#8221; part isn&#8217;t actually true, because as we just saw above you can be explicit about your type and still use <span style="color:#2e74b5;">auto</span>, with good benefit.</li>
<li>The argument doesn&#8217;t apply when you&#8217;re using an IDE, because you can always tell the exact type, for example by hovering over the variable. Granted, this mitigation goes away when you leave the IDE, such as if you print the code.</li>
</ul>
<p>But we should focus on the two major counterarguments:</p>
<ul>
<li>It reflects a bias to code against implementations, not interfaces. Overcommitting to explicit types makes code less generic and more interdependent, and therefore more brittle and limited. It runs counter to the excellent reasons to &#8220;write code against interfaces, not implementations&#8221; we saw in Question 2.</li>
<li><strong>We (meaning <em>you</em>) already ignore actual types all the time…<br />
</strong></li>
</ul>
<p>&#8220;… Wait, what? I do not ignore types all the time,&#8221; someone might say. Actually, not only do you do it, but you&#8217;re so comfortable and cavalier about it that you may not even realize you&#8217;re doing it. Let&#8217;s go back to that code in Question 1:</p>
<pre><code>template&lt;class Container, class Value&gt;
void append_unique( Container&amp; c, const Value&amp; v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.emplace_back(v); 
    assert( !c.empty() );
}
</code></pre>
<p><em>Quick quiz:</em> How many specific types are mentioned in that function? Name as many as you can.</p>
<p>Take a moment to consider that before reading on…</p>
<p>… We can see pretty quickly that the answer is a nice round number: Zero. Zilch. (Pedantic mode: Yes, there&#8217;s <span style="color:#2e74b5;">void</span>, but I&#8217;m going to declare that <span style="color:#2e74b5;">void</span> doesn&#8217;t count because it&#8217;s to denote &#8220;no type,&#8221; it&#8217;s not a meaningful type.)</p>
<p>Not a single specific type appears anywhere in this code, and the lack of exact types makes it much more powerful and doesn&#8217;t significantly harm its readability. Like most people, you probably thought Question 1 felt &#8220;easy&#8221; when we did it in isolation. Granted, this is generic code, and not all your code will be templates—but the point is that the code isn&#8217;t unreadable even though it doesn&#8217;t mention specific types, and in fact auto gives you the ability to write generic code even when <em>not</em> writing a template.</p>
<p>So starting with the cases illustrated in this short example, let&#8217;s consider some places where we routinely ignore exact types. First, function template parameters:</p>
<ul>
<li>What exact type is <span style="color:#2e74b5;">Container</span>? We have no idea, and that&#8217;s great… anything we can call <span style="color:#2e74b5;">begin</span>, <span style="color:#2e74b5;">end</span>, <span style="color:#2e74b5;">emplace_back</span> and <span style="color:#2e74b5;">empty</span> on and otherwise use as needed by this code will do just fine. In fact, we&#8217;re glad we don&#8217;t know anything about the exact type, because it means we&#8217;re following the Open/Closed Principle and staying open for extension— this <span style="color:#2e74b5;">append_unique</span> will work fine with a type that won&#8217;t be written until years from now. Interestingly, the concepts feature currently being proposed for ISO C++ to express template parameter constraints doesn&#8217;t change how this works at all, it only makes it more convenient to express and check the requirements. Note how much more powerful this is compared to OO style frameworks: In OO frameworks where containers have to inherit from a base class or interface, that&#8217;s already inducing coupling and limiting the ability to just plug in and use arbitrary suitable types. It is important that we can know nothing at all about the type here besides its necessary interface, not even restricting it by as much as limiting it to types in a particular inheritance hierarchy. We should strongly resist compromising this wonderful and powerful &#8220;strictly typed but loosely coupled&#8221; genericity.</li>
<li>What exact type is <span style="color:#2e74b5;">Value</span>? Again, we don&#8217;t know, and we don&#8217;t want to know… anything we can pass to <span style="color:#2e74b5;">find</span> and <span style="color:#2e74b5;">emplace_back</span> is just dandy. At this point some of you may be thinking: &#8220;Oh yes we know what type it is, it&#8217;s the container&#8217;s value type!&#8221; No, it doesn&#8217;t have to be that, it just has to be convertible, and that&#8217;s important. For example, we want <span style="color:#2e74b5;">vector&lt;string&gt; vec; append_unique(vec, &#8220;xyzzy&#8221;);</span> to work, and <span style="color:#2e74b5;">&#8220;xyzzy&#8221;</span> is a <span style="color:#2e74b5;">const char[6]</span>, not a <span style="color:#2e74b5;">string</span>.</li>
</ul>
<p>Second, function return values:</p>
<ul>
<li>What type does <span style="color:#2e74b5;">find</span> return? Some iterator type, the same as <span style="color:#2e74b5;">begin(c)</span> coughed up, but we don&#8217;t know specifically what type it is just from reading this code, and it doesn&#8217;t matter. We can look up the signature if we&#8217;re feeling really curious, but nobody bothers doing that because anything that&#8217;s comparable to <span style="color:#2e74b5;">end(c)</span> will do.</li>
<li>What type does <span style="color:#2e74b5;">empty</span> return? We don&#8217;t even think twice about it. Something testable like a <span style="color:#2e74b5;">bool</span>… we don&#8217;t care much what exactly as long as we can &#8220;not&#8221; it.</li>
</ul>
<p>Third, many function parameters:</p>
<ul>
<li>What specific type does <span style="color:#2e74b5;">emplace_back</span> take? Don&#8217;t know; might be the same as <span style="color:#2e74b5;">v</span>, might not. Really don&#8217;t care. Can we pass <span style="color:#2e74b5;">v</span> to it? Yes? Groovy.</li>
</ul>
<p>And that&#8217;s just in this example. We routinely and desirably ignore types in many other places, such as:</p>
<ul>
<li>Fourth, any temporary object: We never get to name the object, much less name its type, and we may know what the type is but we don&#8217;t care about actually spelling out either name in our code.</li>
<li>Fifth, any use of a base class: We don&#8217;t know the dynamic concrete type we&#8217;re actually using, and that&#8217;s a benefit, not a bug.</li>
<li>Sixth, any call to a virtual function: Ditto; plus on top of that if the virtual function return type itself could also be covariant for another layer of &#8220;we don&#8217;t know the dynamic concrete type&#8221; since in the presence of covariance we don&#8217;t know what type we&#8217;re actually getting back.</li>
<li>Seventh, any use of <span style="color:#2e74b5;">function&lt;&gt;</span>, <span style="color:#2e74b5;">bind</span>, or other type erasure: Just think about how little we actually know, and how happy it makes us. For example, given a <span style="color:#2e74b5;">function&lt;int(string)&gt;</span>, not only don&#8217;t we know what specific function or object it&#8217;s bound to, we don&#8217;t even know that thing&#8217;s signature—it might not actually even take a <span style="color:#2e74b5;">string</span> or return an <span style="color:#2e74b5;">int</span>, because conversions are allowed in both directions, so it only has to take something a <span style="color:#2e74b5;">string</span> can be converted to, and return something that can be converted to an <span style="color:#2e74b5;">int</span>. All we know is that it&#8217;s something that we can invoke with a <span style="color:#2e74b5;">string</span> and that gives us back something we can use as an <span style="color:#2e74b5;">int</span>. Ignorance is bliss.</li>
<li>Eighth, Any use of a C++14 generic lambda function: A generic lambda just means the function call operator is a template, after all, and like any function template it gets stamped out individually for whatever actual argument types you pass each time you use it.</li>
</ul>
<p>There are probably more.</p>
<p>Although lack of commitment may be a bad thing in other areas of life, not committing to a specific type is often desirable by default in reusable code.</p>
<h2>4. When declaring a new local variable x, what advantages are there to declaring it using auto and one of the two following syntaxes:</h2>
<p>Let&#8217;s consider the base case first, which has by far the strongest arguments in its favor and is gaining quite a bit of traction in the C++ community.</p>
<h3>(a) auto x = init; when you don&#8217;t need to commit to a specific type?</h3>
<p>GotW #93 offered many concrete examples to support habitually declaring local variables using <span style="color:#2e74b5;">auto x = expr;</span> when you don&#8217;t need to explicitly commit to a type. The advantages include:</p>
<ul>
<li>It guarantees the variable will be initialized. Uninitialized variables are impossible because once you start by saying <span style="color:#2e74b5;">auto</span> the <span style="color:#2e74b5;">=</span> is required and cannot be forgotten.</li>
<li>It is efficient by default and guarantees that no implicit conversions (including narrowing conversions), temporary objects, or wrapper indirections will occur. In particular, prefer using <span style="color:#2e74b5;">auto</span> instead of <span style="color:#2e74b5;">function&lt;&gt;</span> to name lambdas unless you need the type erasure and indirection.</li>
<li>It guarantees that you will use the correct exact type now.</li>
<li>It guarantees that you will continue to use the correct exact type under maintenance as the code changes, and the variable&#8217;s type automatically tracks other functions&#8217; and expressions&#8217; types unless you explicitly said otherwise.</li>
<li>It is the simplest way to portably spell the implementation-specific type of arithmetic operations on built-in types, which vary by platform, and ensure that you cannot accidentally get lossy narrowing conversions when storing the result.</li>
<li>It is the only good option for hard-to-spell and impossible-to-spell types such as lambdas, binders, <span style="color:#2e74b5;">detail::</span> helpers, and template helpers (including expression templates when they should stay unevaluated for performance), short of resorting to repetitive <span style="color:#2e74b5;">decltype</span> expressions or more-expensive indirections like <span style="color:#2e74b5;">function&lt;&gt;</span>.</li>
<li>It is more symmetric and consistent with other parts of modern C++ (see Question 5).</li>
<li>And yes, it is just generally simpler and less typing.</li>
</ul>
<p>See GotW #93 for concrete examples of these cases, where using <span style="color:#2e74b5;">auto</span> helps eliminate correctness bugs, performance bugs, and silently nonportable code.</p>
<p>As noted in the questions, the expression <span style="color:#2e74b5;">init</span> might include calling a helper that performs partial type adjustment, such as <span style="color:#2e74b5;">as_signed</span>, while still not committing to a specific type. As shown in GotW #93, prefer to use <span style="color:#2e74b5;">auto x = as_signed(integer_expr);</span> or <span style="color:#2e74b5;">auto x = as_unsigned(integer_expr);</span> to store the result of an integer computation that should be signed or unsigned—these should be viewed as &#8220;casts that preserve width,&#8221; so we are not casting to a specific type but rather casting an attribute of the type while correctly preserving the other basic characteristics of the type, notably by not forcing it to commit to a particular size.</p>
<p>Using <span style="color:#2e74b5;">auto</span> together with <span style="color:#2e74b5;">as_signed</span> or <span style="color:#2e74b5;">as_unsigned</span> makes code more portable: the variable will both be large enough (thanks to <span style="color:#2e74b5;">auto</span>) and preserve the required signedness on all platforms. Note that signed/unsigned conversions within <span style="color:#2e74b5;">integer_expr</span> may still occur and so you may need additional finer-grained <span style="color:#2e74b5;">as_signed</span>/<span style="color:#2e74b5;">as_unsigned</span> casts within the expression for full portability.</p>
<h3>(b) auto x = type{ init }; when you do want to commit to a specific type by naming a type?</h3>
<p>This is the explicitly typed form, and it still has advantages but they are not as clearly strong as implicitly typed form. The jury is still out on whether to recommend this one wholesale, as we&#8217;re still trying it out, but it does offer some advantages and I suggest you try it out for a while and see if it works well for you.</p>
<p>So here&#8217;s the recommendation to consider trying out for yourself: Consider declaring local variables <span style="color:#2e74b5;">auto x = type{ expr };</span> when you do want to explicitly commit to a type. (Only when you do want to allow explicit narrowing, use <span style="color:#2e74b5;">( )</span> instead of <span style="color:#2e74b5;">{ }</span>.) The advantages of this typed <span style="color:#2e74b5;">auto</span> declaration style include:</p>
<ul>
<li>It guarantees the variable will be initialized; you can&#8217;t forget.</li>
<li>It is self-documenting to show that the code is explicitly requesting a conversion.</li>
<li>It won&#8217;t allow an accidental implicit narrowing conversion.</li>
<li>It is more symmetric and consistent, both with the basic <span style="color:#2e74b5;">auto x = init;</span> form and with other parts of C++…</li>
</ul>
<p>… which brings us to Question 5.</p>
<h2>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:</h2>
<p>Let&#8217;s start off this question with some side-by-side examples that give us a taste of the symmetry we gain when we habitually declare variables using modern <span style="color:#2e74b5;">auto</span> style. Starting with two examples where we don&#8217;t need to commit to a type and then two where we do, we see that the right-hand style is not only more robust and maintainable for the reasons already given, but also arguably cleaner and more regular with the type consistently on the right when it is mentioned:</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

const char* s = "Hello";             <strong>auto</strong> s = "Hello";
widget w = get_widget();             <strong>auto</strong> w = get_widget();

employee e{ empid };                 <strong>auto</strong> e = <strong>employee</strong>{ empid };
widget w{ 12, 34 };                  <strong>auto</strong> w = <strong>widget</strong>{ 12, 34 };
</code></pre>
<p>Now consider the (dare we say elegant) symmetry with each of the following.</p>
<h3>(a) Heap allocation syntax.</h3>
<p>When allocating heap variables, did you notice that the type name is already on the right naturally anyway? And since it&#8217;s there, we don&#8217;t want to have to repeat it. (I&#8217;ll show the raw &#8220;<span style="color:#2e74b5;">new</span>&#8221; form for completeness, but prefer <span style="color:#2e74b5;">make_unique</span> and <span style="color:#2e74b5;">make_shared</span> in that order for allocation in modern code, resorting to raw <span style="color:#2e74b5;">new</span> only well-encapsulated inside the implementation of low-level data structures.)</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

widget* w = new widget{};            /* <strong>auto</strong> w = new <strong>widget</strong>{}; */
unique_ptr&lt;widget&gt; w                 <strong>auto</strong> w = make_unique&lt;<strong>widget</strong>&gt;();
  = make_unique&lt;widget&gt;();
</code></pre>
<h3>(b) Literal suffixes, including user-defined literal operators.</h3>
<p>Using <span style="color:#2e74b5;">auto</span> declaration style doesn&#8217;t merely work naturally with built-in literal suffixes like <span style="color:#2e74b5;">ul</span> for <span style="color:#2e74b5;">unsigned long</span>, plus user-defined literals including standard ones now in draft C++14, but it actively encourages using them:</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

int x = 42;                          <strong>auto</strong> x = 42;
float x = 42.;                       <strong>auto</strong> x = 42.<strong>f</strong>;
unsigned long x = 42;                <strong>auto</strong> x = 42<strong>ul</strong>;
std::string x = "42";                <strong>auto</strong> x = "42"<strong>s</strong>;   // C++14
chrono::nanoseconds x{ 42 };         <strong>auto</strong> x = 42<strong>ns</strong>;    // C++14
</code></pre>
<p>Based on the examples so far, which do you think is more regular? But wait, there&#8217;s more…</p>
<h3>(c) Named lambda syntax.<br />
(d) Function declarations.</h3>
<p>Lambdas have unutterable types, and <span style="color:#2e74b5;">auto</span> is the best way to capture them exactly and efficiently. But because their declarations are now so similar, let&#8217;s consider lambdas and (other) functions together, and in the last two lines of this example also use C++14 return type deduction:</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

int f( double );                     <strong>auto</strong> f <strong>(double) -&gt; int</strong>;
…                                    <strong>auto</strong> f <strong>(double)</strong> { /*...*/ };
…                                    <strong>auto</strong> f = [=]<strong>(double)</strong> { /*...*/ };
</code></pre>
<h3>(e) Template alias declarations.</h3>
<p>Modern C++ frees us from the tyranny of un-template-able <span style="color:#2e74b5;">typedef</span>:</p>
<pre><code>// Classic C++ workaround            // Modern C++ style

typedef set&lt;string&gt; dict;            <strong>using</strong> dict = <strong>set&lt;string&gt;</strong>;

template&lt;class T&gt; struct myvec {     template&lt;class T&gt;
  typedef vector&lt;T,myalloc&gt; type;    <strong>using</strong> myvec = <strong>vector&lt;T,myalloc&gt;</strong>;
};
</code></pre>
<h3>An observation</h3>
<p>Have you noticed that the C++ world is moving to a left-to-right declaration style everywhere, of the form</p>
<p style="text-align:center;"><strong>category</strong> name = <strong>type</strong> and/or initializer ;</p>
<p>where &#8220;category&#8221; can be <span style="color:#2e74b5;">auto</span> or <span style="color:#2e74b5;">using</span>?</p>
<p>Take a moment to re-skim the two columns of examples above. Even ignoring correctness and performance advantages, do you find the right-hand column to be most consistent, and most readable?</p>
<h2>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</h2>
<p>There is one case I know of where this style cannot be followed, and it applies to the type-specific <span style="color:#2e74b5;">auto x = type{ init };</span> form. In that form, <span style="color:#2e74b5;">type</span> has to be moveable (even though the move operation will be routinely elided by compilers), so these won&#8217;t work:</p>
<pre><code>auto lock <strong>=</strong> lock_guard&lt;mutex&gt;{ m };  // error, not moveable
auto ai   <strong>=</strong> atomic&lt;int&gt;{};           // error, not moveable
</code></pre>
<p>(Aside: For at least some of these cases, an argument could be made that this is actually more of a defect in the type itself, in particular that perhaps <span style="color:#2e74b5;">atomic&lt;int&gt;</span> should be moveable.)</p>
<p>Having said that, there are three other cases I know of that you might encounter that may at first look like they don&#8217;t work with this <span style="color:#2e74b5;">auto</span> style, but actually do. Let&#8217;s consider those for completeness.</p>
<p>First, the basic form <span style="color:#2e74b5;">auto x = init;</span> will exactly capture an <span style="color:#2e74b5;">initializer_list</span> or a proxy type, such as an expression template. This is a feature, not a bug, because you have a convenient way to spell both &#8220;capture the list or proxy&#8221; and &#8220;resolve the computation&#8221; depending which you mean, and the default syntax goes to the more efficient one: If you want to efficiently capture the list or proxy, use the basic form which gives you performance by default, and if you mean to force the proxy to resolve the computation, specify the explicit type to ask for the conversion you want. For example:</p>
<pre><code>auto i1 = { 1 };                       // initializer_list&lt;int&gt;
auto i2 = 1;                           // int

auto a = matrix{...}, b = matrix{...}; // some type that does lazy eval
auto ab = a * b;                       // to capture the lazy-eval proxy
auto c = matrix{ a * b };              // to force computation

</code></pre>
<p>Second, here is a rare case that you may discover now that we have <span style="color:#2e74b5;">auto</span>: Due to the mechanics of the C++ grammar, you can&#8217;t legally write a multi-word type like <span style="color:#2e74b5;">long long</span> or <span style="color:#2e74b5;">class widget</span> in the place where <span style="color:#2e74b5;">type</span> goes in the <span style="color:#2e74b5;">auto x = type{ init };</span> form. However, note that this affects only those two cases:</p>
<ul>
<li>The multi-word built-in types like <span style="color:#2e74b5;">long long</span>, where you&#8217;re better off anyway writing a known-width type alias or using a literal.</li>
<li>Elaborated type specifiers like <span style="color:#2e74b5;">class widget</span>, where the &#8220;<span style="color:#2e74b5;">class</span>&#8221; part is already redundant. The &#8220;<span style="color:#2e74b5;">class widget</span>&#8221; syntax is allowed as a compatibility holdover from C which liked seeing <span style="color:#2e74b5;">struct widget</span> everywhere unless you <span style="color:#2e74b5;">typedef</span>&#8216;d the <span style="color:#2e74b5;">struct</span> part away.</li>
</ul>
<p>So just avoid the multi-word form and use the better alternative instead:</p>
<pre><code>auto x = long long{ 42 };            // error
auto x = int64_t{ 42 };              // ok, better 
auto x = 42LL;                       // ok, better 

auto y = class X{1,2,3};             // error
auto y = X{1,2,3};                   // ok
</code></pre>
<h2>Summary</h2>
<p>We already ignore explicit and exact types much of the time, including with temporary objects, virtual functions, templates, and more. This is a feature, not a bug, because it makes our code less tightly coupled, and more generic, flexible, reusable, and future-proof.</p>
<p>Declaring variables using <span style="color:#2e74b5;">auto</span>, whether or not we want to commit to a type, offers advantages for correctness, performance, maintainability, and robustness, as well as typing convenience. Furthermore, it is an example of how the C++ world is moving to a left-to-right declaration style everywhere, of the form</p>
<p style="text-align:center;"><strong>category</strong> name = <strong>type</strong> and/or initializer ;</p>
<p>where &#8220;category&#8221; can be <span style="color:#2e74b5;">auto</span> or <span style="color:#2e74b5;">using</span>, and we can get not only correctness and performance but also consistency benefits by using the style to consistently declare local variables (including using literals and user-defined literals), function declarations, named lambdas, aliases, template aliases, and more.</p>
<h2>Acknowledgments</h2>
<p>Thanks in particular to Scott Meyers and Andrei Alexandrescu for their time and insights in reviewing and discussing drafts of this material. Both helped generate candidate names for this idiom; it was Alexandrescu who suggested the name &#8220;AAA (almost always auto)&#8221; which I merged with the best names I&#8217;d thought of to that point (&#8220;auto style&#8221; or &#8220;auto (+type) style&#8221;) to get &#8220;AAA Style (almost always auto).&#8221; Thanks also to the following for their feedback to improve this article: Adrian, avjewe, mttpd, ned, zadecn, noniussenior, Marcel Wid, J Guy Davidson, Mark Garcia, Jonathan Wakely, &#8220;x y.&#8221;</p>
					<p><a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/" rel="bookmark" title="Permanent Link to GotW #94 Solution: AAA Style (Almost Always&nbsp;Auto)">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
			<div class="post-2186 post type-post status-publish format-standard hentry category-gotw" id="post-2186">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/" rel="bookmark">GotW #94 Special Edition: AAA Style (Almost Always&nbsp;Auto)</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-06-13|
													<a href="https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comments">29 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="color:#5a5a5a;"><em>Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation of its value.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What does this code do? What would be a good name for <span style="color:#2e74b5;">some_function</span>?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>template&lt;class Container, class Value&gt;<br />void some_function( Container&amp; c, const Value&amp; v ) {<br />    if( find(begin(c), end(c), v) == end(c) )<br />        c.emplace_back(v); <br />    assert( !c.empty() );<br />}
</code></pre>
</p>
<p>2. What does &#8220;write code against interfaces, not implementations&#8221; mean, and why is it generally beneficial?
</p>
<h2>Guru Questions<br />
</h2>
<p>3. What are some popular concerns about using <span style="color:#2e74b5;">auto</span> to declare variables? Are they valid? Discuss.
</p>
<p>4. When declaring a new local variable <span style="color:#2e74b5;">x</span>, what advantages are there to declaring it using <span style="color:#2e74b5;">auto</span> and one of the two following syntaxes:
</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">auto x = init;</span> when you don&#8217;t need to commit to a specific type? (Note: The expression <span style="color:#2e74b5;">init</span> might include calling a helper that performs partial type adjustment, such as <span style="color:#2e74b5;">as_signed</span>, while still not committing to a specific type.)
</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">auto x = type{ init };</span> when you do want to commit to a specific type by naming a <span style="color:#2e74b5;">type</span>?
</p>
<p>List as many as you can. (Hint: Look back to GotW #93.)
</p>
<p>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:
</p>
<p style="margin-left:36pt;">(a) Heap allocation syntax.
</p>
<p style="margin-left:36pt;">(b) Literal suffixes, including user-defined literal operators.
</p>
<p style="margin-left:36pt;">(c) Named lambda syntax.
</p>
<p style="margin-left:36pt;">(d) Function declarations.
</p>
<p style="margin-left:36pt;">(e) Template alias declarations.
</p>
<p>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</p>
					<p><a href="https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/" rel="bookmark" title="Permanent Link to GotW #94 Special Edition: AAA Style (Almost Always&nbsp;Auto)">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
			<div class="post-2145 post type-post status-publish format-standard hentry category-gotw" id="post-2145">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/" rel="bookmark">GotW #93 Solution: Auto Variables, Part&nbsp;2</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-06-13|
													<a href="https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comments">42 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="color:#5a5a5a;"><em>Why prefer declaring variables using auto? Let us count some of the reasons why…<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?</p>
<pre><code>// (a)
void traverser( const vector&lt;int&gt;&amp; v ) {
    for( vector&lt;int&gt;::iterator i = begin(v); i != end(v); i += 2 )
        // ...
}

// (b)
vector&lt;int&gt; v1(5);
vector&lt;int&gt; v2 = 5;

// (c)
gadget get_gadget();
// ...
widget w = get_gadget();

// (d)
function&lt;void(vector&lt;int&gt;)&gt; get_size
    = [](const vector&lt;int&gt;&amp; x) { return x.size(); };
</code></pre>
<h2>Guru Question</h2>
<p>2. Same question, subtler examples: In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?</p>
<pre><code>// (a)
widget w;

// (b)
vector&lt;string&gt; v;
int size = v.size();

// (c) x and y are of some built-in integral type
int total = x + y;

// (d) x and y are of some built-in integral type
int diff = x - y;
if(diff &lt; 0) { /*...*/ }

// (e)
int i = f(1,2,3) * 42.0;
</code></pre>
<h1>Solution</h1>
<p>As you worked through these cases, perhaps you noticed a pattern: The cases are mostly very different, but what they have in common is that they illustrate reason after reason motivating why (and how) to use <span style="color:#2e74b5;">auto</span> to declare variables. Let&#8217;s dig in and see.</p>
<h2>1. In the following code, what actual or potential pitfalls exist, which would using auto variable declarations fix, and why or why not?</h2>
<h3>(a) will not compile</h3>
<pre><code>// (a)
void traverser( const vector&lt;int&gt;&amp; v ) {
    for( vector&lt;int&gt;::iterator i = begin(v); i != end(v); i += 2 )
        // ...
}
</code></pre>
<p>With (a), the most important pitfall is that the code doesn&#8217;t compile. Because <span style="color:#2e74b5;">v</span> is <span style="color:#2e74b5;">const</span>, you need a <span style="color:#2e74b5;">const_iterator</span>. The old-school way to fix this is to write <span style="color:#2e74b5;">const_iterator</span>:</p>
<pre><code>vector&lt;int&gt;::const_iterator i = begin(v)     // ok + requires thinking
</code></pre>
<p>However, that requires thinking to remember, &#8220;ah, <span style="color:#2e74b5;">v</span> is a reference to <span style="color:#2e74b5;">const</span>, I better remember to write <span style="color:#2e74b5;">const_</span> in front of its iterator type… and take it off again if I ever change <span style="color:#2e74b5;">v</span> to be a reference to non-<span style="color:#2e74b5;">const</span>… and also change the &#8220;<span style="color:#2e74b5;">vector</span>&#8221; part of <span style="color:#2e74b5;">i</span>&#8216;s type if <span style="color:#2e74b5;">v</span> is some other container type…&#8221;</p>
<p>Not that thinking is a bad thing, mind you, but this is really just a tax on your time when the simplest and clearest thing to write is <span style="color:#2e74b5;">auto</span>:</p>
<pre><code><span style="background-color:yellow;">auto</span> i = begin(v)                           // ok, best
</code></pre>
<p>Using <span style="color:#2e74b5;">auto</span> is not only correct and clear and simpler, but it stays correct if we change the type of the parameter to be non-<span style="color:#2e74b5;">const</span> or pass some other type of container, such as if we make <span style="color:#2e74b5;">traverser</span> into a template in the future.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto x = expr;</strong> when you don&#8217;t need to explicitly commit to a type. It is simpler, guarantees that you will use the correct type, and guarantees that the type stays correct under maintenance.</p></blockquote>
<p>Although our focus is on the variable declaration, there&#8217;s another independent bug in the code: The <span style="color:#2e74b5;">+= 2</span> increment can zoom you off the end of the container. When writing a strided loop, check your iterator increment against end on each increment (best to write it once as a <span style="color:#2e74b5;">checked_next(i,end)</span> helper that does it for you), or use an indexed loop something like <span style="color:#2e74b5;">for( auto i = 0L; i &lt; v.size(); i += 2 )</span> which is more natural to write correctly.</p>
<h3>(b) and (c) rely on implicit conversions</h3>
<pre><code>// (b)
vector&lt;int&gt; v1(5);     // 1
vector&lt;int&gt; v2 = 5;    // 2
</code></pre>
<p>Line 1 performs an explicit conversion and so can call <span style="color:#2e74b5;">vector</span>&#8216;s <span style="color:#2e74b5;">explicit</span> constructor that takes an initial size.</p>
<p>Line 2 doesn&#8217;t compile because its syntax won&#8217;t call an <span style="color:#2e74b5;">explicit</span> constructor. As we saw in GotW #1, it really means &#8220;convert <span style="color:#2e74b5;">5</span> to a temporary <span style="color:#2e74b5;">vector&lt;int&gt;</span>, then move-construct <span style="color:#2e74b5;">v2</span> from that,&#8221; so line 2 only works for types where the conversion is not <span style="color:#2e74b5;">explicit</span>.</p>
<p>Some people view the asymmetry between 1 and 2 as a pitfall, at least conceptually, for several reasons: First, the syntaxes are not quite the same and so learning when to use each can seem like finicky detail. Second, some people like line 2&#8217;s syntax better but have to switch to line 1 to get access to <span style="color:#2e74b5;">explicit</span> constructors. Finally, with this syntax, it&#8217;s easy to forget the <span style="color:#2e74b5;">(5)</span> or <span style="color:#2e74b5;">= 5</span> initializer, and then we&#8217;re into case 2(a), which we&#8217;ll get to in a moment.</p>
<p>If we use <span style="color:#2e74b5;">auto</span>, we have a single syntax that is always obviously explicit:</p>
<pre><code><span style="background-color:yellow;">auto</span> v2 = vector&lt;int&gt;(5);
</code></pre>
<p>Next, case (c) is similar to (b):</p>
<pre><code>// (c)
gadget get_gadget();
// ...
widget w = get_gadget();
</code></pre>
<p>This works, assuming that <span style="color:#2e74b5;">gadget</span> is implicitly convertible to <span style="color:#2e74b5;">widget</span>, but creates a temporary object. That&#8217;s a potential performance pitfall, as the creation of the temporary object is not at all obvious from reading the call site alone in a code review. If we can use a <span style="color:#2e74b5;">gadget</span> just as well as a <span style="color:#2e74b5;">widget</span> in this calling code and so don&#8217;t explicitly need to commit to the <span style="color:#2e74b5;">widget</span> type, we could write the following which guarantees there is no implicit conversion because <span style="color:#2e74b5;">auto</span> always deduces the basic type exactly:</p>
<pre><code>// better, if you don't need an explicit type
<span style="background-color:yellow;">auto</span> w = get_gadget();
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto x = expr;</strong> when you don&#8217;t need to explicitly commit to a type. It is efficient by default and guarantees that no implicit conversions or temporary objects will occur.</p></blockquote>
<p>By the way, if you&#8217;ve been wondering whether that &#8220;<span style="color:#2e74b5;">=</span>&#8221; in <span style="color:#2e74b5;">auto x = expr;</span> causes a temporary object plus a move or copy, wonder no longer: No, it constructs <span style="color:#2e74b5;">x</span> directly. (See GotW #1.)</p>
<p>Now, what if we said <span style="color:#2e74b5;">widget</span> here because we know about the conversion and really do want to deal with a <span style="color:#2e74b5;">widget</span>? Then writing <span style="color:#2e74b5;">auto</span> is still more self-documenting:</p>
<pre><code>// better, if you do need to commit to an explicit type
<span style="background-color:yellow;">auto</span> w = <span style="background-color:yellow;">widget</span>{ get_gadget() };
</code></pre>
<blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion.</p></blockquote>
<p>Note that this last version technically requires a move operation, but compilers are explicitly allowed to elide that and construct <span style="color:#2e74b5;">w</span> directly—and compilers routinely do that, so there is no performance penalty in practice.</p>
<h3>(d) creates an indirection, and commits to a single type</h3>
<pre><code>// (d)
function&lt;void(vector&lt;int&gt;)&gt; get_size
    = [](const vector&lt;int&gt;&amp; x) { return x.size(); };
</code></pre>
<p>Case (d) has two problems, and <span style="color:#2e74b5;">auto</span> can help with both of them. (Bonus points if you noticed that a form of &#8220;auto&#8221; is actually already helping in a third way.)</p>
<p>First, the lambda object is converted to a <span style="color:#2e74b5;">function&lt;&gt;</span>. That can be appropriate when passing or returning the lambda to a function, but it costs an indirection because <span style="color:#2e74b5;">function&lt;&gt;</span> has to erase the actual type and create a wrapper around its target to hold it and invoke it. In this case, we appear to be using the lambda locally, and so the correct default way to capture it is using <span style="color:#2e74b5;">auto</span>, which binds to the exact (compiler-generated and otherwise-unutterable-by-you) type of the lambda and so doesn&#8217;t incur an indirection:</p>
<pre><code>// partly improved
<span style="background-color:yellow;">auto</span> get_size = [](const vector&lt;int&gt;&amp; x) { return x.size(); };
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to use <strong>auto name = </strong>to name a lambda function object. Use <strong>std::function&lt;/*…*/&gt; name =</strong> only when you need to rebind it to another target or pass it to another function that needs a <strong>std::function&lt;&gt;</strong>.</p></blockquote>
<p>Second, the lambda commits to a specific argument type—it only works with <span style="color:#2e74b5;">vector&lt;int&gt;</span>, and not with <span style="color:#2e74b5;">vector&lt;double&gt;</span> or <span style="color:#2e74b5;">set&lt;string&gt;</span> or anything else that is also able to report a <span style="color:#2e74b5;">.size()</span>. The way to fix that is to write another <span style="color:#2e74b5;">auto</span>:</p>
<pre><code>// best
<span style="background-color:yellow;">auto</span> get_size = [](const <span style="background-color:yellow;">auto</span>&amp; x) { return x.size(); };

// yes, you could use this "too cute" variation for slightly less typing
//              [](auto&amp;&amp; x) { return x.size(); };
// but you'll also get less const-enforcement and that isn't a good deal
</code></pre>
<p>This still creates just a single object, but with a templated function call operator so that it can be invoked with different types of arguments, and so will work with any type of container that supports calling <span style="color:#2e74b5;">.size()</span>…</p>
<blockquote><p><strong>Guideline:</strong> Prefer to use <strong>auto</strong> lambda parameter types. They are just as efficient as explicit parameter types, and allow you to call the same lambda with different argument types.</p></blockquote>
<p>… and did you notice the &#8220;third auto&#8221; that was there all along? Even in the original example, we&#8217;ve been implicitly using automatic type deduction in a third place by allowing the lambda to deduce its return type, and so now with the fully generic &#8220;best&#8221; version of the code that return type will always be exactly whatever <span style="color:#2e74b5;">.size()</span> returns for whatever kind of object we&#8217;re calling <span style="color:#2e74b5;">.size()</span> on, which can be different for different argument types. All in all, that&#8217;s pretty nifty.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to use implicit return type deduction for lambda functions.</p></blockquote>
<h2>2. Same question, subtler examples: In the following code, what actual or potential pitfalls exist, which would using auto variable declarations fix, and why or why not?</h2>
<h3>(a) might leave the variable uninitialized.</h3>
<pre><code>// (a)
widget w;
</code></pre>
<p>This creates an object of type <span style="color:#2e74b5;">widget</span>. However, we can&#8217;t tell just looking at this line whether it&#8217;s initialized or contains garbage values. As noted in GotW #1, if <span style="color:#2e74b5;">widget</span> is a built-in type or aggregate type, its members won&#8217;t get initialized. Uninitialized variables should be avoided by default, and only used deliberately in cases where you really want to start with an uninitialized memory region for performance reasons—notably when you have a large object, such as an array, that is expensive to zero-initialize and is immediately going to be overwritten anyway, such as if it&#8217;s being used as an &#8220;out&#8221; parameter.</p>
<blockquote><p><strong>Guideline:</strong> Always initialize variables, except only when you can prove garbage values are okay, typically because you will immediately overwrite the contents.</p></blockquote>
<p>Would <span style="color:#2e74b5;">auto</span> help here? Indeed it would:</p>
<pre><code><span style="background-color:yellow;">auto</span> w = widget{};    // guaranteed to be initialized
</code></pre>
<p>One of the key benefits of declaring a local variable using <span style="color:#2e74b5;">auto</span> is that the &#8220;<span style="color:#2e74b5;">=</span>&#8221; is required—there&#8217;s no way to declare the variable without setting an initial value. Further, this is explicit and clear just from reading the above variable declaration on its own during a code review, without having to go inquire in the type&#8217;s header about the exact details of the type and poll the neighborhood for character references who will swear it&#8217;s not now, and is even under maintenance never likely to become, an aggregate.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto</strong>. It guarantees that you cannot accidentally leave the variable uninitialized.</p></blockquote>
<h3>(b) might perform a silent narrowing conversion.</h3>
<pre><code>// (b)
vector&lt;string&gt; v;
int size = v.size();
</code></pre>
<p>This will compile, run, and sometimes lose information because it uses an implicit narrowing conversion. Not the safest route to a happy weekend when the bug report from the field comes in on Friday night—normally from a large and important customer, because the bug will be exercised only with larger data sizes.</p>
<p>Here&#8217;s why: The return type of <span style="color:#2e74b5;">vector&lt;string&gt;::size()</span> is <span style="color:#2e74b5;">vector&lt;string&gt;::size_type</span>, but what&#8217;s that? It depends on your implementation, because the standard leaves it implementation-defined. But one thing I guarantee you is that &#8220;it ain&#8217;t no <span style="color:#2e74b5;">int</span>&#8220;—for at least two reasons, which lead to at least two ways this can lose information by silent narrowing:</p>
<ul>
<li><em>Sign:</em><br />
<span style="color:#2e74b5;">size_type</span> is required to be an unsigned integer value, so this code is asking to convert it to a signed value. That&#8217;s bad enough even if <span style="color:#2e74b5;">sizeof(size_type) == sizeof(int)</span> and it throws away the high bit—and with it the upper half of the representable values—to make room for the sign bit. It&#8217;s worse than that if <span style="color:#2e74b5;">sizeof(size_type) &gt; sizeof(int)</span>, which brings us to the second problem, because that&#8217;s actually likely…</li>
<li><em>Size:</em><br />
<span style="color:#2e74b5;">size_type</span> basically needs to be the same size as a pointer, since it may have to represent any offset in a <span style="color:#2e74b5;">vector&lt;char&gt;</span> that is larger than half the machine&#8217;s address space. In 64-bit code, 64-bit pointers mean 64-bit <span style="color:#2e74b5;">size_type</span>s. However, if on the same system an <span style="color:#2e74b5;">int</span> is still 32 bits for compatibility (and this is common), then <span style="color:#2e74b5;">size_type</span> is bigger than <span style="color:#2e74b5;">int</span>, and converting to <span style="color:#2e74b5;">int</span> throws away not just the high-order bit, but over half of the bits and the vast majority of the representable values.</li>
</ul>
<p>Of course, you won&#8217;t notice on small <span style="color:#2e74b5;">vector</span>s as long as <span style="color:#2e74b5;">.size()</span> &lt; 2<sup>(CHAR_BITS*sizeof(int)-1)</sup>. That doesn&#8217;t mean it&#8217;s not a bug; it just means it&#8217;s a latent bug.</p>
<p>Does <span style="color:#2e74b5;">auto</span> help? Yes indeed:</p>
<pre><code><span style="background-color:yellow;">auto</span> size = v.size();    // exact type, guaranteed no narrowing
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto</strong>. It guarantees that you get the exact type and cannot accidentally get narrowing conversions.</p></blockquote>
<h3>(c), (d), and (e) have potential narrowing and signedness issues.</h3>
<pre><code>// (c) x and y are of some built-in integral type
int total = x + y;
</code></pre>
<p>In case (c), we might also have a narrowing conversion. The simplest way to see this is that if either <span style="color:#2e74b5;">x</span> or <span style="color:#2e74b5;">y</span> is larger than <span style="color:#2e74b5;">int</span>, which is what we&#8217;re trying to store the result into, then we&#8217;ve definitely got a silent narrowing conversion here, with the same issues as already described in (b). And even if <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> are <span style="color:#2e74b5;">int</span>s today, if under maintenance the type of one later changes to something like <span style="color:#2e74b5;">long</span> or <span style="color:#2e74b5;">size_t</span>, the code silently becomes lossy—and possibly only on some platforms, if it changes to <span style="color:#2e74b5;">long</span> and that&#8217;s the same size as <span style="color:#2e74b5;">int</span> on some platforms you target but larger than <span style="color:#2e74b5;">int</span> on others.</p>
<p>Note that, even if you know the exact types of <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span>, you will get different types for <span style="color:#2e74b5;">x+y</span> on different platforms, particularly if one is signed and one is unsigned. If both <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> are signed, or both are unsigned, and one&#8217;s type has more bits than the other, that&#8217;s the type of the result. If one is signed and the other is unsigned then other rules kick in, and the size and signedness of the result can vary on different platforms depending on the relative actual sizes and the signedness of <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> on that platform. (This is one of the consequences of C and C++ not standardizing the sizes of the built-in types; for example, we know a <span style="color:#2e74b5;">long</span> is guaranteed to be at least as big as an <span style="color:#2e74b5;">int</span>, but we don&#8217;t know how many bits each is, and the answer varies by compiler and platform.)</p>
<p>Does <span style="color:#2e74b5;">auto</span> help here? Almost always &#8220;yes,&#8221; but in one case &#8220;yes with a little help you really want to reach for anyway.&#8221;</p>
<p>By default, write for correctness, clarity, and portability first: To avoid lossy narrowing conversions, <span style="color:#2e74b5;">auto</span> is your portability pal and you should use it by default. Writing <span style="color:#2e74b5;">auto</span> is much better than writing it out by hand as <span style="color:#2e74b5;">std::common_type&lt; decltype(x), decltype(y) &gt;</span>.</p>
<pre><code><span style="background-color:yellow;">auto</span> total = x + y;    // exact type, guaranteed no narrowing
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto</strong>. It guarantees that you get the exact type and so is the simplest way to portably spell the implementation-specific type of arithmetic operations on built-in types, which vary by platform, and ensure that you cannot accidentally get narrowing conversions when storing the result.</p></blockquote>
<p>However, what if in rare cases this code may be in a tight loop where performance matters, and <span style="color:#2e74b5;">auto</span> may select a wider type than you know you need to store all possible values? For example, in some cases performing arithmetic using <span style="color:#2e74b5;">uint64_t</span> instead of <span style="color:#2e74b5;">uint32_t</span> could be twice as slow. If you first prove that this actually matters using hard profiler data, and then further prove by performing other validation that you won&#8217;t (or won&#8217;t care if you do) encounter results that would lose value by narrowing, then go ahead and commit to an explicit type—but prefer to do it using the following style:</p>
<pre><code>// rare cases: use auto + &lt;cstdint&gt; type
<span style="background-color:yellow;">auto</span> total = <span style="background-color:yellow;">uint_fast64_t</span>{ x+y };  // total is an unsigned 64-bit value
             // ^ see note [1]

// or use auto + size-preserving signed/unsigned helper [2]
<span style="background-color:yellow;">auto</span> total = <span style="background-color:yellow;">as_unsigned</span>( x+y );    // total is unsigned and size of x+y
</code></pre>
<ul>
<li>Still use <span style="color:#2e74b5;">auto</span> to naturally make this more self-documenting and make the code review easy, because <span style="color:#2e74b5;">auto</span> syntax makes it explicit that you&#8217;re performing a conversion.</li>
<li>
<div>Use a portable sized type name from the standard <span style="color:#2e74b5;">&lt;cstdint&gt;</span> header, because you almost certainly care about size and this makes the size portable.[1]</div>
<blockquote><p><strong>Guideline:</strong> Prefer using the <strong>&lt;cstdint&gt;</strong> type aliases in code that cares about the size of your numeric variables. Avoid relying on what your current platform(s) happen to do.</p></blockquote>
<blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, and won&#8217;t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use <strong>( )</strong> instead of <strong>{ }</strong>.</p></blockquote>
</li>
</ul>
<p>Case (d) is similar:</p>
<pre><code>// (d) x and y are of some built-in integral type
int diff = x - y;
if(diff &lt; 0) { /*...*/ }
</code></pre>
<p>This time, we&#8217;re doing a subtraction. No matter whether <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> are signed or not, putting the answer in a signed variable like this is the right thing to do—the result could be negative, after all.</p>
<p>However, we have two issues. The first, again, is that <span style="color:#2e74b5;">int</span> may not be big enough to avoid truncating the result, so we might lose information if <span style="color:#2e74b5;">x &#8211; y</span> produces something larger than an <span style="color:#2e74b5;">int</span>. Using <span style="color:#2e74b5;">auto</span> can help with that.</p>
<p>The second is that <span style="color:#2e74b5;">x &#8211; y</span> might give a strange answer, which isn&#8217;t the programmer&#8217;s fault but is something you want to remember about arithmetic in C and C++. Consider this code:</p>
<pre><code>unsigned long x    = 42;
signed short  y    = 43;
<span style="color:#c00000;">auto          diff = x - y;   // one actual result: 18446744073709551615
if(diff &lt; 0) { /*...*/ }      // um, oops – branch won't be taken
</span></code></pre>
<p>&#8220;Wait, what?&#8221; you ask. On nearly all platforms, an <span style="color:#2e74b5;">unsigned long</span> is bigger than a <span style="color:#2e74b5;">signed short</span>, and because of the promotion rules the type of <span style="color:#2e74b5;">s &#8211; u</span>, and therefore of <span style="color:#2e74b5;">result</span>, will be… <span style="color:#2e74b5;">unsigned long</span>. Which is, well, not very signed. So depending on the types of <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span>, and depending on your actual platform, it may be that the branch won&#8217;t be taken, which clearly isn&#8217;t the same as the original code.</p>
<blockquote><p><strong>Guideline:</strong> Combine signed and unsigned arithmetic carefully.</p></blockquote>
<p>Before you say, &#8220;then I always want signed!&#8221; remember that if you overflow then unsigned arithmetic wraps, which can be valid for your use, whereas signed arithmetic has undefined behavior, which is quite unlikely to be useful. Sometimes you really need signed, and sometimes you really need unsigned, even though often you won&#8217;t care.</p>
<p>From observing <span style="color:#2e74b5;">auto</span>&#8216;s effect in case (d), it might seem like <span style="color:#2e74b5;">auto</span> has helped one problem… but was it at the expense of creating another?</p>
<p>Yes, on the one hand, <span style="color:#2e74b5;">auto</span> did indeed help us: Using <span style="color:#2e74b5;">auto</span> ensured we could write portable and correct code where the result wasn&#8217;t needlessly narrowed. If we didn&#8217;t care about signedness, which is often true, that&#8217;s quite sufficient.</p>
<p>On the other hand, using <span style="color:#2e74b5;">auto</span> might not preserve signedness in a computation like <span style="color:#2e74b5;">x &#8211; y</span> that&#8217;s supposed to return something with a sign, or it might not preserve unsignedness when that&#8217;s desirable. But this isn&#8217;t so much an issue with <span style="color:#2e74b5;">auto</span> itself as that we have to be careful when combining signed and unsigned arithmetic, and by binding to an exact type <span style="color:#2e74b5;">auto</span> is exposing this issue with some code that might potentially be already nonportable, or have corner cases the developer wasn&#8217;t aware of when he wrote it.</p>
<p>So what&#8217;s a good answer? Consider using <span style="color:#2e74b5;">auto</span> together with the <span style="color:#2e74b5;">as_signed</span> or <span style="color:#2e74b5;">as_unsigned</span> conversion helper we saw before, which is used in lieu of a cast to a specific type; the helper is written out more fully in the endnotes. [2] Then we get the best of both worlds—we don&#8217;t commit to an explicit type, but we ensure the basic size and signedness in portable code that will work as intended on many different compilers and platforms.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to use <strong>auto x = as_signed(integer_expr);</strong> or <strong>auto x = as_unsigned(integer_expr);</strong> to store the result of an integer computation that should be signed or unsigned. Using <strong>auto</strong> together with <strong>as_signed</strong> or <strong>as_unsigned</strong> makes code more portable: the variable will both be large enough and preserve the required signedness on all platforms. (Signed/unsigned conversions within <strong>integer_expr</strong> may still occur.)</p></blockquote>
<p>Finally, case (e) brings floating point into the picture:</p>
<pre><code>// (e)
int i = f(1,2,3) * 42.0;
</code></pre>
<p>Here we have our by-now-yawnworthy-typical narrowing—and an easy case because it isn&#8217;t even hiding, it&#8217;s saying <span style="color:#2e74b5;">int</span> and <span style="color:#2e74b5;">42.0</span> right there in the same breath, which is narrowing almost regardless of what type <span style="color:#2e74b5;">f</span> returns.</p>
<p>Does <span style="color:#2e74b5;">auto</span> help? Yes, in making our code self-documenting and more reviewable, as we noted before. If we follow the <span style="color:#2e74b5;">auto x = type{expr};</span> declaration style, we would be (happily) forced to write the conversion explicitly, and when we initially use <span style="color:#2e74b5;">{ }</span> we get an error that in fact it&#8217;s a narrowing conversion, which we acknowledge (again explicitly) by switching to <span style="color:#2e74b5;">( )</span>:</p>
<pre><code><span style="background-color:yellow;">auto</span> i = int( f(1,2,3) * 42.0 );
</code></pre>
<p>This code is now free of implicit conversions, including implicit narrowing conversions. If our team&#8217;s coding style says to use <span style="color:#2e74b5;">auto x = expr;</span> or <span style="color:#2e74b5;">auto x = type{expr};</span> wherever possible, then in a code review just seeing the <span style="color:#2e74b5;">( )</span> parens can immediately connote explicit narrowing; adding a comment doesn&#8217;t hurt either.</p>
<p>But for floating point calculations, can using <span style="color:#2e74b5;">auto</span> by itself hurt? Consider this example, contributed by Andrei Alexandrescu:</p>
<pre><code>float f1 = /*...*/, f2 = /*...*/;

<span style="background-color:yellow;">auto</span>   f3 = f1 + f2;   // correct, but on some compilers/platforms...
<span style="background-color:yellow;">double</span> f4 = f1 + f2;   // ... this might keep more bits of precision
</code></pre>
<p>As Alexandrescu notes: &#8220;Machines are free to do intermediate calculations in a larger precision than the target, and in many cases (and traditionally in C) calculations are done in double precision. So for <span style="color:#2e74b5;">f3</span> we have a sum done in double precision, which is then <em>truncated</em> down to <span style="color:#2e74b5;">float</span>. For <span style="color:#2e74b5;">f4</span>, the sum is preserved at full precision.&#8221;</p>
<p>Does this mean using <span style="color:#2e74b5;">auto</span> creates a potential flaw here? Not really. In the language, the type of <span style="color:#2e74b5;">f1 + f2</span> is still <span style="color:#2e74b5;">float</span>, and the naked <span style="color:#2e74b5;">auto</span> maintains that exact type for us. However, if we do want to follow the pattern of switching to <span style="color:#2e74b5;">double</span> early in a complex computation, we can and should say so:</p>
<pre><code>float f1 = /*...*/, f2 = /*...*/;

<span style="background-color:yellow;">auto</span> f5 = <span style="background-color:yellow;">double</span>{f1} + f2;
</code></pre>
<h2>Summary</h2>
<p>We&#8217;ve seen a number of reasons to prefer to declare variables using <span style="color:#2e74b5;">auto</span>, optionally with an explicit type if you do want to commit to a specific type.</p>
<p>If you&#8217;re observed a pattern in this GotW&#8217;s Guidelines, you&#8217;ll already have a sense of what&#8217;s coming in GotW #94… a Special Edition on, you guessed it, <span style="color:#2e74b5;">auto</span> style.</p>
<h2>Notes</h2>
<p>[1] Another reason to prefer using the <span style="color:#2e74b5;">&lt;cstdint&gt;</span> typedef names is because, due to a quirk in the C++ language grammar, only a single-word type is allowed where <span style="color:#2e74b5;">uint64_t</span> appears in this example. That&#8217;s fine nearly always because it&#8217;s all you need for class types and all <span style="color:#2e74b5;">typedef</span> and <span style="color:#2e74b5;">using</span> alias names and most built-in types, but you can&#8217;t directly name arrays or the multi-word built-in types like <span style="color:#2e74b5;">unsigned int</span> or <span style="color:#2e74b5;">long long</span> in that position; for the latter, use the <span style="color:#2e74b5;">uintNN_t</span>-style typedef names instead. The exact ones, such as <span style="color:#2e74b5;">uint64_t</span>, are &#8220;optional&#8221; in the standard, but they are in the standard and expected to be widely implemented so I used them. The &#8220;least&#8221; and &#8220;fast&#8221; ones are required, so if you don&#8217;t have <span style="color:#2e74b5;">uint64_t</span> you can use <span style="color:#2e74b5;">uint_least64_t</span> or <span style="color:#2e74b5;">uint_fast64_t</span>.</p>
<p>[2] The helpers preserve the size of the type while changing only the signedness. Thanks to Andrei Alexandrescu for this basic idea; any errors are mine, not his. The C++98 way is to provide a set of overloads for each type, but a modern version might look something like the following which uses the C++11 <span style="color:#2e74b5;">std::make_signed</span>/<span style="color:#2e74b5;">make_unsigned</span> facilities.</p>
<pre><code>// C++11 version
//
template&lt;class T&gt;
typename make_signed&lt;T&gt;::type as_signed(T t)
    { return make_signed&lt;T&gt;::type(t); }

template&lt;class T&gt;
typename make_unsigned&lt;T&gt;::type as_unsigned(T t)
    { return make_unsigned&lt;T&gt;::type(t); }
</code></pre>
<p>Note that with C++14 this gets even sweeter, using <span style="color:#2e74b5;">auto</span> return type deduction to eliminate <span style="color:#2e74b5;">typename</span> and repetition, and the <span style="color:#2e74b5;">_t</span> alias to replace <span style="color:#2e74b5;">::type</span>:</p>
<pre><code>// C++14 version, option 1
//
template&lt;class T&gt; auto as_signed  (T t){ return make_signed_t  &lt;T&gt;(t); }
template&lt;class T&gt; auto as_unsigned(T t){ return make_unsigned_t&lt;T&gt;(t); }
</code></pre>
<p>or you can equivalently write these function templates as named lambdas:</p>
<pre><code>// C++14 version, option 2
//
auto as_signed   =[](auto x){ return make_signed_t  &lt;decltype(x)&gt;(x); };
auto as_unsigned =[](auto x){ return make_unsigned_t&lt;decltype(x)&gt;(x); };
</code></pre>
<p>Sweet, isn&#8217;t it? Once you have a compiler that supports these features, pick whichever suits your fancy.</p>
<h2>Acknowledgments</h2>
<p>Thanks in particular to Scott Meyers and Andrei Alexandrescu for their time and insights in reviewing and discussing drafts of this material. Thanks also to the following for their feedback to improve this article: mttpd, Jim Park, Yuri Khan, Arne, rhalbersma, Tom, Martin Ba, John, Frederic Dumont, Sebastian.</p>
					<p><a href="https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/" rel="bookmark" title="Permanent Link to GotW #93 Solution: Auto Variables, Part&nbsp;2">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
			<div class="post-2119 post type-post status-publish format-standard hentry category-gotw" id="post-2119">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/" rel="bookmark">GotW #93: Auto Variables, Part&nbsp;2</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-06-07|
													<a href="https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comments">12 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="color:#5a5a5a;"><em>Why prefer declaring variables using auto? Let us count some of the reasons why…<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// (a)<br />void traverser( const vector&lt;int&gt;&amp; v ) {<br />    for( vector&lt;int&gt;::iterator i = begin(v); i != end(v); i += 2 )<br />        // ...<br />}<br /><br />// (b)<br />vector&lt;int&gt; v1(5);<br />vector&lt;int&gt; v2 = 5;<br /><br />// (c)<br />gadget get_gadget();<br />// ...<br />widget w = get_gadget();<br /><br />// (d)<br />function&lt;void(vector&lt;int&gt;)&gt; get_size<br />    = [](vector&lt;int&gt; x) { return x.size(); };
</code></pre>
</p>
<h2>Guru Question<br />
</h2>
<p>2. Same question, subtler examples: In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// (a)<br />widget w;<br /><br />// (b)<br />vector&lt;string&gt; v;<br />int size = v.size();<br /><br />// (c) x and y are of some built-in integral type<br />int total = x + y;<br /><br />// (d) x and y are of some built-in integral type<br />int diff = x - y;<br />if(diff &lt; 0) { /*...*/ }<br /><br />// (e)<br />int i = f(1,2,3) * 42.0;
</code></pre></p>
					<p><a href="https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/" rel="bookmark" title="Permanent Link to GotW #93: Auto Variables, Part&nbsp;2">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
			<div class="post-2109 post type-post status-publish format-standard hentry category-gotw" id="post-2109">
				<div class="posttitle">
					<h2><a href="https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/" rel="bookmark">GotW #92 Solution: Auto Variables, Part&nbsp;1</a></h2>
					<p class="post-info">
					Posted in <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a> on 2013-06-07|
													<a href="https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comments">19 Comments &#187;</a>											</p>
				</div>

				<div class="entry">
					<p><span style="color:#5a5a5a;"><em>What does auto do on variable declarations, exactly? And how should we think about auto? In this GotW, we&#8217;ll start taking a look at C++&#8217;s oldest new feature.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is the oldest C++11 feature? Explain.
</p>
<p>2. What does <span style="color:#2e74b5;">auto</span> mean when declaring a local variable?
</p>
<h2>Guru Questions<br />
</h2>
<p>3. In the following code, what is the type of variables <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">k</span>, and why? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int         val = 0;<br />auto        a   = val;<br />auto&amp;       b   = val;<br />const auto  c   = val;<br />const auto&amp; d   = val;<br /><br />int&amp;        ir  = val;<br />auto        e   = ir;<br /><br />int*        ip  = &amp;val; <br />auto        f   = ip;<br /><br />const int   ci  = val;<br />auto        g   = ci;<br /><br />const int&amp;  cir = val;<br />auto        h   = cir;<br /><br />const int*  cip = &amp;val;<br />auto        i   = cip;<br /><br />int* const  ipc = &amp;val;<br />auto        j   = ipc;<br /><br />const int* const cipc = &amp;val;<br />auto             k    = cipc;
</code></pre>
</p>
<p>4. In the following code, what type does <span style="color:#2e74b5;">auto</span> deduce for variables <span style="color:#2e74b5;">a</span> and <span style="color:#2e74b5;">b</span>, and why? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int val = 0;<br /><br />auto a { val };<br />auto b = { val };
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What is the oldest C++11 feature? Explain.<br />
</h2>
<p><span style="color:#2e74b5;">auto x = something;</span> to declare a new local variable whose type is deduced from <span style="color:#2e74b5;">something</span>, and isn&#8217;t just always <span style="color:#2e74b5;">int</span>.
</p>
<p>Bjarne Stroustrup likes to point out that <span style="color:#2e74b5;">auto</span> for deducing the type of local variables is the oldest feature added in the 2011 release of the C++ standard. He implemented it in C++ 28 years earlier, in 1983—which incidentally was the same year the language&#8217;s name was changed to C++ from C with Classes (the new name was unveiled publicly on January 1, 1984), and the same year Stroustrup added other fundamental features including <span style="color:#2e74b5;">const</span> (later adopted by C), <span style="color:#2e74b5;">virtual</span> functions, <span style="color:#2e74b5;">&amp;</span> references, and BCPL-style <span style="color:#2e74b5;">//</span> comments.
</p>
<p>Alas, Stroustrup was forced to remove <span style="color:#2e74b5;">auto</span> because of compatibility concerns with C&#8217;s then-existing implicit <span style="color:#2e74b5;">int</span> rule, which has since been abandoned in C. We&#8217;re glad <span style="color:#2e74b5;">auto</span> is now back and here to stay.
</p>
<h2>2. What does auto mean when declaring a local variable?<br />
</h2>
<p>It means to deduce the type from the expression used to initialize the new variable. In particular, <span style="color:#2e74b5;">auto</span> local variables deduction is exactly the same as type deduction for parameters of function templates—by specification, the rule for <span style="color:#2e74b5;">auto</span> variables says &#8220;do what function templates are required to do&#8221;—plus they can capture <span style="color:#2e74b5;">initializer_list</span> as a type. For example:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>template&lt;class T&gt; void f( T ) { }<br /><br />int val = 0;<br /><br />f( val );                // deduces T == int, calls f&lt;int&gt;( val )<br />auto x = val;            // deduces T == int, x is of type int
</code></pre>
</p>
<p>When you&#8217;re new to <span style="color:#2e74b5;">auto</span>, the key thing to remember is that you really are declaring your own new local variable. That is, &#8220;what&#8217;s on the left&#8221; is my new variable, and &#8220;what&#8217;s on the right&#8221; is just its initial value:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>auto my_new_variable = its_initial_value;
</code></pre>
</p>
<p>You want <em>your new variable</em> to be just like <em>some existing variable</em> or expression over there, and be initialized from it, but that only means that you want the same basic type, not necessarily that other variable&#8217;s own personal secondary attributes such as top-level <span style="color:#2e74b5;">const</span>&#8211; or <span style="color:#2e74b5;">volatile</span>-ness and <span style="color:#2e74b5;">&amp;</span>/<span style="color:#2e74b5;">&amp;&amp;</span> reference-ness which are per-variable. For example, just because he&#8217;s <span style="color:#2e74b5;">const</span> doesn&#8217;t mean you&#8217;re <span style="color:#2e74b5;">const</span>, and vice versa.
</p>
<p>It&#8217;s kind of like being identical twins: Andy may be genetically <em>just like</em> his brother Bobby and is part of the same family, but he&#8217;s not the same person; he&#8217;s a distinct person and can make his own choice of clothes and/or jewelry, go to be seen on the scene in different parts of town, and so forth. So your new variable will be <em>just like</em> that other one and be part of the same type family, but it&#8217;s not the same variable; it&#8217;s a distinct variable with its own choice of whether it wants to be dressed with <span style="color:#2e74b5;">const</span>, <span style="color:#2e74b5;">volatile</span>, and/or a <span style="color:#2e74b5;">&amp;</span> or <span style="color:#2e74b5;">&amp;&amp;</span> reference, may be visible to different threads, and so forth.
</p>
<p>Remembering this will let us easily answer the rest of our questions.
</p>
<h2>3. In the following code, what is the type of variables a through k, and why? Explain.<br />
</h2>
<p>Quick reminder: <span style="color:#2e74b5;">auto</span> means &#8220;take exactly the type on the right-hand side, but strip off top-level <span style="color:#2e74b5;">const</span>/<span style="color:#2e74b5;">volatile</span> and <span style="color:#2e74b5;">&amp;</span>/<span style="color:#2e74b5;">&amp;&amp;</span>.&#8221; Armed with that, these are mostly pretty easy.
</p>
<p>For simplicity, these examples use <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">&amp;</span>. The rules for adding or removing <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">volatile</span> are the same, and the rules for adding or removing <span style="color:#2e74b5;">&amp;</span> and <span style="color:#2e74b5;">&amp;&amp;</span> are the same.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int         val = 0;<br />auto        a   = val;<br />auto&amp;       b   = val;<br />const auto  c   = val;<br />const auto&amp; d   = val;
</code></pre>
</p>
<p>For <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">d</span>, the type is what you get from replacing <span style="color:#2e74b5;">auto</span> with <span style="color:#2e74b5;">int</span>: <span style="color:#2e74b5;">int</span>, <span style="color:#2e74b5;">int&amp;</span>, <span style="color:#2e74b5;">const int</span>, and <span style="color:#2e74b5;">const int&amp;</span>, respectively. The same ability to add <span style="color:#2e74b5;">const</span> applies to <span style="color:#2e74b5;">volatile</span>, and the same ability to add <span style="color:#2e74b5;">&amp;</span> applies to <span style="color:#2e74b5;">&amp;&amp;</span>. (Note that <span style="color:#2e74b5;">&amp;&amp;</span> will be what Scott Meyers calls a universal reference, just as with templates, and does in some cases bring across the <span style="color:#2e74b5;">const</span>-ness if it&#8217;s binding to something <span style="color:#2e74b5;">const</span>.)
</p>
<p>Now that we&#8217;ve exercised adding top-level <span style="color:#2e74b5;">const</span> (or <span style="color:#2e74b5;">volatile</span>) and <span style="color:#2e74b5;">&amp;</span> (or <span style="color:#2e74b5;">&amp;&amp;</span>) on the left, let&#8217;s consider how they&#8217;re removed on the right. Note that the left hand side of <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">d</span> can be used in any combination with the right hand side of <span style="color:#2e74b5;">e</span> through <span style="color:#2e74b5;">k</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int&amp;        ir  = val;<br />auto        e   = ir;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">e</span> is <span style="color:#2e74b5;">int</span>. Because <span style="color:#2e74b5;">ir</span> is a reference to <span style="color:#2e74b5;">val</span>, which makes <span style="color:#2e74b5;">ir</span> just another name for <span style="color:#2e74b5;">val</span>, it&#8217;s exactly the same as if we had written <span style="color:#2e74b5;">auto e = val;</span> here.
</p>
<p>Remember, just because <span style="color:#2e74b5;">ir</span> is a reference (another name for the existing variable <span style="color:#2e74b5;">val</span>) doesn&#8217;t have any bearing on whether we want <span style="color:#2e74b5;">e</span> to be a reference. If we wanted <span style="color:#2e74b5;">e</span> to be a reference, we would have said <span style="color:#2e74b5;">auto&amp;</span> as we did in case <span style="color:#2e74b5;">b</span> above, and it would have been a reference irrespective of whether <span style="color:#2e74b5;">ir</span> happened to be a reference or not.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int*        ip  = &amp;val; <br />auto        f   = ip;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">f</span> is <span style="color:#2e74b5;">int*</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int   ci  = val;<br />auto        g   = ci;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">g</span> is <span style="color:#2e74b5;">int</span>.
</p>
<p>Remember, just because <span style="color:#2e74b5;">ci</span> is <span style="color:#2e74b5;">const</span> (read-only) doesn&#8217;t have any bearing on whether we want <span style="color:#2e74b5;">g</span> to be <span style="color:#2e74b5;">const</span>. It&#8217;s a separate variable. If we wanted <span style="color:#2e74b5;">g</span> to be const, we would have said <span style="color:#2e74b5;">const auto</span> as we did in case <span style="color:#2e74b5;">c</span> above, and it would have been <span style="color:#2e74b5;">const</span> irrespective of whether <span style="color:#2e74b5;">ci</span> happened to be <span style="color:#2e74b5;">const</span> or not.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int&amp;  cir = val;<br />auto        h   = cir;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">h</span> is <span style="color:#2e74b5;">int</span>.
</p>
<p>Again, remember we just drop top-level <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">&amp;</span> to get the basic type. If we wanted <span style="color:#2e74b5;">h</span> to be <span style="color:#2e74b5;">const</span> and/or <span style="color:#2e74b5;">&amp;</span>, we could just add it as shown with <span style="color:#2e74b5;">b</span>, <span style="color:#2e74b5;">c</span>, and <span style="color:#2e74b5;">d</span> above.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int*  cip = &amp;val;<br />auto        i   = cip;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">i</span> is <span style="color:#2e74b5;">const int*</span>.
</p>
<p>Note that this isn&#8217;t a top-level <span style="color:#2e74b5;">const</span>, so we don&#8217;t drop it. We pronounce <span style="color:#2e74b5;">cip</span>&#8216;s declaration right to left: The type of <span style="color:#2e74b5;">cip</span> is &#8220;pointer to <span style="color:#2e74b5;">const int</span>,&#8221; not &#8220;<span style="color:#2e74b5;">const</span> pointer to <span style="color:#2e74b5;">int</span>.&#8221; What&#8217;s <span style="color:#2e74b5;">const</span> is not <span style="color:#2e74b5;">cip</span>, but rather <span style="color:#2e74b5;">*cip</span>, the <span style="color:#2e74b5;">int</span> it&#8217;s pointing to.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int* const  ipc = &amp;val;<br />auto        j   = ipc;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">j</span> is <span style="color:#2e74b5;">int*</span>. This <span style="color:#2e74b5;">const</span> is a top-level <span style="color:#2e74b5;">const</span>, and <span style="color:#2e74b5;">ipc</span>&#8216;s being <span style="color:#2e74b5;">const</span> is immaterial to whether we want <span style="color:#2e74b5;">j</span> to be <span style="color:#2e74b5;">const</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int* const cipc = &amp;val;<br />auto             k    = cipc;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">k</span> is <span style="color:#2e74b5;">const int*</span>.
</p>
<h2>4. In the following code, what type does auto deduce for variables a and b, and why? Explain.<br />
</h2>
<p>As we noted in #2, the only place where an <span style="color:#2e74b5;">auto</span> variable deduces anything different from a template parameter is that <span style="color:#2e74b5;">auto</span> deduces an <span style="color:#2e74b5;">initializer_list</span>. This brings us to the final cases:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int val = 0;<br /><br />auto a { val };<br />auto b = { val };
</code></pre>
</p>
<p>The type of both <span style="color:#2e74b5;">a</span> and <span style="color:#2e74b5;">b</span> is <span style="color:#2e74b5;">std::initializer_list&lt;int&gt;</span>.
</p>
<p>That&#8217;s the only difference between <span style="color:#2e74b5;">auto</span> variable deduction and template parameter deduction—by specification, because auto deduction is defined in the standard as &#8220;follow those rules over there in the templates clause, plus deduce <span style="color:#2e74b5;">initializer_list</span>.&#8221;
</p>
<p>If you&#8217;re familiar with templates and curious how <span style="color:#2e74b5;">auto</span> deduction and template deduction map to each other, the table below lists the main cases and shows the equivalent syntax between the two features. For the left column, I&#8217;ll put the variable and the initialization on separate lines to emphasize how they correspond to the separated template parameter and call site on the right.
</p>
<p style="text-align:center;"><img src="https://herbsutter.files.wordpress.com/2013/06/061013_1727_gotw92solut1.png?w=500" alt="" />
	</p>
<p>Not only are the cases equivalent in expressive power, but you might even feel that some of the <span style="color:#2e74b5;">auto</span> versions feel even slicker to you than their template counterparts.
</p>
<h2>Summary<br />
</h2>
<p>Having <span style="color:#2e74b5;">auto</span> variables really brings a feature we already had (template deduction) to an even wider audience. But so far we&#8217;ve only seen what <span style="color:#2e74b5;">auto</span> does. The even more interesting question is how to use it. Which brings us to our next GotW…
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: davidphilliposter, Phil Barila, Ralph Tandetzky, Marcel Wild.</p>
					<p><a href="https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/" rel="bookmark" title="Permanent Link to GotW #92 Solution: Auto Variables, Part&nbsp;1">Read Full Post &raquo;</a></p>
				</div>
							</div>

		
		<p align="center"><a href="https://herbsutter.com/category/c/gotw/" >&laquo; Newer Posts</a> - <a href="https://herbsutter.com/category/c/gotw/page/3/" >Older Posts &raquo;</a></p>

	</div><!-- end id:content-main -->
<div id="sidebar">
<ul>
<li class="sidebox"><h2><label for="subscribe-field">Follow by email</label></h2>
				<form action="https://subscribe.wordpress.com" method="post" accept-charset="utf-8" id="subscribe-blog">
																	<p><input type="text" name="email" style="width: 95%; padding: 1px 2px" placeholder="Enter your email address" value="" id="subscribe-field"/></p>
					
					<p>
						<input type="hidden" name="action" value="subscribe"/>
						<input type="hidden" name="blog_id" value="3379246"/>
						<input type="hidden" name="source" value="https://herbsutter.com/category/c/gotw/page/2/"/>
						<input type="hidden" name="sub-type" value="widget"/>
						<input type="hidden" name="redirect_fragment" value="blog_subscription-3" />
						<input type="hidden" id="_wpnonce" name="_wpnonce" value="4590924cc6" />						<input type="submit" value="Subscribe" />
					</p>
				</form>
			
</li><li class="sidebox"><h2><a href='http://twitter.com/herbsutter'>Tweets</a></h2><ul class='tweets'></ul><a href="http://twitter.com/herbsutter"  class='twitter-follow-button' data-show-count='false' data-link-color='#265e15' data-text-color='#333333'>Follow @herbsutter</a></li><li class="sidebox"><h2>Popular</h2><ul>				<li>
										<a href="https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/" class="bump-view" data-bump-view="tp">
						Trip report: Fall ISO C++ standards meeting (San Diego)					</a>
										</li>
								<li>
										<a href="https://herbsutter.com/gotw/" class="bump-view" data-bump-view="tp">
						GotW					</a>
										</li>
								<li>
										<a href="https://herbsutter.com/2018/09/20/lifetime-profile-v1-0-posted/" class="bump-view" data-bump-view="tp">
						Lifetime profile v1.0 posted					</a>
										</li>
				</ul></li><li class="sidebox"><h2>Categories</h2>		<ul>
				<li class="cat-item cat-item-291"><a href="https://herbsutter.com/category/apple/" >Apple</a>
</li>
	<li class="cat-item cat-item-49277"><a href="https://herbsutter.com/category/c-net/" >C# / .NET</a>
</li>
	<li class="cat-item cat-item-2426 current-cat-parent current-cat-ancestor"><a href="https://herbsutter.com/category/c/" >C++</a>
</li>
	<li class="cat-item cat-item-69816"><a href="https://herbsutter.com/category/cloud/" >Cloud</a>
</li>
	<li class="cat-item cat-item-214618"><a href="https://herbsutter.com/category/concurrency/" >Concurrency</a>
</li>
	<li class="cat-item cat-item-8259773"><a href="https://herbsutter.com/category/effective-concurrency/" >Effective Concurrency</a>
</li>
	<li class="cat-item cat-item-3696745"><a href="https://herbsutter.com/category/friday-thoughts/" >Friday Thoughts</a>
</li>
	<li class="cat-item cat-item-3867746 current-cat"><a href="https://herbsutter.com/category/c/gotw/" >GotW</a>
</li>
	<li class="cat-item cat-item-79"><a href="https://herbsutter.com/category/hardware/" >Hardware</a>
</li>
	<li class="cat-item cat-item-1017"><a href="https://herbsutter.com/category/java/" >Java</a>
</li>
	<li class="cat-item cat-item-637"><a href="https://herbsutter.com/category/microsoft/" >Microsoft</a>
</li>
	<li class="cat-item cat-item-420845"><a href="https://herbsutter.com/category/opinion-editorial/" >Opinion &amp; Editorial</a>
</li>
	<li class="cat-item cat-item-1633077"><a href="https://herbsutter.com/category/reader-qa/" >Reader Q&amp;A</a>
</li>
	<li class="cat-item cat-item-2301"><a href="https://herbsutter.com/category/software-development/" >Software Development</a>
</li>
	<li class="cat-item cat-item-393523"><a href="https://herbsutter.com/category/talks-events/" >Talks &amp; Events</a>
</li>
	<li class="cat-item cat-item-1"><a href="https://herbsutter.com/category/uncategorized/" >Uncategorized</a>
</li>
	<li class="cat-item cat-item-151"><a href="https://herbsutter.com/category/web/" >Web</a>
</li>
		</ul>
			</li></ul>
</div><!-- end id:sidebar -->
</div><!-- end id:content -->
</div><!-- end id:container -->
<div id="footer">
	<div id="colophon">
		<p><a href="https://wordpress.com/?ref=footer_blog">Blog at WordPress.com.</a></p>
		<p>WPThemes.</p>
		<br class="clear" />
	</div><!-- end #colophon-->
</div><!-- end #footer-->
		<script type="text/javascript">
		//<![CDATA[
		var infiniteScroll = {"settings":{"id":"content-main","ajaxurl":"https:\/\/herbsutter.com\/?infinity=scrolling","type":"scroll","wrapper":true,"wrapper_class":"infinite-wrap","footer":true,"click_handle":"1","text":"Older posts","totop":"Scroll back to top","currentday":"07.06.13","order":"DESC","scripts":[],"styles":[],"google_analytics":false,"offset":2,"history":{"host":"herbsutter.com","path":"\/category\/c\/gotw\/page\/%d\/","use_trailing_slashes":true,"parameters":""},"query_args":{"paged":2,"category_name":"gotw","error":"","m":"","p":0,"post_parent":"","subpost":"","subpost_id":"","attachment":"","attachment_id":0,"name":"","pagename":"","page_id":0,"second":"","minute":"","hour":"","day":0,"monthnum":0,"year":0,"w":0,"tag":"","cat":3867746,"tag_id":"","author":"","author_name":"","feed":"","tb":"","meta_key":"","meta_value":"","preview":"","s":"","sentence":"","title":"","fields":"","menu_order":"","embed":"","category__in":[],"category__not_in":[],"category__and":[],"post__in":[],"post__not_in":[],"post_name__in":[],"tag__in":[],"tag__not_in":[],"tag__and":[],"tag_slug__in":[],"tag_slug__and":[],"post_parent__in":[],"post_parent__not_in":[],"author__in":[],"author__not_in":[],"posts_per_page":7,"ignore_sticky_posts":false,"suppress_filters":false,"cache_results":false,"update_post_term_cache":true,"lazy_load_term_meta":true,"update_post_meta_cache":true,"post_type":"","nopaging":false,"comments_per_page":"50","no_found_rows":false,"order":"DESC"},"last_post_date":"2013-06-07 05:34:05","stats":"blog=3379246&v=wpcom&tz=-8&user_id=0&subd=herbsutter&x_pagetype=infinite"}};
		//]]>
		</script>
		<!--  -->
<script type='text/javascript' src='//0.gravatar.com/js/gprofiles.js?ver=201847y'></script>
<script type='text/javascript'>
/* <![CDATA[ */
var WPGroHo = {"my_hash":""};
/* ]]> */
</script>
<script type='text/javascript' src='https://s1.wp.com/wp-content/mu-plugins/gravatar-hovercards/wpgroho.js?m=1380573781h'></script>

	<script>
		//initialize and attach hovercards to all gravatars
		jQuery( document ).ready( function( $ ) {

			if (typeof Gravatar === "undefined"){
				return;
			}

			if ( typeof Gravatar.init !== "function" ) {
				return;
			}			

			Gravatar.profile_cb = function( hash, id ) {
				WPGroHo.syncProfileData( hash, id );
			};
			Gravatar.my_hash = WPGroHo.my_hash;
			Gravatar.init( 'body', '#wp-admin-bar-my-account' );
		});
	</script>

		<div style="display:none">
	</div>
		<div id="infinite-footer">
			<div class="container">
				<div class="blog-info">
					<a id="infinity-blog-title" href="https://herbsutter.com/" rel="home">
						Sutter’s Mill					</a>
				</div>
				<div class="blog-credits">
					<a href="https://wordpress.com/?ref=footer_blog">Blog at WordPress.com.</a> 				</div>
			</div>
		</div><!-- #infinite-footer -->
		
	<div id="carousel-reblog-box">
		<form action="#" name="carousel-reblog">
			<textarea id="carousel-reblog-content" name="carousel-reblog-content" placeholder="Add your thoughts here... (optional)"></textarea>
			<label for="carousel-reblog-to-blog-id" id="carousel-reblog-lblogid">Post to</label>
			<select name="carousel-reblog-to-blog-id" id="carousel-reblog-to-blog-id">
						</select>

			<div class="submit">
				<span class="canceltext"><a href="#" class="cancel">Cancel</a></span>
				<input type="submit" name="carousel-reblog-submit" class="button" id="carousel-reblog-submit" value="Reblog Post" />
				<input type="hidden" id="carousel-reblog-blog-id" value="3379246" />
				<input type="hidden" id="carousel-reblog-blog-url" value="https://herbsutter.com" />
				<input type="hidden" id="carousel-reblog-blog-title" value="Sutter’s Mill" />
				<input type="hidden" id="carousel-reblog-post-url" value="" />
				<input type="hidden" id="carousel-reblog-post-title" value="" />
			</div>

			<input type="hidden" id="_wpnonce" name="_wpnonce" value="c0f0a72e87" /><input type="hidden" name="_wp_http_referer" value="/category/c/gotw/page/2/" />		</form>

		<div class="arrow"></div>
	</div>
<link rel='stylesheet' id='all-css-0-2' href='https://s0.wp.com/wp-content/mu-plugins/carousel/jetpack-carousel.css?m=1524699534h&cssminify=yes' type='text/css' media='all' />
<!--[if lte IE 8]>
<link rel='stylesheet' id='jetpack-carousel-ie8fix-css'  href='https://s1.wp.com/wp-content/mu-plugins/carousel/jetpack-carousel-ie8fix.css?m=1412618825h&#038;ver=20121024' type='text/css' media='all' />
<![endif]-->
<link rel='stylesheet' id='all-css-2-2' href='https://s2.wp.com/wp-content/mu-plugins/tiled-gallery/tiled-gallery.css?m=1443731146h&cssminify=yes' type='text/css' media='all' />
<script type='text/javascript'>
/* <![CDATA[ */
var actionbardata = {"siteID":"3379246","siteName":"Sutter\u2019s Mill","siteURL":"https:\/\/herbsutter.com","icon":"<img alt='' src='https:\/\/secure.gravatar.com\/blavatar\/4554b8d24c7f200dc5e2e1b18db1893f?s=50&d=https%3A%2F%2Fs2.wp.com%2Fi%2Flogo%2Fwpcom-gray-white.png' class='avatar avatar-50' height='50' width='50' \/>","canManageOptions":"","canCustomizeSite":"","isFollowing":"","themeSlug":"pub\/mistylook","signupURL":"https:\/\/wordpress.com\/start\/","loginURL":"https:\/\/herbsutter.wordpress.com\/wp-login.php?redirect_to=https%3A%2F%2Fherbsutter.com%2F2013%2F08%2F19%2Fgotw-7a-solution-minimizing-compile-time-dependencies-part-1%2F","themeURL":"","xhrURL":"https:\/\/herbsutter.com\/wp-admin\/admin-ajax.php","nonce":"8fb9818ae2","isSingular":"","isFolded":"","isLoggedIn":"","isMobile":"","subscribeNonce":"<input type=\"hidden\" id=\"_wpnonce\" name=\"_wpnonce\" value=\"4590924cc6\" \/>","referer":"https:\/\/herbsutter.com\/category\/c\/gotw\/page\/2\/","canFollow":"1","feedID":"171936","statusMessage":"","customizeLink":"https:\/\/herbsutter.wordpress.com\/wp-admin\/customize.php?url=https%3A%2F%2Fherbsutter.wordpress.com%2Fcategory%2Fc%2Fgotw%2Fpage%2F2%2F","i18n":{"view":"View site","follow":"Follow","following":"Following","edit":"Edit","login":"Log in","signup":"Sign up","customize":"Customize","report":"Report this content","themeInfo":"Get theme: MistyLook","shortlink":"Copy shortlink","copied":"Copied","followedText":"New posts from this site will now appear in your <a href=\"https:\/\/wordpress.com\/\">Reader<\/a>","foldBar":"Collapse this bar","unfoldBar":"Expand this bar","editSubs":"Manage subscriptions","viewReader":"View site in Reader","viewReadPost":"View post in Reader","subscribe":"Sign me up","enterEmail":"Enter your email address","followers":"Join 19,532 other followers","alreadyUser":"Already have a WordPress.com account? <a href=\"https:\/\/herbsutter.wordpress.com\/wp-login.php?redirect_to=https%3A%2F%2Fherbsutter.com%2F2013%2F08%2F19%2Fgotw-7a-solution-minimizing-compile-time-dependencies-part-1%2F\">Log in now.<\/a>","stats":"Stats"}};
/* ]]> */
</script>
<script type='text/javascript'>
/* <![CDATA[ */
var jetpackCarouselStrings = {"widths":[370,700,1000,1200,1400,2000],"is_logged_in":"","lang":"en","ajaxurl":"https:\/\/herbsutter.com\/wp-admin\/admin-ajax.php","nonce":"665015e67f","display_exif":"1","display_geo":"1","single_image_gallery":"1","single_image_gallery_media_file":"","background_color":"black","comment":"Comment","post_comment":"Post Comment","write_comment":"Write a Comment...","loading_comments":"Loading Comments...","download_original":"View full size <span class=\"photo-size\">{0}<span class=\"photo-size-times\">\u00d7<\/span>{1}<\/span>","no_comment_text":"Please be sure to submit some text with your comment.","no_comment_email":"Please provide an email address to comment.","no_comment_author":"Please provide your name to comment.","comment_post_error":"Sorry, but there was an error posting your comment. Please try again later.","comment_approved":"Your comment was approved.","comment_unapproved":"Your comment is in moderation.","camera":"Camera","aperture":"Aperture","shutter_speed":"Shutter Speed","focal_length":"Focal Length","copyright":"Copyright","comment_registration":"0","require_name_email":"1","login_url":"https:\/\/herbsutter.wordpress.com\/wp-login.php?redirect_to=https%3A%2F%2Fherbsutter.com%2F2013%2F06%2F07%2Fgotw-92-solution-auto-variables-part-1%2F","blog_id":"3379246","meta_data":["camera","aperture","shutter_speed","focal_length","copyright"],"local_comments_commenting_as":"<fieldset><label for=\"email\">Email (Required)<\/label> <input type=\"text\" name=\"email\" class=\"jp-carousel-comment-form-field jp-carousel-comment-form-text-field\" id=\"jp-carousel-comment-form-email-field\" \/><\/fieldset><fieldset><label for=\"author\">Name (Required)<\/label> <input type=\"text\" name=\"author\" class=\"jp-carousel-comment-form-field jp-carousel-comment-form-text-field\" id=\"jp-carousel-comment-form-author-field\" \/><\/fieldset><fieldset><label for=\"url\">Website<\/label> <input type=\"text\" name=\"url\" class=\"jp-carousel-comment-form-field jp-carousel-comment-form-text-field\" id=\"jp-carousel-comment-form-url-field\" \/><\/fieldset>","reblog":"Reblog","reblogged":"Reblogged","reblog_add_thoughts":"Add your thoughts here... (optional)","reblogging":"Reblogging...","post_reblog":"Post Reblog","stats_query_args":"blog=3379246&v=wpcom&tz=-8&user_id=0&subd=herbsutter","is_public":"1","reblog_enabled":""};
/* ]]> */
</script>
<script type='text/javascript' src='https://s0.wp.com/_static/??-eJyVUNEOwiAM/CGxGqM+Gb8FWXVFVpCWqX8vmmwxGpf4QHJc77ijcE3GRVZkBS/QYE8O023uZQZvo66YFMqJWCDQGQUuBQu2lpuAeUJMfCQmvY/gUzsI5c5qby2d2lCPYv5mJmJs0xGbg83QWanSikzsMWdqateR+/MFzdadZcrklCI/TSMa1MQulGd4Xapcj/Hg0emvz/e1ZgQrgvoyvO4po0yFO5tjEQzgUVMtagaievbdbrlebZbb7WK98A97a7cy'></script>
<script type='text/javascript' src='https://platform.twitter.com/widgets.js?ver=20111117'></script>
<script type='text/javascript' src='https://s0.wp.com/_static/??-eJyVy0sOQEAMANALqcYvYSHOgmkmpWoyirg9WyuxfIuHZ4BxVSM1XHYIsnvWDe1kM4owSD/OA0cHgQmVDoqkjtWn05bgnxu+Hws58L0IxeutZ3VLm1V5WRVlU+fTDQ0qQ9Y='></script>
<script type="text/javascript">
// <![CDATA[
(function() {
try{
  if ( window.external &&'msIsSiteMode' in window.external) {
    if (window.external.msIsSiteMode()) {
      var jl = document.createElement('script');
      jl.type='text/javascript';
      jl.async=true;
      jl.src='/wp-content/plugins/ie-sitemode/custom-jumplist.php';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(jl, s);
    }
  }
}catch(e){}
})();
// ]]>
</script><script type="text/javascript">
			jQuery.extend( infiniteScroll.settings.scripts, ["jquery-core","jquery-migrate","jquery","mobile-useragent-info","postmessage","jquery_inview","jetpack_resize","spin","jquery.spin","grofiles-cards","wpgroho","devicepx","jetpack_likes_queuehandler","the-neverending-homepage","syntaxhighlighter","wpcom-masterbar-js","wpcom-masterbar-tracks-js","wpcom-actionbar-bar","swfobject","videopress","jetpack-carousel","twitter-widgets","twitter-widgets-infinity","twitter-widgets-pending","tiled-gallery"] );
			jQuery.extend( infiniteScroll.settings.styles, ["jetpack_likes","the-neverending-homepage","infinity-mistylook","wpcom-core-compat-playlist-styles","mp6hacks","wpcom-bbpress2-staff-css","wp-block-library","mistylook","jetpack-top-posts-widget","jetpack-widget-social-icons-styles","noticons","geo-location-flair","reblogging","a8c-global-print","wpcom-actionbar-bar","h4-global","jetpack-carousel","tiled-gallery","jetpack-carousel-ie8fix"] );
		</script><script src="//stats.wp.com/w.js?56" type="text/javascript" async defer></script>
<script type="text/javascript">
_tkq = window._tkq || [];
_stq = window._stq || [];
_tkq.push(['storeContext', {'blog_id':'3379246','blog_tz':'-8','user_lang':'en','blog_lang':'en','user_id':'0'}]);
_stq.push(['view', {'blog':'3379246','v':'wpcom','tz':'-8','user_id':'0','subd':'herbsutter'}]);
_stq.push(['extra', {'crypt':'UE40eW5QN0p8M2Y/RE1TaVhzUzFMbjdWNHpwZGhTayxPSUFCMGNrd29+Smw0TDhnZmRTK0hlRi9QSGh6bi9GXVhBJWIlZlR5U1JMLU8/MkNtblkvY1d1TjBELytHc0k/MXdHUVQyK2IyUVA5SjU1bj9VX3ExLHYsREFpcnlfNHYtXV1HSUIsLkJrcnp0eS5sNGtNZl12Yl0wTFovZTZBcXklWXkteG1EQk1jbkE/Zkt+aXF4TnRjVlpvSmpYYV9QVkpLUVVCd3dmMFMyNjlXLFpDQ2hVdFk5MFFwbzgza3lhYj9Bbj9yJXVzUmE3MWJ+L0lOZy1raU5LU0ddRGlKcWlEZjJQUy1jS3ktWTVHUXUwQ2lQUjZGOSY5MHE1QzZdLD9OK1diWXNjZDdUMnEtYzRYJm5GRlY9TUddUVFDRj82cDRK'}]);
_stq.push([ 'clickTrackerInit', '3379246', '0' ]);
	</script>
<noscript><img src="https://pixel.wp.com/b.gif?v=noscript" style="height:0px;width:0px;overflow:hidden" alt="" /></noscript>
<script>
if ( 'object' === typeof wpcom_mobile_user_agent_info ) {

	wpcom_mobile_user_agent_info.init();
	var mobileStatsQueryString = "";
	
	if( false !== wpcom_mobile_user_agent_info.matchedPlatformName )
		mobileStatsQueryString += "&x_" + 'mobile_platforms' + '=' + wpcom_mobile_user_agent_info.matchedPlatformName;
	
	if( false !== wpcom_mobile_user_agent_info.matchedUserAgentName )
		mobileStatsQueryString += "&x_" + 'mobile_devices' + '=' + wpcom_mobile_user_agent_info.matchedUserAgentName;
	
	if( wpcom_mobile_user_agent_info.isIPad() )
		mobileStatsQueryString += "&x_" + 'ipad_views' + '=' + 'views';

	if( "" != mobileStatsQueryString ) {
		new Image().src = document.location.protocol + '//pixel.wp.com/g.gif?v=wpcom-no-pv' + mobileStatsQueryString + '&baba=' + Math.random();
	}
	
}
</script></body>
</html>