<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>GotW &#8211; Sutter’s Mill</title>
	<atom:link href="https://herbsutter.com/category/c/gotw/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Fri, 23 Nov 2018 09:31:39 +0000	</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='herbsutter.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>GotW &#8211; Sutter’s Mill</title>
		<link>https://herbsutter.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://herbsutter.com/osd.xml" title="Sutter’s Mill" />
	<atom:link rel='hub' href='https://herbsutter.com/?pushpress=hub'/>
	<item>
		<title>GotW #96: Oversharing</title>
		<link>https://herbsutter.com/2014/01/14/gotw-96-oversharing/</link>
				<comments>https://herbsutter.com/2014/01/14/gotw-96-oversharing/#comments</comments>
				<pubDate>Tue, 14 Jan 2014 16:55:10 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2414</guid>
				<description><![CDATA[Following on from #95, let&#8217;s consider reasons and methods to avoid mutable sharing in the first place…   Problem Consider the following code from GotW #95&#8217;s solution, where some_obj is a shared variable visible to multiple threads which then synchronize access to it. // thread 1{ lock_guard hold(mut_some_obj); // acquire lock code_that_reads_from( some_obj ); // [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Following on from #95, let&#8217;s consider reasons and methods to avoid mutable sharing in the first place…<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<p>Consider the following code from GotW #95&#8217;s solution, where <span style="color:#2e74b5;">some_obj</span> is a shared variable visible to multiple threads which then synchronize access to it.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br />}<br /><br />// thread 2<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_modifies( some_obj );    // passes some_obj by non-const &amp;<br />}
</code></pre>
</p>
<p>
 </p>
<h2>JG Questions<br />
</h2>
<p>1. Why do mutable shared variables like <span style="color:#2e74b5;">some_obj</span> make your code:
</p>
<p style="margin-left:36pt;">(a) more complex?
</p>
<p style="margin-left:36pt;">(b) more brittle?
</p>
<p style="margin-left:36pt;">(c) less scalable?
</p>
<p>
 </p>
<h2>Guru Questions<br />
</h2>
<p>2. Give an example of how the code that uses a mutable shared variable like <span style="color:#2e74b5;">some_obj</span> can be changed so that the variable is:
</p>
<p style="margin-left:36pt;">(a) <em>not shared</em>.
</p>
<p style="margin-left:36pt;">(b) <em>not mutable</em>.
</p>
<p>3. Let&#8217;s say we&#8217;re in a situation where we can&#8217;t apply the techniques from the answers to #2, so that the variable itself must remain shared and apparently mutable. Is there any way that the <em>internal implementation</em> of the variable can make the variable be <em>physically </em>not shared and/or not mutable, so that the calling code can treat it as a logically shared-and-mutable object yet not need to perform external synchronization? If so, explain. If not, why not?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/14/gotw-96-oversharing/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #95 Solution: Thread Safety and Synchronization</title>
		<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/</link>
				<comments>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comments</comments>
				<pubDate>Mon, 13 Jan 2014 19:00:16 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2411</guid>
				<description><![CDATA[This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.   Problem JG Questions 1. What is a race condition, and how serious [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is a race condition, and how serious is it?
</p>
<p>2. What is a correctly synchronized program? How do you achieve it? Be specific.
</p>
<p>
 </p>
<h2>Guru Questions<br />
</h2>
<p>3. Consider the following code, where <span style="color:#2e74b5;">some_obj</span> is a shared variable visible to multiple threads.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1 (performs no additional synchronization)<br />code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br /><br />// thread 2 (performs no additional synchronization)<br />code_that_modifies( some_obj );    // passes some_obj by non-const &amp;
</code></pre>
</p>
<p>If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of <span style="color:#2e74b5;">some_obj</span> is:
</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">int</span>?
</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">string</span>?
</p>
<p style="margin-left:36pt;">(c) <span style="color:#2e74b5;">vector&lt;map&lt;int,string&gt;&gt;</span>?
</p>
<p style="margin-left:36pt;">(d) <span style="color:#2e74b5;">shared_ptr&lt;widget&gt;</span>?
</p>
<p style="margin-left:36pt;">(e) <span style="color:#2e74b5;">mutex</span>?
</p>
<p style="margin-left:36pt;">(f) <span style="color:#2e74b5;">condition_variable</span>?
</p>
<p style="margin-left:36pt;">(g) <span style="color:#2e74b5;">atomic&lt;unsigned&gt;</span>?<span style="color:#2e74b5;"><br />
		</span></p>
<p>Hint: This is actually a two-part question, not a seven-part question. There are only two unique answers, each of which covers a subset of the cases.
</p>
<p>4. <em>External synchronization</em> means that the code that uses/owns a given shared object is responsible for performing synchronization on that object. Answer the following questions related to external synchronization:
</p>
<p style="margin-left:36pt;">(a) What is the normal external synchronization responsibility of code that owns and uses a given shared variable?
</p>
<p style="margin-left:36pt;">(b) What is the &#8220;basic thread safety guarantee&#8221; that all types must obey to enable calling code to perform normal external synchronization?
</p>
<p style="margin-left:36pt;">(c) What partial internal synchronization can still be required within the shared variable&#8217;s implementation?
</p>
<p>5. <em>Full internal synchronization</em> (a.k.a. &#8220;synchronized types&#8221; or &#8220;thread-safe types&#8221;) means that a shared object performs all necessary synchronization internally within that object, so that calling code does not need to perform any external synchronization. What types should be fully internally synchronized, and why?
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>Preface<br />
</h2>
<p>The discussion in this GotW applies not only to C++ but also to any mainstream language, except mainly that certain races have defined behavior in C# and Java. But the definition of what variables need to be synchronized, the tools we use to synchronize them, and the distinction between external and internal synchronization and when you use each one, are the same in all mainstream languages. If you&#8217;re a C# or Java programmer, everything here applies equally to you, with some minor renaming such as to rename C++ <span style="color:#2e74b5;">atomic</span> to C#/Java <span style="color:#2e74b5;">volatile</span>, although some concepts are harder to express in C#/Java (such as identifying the read-only methods on an otherwise mutable shared object; there are <span style="color:#2e74b5;">readonly</span> fields and &#8220;read-only&#8221; properties that have <span style="color:#2e74b5;">get</span> but not <span style="color:#2e74b5;">set</span>, but they express a subset of what you can express using C++ <span style="color:#2e74b5;">const</span> on member functions).
</p>
<p>Note: C++ <span style="color:#2e74b5;">volatile</span> variables (which have no analog in languages like C# and Java) are always beyond the scope of this and any other article about the memory model and synchronization. That&#8217;s because C++ <span style="color:#2e74b5;">volatile</span> variables aren&#8217;t about threads or communication at all and don&#8217;t interact with those things. Rather, a C++ <span style="color:#2e74b5;">volatile</span> variable should be viewed as portal into a different universe beyond the language — a memory location that by definition does not obey the language&#8217;s memory model because that memory location is accessed by hardware (e.g., written to by a daughter card), have more than one address, or is otherwise &#8220;strange&#8221; and beyond the language. So C++ <span style="color:#2e74b5;">volatile</span> variables are universally an exception to every guideline about synchronization because are always inherently &#8220;racy&#8221; and unsynchronizable using the normal tools  (mutexes, atomics, etc.) and more generally exist outside all normal of the language and compiler including that they generally cannot be optimized by the compiler (because the compiler isn&#8217;t allowed to know their semantics; a <span style="color:#2e74b5;">volatile int vi;</span> may not behave anything like a normal <span style="color:#2e74b5;">int</span>, and you can&#8217;t even assume that code like <span style="color:#2e74b5;">vi = 5; int read_back = vi;</span> is guaranteed to result in <span style="color:#2e74b5;">read_back == 5</span>, or that code like <span style="color:#2e74b5;">int i = vi; int j = vi;</span> that reads <span style="color:#2e74b5;">vi</span> twice will result in <span style="color:#2e74b5;">i == j</span> which will not be true if <span style="color:#2e74b5;">vi</span> is a hardware counter for example). For more discussion, see my article <a href="http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484">&#8220;volatile vs. volatile.&#8221;</a>
	</p>
<p>
 </p>
<h2>1. What is a race condition, and how serious is it?<br />
</h2>
<p>A <em>race condition</em> occurs when two threads access the same shared variable concurrently, and at least one is a non-<span style="color:#2e74b5;">const</span> operation (writer). Concurrent <span style="color:#2e74b5;">const</span> operations are valid, and do not race with each other.
</p>
<p>Consecutive nonzero-length bitfields count as a single variable for the purpose of defining what a race condition is.
</p>
<p>Terminology note: Some people use &#8220;race&#8221; in a different sense, where in a program with no actual race conditions (as defined above) still operations on different threads could interleave in different orders in different executions of a correctly-synchronized program depending on how fast threads happen to execute relative to each other. That&#8217;s not a race condition in the sense we mean here—a better term for that might be &#8220;timing-dependent code.&#8221;
</p>
<p>If a race condition occurs, your program has <em>undefined behavior</em>. C++ does not recognize any so-called &#8220;benign races&#8221;—and in languages that have recognized some races as &#8220;benign&#8221; the community has gradually learned over time that many of them actually, well, aren&#8217;t.
</p>
<blockquote>
<p><strong>Guideline:</strong> Reads (<strong>const</strong> operations) on a shared object are safe to run concurrently with each other without synchronization.
</p>
</blockquote>
<p>
 </p>
<h2>2. What is a correctly synchronized program? How do you achieve it? Be specific.<br />
</h2>
<p>A correctly synchronized program is one that contains no race conditions. You achieve it by making sure that, for every shared variable, every thread that performs a write (non-<span style="color:#2e74b5;">const</span> operation) on that variable is synchronized so that no other reads or writes of that variable on other threads can run concurrently with that write.
</p>
<p>The shared variable usually protected by:
</p>
<ul>
<li>(commonly) using a <span style="color:#2e74b5;">mutex</span> or equivalent;
</li>
<li>(very rarely) by making it <span style="color:#2e74b5;">atomic</span> if that&#8217;s appropriate, such as in low-lock code; or
</li>
<li>(very rarely) for certain types by performing the synchronization internally, as we will see below.
</li>
</ul>
<p>
 </p>
<h2>3. Consider the following code… If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of some_obj is: (a) int? (b) string? (c) vector&lt;map&lt;int,string&gt;&gt;? (d) shared_ptr&lt;widget&gt;?<br />
</h2>
<p>No. The code has one thread reading (via <span style="color:#2e74b5;">const</span> operations) from <span style="color:#2e74b5;">some_obj</span>, and a second thread writing to the same variable. If those threads can execute at the same time, that&#8217;s a race and a direct non-stop ticket to undefined behavior land.
</p>
<p>The answer is to synchronize access to the variable, for example using a <span style="color:#2e74b5;">mutex</span>:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br />}<br /><br />// thread 2<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_modifies( some_obj );    // passes some_obj by non-const &amp;<br />}
</code></pre>
</p>
<p>Virtually all types, including <span style="color:#2e74b5;">shared_ptr</span> and <span style="color:#2e74b5;">vector</span> and other types, are just as thread-safe as <span style="color:#2e74b5;">int</span>; they&#8217;re not special for concurrency purposes. It doesn&#8217;t matter whether <span style="color:#2e74b5;">some_obj</span> is an <span style="color:#2e74b5;">int</span>, a <span style="color:#2e74b5;">string</span>, a container, or a smart pointer… concurrent reads (<span style="color:#2e74b5;">const</span> operations) are safe without synchronization, but the shared object is writeable, then the code that owns the object has to synchronize access to it.
</p>
<p>But when I said this is true for &#8220;virtually all types,&#8221; I meant all types except for types that are not fully internally synchronized, which brings us to the types that, by design, <em>are</em> special for concurrency purposes…
</p>
<p>
 </p>
<h2>… If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of g+shared is: (e) mutex? (f) condition_variable? (g) atomic&lt;unsigned&gt;?<br />
</h2>
<p>Yes. For these types, the code is okay, because these types already perform full internal synchronization and so they are safe to access without external synchronization.
</p>
<p>In fact, these types had better be safe to use without external synchronization, because they&#8217;re synchronization primitives you need to use as tools to synchronize other variables! And its turns out that that&#8217;s no accident…
</p>
<blockquote>
<p><strong>Guideline:</strong> A type should only be fully internally synchronized if and only if its purpose is to provide  inter-thread communication (e.g., a message queue) or synchronization (e.g., a mutex).
</p>
</blockquote>
<p>
 </p>
<h2>4. <em>External synchronization</em> means that the code that uses/owns a given shared object is responsible for performing synchronization on that object. Answer the following questions related to external synchronization:<br />
</h2>
<h3>(a) What is the normal external synchronization responsibility of code that owns and uses a given shared variable?<br />
</h3>
<p>The normal synchronization duty of care is simply this: The code that knows about and owns a writeable shared variable has to synchronize access to it. It will typically do that using a <span style="color:#2e74b5;">mutex</span> or similar (~99.9% of the time), or by making it <span style="color:#2e74b5;">atomic</span> if that&#8217;s possible and appropriate (~0.1% of the time).
</p>
<blockquote>
<p><strong>Guideline:</strong> The code that knows about and owns a writeable shared variable is responsible for synchronizing access to it.
</p>
</blockquote>
<p>
 </p>
<h3>(b) What is the &#8220;basic thread safety guarantee&#8221; that all types must obey to enable calling code to perform normal external synchronization?<br />
</h3>
<p>To make it possible for the code that uses a shared variable to do the above, two basic things must be true.
</p>
<p>First, concurrent operations on different objects must be safe. For example, let&#8217;s say we have two <span style="color:#2e74b5;">X</span> objects <span style="color:#2e74b5;">x1</span> and <span style="color:#2e74b5;">x2</span>, each of which is only used by one thread. Then consider this situation:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case A: Using distinct objects<br /><br />// thread 1 (performs no additional synchronization)<br />x1.something();                   // do something with x1<br /><br />// thread 2 (performs no additional synchronization)<br />x2 = something_else;              // do something else with x2
</code></pre>
</p>
<p>This must always be considered correctly synchronized. Remember, we stated that <span style="color:#2e74b5;">x1</span> and <span style="color:#2e74b5;">x2</span> are distinct objects, and cannot be aliases for the same object or similar hijinks.
</p>
<p>Second, concurrent <span style="color:#2e74b5;">const</span> operations that are just reading from the same variable <span style="color:#2e74b5;">x</span> must be safe:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case B: const access to the same object<br /><br />// thread 1 (performs no additional synchronization)<br />x.something_const();              // read from x (const operation)<br /><br />// thread 2 (performs no additional synchronization)<br />x.something_else_const();         // read from x (const operation)
</code></pre>
</p>
<p>This code too must be considered correctly synchronized, and had better work without external synchronization. It&#8217;s not a race, because the two threads are both performing <span style="color:#2e74b5;">const</span> accesses and reading from the shared object.
</p>
<p>This brings us to the case where there might be a combination of internal and external synchronization required…
</p>
<p>
 </p>
<h3>(c) What partial internal synchronization can still be required within the shared variable&#8217;s implementation?<br />
</h3>
<p>In some classes, objects that from the outside appear to be distinct but still may share state under the covers, without the calling code being able to tell that two apparently distinct objects are connected under the covers. Note that this not an exception to the previous guideline—it&#8217;s the same guideline!
</p>
<blockquote>
<p><strong>Guideline:</strong> It is always true that the code that knows about and owns a writeable shared variable is responsible for synchronizing access to it. If the writeable shared state is hidden inside the implementation of some class, then it&#8217;s simply that class&#8217; internals that are the &#8216;owning code&#8217; that has to synchronize access to (just) the shared state that only it knows about.
</p>
</blockquote>
<p>A classic case of &#8220;under-the-covers shared state&#8221; is reference counting, and the two poster-child examples are <span style="color:#2e74b5;">std::shared_ptr</span> and copy-on-write. Let&#8217;s use <span style="color:#2e74b5;">shared_ptr</span> as our main example.
</p>
<p>A reference-counted smart pointer like <span style="color:#2e74b5;">shared_ptr</span> keeps a reference count under the covers. Let&#8217;s say we have two distinct <span style="color:#2e74b5;">shared_ptr</span> objects <span style="color:#2e74b5;">sp1</span> and <span style="color:#2e74b5;">sp2</span>, each of which is used by only one thread. Then consider this situation:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case A: Using distinct objects<br /><br />// thread 1 (performs no additional synchronization)<br />auto x = sp1;                      // read from sp1 (writes the count!) <br /><br />// thread 2 (performs no additional synchronization)<br />sp2 = something_else;              // write to sp2 (writes the count!)
</code></pre>
</p>
<p>This code must be considered correctly synchronized, and had better work as shown without any external synchronization. Okay, fine …
</p>
<p>… but what if <span style="color:#2e74b5;">sp1</span> and <span style="color:#2e74b5;">sp2</span> are pointing to the same object and so share a reference count? If so, <em>that reference count is a writeable shared object</em>, and so it must be synchronized to avoid a race—but it is in general impossible for the calling code to do the right synchronization, because it is not even aware of the sharing! The code we just saw above doesn&#8217;t see the count, doesn&#8217;t know the count variable&#8217;s name, and doesn&#8217;t in general know which pointers share counts.
</p>
<p>Similarly, consider two threads just reading from the same variable <span style="color:#2e74b5;">sp</span>:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case B: const access to the same object<br /><br />// thread 1 (performs no additional synchronization)<br />auto sp3 = sp;                     // read from sp (writes the count!)<br /><br />// thread 2 (performs no additional synchronization)<br />auto sp4 = sp;                     // read from sp (writes the count!)
</code></pre>
</p>
<p>This code too must be considered correctly synchronized, and had better work without external synchronization. It&#8217;s not a race, because the two threads are both performing <span style="color:#2e74b5;">const</span> accesses and reading from the shared object. But under the covers, reading from <span style="color:#2e74b5;">sp</span> to copy it increments the reference count, and so again <em>that reference count is a writeable shared object</em>, and so it must be synchronized to avoid a race—and again it is in general impossible for the calling code to do the right synchronization, because it is not even aware of the sharing.
</p>
<p>So to deal with these cases, the code that knows about the shared reference count, namely the <span style="color:#2e74b5;">shared_ptr</span> implementation, has to synchronize access to the reference count. For reference counting, this is typically done by making the reference count a <span style="color:#2e74b5;">mutable atomic</span> variable. (See also GotW #6a and #6b.)
</p>
<p>For completeness, yes, of course external synchronization is still required as usual if the calling code shared a given visible <span style="color:#2e74b5;">shared_ptr</span> object and makes that same shared<span style="color:#2e74b5;">_ptr</span> object writable across threads:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case C: External synchronization still required as usual<br />//         for non-const access to same visible shared object<br /><br />// thread 1<br />{<br />    lock_guard hold(mut_sp);           // acquire lock<br />    auto sp3 = sp;                     // read from sp<br />}<br /><br />// thread 2<br />{<br />    lock_guard hold(mut_sp);           // acquire lock<br />    sp = something_else;               // modify sp<br />}
</code></pre>
</p>
<p>So it&#8217;s not like <span style="color:#2e74b5;">shared_ptr</span> is a fully internally synchronized type; if the caller is sharing an object of that type, the caller must synchronize access to it like it would do for other types, as noted in Question 3(d).
</p>
<p>So what&#8217;s the purpose of the internal synchronization? It&#8217;s only to do necessary synchronization on the parts that the internals know are shared <em>and that the internals own</em>, but that the caller can&#8217;t synchronize because he doesn&#8217;t know about the sharing and shouldn&#8217;t need to because the caller doesn&#8217;t own them, the internals do. So in the internal implementation of the type we do just enough internal synchronization to get back to the level where the caller can assume his usual duty of care and in the usual ways correctly synchronize any objects that might actually be shared.
</p>
<p>The same applies to other uses of reference counting, such as copy-on-write strategies. It also applies generally to any other internal sharing going on under the covers between objects that appear distinct and independent to the calling code.
</p>
<blockquote>
<p><strong>Guideline:</strong> If you design a class where two objects may invisibly share state under the covers, it is your class&#8217; responsibility to internally synchronize access to that <strong>mutable</strong> shared state (only) that it owns and that only it can see, because the calling code can&#8217;t. If you opt for under-the-covers-sharing strategies like copy-on-write, be aware of the duty you&#8217;re taking on for yourself and code with care.
</p>
</blockquote>
<p>For why such internal shared state should be <strong>mutable</strong>, see GotW #6a and #6b.
</p>
<p>
 </p>
<h2>5. <em>… </em>What types should be fully internally synchronized, and why?<br />
</h2>
<p>There is exactly one category of types which should be fully internally synchronized, so that any object of that type is always safe to use concurrently without external synchronization: Inter-thread synchronization and communication primitives themselves. This includes standard types like mutexes and atomics, but also inter-thread communication and synchronization types you might write yourself such as a message queue (communicating messages from one thread to another), Producer/Consumer active objects (again passing data from one concurrent entity to another), or a thread-safe counter (communicating counter increments and decrements among multiple threads).
</p>
<p>If you&#8217;re wondering if there might be other kinds of types that should be internally synchronized,  consider: The only type for which it would make sense to always internally synchronize every operation is a type where you know <em>every object</em> is going to be both (a) writeable and (b) shared across threads… and that means that the type is by definition designed to be used for inter-thread communication and/or synchronization.
</p>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: Daniel Hardman, Casey, Alb, Marcel Wid, ixache.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/feed/</wfw:commentRss>
		<slash:comments>24</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #95: Thread Safety and Synchronization</title>
		<link>https://herbsutter.com/2014/01/06/gotw-95-thread-safety-and-synchronization/</link>
				<comments>https://herbsutter.com/2014/01/06/gotw-95-thread-safety-and-synchronization/#comments</comments>
				<pubDate>Mon, 06 Jan 2014 16:00:09 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2401</guid>
				<description><![CDATA[This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.   Problem JG Questions 1. What is a race condition, and how serious [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is a race condition, and how serious is it?
</p>
<p>2. What is a correctly synchronized program? How do you achieve it? Be specific.
</p>
<p>
 </p>
<h2>Guru Questions<br />
</h2>
<p>3. Consider the following code, where <span style="color:#2e74b5;">some_obj</span> is a shared variable visible to multiple threads.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1 (performs no additional synchronization)<br />code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br /><br />// thread 2 (performs no additional synchronization)<br />code_that_modifies( some_obj );    // passes some_obj by non-const &amp;
</code></pre>
</p>
<p>If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of <span style="color:#2e74b5;">some_obj</span> is:
</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">int</span>?
</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">string</span>?
</p>
<p style="margin-left:36pt;">(c) <span style="color:#2e74b5;">vector&lt;map&lt;int,string&gt;&gt;</span>?
</p>
<p style="margin-left:36pt;">(d) <span style="color:#2e74b5;">shared_ptr&lt;widget&gt;</span>?
</p>
<p style="margin-left:36pt;">(e) <span style="color:#2e74b5;">mutex</span>?
</p>
<p style="margin-left:36pt;">(f) <span style="color:#2e74b5;">condition_variable</span>?
</p>
<p style="margin-left:36pt;">(g) <span style="color:#2e74b5;">atomic&lt;unsigned&gt;</span>?<span style="color:#2e74b5;"><br />
		</span></p>
<p>Hint: This is actually a two-part question, not a seven-part question. There are only two unique answers, each of which covers a subset of the cases.
</p>
<p>4. <em>External synchronization</em> means that the code that uses/owns a given shared object is responsible for performing synchronization on that object. Answer the following questions related to external synchronization:
</p>
<p style="margin-left:36pt;">(a) What is the normal external synchronization responsibility of code that owns and uses a given shared variable?
</p>
<p style="margin-left:36pt;">(b) What is the &#8220;basic thread safety guarantee&#8221; that all types must obey to enable calling code to perform normal external synchronization?
</p>
<p style="margin-left:36pt;">(c) What partial internal synchronization can still be required within the shared variable&#8217;s implementation?
</p>
<p>5. <em>Full internal synchronization</em> (a.k.a. &#8220;synchronized types&#8221; or &#8220;thread-safe types&#8221;) means that a shared object performs all necessary synchronization internally within that object, so that calling code does not need to perform any external synchronization. What types should be fully internally synchronized, and why?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/06/gotw-95-thread-safety-and-synchronization/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7c Solution: Minimizing Compile-Time Dependencies, Part 3</title>
		<link>https://herbsutter.com/2014/01/06/gotw-7c-solution-minimizing-compile-time-dependencies-part-3/</link>
				<comments>https://herbsutter.com/2014/01/06/gotw-7c-solution-minimizing-compile-time-dependencies-part-3/#comments</comments>
				<pubDate>Mon, 06 Jan 2014 15:58:39 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2399</guid>
				<description><![CDATA[Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.   Problem JG Question 1. What is the tightest coupling you can express in C++? [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the tightest coupling you can express in C++? And what&#8217;s the second-tightest?
</p>
<h2>Guru Question<br />
</h2>
<p>2. The Incredible Shrinking Header has now been greatly trimmed, but there may still be ways to reduce the dependencies further. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made further changes to <span style="color:#2e74b5;">X</span>, and how?
</p>
<p>This time, you may make any changes at all to <span style="color:#2e74b5;">X</span> as long as they don&#8217;t change its public interface, so that existing code that uses <span style="color:#2e74b5;">X</span> is unaffected. Again, note that the comments are important.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after converting to use a Pimpl to hide implementation details<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />#include "b.h"  // class B (has no virtual functions)<br />class C;<br />class E;<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What is the tightest coupling you can express in C++? And what&#8217;s the second-tightest?<br />
</h2>
<p>Friendship and inheritance, respectively.
</p>
<p>A friend of a class has access to everything in that class, including all of its private data and functions, and so the code in a friend depends on every detail of the type. Now that&#8217;s a close friend!
</p>
<p>A class derived from a class <span style="color:#2e74b5;">Base</span> has access to public and protected members in <span style="color:#2e74b5;">Base</span>, and depends on the size and layout of <span style="color:#2e74b5;">Base</span> because it contains a <span style="color:#2e74b5;">Base</span> subobject. Further, the inheritance relationship means that a derived type is at least by default substitutable for its <span style="color:#2e74b5;">Base</span>; whether the inheritance is public or nonpublic only changes what other code can see and make use of the substitutability. That&#8217;s pretty tight coupling, second only to friendship.
</p>
<p>
 </p>
<h2>2. What further #includes could be removed if we made further changes to X, and how?<br />
</h2>
<p>Many programmers still seem to march to the &#8220;It isn&#8217;t OO unless you inherit!&#8221; battle hymn, by which I mean that they use inheritance more than necessary. I&#8217;ll save the whole lecture for another time, but my bottom line is simply that inheritance (including but not limited to IS-A) is a much stronger relationship than HAS-A or USES-A. When it comes to managing dependencies, therefore, you should always prefer composition/membership over inheritance wherever possible. To paraphrase Einstein: &#8216;Use as strong a relationship as necessary, but no stronger.&#8217;
</p>
<p>In this code, <span style="color:#2e74b5;">X</span> is derived publicly from <span style="color:#2e74b5;">A</span> and privately from <span style="color:#2e74b5;">B</span>. Recall that public inheritance should always model IS-A and satisfy the Liskov Substitutability Principle (LSP). In this case <span style="color:#2e74b5;">X</span> IS-A <span style="color:#2e74b5;">A</span> and there&#8217;s naught wrong with it, so we&#8217;ll leave that as it is.
</p>
<p>But did you notice the curious thing about <span style="color:#2e74b5;">B</span>&#8216;s virtual functions?
</p>
<p>&#8220;What?&#8221; you might say. &#8220;<span style="color:#2e74b5;">B</span> has no virtual functions.&#8221;
</p>
<p>Right. <a href="http://en.wikipedia.org/wiki/Silver_Blaze">That is the curious thing.</a>
	</p>
<p><span style="color:#2e74b5;">B</span> is a private base class of <span style="color:#2e74b5;">X</span>. Normally, the only reason you would choose private inheritance over composition/membership is to gain access to protected members—which most of the time means &#8220;to override a virtual function.&#8221; (There are a few other rare and obscure reasons to inherit, but they&#8217;re, well, rare and obscure.) Otherwise you wouldn&#8217;t choose inheritance, because it&#8217;s almost the tightest coupling you can express in C++, second only to <span style="color:#2e74b5;">friend</span>ship.
</p>
<p>We are given that <span style="color:#2e74b5;">B</span> has no virtual functions, so there&#8217;s probably no reason to prefer the stronger relationship of inheritance—unless <span style="color:#2e74b5;">X</span> needs access to some protected function or data in <span style="color:#2e74b5;">B</span>, of course, but for now I&#8217;ll assume that this is not the case. So, instead of having a base subobject of type <span style="color:#2e74b5;">B</span>, <span style="color:#2e74b5;">X</span> probably ought to have simply a member object of type <span style="color:#2e74b5;">B</span>. Therefore, the way to further simplify the header is:
</p>
<p>
 </p>
<h2>(a) Remove unnecessary inheritance from class <span style="color:#2e74b5;">B.<br />
</span></h2>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>#include "b.h"  // class B (has no virtual functions)
</code></pre>
</p>
<p>Because the <span style="color:#2e74b5;">B</span> member object should be private (it is, after all, an implementation detail), and in order to get rid of the <span style="color:#2e74b5;">b.h</span> header entirely, this member should live in <span style="color:#2e74b5;">X</span>&#8216;s hidden <span style="color:#2e74b5;">pimpl</span> portion.
</p>
<blockquote>
<p><strong>Guideline: </strong>Never inherit when composition is sufficient.
</p>
</blockquote>
<p>
 </p>
<p>This leaves us with header code that&#8217;s vastly simplified from where we started in GotW #7a:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after removing unnecessary inheritance<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />class B;<br />class C;<br />class E;<br /><br />class X : public A {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // this now quietly includes a B<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>
 </p>
<p>After three passes of progressively greater simplification, the final result is that <span style="color:#2e74b5;">x.h</span> is still using other class names all over the place, but clients of <span style="color:#2e74b5;">X</span> need only pay for three <span style="color:#2e74b5;">#include</span>s: <span style="color:#2e74b5;">a.h</span>, <span style="color:#2e74b5;">memory</span>, and <span style="color:#2e74b5;">iosfwd</span>. What an improvement over the original!
</p>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: juanchopanza, anicolaescu, Bert Rodiers.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/06/gotw-7c-solution-minimizing-compile-time-dependencies-part-3/feed/</wfw:commentRss>
		<slash:comments>26</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7c: Minimizing Compile-Time Dependencies, Part 3</title>
		<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/</link>
				<comments>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comments</comments>
				<pubDate>Tue, 31 Dec 2013 20:32:15 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2387</guid>
				<description><![CDATA[Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.   Problem JG Question 1. What is the tightest coupling you can express in C++? [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the tightest coupling you can express in C++? And what&#8217;s the second-tightest?
</p>
<h2>Guru Question<br />
</h2>
<p>2. The Incredible Shrinking Header has now been greatly trimmed, but there may still be ways to reduce the dependencies further. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made further changes to <span style="color:#2e74b5;">X</span>, and how?
</p>
<p>This time, you may make any changes at all to <span style="color:#2e74b5;">X</span> as long as they don&#8217;t change its public interface, so that existing code that uses <span style="color:#2e74b5;">X</span> is unaffected. Again, note that the comments are important.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after converting to use a Pimpl to hide implementation details<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />#include "b.h"  // class B (has no virtual functions)<br />class C;<br />class E;<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7b Solution: Minimizing Compile-Time Dependencies, Part 2</title>
		<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/</link>
				<comments>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comments</comments>
				<pubDate>Tue, 31 Dec 2013 20:24:37 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2384</guid>
				<description><![CDATA[Now that the unnecessary headers have been removed, it&#8217;s time for Phase 2: How can you limit dependencies on the internals of a class?   Problem JG Questions 1. What does private mean for a class member in C++? 2. Why does changing the private members of a type cause a recompilation? Guru Question 3. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now that the unnecessary headers have been removed, it&#8217;s time for Phase 2: How can you limit dependencies on the internals of a class?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What does <span style="color:#2e74b5;">private</span> mean for a class member in C++?
</p>
<p>2. Why does changing the private members of a type cause a recompilation?
</p>
<h2>Guru Question<br />
</h2>
<p>3. Below is how the header from the previous Item looks after the initial cleanup pass. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made some suitable changes, and how?
</p>
<p>This time, you may make changes to <span style="color:#2e74b5;">X</span> as long as <span style="color:#2e74b5;">X</span>&#8216;s base classes and its public interface remain unchanged; any current code that already uses <span style="color:#2e74b5;">X</span> should not be affected beyond requiring a simple recompilation.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: sans gratuitous headers<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;list&gt;<br /><br />// None of A, B, C, or D are templates.<br />// Only A and C have virtual functions.<br />#include "a.h"  // class A<br />#include "b.h"  // class B<br />#include "c.h"  // class C<br />#include "d.h"  // class D<br />class E;<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />  private:<br />    std::list&lt;C&gt; clist;<br />    D            d;<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What does private mean for a class member in C++?<br />
</h2>
<p>It means that outside code cannot access that member. Specifically, it cannot name it or call it.
</p>
<p>For example, given this class:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class widget {<br />public:<br />    void f() { }<br />private:<br />    void f(int) { }<br />    int i;<br />};
</code></pre>
</p>
<p>Outside code cannot use the name of the <span style="color:#2e74b5;">private</span> members:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code> int main() {<br />    auto w = widget{};<br />    w.f();               // ok<br />    w.f(42);             // error, cannot access name "f(int)"<br />    w.i = 42;            // error, cannot access name "i"<br />}
</code></pre>
</p>
<p>
 </p>
<h2>2. Why does changing the private members of a type cause a recompilation?<br />
</h2>
<p>Because private data members can change the size of the object, and private member functions participate in overload resolution.
</p>
<p>Note that accessibility is still safely enforced: <em>Calling code</em> still doesn&#8217;t get to use the private parts of the class. However, <em>the compiler</em> gets to know all about them at all times, including as it compiles the calling code. This does increase build coupling, but it&#8217;s for a deliberate reason: C++ has always been designed for efficiency, and a little-appreciated cornerstone of that is that C++ is designed to by default expose a type&#8217;s full implementation to the compiler in order to make aggressive optimization easier. It&#8217;s one of the fundamental reasons C++ is an efficient language.
</p>
<p>
 </p>
<h2>3. What further #includes could be removed if we made some suitable changes, and how? … any current code that already uses X should not be affected beyond requiring a simple recompilation.<br />
</h2>
<p>There are a few things we weren&#8217;t able to do in the previous problem:
</p>
<ul>
<li>We had to leave <span style="color:#2e74b5;">a.h</span> and <span style="color:#2e74b5;">b.h</span>. We couldn&#8217;t get rid of these because <span style="color:#2e74b5;">X</span> inherits from both <span style="color:#2e74b5;">A</span> and <span style="color:#2e74b5;">B</span>, and you always have to have full definitions for base classes so that the compiler can determine <span style="color:#2e74b5;">X</span>&#8216;s object size, virtual functions, and other fundamentals. (Can you anticipate how to remove one of these? Think about it: Which one can you remove, and why/how? The answer will come shortly.)
</li>
<li>We had to leave <span style="color:#2e74b5;">list</span>, <span style="color:#2e74b5;">c.h</span> and <span style="color:#2e74b5;">d.h</span>. We couldn&#8217;t get rid of these right away because a <span style="color:#2e74b5;">list&lt;C&gt;</span> and a <span style="color:#2e74b5;">D</span> appear as private data members of <span style="color:#2e74b5;">X</span>. Although <span style="color:#2e74b5;">C</span> appears as neither a base class nor a member, it is being used to instantiate the <span style="color:#2e74b5;">list</span> member, and some have compilers required that when you instantiate <span style="color:#2e74b5;">list&lt;C&gt;</span> you be able to see the definition of <span style="color:#2e74b5;">C</span>. (The standard doesn&#8217;t require a definition here, though, so even if the compiler you are currently using has this restriction, you can expect the restriction to go away over time.)
</li>
</ul>
<p>Now let&#8217;s talk about the beauty of Pimpls.
</p>
<p>
 </p>
<h3>The Pimpl Idiom<br />
</h3>
<p>C++ lets us easily encapsulate the private parts of a class from unauthorized access. Unfortunately, because of the header file approach inherited from C, it can take a little more work to encapsulate dependencies on a class&#8217; privates.
</p>
<p>&#8220;But,&#8221; you say, &#8220;the whole point of encapsulation is that the client code shouldn&#8217;t have to know or care about a class&#8217; private implementation details, right?&#8221; Right, and in C++ the client code doesn&#8217;t need to know or care about access to a class&#8217; privates (because unless it&#8217;s a friend it isn&#8217;t allowed any), but because the privates are visible in the header the client code does have to depend upon any types they mention. This coupling between the caller and the class&#8217;s internal details creates dependencies on both (re)compilation and binary layout.
</p>
<p>How can we better insulate clients from a class&#8217; private implementation details? One good way is to use a special form of the handle/body idiom, popularly called the Pimpl Idiom because of the intentionally pronounceable <span style="color:#2e74b5;">pimpl</span> pointer, as a compilation firewall.
</p>
<p>A Pimpl is just an opaque pointer (a pointer to a forward-declared, but undefined, helper class) used to hide the private members of a class. That is, instead of writing this:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// file widget.h<br />//<br />class widget {<br />    // public and protected members<br />private:<br />    // private members; whenever these change,<br />    // all client code must be recompiled<br />};
</code></pre>
</p>
<p>We write instead:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// file widget.h<br />//<br />#include &lt;memory&gt;<br /><br />class widget {<br />public:<br />    widget();<br />    ~widget();<br />    // public and protected members<br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />// file widget.cpp<br />//<br />#include "widget.h"<br /><br />struct widget::impl {<br />    // private members; fully hidden, can be<br />    // changed at will without recompiling clients<br />};<br /><br />widget::widget() : pimpl{ make_unique&lt;widget::impl&gt;(/*...*/) } { }<br />widget::~widget() =default;
</code></pre>
</p>
<p>Every <span style="color:#2e74b5;">widget</span> object dynamically allocates its <span style="color:#2e74b5;">impl</span> object. If you think of an object as a physical block, we&#8217;ve essentially lopped off a large chunk of the block and in its place left only &#8220;a little bump on the side&#8221;—the opaque pointer, or Pimpl. If copy and move are appropriate for your type, write those four operations to perform a deep copy that clones the <span style="color:#2e74b5;">impl</span> state.
</p>
<p>The major advantages of this idiom come from the fact that it breaks the caller&#8217;s dependency on the private details, including breaking both compile-time dependencies and binary dependencies:
</p>
<ul>
<li>Types mentioned only in a class&#8217; implementation need no longer be defined for client code, which can eliminate extra <span style="color:#2e74b5;">#include</span>s and improve compile speeds.
</li>
<li>A class&#8217; implementation can be changed—that is, private members can be freely added or removed—without recompiling client code. This is a useful technique for providing ABI-safety or binary compatibility, so that the client code is not dependent on the exact layout of the object.
</li>
</ul>
<p>The major costs of this idiom are in performance:
</p>
<ul>
<li>Each construction/destruction must allocate/deallocate memory.
</li>
<li>Each access of a hidden member can require at least one extra indirection. (If the hidden member being accessed itself uses a back pointer to call a function in the visible class, there will be multiple indirections, but is usually easy to avoid needing a back pointer.)
</li>
</ul>
<p>And of course we&#8217;re replacing any removed headers with the <span style="color:#2e74b5;">&lt;memory&gt;</span> header.
</p>
<p>We&#8217;ll come back to these and other Pimpl issues in GotW #24. For now, in our example, there were three headers whose definitions were needed simply because they appeared as private members of <span style="color:#2e74b5;">X</span>. If we instead restructure <span style="color:#2e74b5;">X</span> to use a Pimpl, we can immediately make several further simplifications:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>#include &lt;list&gt;<br />#include "c.h"  // class C<br />#include "d.h"  // class D
</code></pre>
</p>
<p>One of these headers (<span style="color:#2e74b5;">c.h</span>) can be replaced with a forward declaration because <span style="color:#2e74b5;">C</span> is still being mentioned elsewhere as a parameter or return type, and the other two (<span style="color:#2e74b5;">list</span> and <span style="color:#2e74b5;">d.h</span>) can disappear completely.
</p>
<blockquote>
<p><strong>Guideline:</strong> For widely-included classes whose implementations may change, or to provide ABI-safety or binary compatibility, consider using the compiler-firewall idiom (Pimpl Idiom) to hide implementation details. Use an opaque pointer (a pointer to a declared but undefined class) declared as <strong>struct impl; std::unique_ptr&lt;impl&gt; pimpl;</strong> to store private nonvirtual members.
</p>
</blockquote>
<p>
 </p>
<p>Note: We can&#8217;t tell from the original code by itself whether or not <span style="color:#2e74b5;">X</span> had (default) copy or move operations. If it did, then to preserve that we would need to write them again ourselves since the move-only <span style="color:#2e74b5;">unique_ptr</span> member suppresses the implicit generation of copy construction and copy assignment, and the user-declared destructor suppresses the implicit generation of move construction and move assignment. If we do need to write them by hand, the move constructor and move assignment can be <span style="color:#2e74b5;">=default</span>ed, and the copy constructor and copy assignment will need to copy the Pimpl object.
</p>
<p>After making that additional change, the header looks like this:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after converting to use a Pimpl<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />#include "b.h"  // class B (has no virtual functions)<br />class C;<br />class E;<br /><br />class X : public A, private B {<br />public:<br />    ~X();                          // defined out of line<br />    // and copy/move operations if X had them before<br /><br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>Without more extensive changes, we still need the definitions for <span style="color:#2e74b5;">A</span> and <span style="color:#2e74b5;">B</span> because they are base classes, and we have to know at least their sizes in order to define the derived class <span style="color:#2e74b5;">X</span>.
</p>
<p>The private details go into <span style="color:#2e74b5;">X</span>&#8216;s implementation file where client code never sees them and therefore never depends upon them:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  Implementation file x.cpp<br />//<br />#include &lt;list&gt;<br />#include "c.h"  // class C<br />#include "d.h"  // class D<br />using namespace std;<br /><br />struct X::impl {<br />    list&lt;C&gt; clist;<br />    D       d;<br />};<br /><br />X::X() : pimpl{ make_unique&lt;X::impl&gt;(/*...*/) } { }<br />X::~X() =default;
</code></pre>
</p>
<p>That brings us down to including only four headers, which is a great improvement—but it turns out that there is still a little more we could do, if only we were allowed to change the structure of <span style="color:#2e74b5;">X</span> more extensively. This leads us nicely into Part 3…
</p>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks to the following for their feedback to improve this article: John Humphrey, thokra, Motti Lanzkron, Marcelo Pinto.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7b: Minimizing Compile-Time Dependencies, Part 2</title>
		<link>https://herbsutter.com/2013/08/19/gotw-7b-minimizing-compile-time-dependencies-part-2/</link>
				<comments>https://herbsutter.com/2013/08/19/gotw-7b-minimizing-compile-time-dependencies-part-2/#comments</comments>
				<pubDate>Mon, 19 Aug 2013 10:33:12 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2294</guid>
				<description><![CDATA[Now that the unnecessary headers have been removed, it&#8217;s time for Phase 2: How can you limit dependencies on the internals of a class? Problem JG Questions 1. What does private mean for a class member in C++? 2. Why does changing the private members of a type cause a recompilation? Guru Question 3. Below [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now that the unnecessary headers have been removed, it&#8217;s time for Phase 2: How can you limit dependencies on the internals of a class?</em></span></p>
<h1>Problem</h1>
<h2>JG Questions</h2>
<p>1. What does <span style="color:#2e74b5;">private</span> mean for a class member in C++?</p>
<p>2. Why does changing the private members of a type cause a recompilation?</p>
<h2>Guru Question</h2>
<p>3. Below is how the header from the previous Item looks after the initial cleanup pass. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made some suitable changes, and how?</p>
<p>This time, you may make changes to <span style="color:#2e74b5;">X</span> as long as <span style="color:#2e74b5;">X</span>&#8216;s base classes and its public interface remain unchanged; any current code that already uses <span style="color:#2e74b5;">X</span> should not be affected beyond requiring a simple recompilation.</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: sans gratuitous headers
//
#include &lt;iosfwd&gt;
#include &lt;list&gt;

// None of A, B, C, or D are templates.
// Only A and C have virtual functions.
#include "a.h"  // class A
#include "b.h"  // class B
#include "c.h"  // class C
#include "d.h"  // class D
class E;

class X : public A, private B {
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
};

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</code></pre>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/08/19/gotw-7b-minimizing-compile-time-dependencies-part-2/feed/</wfw:commentRss>
		<slash:comments>21</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7a Solution: Minimizing Compile-Time Dependencies, Part 1</title>
		<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/</link>
				<comments>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comments</comments>
				<pubDate>Mon, 19 Aug 2013 10:31:39 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2292</guid>
				<description><![CDATA[Managing dependencies well is an essential part of writing solid code. C++ supports two powerful methods of abstraction: object-oriented programming and generic programming. Both of these are fundamentally tools to help manage dependencies, and therefore manage complexity. It&#8217;s telling that all of the common OO/generic buzzwords—including encapsulation, polymorphism, and type independence—along with most design patterns, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Managing dependencies well is an essential part of writing solid code. C++ supports two powerful methods of abstraction: object-oriented programming and generic programming. Both of these are fundamentally tools to help manage dependencies, and therefore manage complexity. It&#8217;s telling that all of the common OO/generic buzzwords—including encapsulation, polymorphism, and type independence—along with most design patterns, are really about describing ways to manage complexity within a software system by managing the code&#8217;s interdependencies.<br />
</em></span></p>
<p><span style="color:#5a5a5a;"><em>When we talk about dependencies, we usually think of run-time dependencies like class interactions. In this Item, we will focus instead on how to analyze and manage compile-time dependencies. As a first step, try to identify (and root out) unnecessary headers.</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. For a function or a class, what is the difference between a forward declaration and a definition?</p>
<h2>Guru Question</h2>
<p>2. Many programmers habitually <span style="color:#2e74b5;">#include</span> many more headers than necessary. Unfortunately, doing so can seriously degrade build times, especially when a popular header file includes too many other headers.</p>
<p>In the following header file, what <span style="color:#2e74b5;">#include</span> directives could be immediately removed without ill effect? You may not make any changes other than removing or rewriting (including replacing) <span style="color:#2e74b5;">#include</span> directives. Note that the comments are important.</p>
<pre><code>//  x.h: original header
//
#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;list&gt;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include "a.h"  // class A
#include "b.h"  // class B
#include "c.h"  // class C
#include "d.h"  // class D
#include "e.h"  // class E

class X : public A, private B {
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
  };

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</code></pre>
<h1>Solution</h1>
<h2>1. For a function or class, what is the difference between a forward declaration and a definition?</h2>
<p>A forward declaration of a (possibly templated) function or class simply introduces a name. For example:</p>
<pre><code>class widget;  // "widget" names a class 

widget* p;     // ok: allocates sizeof(*) space typed as widget*

widget  w;     // error: wait, what? how big is that? does it have a
               //        default constructor?
</code></pre>
<p>Again, a forward declaration only <em>introduces a name</em>. It lets you do things that require only the name, such as declaring a pointer to it—all pointers to objects are the same size and have the same set of operations you can perform on them, and ditto for pointers to nonmember functions, so the name is all you need to make a strongly-typed and fully-usable variable that&#8217;s a pointer to class or pointer to function.</p>
<p>What a class forward declaration does <em>not</em> do is tell you anything about what you can do with the type itself, such as what constructors or member functions it has or how big it is if you want to allocate space for one. If you try to create a <span style="color:#2e74b5;">widget w;</span> with only the above code, you&#8217;ll get a compile-time error because <span style="color:#2e74b5;">widget</span> has no definition yet and so the compiler can&#8217;t know how much space to allocate or what functions the type has (including whether it has a default constructor).</p>
<p>A class definition has a body and lets you know the class&#8217;s size and know the names and types of its members:</p>
<pre><code>class widget { // "{" means definition
    widget();
    // ...
};

widget* p;     // ok: allocs sizeof(ptr) space typed as widget*

widget  w;     // ok: allocs sizeof(widget) space typed as widget
               //     and calls default constructor
</code></pre>
<h2>2. In the following header file, what #include directives could be immediately removed without ill effect?</h2>
<p>Of the first two standard headers mentioned in <span style="color:#2e74b5;">x.h</span>, one can be immediately removed because it&#8217;s not needed at all, and the second can be replaced with a smaller header:</p>
<h3>1. Remove iostream.</h3>
<pre><code>#include &lt;iostream&gt;
</code></pre>
<p>Many programmers <span style="color:#2e74b5;">#include &lt;iostream&gt;</span> purely out of habit as soon as they see anything resembling a stream nearby. Class <span style="color:#2e74b5;">X</span> does make use of streams, that&#8217;s true; but it doesn&#8217;t mention anything specifically from <span style="color:#2e74b5;">iostream</span>, which mainly declares the standard stream objects like <span style="color:#2e74b5;">cout</span>. At the most, <span style="color:#2e74b5;">X</span> needs <span style="color:#2e74b5;">ostream</span> alone for its <span style="color:#2e74b5;">basic_ostream</span> type, and even that can be whittled down as we will see.</p>
<blockquote><p><strong>Guideline:</strong> Never <strong>#include</strong> unnecessary header files.</p></blockquote>
<h3>2. Replace ostream with iosfwd.</h3>
<pre><code>#include &lt;ostream&gt;
</code></pre>
<p>Parameter and return types only need to be forward-declared, so instead of the full definition of <span style="color:#2e74b5;">ostream</span> we really only need its forward declaration.</p>
<p>However, you can&#8217;t write the forward declaration yourself using something like <span style="color:#2e74b5;">class ostream;</span>. First, <span style="color:#2e74b5;">ostream</span> lives in namespace <span style="color:#2e74b5;">std</span> in which you can&#8217;t redeclare existing standard types and objects. Second, <span style="color:#2e74b5;">ostream</span> is an alias for <span style="color:#2e74b5;">basic_ostream&lt;char&gt;</span> which you couldn&#8217;t reliably forward-declare even if you were allowed to because library implementations are allowed to do things like add their own extra template parameters beyond those required by the standard that of course your code wouldn&#8217;t know about—which is one of the primary reasons for the rule that programmers aren&#8217;t allowed to write their own declarations for things in namespace <span style="color:#2e74b5;">std</span>.</p>
<p>All is not lost, though: The standard library helpfully provides the header <span style="color:#2e74b5;">iosfwd</span>, which contains forward declarations for all of the stream templates and their standard aliases, including <span style="color:#2e74b5;">basic_ostream </span>and <span style="color:#2e74b5;">ostream</span>. So all we need to do is replace <span style="color:#2e74b5;">#include &lt;ostream&gt;</span> with <span style="color:#2e74b5;">#include &lt;iosfwd&gt;</span>.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to <strong>#include &lt;iosfwd&gt;</strong> when a forward declaration of a stream will suffice.</p></blockquote>
<p>Incidentally, once you see <span style="color:#2e74b5;">iosfwd</span>, one might think that the same trick would work for other standard library templates like <span style="color:#2e74b5;">string</span> and <span style="color:#2e74b5;">list</span>. There are, however, no comparable &#8220;stringfwd&#8221; or &#8220;listfwd&#8221; standard headers. The <span style="color:#2e74b5;">iosfwd</span> header was created to give streams special treatment for backwards compatibility, to avoid breaking code written in years past for the &#8220;old&#8221; non-templated version of the iostreams subsystem. It is hoped that a real solution will come in a future version of C++ that supports <em>modules</em>, but that&#8217;s a topic for a later time.</p>
<p>There, that was easy. We can now move on to…</p>
<p>… what? &#8220;Not so fast!&#8221; I hear some of you say. &#8220;This header does a lot more with <span style="color:#2e74b5;">ostream</span> than just mention it as a parameter or return type. The inlined <span style="color:#2e74b5;">operator&lt;&lt;</span> actually uses an <span style="color:#2e74b5;">ostream</span> object! So it must need <span style="color:#2e74b5;">ostream</span>&#8216;s definition, right?&#8221;</p>
<p>That&#8217;s a reasonable question. Happily, the answer is: No, it doesn&#8217;t. Consider again the function in question:</p>
<pre><code>std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</code></pre>
<p>This function mentions an <span style="color:#2e74b5;">ostream&amp;</span> as both a parameter and a return type, which most people know doesn&#8217;t require a definition. And it passes its <span style="color:#2e74b5;">ostream&amp;</span> parameter in turn as a parameter to another function, which many people <em>don&#8217;t</em> know doesn&#8217;t require a definition either—it&#8217;s the same as if it were a pointer, <span style="color:#2e74b5;">ostream*</span>, discussed above. As long as that&#8217;s all we&#8217;re doing with the <span style="color:#2e74b5;">ostream&amp;</span>, there&#8217;s no need for a full <span style="color:#2e74b5;">ostream</span> definition—we&#8217;re not really using an <span style="color:#2e74b5;">ostream</span> itself at all, such as by calling functions on it, we&#8217;re only using a reference to type for which we only need to know the name. Of course, we would need the full definition if we tried to call any member functions, for example, but we&#8217;re not doing anything like that here.</p>
<p>So, as I was saying, we can now move on to get rid of one of the other headers, but only one just yet:</p>
<h3>3. Replace e.h with a forward declaration.</h3>
<pre><code>#include "e.h"  // class E
</code></pre>
<p>Class <span style="color:#2e74b5;">E</span> is just being mentioned as a parameter and as a return type in function <span style="color:#2e74b5;">E h(E)</span>, so no definition is required and <span style="color:#2e74b5;">x.h</span> shouldn&#8217;t be pulling in <span style="color:#2e74b5;">e.h</span> in the first place because the caller couldn&#8217;t even be calling this function if he didn&#8217;t have the definition of <span style="color:#2e74b5;">E</span> already, so there&#8217;s no point in including it again. (Note this would not be true if <span style="color:#2e74b5;">E</span> were only a return type, such as if the signature were <span style="color:#2e74b5;">E h();</span>, because in that case it’s good style to include <span style="color:#2e74b5;">E</span>’s definition for the caller’s convenience so he can easily write code like <span style="color:#2e74b5;">auto val = x.h();</span>.) All we need to do is replace <span style="color:#2e74b5;">#include &#8220;e.h&#8221;</span> with <span style="color:#2e74b5;">class E;</span>.</p>
<blockquote><p><strong>Guideline: </strong>Never <strong>#include</strong> a header when a forward declaration will suffice.</p></blockquote>
<p>That’s it.</p>
<p>You may be wondering why we can’t get rid of the other headers yet. It’s because to define class <span style="color:#2e74b5;">X</span> means you need to know its size in order to know how much space to allocate for an <span style="color:#2e74b5;">X</span> object, and to know <span style="color:#2e74b5;">X</span>’s size you need to know at least the size of every base class and data member. So we need the definitions of <span style="color:#2e74b5;">A</span> and <span style="color:#2e74b5;">B</span> because they are base classes, and we need the header definitions of <span style="color:#2e74b5;">list</span>, <span style="color:#2e74b5;">C</span>, and <span style="color:#2e74b5;">D</span> because they are used to define the data members. How we can begin to address some of these is the subject of Part 2&#8230;</p>
<p>&nbsp;</p>
<h2>Acknowledgments</h2>
<p>Thanks to the following for their feedback to improve this article: Gennaro, Sebastien Redl, Emmanuel Thivierge.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7a: Minimizing Compile-Time Dependencies, Part 1</title>
		<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/</link>
				<comments>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comments</comments>
				<pubDate>Mon, 12 Aug 2013 22:53:30 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2277</guid>
				<description><![CDATA[GotW #7a: Minimizing Compile-Time Dependencies, Part 1 Managing dependencies well is an essential part of writing solid code. C++ supports two powerful methods of abstraction: object-oriented programming and generic programming. Both of these are fundamentally tools to help manage dependencies, and therefore manage complexity. It&#8217;s telling that all of the common OO/generic buzzwords—including encapsulation, polymorphism, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="font-size:28pt;">GotW #7a: Minimizing Compile-Time Dependencies, Part 1<br />
</span></p>
<p><span style="color:#5a5a5a;"><em>Managing dependencies well is an essential part of writing solid code. C++ supports two powerful methods of abstraction: object-oriented programming and generic programming. Both of these are fundamentally tools to help manage dependencies, and therefore manage complexity. It&#8217;s telling that all of the common OO/generic buzzwords—including encapsulation, polymorphism, and type independence—along with the lion&#8217;s share of design patterns, are really about describing ways to manage complexity within a software system by managing the code&#8217;s interdependencies.<br />
</em></span></p>
<p><span style="color:#5a5a5a;"><em>When we talk about dependencies, we usually think of run-time dependencies like class interactions. In this Item, we will focus instead on how to analyze and manage compile-time dependencies. As a first step, try to identify (and root out) unnecessary headers.</em></span>
	</p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. For a function or a class, what is the difference between a forward declaration and a definition?
</p>
<h2>Guru Question<br />
</h2>
<p>2. Many programmers habitually <span style="color:#2e74b5;">#include</span> many more headers than necessary. Unfortunately, doing so can seriously degrade build times, especially when a popular header file includes too many other headers.
</p>
<p>In the following header file, what <span style="color:#2e74b5;">#include</span> directives could be immediately removed without ill effect? You may not make any changes other than removing or rewriting <span style="color:#2e74b5;">#include</span> directives. Note that the comments are important.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: original header<br />//<br />#include &lt;iostream&gt;<br />#include &lt;ostream&gt;<br />#include &lt;list&gt;<br /><br />// None of A, B, C, D or E are templates.<br />// Only A and C have virtual functions.<br />#include "a.h"  // class A<br />#include "b.h"  // class B<br />#include "c.h"  // class C<br />#include "d.h"  // class D<br />#include "e.h"  // class E<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />  private:<br />    std::list&lt;C&gt; clist;<br />    D            d_;<br />  };<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/feed/</wfw:commentRss>
		<slash:comments>21</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #94 Solution: AAA Style (Almost Always Auto)</title>
		<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</link>
				<comments>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comments</comments>
				<pubDate>Mon, 12 Aug 2013 19:42:37 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2230</guid>
				<description><![CDATA[Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation of its value. Problem JG Questions 1. What does this code do? What would be a good name for some_function? template&#60;class Container, class Value&#62; void some_function( Container&#38; c, const Value&#38; v ) { if( find(begin(c), end(c), [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation of its value.<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Questions</h2>
<p>1. What does this code do? What would be a good name for <span style="color:#2e74b5;">some_function</span>?</p>
<pre><code>template&lt;class Container, class Value&gt;
void some_function( Container&amp; c, const Value&amp; v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.emplace_back(v); 
    assert( !c.empty() );
}
</code></pre>
<p>2. What does &#8220;write code against interfaces, not implementations&#8221; mean, and why is it generally beneficial?</p>
<h2>Guru Questions</h2>
<p>3. What are some popular concerns about using <span style="color:#2e74b5;">auto</span> to declare variables? Are they valid? Discuss.</p>
<p>4. When declaring a new local variable <span style="color:#2e74b5;">x</span>, what advantages are there to declaring it using <span style="color:#2e74b5;">auto</span> and one of the two following syntaxes:</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">auto x = init;</span> when you don&#8217;t need to commit to a specific type? (Note: The expression <span style="color:#2e74b5;">init</span> might include calling a helper that performs partial type adjustment, such as <span style="color:#2e74b5;">as_signed</span>, while still not committing to a specific type.)</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">auto x = type{ init };</span> when you do want to commit to a specific type by naming a <span style="color:#2e74b5;">type</span>?</p>
<p>List as many as you can. (Hint: Look back to GotW #93.)</p>
<p>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:</p>
<p style="margin-left:36pt;">(a) Heap allocation syntax.</p>
<p style="margin-left:36pt;">(b) Literal suffixes, including user-defined literal operators.</p>
<p style="margin-left:36pt;">(c) Named lambda syntax.</p>
<p style="margin-left:36pt;">(d) Function declarations.</p>
<p style="margin-left:36pt;">(e) Template alias declarations.</p>
<p>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</p>
<h1>Solution</h1>
<h2>1. What does this code do? What would be a good name for some_function?</h2>
<pre><code>template&lt;class Container, class Value&gt;
void <span style="background-color:yellow;">append_unique</span>( Container&amp; c, const Value&amp; v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.emplace_back(v); 
    assert( !c.empty() );
}
</code></pre>
<p>Let&#8217;s call this function <span style="color:#2e74b5;">append_unique</span>. First, it checks to see whether the value <span style="color:#2e74b5;">v</span> is already in the container. If not, it appends it at the end. Finally, it asserts that <span style="color:#2e74b5;">c</span> is not empty, since by now it must contain one copy of the value <span style="color:#2e74b5;">v</span>.</p>
<p>You probably thought this question was fairly easy.</p>
<p>Maybe <em>too</em> easy.</p>
<p>If so, good. That&#8217;s the point of the example. Hold the thought, and we&#8217;ll come back to this in Question 3.</p>
<h2>2. What does &#8220;write code against interfaces, not implementations&#8221; mean, and why is it generally beneficial?</h2>
<p>It means we should care principally about &#8220;what,&#8221; not &#8220;how.&#8221; This separation of concerns applies at all levels in high-quality modern software—hiding <em>code</em>, hiding <em>data</em>, and hiding <em>type</em>. Each increases encapsulation and reduces coupling, which are essential for large-scale and robust software.</p>
<p>Please indulge a little repetition in the following paragraphs. It&#8217;s there to make a point about similarity.</p>
<p><strong>Hiding code.</strong> With the invention of separately compiled functions and structured programming, we gained &#8220;encapsulation to <em>hide code.</em>&#8221; The caller knows the signature only—the function&#8217;s internal code is not his concern and not accessible programmatically, even if the function is <span style="color:#2e74b5;">inline</span> and the body happens to be visible in source code. We try hard not to inadvertently leak implementation details, such as internal data structure types. The point is that the caller does not, and should not, commit to knowledge of the current internal code; if he did, it would create interdependencies and make separately compiled libraries impossible.</p>
<p><strong>Hiding data (and code).</strong> With object oriented styles (OO), we gained two new manifestations of this separation. First, we got &#8220;more encapsulation to <em>hide both code and data.</em>&#8221; The caller knows the class name, bases, and member function signatures only—the class&#8217;s internal data and internal code are hidden and not accessible programmatically, even though the <span style="color:#2e74b5;">private</span> class members are lexically visible in the class definition and <span style="color:#2e74b5;">inline</span> function bodies may also be visible. (In turn, dynamic libraries and the potential future-C++ modules work aim to accomplish the same thing at a still larger scale.) Again we try hard not to inadvertently leak implementation details, and again the point is that the caller does not, and should not, commit to knowledge of the current internal data or code, which would make the class difficult to ever change or to ship on its own as a library.</p>
<p><strong>Hiding type (run-time polymorphism).</strong> Second, OO also gave us &#8220;separation of interfaces to <em>hide type.</em>&#8221; A base class or interface can delegate work to a concrete derived implementation via virtual functions. Now the interface the caller sees and the implementation are actually different types, and the caller knows the base type only—he doesn&#8217;t know or care about the concrete type, including even its size. The point, once again, is that the caller does not, and should not, commit to a single concrete type, which would make the caller&#8217;s code less general and less able to be reused with new types.</p>
<p><strong>Hiding type (compile-time polymorphism).</strong> With templates, we gained a new compile-time form of this separation—and it&#8217;s still &#8220;separation of interfaces to <em>hide type</em>.&#8221; The caller knows an ad-hoc &#8220;duck typed&#8221; set of operations he wants to perform using a type, and any type that supports those operations will do just fine. The contemplated future C++ concepts feature will allow making this stricter and less ad-hoc, but still avoids committing to a concrete type at all. The whole point is still is that the caller does not, and should not, commit to a single concrete type, which would make the caller&#8217;s code less generic and less able to be reused with new types.</p>
<h2>3. What are some popular concerns about using auto to declare variables? Are they valid? Discuss.</h2>
<p>In many languages, not just C++, there are several reasons people commonly give for why they are reluctant to use <span style="color:#2e74b5;">auto</span> to declare variables (or the equivalent in another language, such as <span style="color:#2e74b5;">var</span> or <span style="color:#2e74b5;">let</span>). We could summarize them as: <em>laziness</em>, <em>commitment</em>, and <em>readability</em>. Let&#8217;s take them in order.</p>
<h3>Laziness and commitment</h3>
<p>First, laziness: One common concern is that &#8220;writing <span style="color:#2e74b5;">auto</span> to declare a variable is primarily about saving typing.&#8221; However, this is just a misunderstanding of <span style="color:#2e74b5;">auto</span>. As we saw in GotW #92 and #93 and will see again below, the main reasons to declare variables using <span style="color:#2e74b5;">auto</span> are for correctness, performance, maintainability, and robustness—and, yes, convenience, but that&#8217;s in last place on the list.</p>
<blockquote><p><strong>Guideline:</strong> Remember that preferring <strong>auto</strong> variables is motivated primarily by correctness, performance, maintainability, and robustness—and only lastly about typing convenience.</p></blockquote>
<p>Second, commitment: &#8220;But in some cases I do want to commit to a specific type, not automatically deduce it, so I can&#8217;t use <span style="color:#2e74b5;">auto</span>.&#8221; It&#8217;s true that sometimes you do want to commit to a specific type, but you can still use <span style="color:#2e74b5;">auto</span>. As demonstrated in GotW #92 and #93, not only can you still write declarations of the form <span style="color:#2e74b5;">auto x = type{ init };</span> (instead of <span style="color:#2e74b5;">type x{init};</span>) to commit to a specific type, but there are good reasons for doing so, such as that saying <span style="color:#2e74b5;">auto</span> means you can&#8217;t possibly forget to initialize the variable.</p>
<blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, it guarantees the variable will be initialized, and it won&#8217;t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use <strong>( )</strong> instead of <strong>{ }</strong>.</p></blockquote>
<h3>(Un)readability?</h3>
<p>The third and most common argument concerns readability: &#8220;My code gets unreadable quickly when I don&#8217;t know what exact type my variable is without hunting around to see what that function or expression returns, so I can&#8217;t just use <span style="color:#2e74b5;">auto</span> all the time.&#8221; There is truth to this, including losing the ability to search for occurrences of specific types when using the non-typed syntax <em>auto x = expr;</em> in 4(a) below, so this appears at first to be a strong argument. And it&#8217;s true that any feature can be overused. However, I think this argument is actually weaker than it first seems for four reasons, two minor and two major.</p>
<p>The two minor counterarguments are:</p>
<ul>
<li>The &#8220;can&#8217;t use <span style="color:#2e74b5;">auto</span>&#8221; part isn&#8217;t actually true, because as we just saw above you can be explicit about your type and still use <span style="color:#2e74b5;">auto</span>, with good benefit.</li>
<li>The argument doesn&#8217;t apply when you&#8217;re using an IDE, because you can always tell the exact type, for example by hovering over the variable. Granted, this mitigation goes away when you leave the IDE, such as if you print the code.</li>
</ul>
<p>But we should focus on the two major counterarguments:</p>
<ul>
<li>It reflects a bias to code against implementations, not interfaces. Overcommitting to explicit types makes code less generic and more interdependent, and therefore more brittle and limited. It runs counter to the excellent reasons to &#8220;write code against interfaces, not implementations&#8221; we saw in Question 2.</li>
<li><strong>We (meaning <em>you</em>) already ignore actual types all the time…<br />
</strong></li>
</ul>
<p>&#8220;… Wait, what? I do not ignore types all the time,&#8221; someone might say. Actually, not only do you do it, but you&#8217;re so comfortable and cavalier about it that you may not even realize you&#8217;re doing it. Let&#8217;s go back to that code in Question 1:</p>
<pre><code>template&lt;class Container, class Value&gt;
void append_unique( Container&amp; c, const Value&amp; v ) {
    if( find(begin(c), end(c), v) == end(c) )
        c.emplace_back(v); 
    assert( !c.empty() );
}
</code></pre>
<p><em>Quick quiz:</em> How many specific types are mentioned in that function? Name as many as you can.</p>
<p>Take a moment to consider that before reading on…</p>
<p>… We can see pretty quickly that the answer is a nice round number: Zero. Zilch. (Pedantic mode: Yes, there&#8217;s <span style="color:#2e74b5;">void</span>, but I&#8217;m going to declare that <span style="color:#2e74b5;">void</span> doesn&#8217;t count because it&#8217;s to denote &#8220;no type,&#8221; it&#8217;s not a meaningful type.)</p>
<p>Not a single specific type appears anywhere in this code, and the lack of exact types makes it much more powerful and doesn&#8217;t significantly harm its readability. Like most people, you probably thought Question 1 felt &#8220;easy&#8221; when we did it in isolation. Granted, this is generic code, and not all your code will be templates—but the point is that the code isn&#8217;t unreadable even though it doesn&#8217;t mention specific types, and in fact auto gives you the ability to write generic code even when <em>not</em> writing a template.</p>
<p>So starting with the cases illustrated in this short example, let&#8217;s consider some places where we routinely ignore exact types. First, function template parameters:</p>
<ul>
<li>What exact type is <span style="color:#2e74b5;">Container</span>? We have no idea, and that&#8217;s great… anything we can call <span style="color:#2e74b5;">begin</span>, <span style="color:#2e74b5;">end</span>, <span style="color:#2e74b5;">emplace_back</span> and <span style="color:#2e74b5;">empty</span> on and otherwise use as needed by this code will do just fine. In fact, we&#8217;re glad we don&#8217;t know anything about the exact type, because it means we&#8217;re following the Open/Closed Principle and staying open for extension— this <span style="color:#2e74b5;">append_unique</span> will work fine with a type that won&#8217;t be written until years from now. Interestingly, the concepts feature currently being proposed for ISO C++ to express template parameter constraints doesn&#8217;t change how this works at all, it only makes it more convenient to express and check the requirements. Note how much more powerful this is compared to OO style frameworks: In OO frameworks where containers have to inherit from a base class or interface, that&#8217;s already inducing coupling and limiting the ability to just plug in and use arbitrary suitable types. It is important that we can know nothing at all about the type here besides its necessary interface, not even restricting it by as much as limiting it to types in a particular inheritance hierarchy. We should strongly resist compromising this wonderful and powerful &#8220;strictly typed but loosely coupled&#8221; genericity.</li>
<li>What exact type is <span style="color:#2e74b5;">Value</span>? Again, we don&#8217;t know, and we don&#8217;t want to know… anything we can pass to <span style="color:#2e74b5;">find</span> and <span style="color:#2e74b5;">emplace_back</span> is just dandy. At this point some of you may be thinking: &#8220;Oh yes we know what type it is, it&#8217;s the container&#8217;s value type!&#8221; No, it doesn&#8217;t have to be that, it just has to be convertible, and that&#8217;s important. For example, we want <span style="color:#2e74b5;">vector&lt;string&gt; vec; append_unique(vec, &#8220;xyzzy&#8221;);</span> to work, and <span style="color:#2e74b5;">&#8220;xyzzy&#8221;</span> is a <span style="color:#2e74b5;">const char[6]</span>, not a <span style="color:#2e74b5;">string</span>.</li>
</ul>
<p>Second, function return values:</p>
<ul>
<li>What type does <span style="color:#2e74b5;">find</span> return? Some iterator type, the same as <span style="color:#2e74b5;">begin(c)</span> coughed up, but we don&#8217;t know specifically what type it is just from reading this code, and it doesn&#8217;t matter. We can look up the signature if we&#8217;re feeling really curious, but nobody bothers doing that because anything that&#8217;s comparable to <span style="color:#2e74b5;">end(c)</span> will do.</li>
<li>What type does <span style="color:#2e74b5;">empty</span> return? We don&#8217;t even think twice about it. Something testable like a <span style="color:#2e74b5;">bool</span>… we don&#8217;t care much what exactly as long as we can &#8220;not&#8221; it.</li>
</ul>
<p>Third, many function parameters:</p>
<ul>
<li>What specific type does <span style="color:#2e74b5;">emplace_back</span> take? Don&#8217;t know; might be the same as <span style="color:#2e74b5;">v</span>, might not. Really don&#8217;t care. Can we pass <span style="color:#2e74b5;">v</span> to it? Yes? Groovy.</li>
</ul>
<p>And that&#8217;s just in this example. We routinely and desirably ignore types in many other places, such as:</p>
<ul>
<li>Fourth, any temporary object: We never get to name the object, much less name its type, and we may know what the type is but we don&#8217;t care about actually spelling out either name in our code.</li>
<li>Fifth, any use of a base class: We don&#8217;t know the dynamic concrete type we&#8217;re actually using, and that&#8217;s a benefit, not a bug.</li>
<li>Sixth, any call to a virtual function: Ditto; plus on top of that if the virtual function return type itself could also be covariant for another layer of &#8220;we don&#8217;t know the dynamic concrete type&#8221; since in the presence of covariance we don&#8217;t know what type we&#8217;re actually getting back.</li>
<li>Seventh, any use of <span style="color:#2e74b5;">function&lt;&gt;</span>, <span style="color:#2e74b5;">bind</span>, or other type erasure: Just think about how little we actually know, and how happy it makes us. For example, given a <span style="color:#2e74b5;">function&lt;int(string)&gt;</span>, not only don&#8217;t we know what specific function or object it&#8217;s bound to, we don&#8217;t even know that thing&#8217;s signature—it might not actually even take a <span style="color:#2e74b5;">string</span> or return an <span style="color:#2e74b5;">int</span>, because conversions are allowed in both directions, so it only has to take something a <span style="color:#2e74b5;">string</span> can be converted to, and return something that can be converted to an <span style="color:#2e74b5;">int</span>. All we know is that it&#8217;s something that we can invoke with a <span style="color:#2e74b5;">string</span> and that gives us back something we can use as an <span style="color:#2e74b5;">int</span>. Ignorance is bliss.</li>
<li>Eighth, Any use of a C++14 generic lambda function: A generic lambda just means the function call operator is a template, after all, and like any function template it gets stamped out individually for whatever actual argument types you pass each time you use it.</li>
</ul>
<p>There are probably more.</p>
<p>Although lack of commitment may be a bad thing in other areas of life, not committing to a specific type is often desirable by default in reusable code.</p>
<h2>4. When declaring a new local variable x, what advantages are there to declaring it using auto and one of the two following syntaxes:</h2>
<p>Let&#8217;s consider the base case first, which has by far the strongest arguments in its favor and is gaining quite a bit of traction in the C++ community.</p>
<h3>(a) auto x = init; when you don&#8217;t need to commit to a specific type?</h3>
<p>GotW #93 offered many concrete examples to support habitually declaring local variables using <span style="color:#2e74b5;">auto x = expr;</span> when you don&#8217;t need to explicitly commit to a type. The advantages include:</p>
<ul>
<li>It guarantees the variable will be initialized. Uninitialized variables are impossible because once you start by saying <span style="color:#2e74b5;">auto</span> the <span style="color:#2e74b5;">=</span> is required and cannot be forgotten.</li>
<li>It is efficient by default and guarantees that no implicit conversions (including narrowing conversions), temporary objects, or wrapper indirections will occur. In particular, prefer using <span style="color:#2e74b5;">auto</span> instead of <span style="color:#2e74b5;">function&lt;&gt;</span> to name lambdas unless you need the type erasure and indirection.</li>
<li>It guarantees that you will use the correct exact type now.</li>
<li>It guarantees that you will continue to use the correct exact type under maintenance as the code changes, and the variable&#8217;s type automatically tracks other functions&#8217; and expressions&#8217; types unless you explicitly said otherwise.</li>
<li>It is the simplest way to portably spell the implementation-specific type of arithmetic operations on built-in types, which vary by platform, and ensure that you cannot accidentally get lossy narrowing conversions when storing the result.</li>
<li>It is the only good option for hard-to-spell and impossible-to-spell types such as lambdas, binders, <span style="color:#2e74b5;">detail::</span> helpers, and template helpers (including expression templates when they should stay unevaluated for performance), short of resorting to repetitive <span style="color:#2e74b5;">decltype</span> expressions or more-expensive indirections like <span style="color:#2e74b5;">function&lt;&gt;</span>.</li>
<li>It is more symmetric and consistent with other parts of modern C++ (see Question 5).</li>
<li>And yes, it is just generally simpler and less typing.</li>
</ul>
<p>See GotW #93 for concrete examples of these cases, where using <span style="color:#2e74b5;">auto</span> helps eliminate correctness bugs, performance bugs, and silently nonportable code.</p>
<p>As noted in the questions, the expression <span style="color:#2e74b5;">init</span> might include calling a helper that performs partial type adjustment, such as <span style="color:#2e74b5;">as_signed</span>, while still not committing to a specific type. As shown in GotW #93, prefer to use <span style="color:#2e74b5;">auto x = as_signed(integer_expr);</span> or <span style="color:#2e74b5;">auto x = as_unsigned(integer_expr);</span> to store the result of an integer computation that should be signed or unsigned—these should be viewed as &#8220;casts that preserve width,&#8221; so we are not casting to a specific type but rather casting an attribute of the type while correctly preserving the other basic characteristics of the type, notably by not forcing it to commit to a particular size.</p>
<p>Using <span style="color:#2e74b5;">auto</span> together with <span style="color:#2e74b5;">as_signed</span> or <span style="color:#2e74b5;">as_unsigned</span> makes code more portable: the variable will both be large enough (thanks to <span style="color:#2e74b5;">auto</span>) and preserve the required signedness on all platforms. Note that signed/unsigned conversions within <span style="color:#2e74b5;">integer_expr</span> may still occur and so you may need additional finer-grained <span style="color:#2e74b5;">as_signed</span>/<span style="color:#2e74b5;">as_unsigned</span> casts within the expression for full portability.</p>
<h3>(b) auto x = type{ init }; when you do want to commit to a specific type by naming a type?</h3>
<p>This is the explicitly typed form, and it still has advantages but they are not as clearly strong as implicitly typed form. The jury is still out on whether to recommend this one wholesale, as we&#8217;re still trying it out, but it does offer some advantages and I suggest you try it out for a while and see if it works well for you.</p>
<p>So here&#8217;s the recommendation to consider trying out for yourself: Consider declaring local variables <span style="color:#2e74b5;">auto x = type{ expr };</span> when you do want to explicitly commit to a type. (Only when you do want to allow explicit narrowing, use <span style="color:#2e74b5;">( )</span> instead of <span style="color:#2e74b5;">{ }</span>.) The advantages of this typed <span style="color:#2e74b5;">auto</span> declaration style include:</p>
<ul>
<li>It guarantees the variable will be initialized; you can&#8217;t forget.</li>
<li>It is self-documenting to show that the code is explicitly requesting a conversion.</li>
<li>It won&#8217;t allow an accidental implicit narrowing conversion.</li>
<li>It is more symmetric and consistent, both with the basic <span style="color:#2e74b5;">auto x = init;</span> form and with other parts of C++…</li>
</ul>
<p>… which brings us to Question 5.</p>
<h2>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:</h2>
<p>Let&#8217;s start off this question with some side-by-side examples that give us a taste of the symmetry we gain when we habitually declare variables using modern <span style="color:#2e74b5;">auto</span> style. Starting with two examples where we don&#8217;t need to commit to a type and then two where we do, we see that the right-hand style is not only more robust and maintainable for the reasons already given, but also arguably cleaner and more regular with the type consistently on the right when it is mentioned:</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

const char* s = "Hello";             <strong>auto</strong> s = "Hello";
widget w = get_widget();             <strong>auto</strong> w = get_widget();

employee e{ empid };                 <strong>auto</strong> e = <strong>employee</strong>{ empid };
widget w{ 12, 34 };                  <strong>auto</strong> w = <strong>widget</strong>{ 12, 34 };
</code></pre>
<p>Now consider the (dare we say elegant) symmetry with each of the following.</p>
<h3>(a) Heap allocation syntax.</h3>
<p>When allocating heap variables, did you notice that the type name is already on the right naturally anyway? And since it&#8217;s there, we don&#8217;t want to have to repeat it. (I&#8217;ll show the raw &#8220;<span style="color:#2e74b5;">new</span>&#8221; form for completeness, but prefer <span style="color:#2e74b5;">make_unique</span> and <span style="color:#2e74b5;">make_shared</span> in that order for allocation in modern code, resorting to raw <span style="color:#2e74b5;">new</span> only well-encapsulated inside the implementation of low-level data structures.)</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

widget* w = new widget{};            /* <strong>auto</strong> w = new <strong>widget</strong>{}; */
unique_ptr&lt;widget&gt; w                 <strong>auto</strong> w = make_unique&lt;<strong>widget</strong>&gt;();
  = make_unique&lt;widget&gt;();
</code></pre>
<h3>(b) Literal suffixes, including user-defined literal operators.</h3>
<p>Using <span style="color:#2e74b5;">auto</span> declaration style doesn&#8217;t merely work naturally with built-in literal suffixes like <span style="color:#2e74b5;">ul</span> for <span style="color:#2e74b5;">unsigned long</span>, plus user-defined literals including standard ones now in draft C++14, but it actively encourages using them:</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

int x = 42;                          <strong>auto</strong> x = 42;
float x = 42.;                       <strong>auto</strong> x = 42.<strong>f</strong>;
unsigned long x = 42;                <strong>auto</strong> x = 42<strong>ul</strong>;
std::string x = "42";                <strong>auto</strong> x = "42"<strong>s</strong>;   // C++14
chrono::nanoseconds x{ 42 };         <strong>auto</strong> x = 42<strong>ns</strong>;    // C++14
</code></pre>
<p>Based on the examples so far, which do you think is more regular? But wait, there&#8217;s more…</p>
<h3>(c) Named lambda syntax.<br />
(d) Function declarations.</h3>
<p>Lambdas have unutterable types, and <span style="color:#2e74b5;">auto</span> is the best way to capture them exactly and efficiently. But because their declarations are now so similar, let&#8217;s consider lambdas and (other) functions together, and in the last two lines of this example also use C++14 return type deduction:</p>
<pre><code>// Classic C++ declaration order     // Modern C++ style

int f( double );                     <strong>auto</strong> f <strong>(double) -&gt; int</strong>;
…                                    <strong>auto</strong> f <strong>(double)</strong> { /*...*/ };
…                                    <strong>auto</strong> f = [=]<strong>(double)</strong> { /*...*/ };
</code></pre>
<h3>(e) Template alias declarations.</h3>
<p>Modern C++ frees us from the tyranny of un-template-able <span style="color:#2e74b5;">typedef</span>:</p>
<pre><code>// Classic C++ workaround            // Modern C++ style

typedef set&lt;string&gt; dict;            <strong>using</strong> dict = <strong>set&lt;string&gt;</strong>;

template&lt;class T&gt; struct myvec {     template&lt;class T&gt;
  typedef vector&lt;T,myalloc&gt; type;    <strong>using</strong> myvec = <strong>vector&lt;T,myalloc&gt;</strong>;
};
</code></pre>
<h3>An observation</h3>
<p>Have you noticed that the C++ world is moving to a left-to-right declaration style everywhere, of the form</p>
<p style="text-align:center;"><strong>category</strong> name = <strong>type</strong> and/or initializer ;</p>
<p>where &#8220;category&#8221; can be <span style="color:#2e74b5;">auto</span> or <span style="color:#2e74b5;">using</span>?</p>
<p>Take a moment to re-skim the two columns of examples above. Even ignoring correctness and performance advantages, do you find the right-hand column to be most consistent, and most readable?</p>
<h2>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</h2>
<p>There is one case I know of where this style cannot be followed, and it applies to the type-specific <span style="color:#2e74b5;">auto x = type{ init };</span> form. In that form, <span style="color:#2e74b5;">type</span> has to be moveable (even though the move operation will be routinely elided by compilers), so these won&#8217;t work:</p>
<pre><code>auto lock <strong>=</strong> lock_guard&lt;mutex&gt;{ m };  // error, not moveable
auto ai   <strong>=</strong> atomic&lt;int&gt;{};           // error, not moveable
</code></pre>
<p>(Aside: For at least some of these cases, an argument could be made that this is actually more of a defect in the type itself, in particular that perhaps <span style="color:#2e74b5;">atomic&lt;int&gt;</span> should be moveable.)</p>
<p>Having said that, there are three other cases I know of that you might encounter that may at first look like they don&#8217;t work with this <span style="color:#2e74b5;">auto</span> style, but actually do. Let&#8217;s consider those for completeness.</p>
<p>First, the basic form <span style="color:#2e74b5;">auto x = init;</span> will exactly capture an <span style="color:#2e74b5;">initializer_list</span> or a proxy type, such as an expression template. This is a feature, not a bug, because you have a convenient way to spell both &#8220;capture the list or proxy&#8221; and &#8220;resolve the computation&#8221; depending which you mean, and the default syntax goes to the more efficient one: If you want to efficiently capture the list or proxy, use the basic form which gives you performance by default, and if you mean to force the proxy to resolve the computation, specify the explicit type to ask for the conversion you want. For example:</p>
<pre><code>auto i1 = { 1 };                       // initializer_list&lt;int&gt;
auto i2 = 1;                           // int

auto a = matrix{...}, b = matrix{...}; // some type that does lazy eval
auto ab = a * b;                       // to capture the lazy-eval proxy
auto c = matrix{ a * b };              // to force computation

</code></pre>
<p>Second, here is a rare case that you may discover now that we have <span style="color:#2e74b5;">auto</span>: Due to the mechanics of the C++ grammar, you can&#8217;t legally write a multi-word type like <span style="color:#2e74b5;">long long</span> or <span style="color:#2e74b5;">class widget</span> in the place where <span style="color:#2e74b5;">type</span> goes in the <span style="color:#2e74b5;">auto x = type{ init };</span> form. However, note that this affects only those two cases:</p>
<ul>
<li>The multi-word built-in types like <span style="color:#2e74b5;">long long</span>, where you&#8217;re better off anyway writing a known-width type alias or using a literal.</li>
<li>Elaborated type specifiers like <span style="color:#2e74b5;">class widget</span>, where the &#8220;<span style="color:#2e74b5;">class</span>&#8221; part is already redundant. The &#8220;<span style="color:#2e74b5;">class widget</span>&#8221; syntax is allowed as a compatibility holdover from C which liked seeing <span style="color:#2e74b5;">struct widget</span> everywhere unless you <span style="color:#2e74b5;">typedef</span>&#8216;d the <span style="color:#2e74b5;">struct</span> part away.</li>
</ul>
<p>So just avoid the multi-word form and use the better alternative instead:</p>
<pre><code>auto x = long long{ 42 };            // error
auto x = int64_t{ 42 };              // ok, better 
auto x = 42LL;                       // ok, better 

auto y = class X{1,2,3};             // error
auto y = X{1,2,3};                   // ok
</code></pre>
<h2>Summary</h2>
<p>We already ignore explicit and exact types much of the time, including with temporary objects, virtual functions, templates, and more. This is a feature, not a bug, because it makes our code less tightly coupled, and more generic, flexible, reusable, and future-proof.</p>
<p>Declaring variables using <span style="color:#2e74b5;">auto</span>, whether or not we want to commit to a type, offers advantages for correctness, performance, maintainability, and robustness, as well as typing convenience. Furthermore, it is an example of how the C++ world is moving to a left-to-right declaration style everywhere, of the form</p>
<p style="text-align:center;"><strong>category</strong> name = <strong>type</strong> and/or initializer ;</p>
<p>where &#8220;category&#8221; can be <span style="color:#2e74b5;">auto</span> or <span style="color:#2e74b5;">using</span>, and we can get not only correctness and performance but also consistency benefits by using the style to consistently declare local variables (including using literals and user-defined literals), function declarations, named lambdas, aliases, template aliases, and more.</p>
<h2>Acknowledgments</h2>
<p>Thanks in particular to Scott Meyers and Andrei Alexandrescu for their time and insights in reviewing and discussing drafts of this material. Both helped generate candidate names for this idiom; it was Alexandrescu who suggested the name &#8220;AAA (almost always auto)&#8221; which I merged with the best names I&#8217;d thought of to that point (&#8220;auto style&#8221; or &#8220;auto (+type) style&#8221;) to get &#8220;AAA Style (almost always auto).&#8221; Thanks also to the following for their feedback to improve this article: Adrian, avjewe, mttpd, ned, zadecn, noniussenior, Marcel Wid, J Guy Davidson, Mark Garcia, Jonathan Wakely, &#8220;x y.&#8221;</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/feed/</wfw:commentRss>
		<slash:comments>67</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #94 Special Edition: AAA Style (Almost Always Auto)</title>
		<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/</link>
				<comments>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comments</comments>
				<pubDate>Fri, 14 Jun 2013 02:27:13 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2186</guid>
				<description><![CDATA[Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation of its value.   Problem JG Questions 1. What does this code do? What would be a good name for some_function? template&#60;class Container, class Value&#62;void some_function( Container&#38; c, const Value&#38; v ) { if( find(begin(c), end(c), [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation of its value.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What does this code do? What would be a good name for <span style="color:#2e74b5;">some_function</span>?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>template&lt;class Container, class Value&gt;<br />void some_function( Container&amp; c, const Value&amp; v ) {<br />    if( find(begin(c), end(c), v) == end(c) )<br />        c.emplace_back(v); <br />    assert( !c.empty() );<br />}
</code></pre>
</p>
<p>2. What does &#8220;write code against interfaces, not implementations&#8221; mean, and why is it generally beneficial?
</p>
<h2>Guru Questions<br />
</h2>
<p>3. What are some popular concerns about using <span style="color:#2e74b5;">auto</span> to declare variables? Are they valid? Discuss.
</p>
<p>4. When declaring a new local variable <span style="color:#2e74b5;">x</span>, what advantages are there to declaring it using <span style="color:#2e74b5;">auto</span> and one of the two following syntaxes:
</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">auto x = init;</span> when you don&#8217;t need to commit to a specific type? (Note: The expression <span style="color:#2e74b5;">init</span> might include calling a helper that performs partial type adjustment, such as <span style="color:#2e74b5;">as_signed</span>, while still not committing to a specific type.)
</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">auto x = type{ init };</span> when you do want to commit to a specific type by naming a <span style="color:#2e74b5;">type</span>?
</p>
<p>List as many as you can. (Hint: Look back to GotW #93.)
</p>
<p>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:
</p>
<p style="margin-left:36pt;">(a) Heap allocation syntax.
</p>
<p style="margin-left:36pt;">(b) Literal suffixes, including user-defined literal operators.
</p>
<p style="margin-left:36pt;">(c) Named lambda syntax.
</p>
<p style="margin-left:36pt;">(d) Function declarations.
</p>
<p style="margin-left:36pt;">(e) Template alias declarations.
</p>
<p>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/feed/</wfw:commentRss>
		<slash:comments>29</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #93 Solution: Auto Variables, Part 2</title>
		<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/</link>
				<comments>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comments</comments>
				<pubDate>Fri, 14 Jun 2013 00:10:19 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2145</guid>
				<description><![CDATA[Why prefer declaring variables using auto? Let us count some of the reasons why… Problem JG Question 1. In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using auto variable declarations fix, and why or why not? // (a) void traverser( const vector&#60;int&#62;&#38; [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Why prefer declaring variables using auto? Let us count some of the reasons why…<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?</p>
<pre><code>// (a)
void traverser( const vector&lt;int&gt;&amp; v ) {
    for( vector&lt;int&gt;::iterator i = begin(v); i != end(v); i += 2 )
        // ...
}

// (b)
vector&lt;int&gt; v1(5);
vector&lt;int&gt; v2 = 5;

// (c)
gadget get_gadget();
// ...
widget w = get_gadget();

// (d)
function&lt;void(vector&lt;int&gt;)&gt; get_size
    = [](const vector&lt;int&gt;&amp; x) { return x.size(); };
</code></pre>
<h2>Guru Question</h2>
<p>2. Same question, subtler examples: In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?</p>
<pre><code>// (a)
widget w;

// (b)
vector&lt;string&gt; v;
int size = v.size();

// (c) x and y are of some built-in integral type
int total = x + y;

// (d) x and y are of some built-in integral type
int diff = x - y;
if(diff &lt; 0) { /*...*/ }

// (e)
int i = f(1,2,3) * 42.0;
</code></pre>
<h1>Solution</h1>
<p>As you worked through these cases, perhaps you noticed a pattern: The cases are mostly very different, but what they have in common is that they illustrate reason after reason motivating why (and how) to use <span style="color:#2e74b5;">auto</span> to declare variables. Let&#8217;s dig in and see.</p>
<h2>1. In the following code, what actual or potential pitfalls exist, which would using auto variable declarations fix, and why or why not?</h2>
<h3>(a) will not compile</h3>
<pre><code>// (a)
void traverser( const vector&lt;int&gt;&amp; v ) {
    for( vector&lt;int&gt;::iterator i = begin(v); i != end(v); i += 2 )
        // ...
}
</code></pre>
<p>With (a), the most important pitfall is that the code doesn&#8217;t compile. Because <span style="color:#2e74b5;">v</span> is <span style="color:#2e74b5;">const</span>, you need a <span style="color:#2e74b5;">const_iterator</span>. The old-school way to fix this is to write <span style="color:#2e74b5;">const_iterator</span>:</p>
<pre><code>vector&lt;int&gt;::const_iterator i = begin(v)     // ok + requires thinking
</code></pre>
<p>However, that requires thinking to remember, &#8220;ah, <span style="color:#2e74b5;">v</span> is a reference to <span style="color:#2e74b5;">const</span>, I better remember to write <span style="color:#2e74b5;">const_</span> in front of its iterator type… and take it off again if I ever change <span style="color:#2e74b5;">v</span> to be a reference to non-<span style="color:#2e74b5;">const</span>… and also change the &#8220;<span style="color:#2e74b5;">vector</span>&#8221; part of <span style="color:#2e74b5;">i</span>&#8216;s type if <span style="color:#2e74b5;">v</span> is some other container type…&#8221;</p>
<p>Not that thinking is a bad thing, mind you, but this is really just a tax on your time when the simplest and clearest thing to write is <span style="color:#2e74b5;">auto</span>:</p>
<pre><code><span style="background-color:yellow;">auto</span> i = begin(v)                           // ok, best
</code></pre>
<p>Using <span style="color:#2e74b5;">auto</span> is not only correct and clear and simpler, but it stays correct if we change the type of the parameter to be non-<span style="color:#2e74b5;">const</span> or pass some other type of container, such as if we make <span style="color:#2e74b5;">traverser</span> into a template in the future.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto x = expr;</strong> when you don&#8217;t need to explicitly commit to a type. It is simpler, guarantees that you will use the correct type, and guarantees that the type stays correct under maintenance.</p></blockquote>
<p>Although our focus is on the variable declaration, there&#8217;s another independent bug in the code: The <span style="color:#2e74b5;">+= 2</span> increment can zoom you off the end of the container. When writing a strided loop, check your iterator increment against end on each increment (best to write it once as a <span style="color:#2e74b5;">checked_next(i,end)</span> helper that does it for you), or use an indexed loop something like <span style="color:#2e74b5;">for( auto i = 0L; i &lt; v.size(); i += 2 )</span> which is more natural to write correctly.</p>
<h3>(b) and (c) rely on implicit conversions</h3>
<pre><code>// (b)
vector&lt;int&gt; v1(5);     // 1
vector&lt;int&gt; v2 = 5;    // 2
</code></pre>
<p>Line 1 performs an explicit conversion and so can call <span style="color:#2e74b5;">vector</span>&#8216;s <span style="color:#2e74b5;">explicit</span> constructor that takes an initial size.</p>
<p>Line 2 doesn&#8217;t compile because its syntax won&#8217;t call an <span style="color:#2e74b5;">explicit</span> constructor. As we saw in GotW #1, it really means &#8220;convert <span style="color:#2e74b5;">5</span> to a temporary <span style="color:#2e74b5;">vector&lt;int&gt;</span>, then move-construct <span style="color:#2e74b5;">v2</span> from that,&#8221; so line 2 only works for types where the conversion is not <span style="color:#2e74b5;">explicit</span>.</p>
<p>Some people view the asymmetry between 1 and 2 as a pitfall, at least conceptually, for several reasons: First, the syntaxes are not quite the same and so learning when to use each can seem like finicky detail. Second, some people like line 2&#8217;s syntax better but have to switch to line 1 to get access to <span style="color:#2e74b5;">explicit</span> constructors. Finally, with this syntax, it&#8217;s easy to forget the <span style="color:#2e74b5;">(5)</span> or <span style="color:#2e74b5;">= 5</span> initializer, and then we&#8217;re into case 2(a), which we&#8217;ll get to in a moment.</p>
<p>If we use <span style="color:#2e74b5;">auto</span>, we have a single syntax that is always obviously explicit:</p>
<pre><code><span style="background-color:yellow;">auto</span> v2 = vector&lt;int&gt;(5);
</code></pre>
<p>Next, case (c) is similar to (b):</p>
<pre><code>// (c)
gadget get_gadget();
// ...
widget w = get_gadget();
</code></pre>
<p>This works, assuming that <span style="color:#2e74b5;">gadget</span> is implicitly convertible to <span style="color:#2e74b5;">widget</span>, but creates a temporary object. That&#8217;s a potential performance pitfall, as the creation of the temporary object is not at all obvious from reading the call site alone in a code review. If we can use a <span style="color:#2e74b5;">gadget</span> just as well as a <span style="color:#2e74b5;">widget</span> in this calling code and so don&#8217;t explicitly need to commit to the <span style="color:#2e74b5;">widget</span> type, we could write the following which guarantees there is no implicit conversion because <span style="color:#2e74b5;">auto</span> always deduces the basic type exactly:</p>
<pre><code>// better, if you don't need an explicit type
<span style="background-color:yellow;">auto</span> w = get_gadget();
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto x = expr;</strong> when you don&#8217;t need to explicitly commit to a type. It is efficient by default and guarantees that no implicit conversions or temporary objects will occur.</p></blockquote>
<p>By the way, if you&#8217;ve been wondering whether that &#8220;<span style="color:#2e74b5;">=</span>&#8221; in <span style="color:#2e74b5;">auto x = expr;</span> causes a temporary object plus a move or copy, wonder no longer: No, it constructs <span style="color:#2e74b5;">x</span> directly. (See GotW #1.)</p>
<p>Now, what if we said <span style="color:#2e74b5;">widget</span> here because we know about the conversion and really do want to deal with a <span style="color:#2e74b5;">widget</span>? Then writing <span style="color:#2e74b5;">auto</span> is still more self-documenting:</p>
<pre><code>// better, if you do need to commit to an explicit type
<span style="background-color:yellow;">auto</span> w = <span style="background-color:yellow;">widget</span>{ get_gadget() };
</code></pre>
<blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion.</p></blockquote>
<p>Note that this last version technically requires a move operation, but compilers are explicitly allowed to elide that and construct <span style="color:#2e74b5;">w</span> directly—and compilers routinely do that, so there is no performance penalty in practice.</p>
<h3>(d) creates an indirection, and commits to a single type</h3>
<pre><code>// (d)
function&lt;void(vector&lt;int&gt;)&gt; get_size
    = [](const vector&lt;int&gt;&amp; x) { return x.size(); };
</code></pre>
<p>Case (d) has two problems, and <span style="color:#2e74b5;">auto</span> can help with both of them. (Bonus points if you noticed that a form of &#8220;auto&#8221; is actually already helping in a third way.)</p>
<p>First, the lambda object is converted to a <span style="color:#2e74b5;">function&lt;&gt;</span>. That can be appropriate when passing or returning the lambda to a function, but it costs an indirection because <span style="color:#2e74b5;">function&lt;&gt;</span> has to erase the actual type and create a wrapper around its target to hold it and invoke it. In this case, we appear to be using the lambda locally, and so the correct default way to capture it is using <span style="color:#2e74b5;">auto</span>, which binds to the exact (compiler-generated and otherwise-unutterable-by-you) type of the lambda and so doesn&#8217;t incur an indirection:</p>
<pre><code>// partly improved
<span style="background-color:yellow;">auto</span> get_size = [](const vector&lt;int&gt;&amp; x) { return x.size(); };
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to use <strong>auto name = </strong>to name a lambda function object. Use <strong>std::function&lt;/*…*/&gt; name =</strong> only when you need to rebind it to another target or pass it to another function that needs a <strong>std::function&lt;&gt;</strong>.</p></blockquote>
<p>Second, the lambda commits to a specific argument type—it only works with <span style="color:#2e74b5;">vector&lt;int&gt;</span>, and not with <span style="color:#2e74b5;">vector&lt;double&gt;</span> or <span style="color:#2e74b5;">set&lt;string&gt;</span> or anything else that is also able to report a <span style="color:#2e74b5;">.size()</span>. The way to fix that is to write another <span style="color:#2e74b5;">auto</span>:</p>
<pre><code>// best
<span style="background-color:yellow;">auto</span> get_size = [](const <span style="background-color:yellow;">auto</span>&amp; x) { return x.size(); };

// yes, you could use this "too cute" variation for slightly less typing
//              [](auto&amp;&amp; x) { return x.size(); };
// but you'll also get less const-enforcement and that isn't a good deal
</code></pre>
<p>This still creates just a single object, but with a templated function call operator so that it can be invoked with different types of arguments, and so will work with any type of container that supports calling <span style="color:#2e74b5;">.size()</span>…</p>
<blockquote><p><strong>Guideline:</strong> Prefer to use <strong>auto</strong> lambda parameter types. They are just as efficient as explicit parameter types, and allow you to call the same lambda with different argument types.</p></blockquote>
<p>… and did you notice the &#8220;third auto&#8221; that was there all along? Even in the original example, we&#8217;ve been implicitly using automatic type deduction in a third place by allowing the lambda to deduce its return type, and so now with the fully generic &#8220;best&#8221; version of the code that return type will always be exactly whatever <span style="color:#2e74b5;">.size()</span> returns for whatever kind of object we&#8217;re calling <span style="color:#2e74b5;">.size()</span> on, which can be different for different argument types. All in all, that&#8217;s pretty nifty.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to use implicit return type deduction for lambda functions.</p></blockquote>
<h2>2. Same question, subtler examples: In the following code, what actual or potential pitfalls exist, which would using auto variable declarations fix, and why or why not?</h2>
<h3>(a) might leave the variable uninitialized.</h3>
<pre><code>// (a)
widget w;
</code></pre>
<p>This creates an object of type <span style="color:#2e74b5;">widget</span>. However, we can&#8217;t tell just looking at this line whether it&#8217;s initialized or contains garbage values. As noted in GotW #1, if <span style="color:#2e74b5;">widget</span> is a built-in type or aggregate type, its members won&#8217;t get initialized. Uninitialized variables should be avoided by default, and only used deliberately in cases where you really want to start with an uninitialized memory region for performance reasons—notably when you have a large object, such as an array, that is expensive to zero-initialize and is immediately going to be overwritten anyway, such as if it&#8217;s being used as an &#8220;out&#8221; parameter.</p>
<blockquote><p><strong>Guideline:</strong> Always initialize variables, except only when you can prove garbage values are okay, typically because you will immediately overwrite the contents.</p></blockquote>
<p>Would <span style="color:#2e74b5;">auto</span> help here? Indeed it would:</p>
<pre><code><span style="background-color:yellow;">auto</span> w = widget{};    // guaranteed to be initialized
</code></pre>
<p>One of the key benefits of declaring a local variable using <span style="color:#2e74b5;">auto</span> is that the &#8220;<span style="color:#2e74b5;">=</span>&#8221; is required—there&#8217;s no way to declare the variable without setting an initial value. Further, this is explicit and clear just from reading the above variable declaration on its own during a code review, without having to go inquire in the type&#8217;s header about the exact details of the type and poll the neighborhood for character references who will swear it&#8217;s not now, and is even under maintenance never likely to become, an aggregate.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto</strong>. It guarantees that you cannot accidentally leave the variable uninitialized.</p></blockquote>
<h3>(b) might perform a silent narrowing conversion.</h3>
<pre><code>// (b)
vector&lt;string&gt; v;
int size = v.size();
</code></pre>
<p>This will compile, run, and sometimes lose information because it uses an implicit narrowing conversion. Not the safest route to a happy weekend when the bug report from the field comes in on Friday night—normally from a large and important customer, because the bug will be exercised only with larger data sizes.</p>
<p>Here&#8217;s why: The return type of <span style="color:#2e74b5;">vector&lt;string&gt;::size()</span> is <span style="color:#2e74b5;">vector&lt;string&gt;::size_type</span>, but what&#8217;s that? It depends on your implementation, because the standard leaves it implementation-defined. But one thing I guarantee you is that &#8220;it ain&#8217;t no <span style="color:#2e74b5;">int</span>&#8220;—for at least two reasons, which lead to at least two ways this can lose information by silent narrowing:</p>
<ul>
<li><em>Sign:</em><br />
<span style="color:#2e74b5;">size_type</span> is required to be an unsigned integer value, so this code is asking to convert it to a signed value. That&#8217;s bad enough even if <span style="color:#2e74b5;">sizeof(size_type) == sizeof(int)</span> and it throws away the high bit—and with it the upper half of the representable values—to make room for the sign bit. It&#8217;s worse than that if <span style="color:#2e74b5;">sizeof(size_type) &gt; sizeof(int)</span>, which brings us to the second problem, because that&#8217;s actually likely…</li>
<li><em>Size:</em><br />
<span style="color:#2e74b5;">size_type</span> basically needs to be the same size as a pointer, since it may have to represent any offset in a <span style="color:#2e74b5;">vector&lt;char&gt;</span> that is larger than half the machine&#8217;s address space. In 64-bit code, 64-bit pointers mean 64-bit <span style="color:#2e74b5;">size_type</span>s. However, if on the same system an <span style="color:#2e74b5;">int</span> is still 32 bits for compatibility (and this is common), then <span style="color:#2e74b5;">size_type</span> is bigger than <span style="color:#2e74b5;">int</span>, and converting to <span style="color:#2e74b5;">int</span> throws away not just the high-order bit, but over half of the bits and the vast majority of the representable values.</li>
</ul>
<p>Of course, you won&#8217;t notice on small <span style="color:#2e74b5;">vector</span>s as long as <span style="color:#2e74b5;">.size()</span> &lt; 2<sup>(CHAR_BITS*sizeof(int)-1)</sup>. That doesn&#8217;t mean it&#8217;s not a bug; it just means it&#8217;s a latent bug.</p>
<p>Does <span style="color:#2e74b5;">auto</span> help? Yes indeed:</p>
<pre><code><span style="background-color:yellow;">auto</span> size = v.size();    // exact type, guaranteed no narrowing
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto</strong>. It guarantees that you get the exact type and cannot accidentally get narrowing conversions.</p></blockquote>
<h3>(c), (d), and (e) have potential narrowing and signedness issues.</h3>
<pre><code>// (c) x and y are of some built-in integral type
int total = x + y;
</code></pre>
<p>In case (c), we might also have a narrowing conversion. The simplest way to see this is that if either <span style="color:#2e74b5;">x</span> or <span style="color:#2e74b5;">y</span> is larger than <span style="color:#2e74b5;">int</span>, which is what we&#8217;re trying to store the result into, then we&#8217;ve definitely got a silent narrowing conversion here, with the same issues as already described in (b). And even if <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> are <span style="color:#2e74b5;">int</span>s today, if under maintenance the type of one later changes to something like <span style="color:#2e74b5;">long</span> or <span style="color:#2e74b5;">size_t</span>, the code silently becomes lossy—and possibly only on some platforms, if it changes to <span style="color:#2e74b5;">long</span> and that&#8217;s the same size as <span style="color:#2e74b5;">int</span> on some platforms you target but larger than <span style="color:#2e74b5;">int</span> on others.</p>
<p>Note that, even if you know the exact types of <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span>, you will get different types for <span style="color:#2e74b5;">x+y</span> on different platforms, particularly if one is signed and one is unsigned. If both <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> are signed, or both are unsigned, and one&#8217;s type has more bits than the other, that&#8217;s the type of the result. If one is signed and the other is unsigned then other rules kick in, and the size and signedness of the result can vary on different platforms depending on the relative actual sizes and the signedness of <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> on that platform. (This is one of the consequences of C and C++ not standardizing the sizes of the built-in types; for example, we know a <span style="color:#2e74b5;">long</span> is guaranteed to be at least as big as an <span style="color:#2e74b5;">int</span>, but we don&#8217;t know how many bits each is, and the answer varies by compiler and platform.)</p>
<p>Does <span style="color:#2e74b5;">auto</span> help here? Almost always &#8220;yes,&#8221; but in one case &#8220;yes with a little help you really want to reach for anyway.&#8221;</p>
<p>By default, write for correctness, clarity, and portability first: To avoid lossy narrowing conversions, <span style="color:#2e74b5;">auto</span> is your portability pal and you should use it by default. Writing <span style="color:#2e74b5;">auto</span> is much better than writing it out by hand as <span style="color:#2e74b5;">std::common_type&lt; decltype(x), decltype(y) &gt;</span>.</p>
<pre><code><span style="background-color:yellow;">auto</span> total = x + y;    // exact type, guaranteed no narrowing
</code></pre>
<blockquote><p><strong>Guideline:</strong> Prefer to declare local variables using <strong>auto</strong>. It guarantees that you get the exact type and so is the simplest way to portably spell the implementation-specific type of arithmetic operations on built-in types, which vary by platform, and ensure that you cannot accidentally get narrowing conversions when storing the result.</p></blockquote>
<p>However, what if in rare cases this code may be in a tight loop where performance matters, and <span style="color:#2e74b5;">auto</span> may select a wider type than you know you need to store all possible values? For example, in some cases performing arithmetic using <span style="color:#2e74b5;">uint64_t</span> instead of <span style="color:#2e74b5;">uint32_t</span> could be twice as slow. If you first prove that this actually matters using hard profiler data, and then further prove by performing other validation that you won&#8217;t (or won&#8217;t care if you do) encounter results that would lose value by narrowing, then go ahead and commit to an explicit type—but prefer to do it using the following style:</p>
<pre><code>// rare cases: use auto + &lt;cstdint&gt; type
<span style="background-color:yellow;">auto</span> total = <span style="background-color:yellow;">uint_fast64_t</span>{ x+y };  // total is an unsigned 64-bit value
             // ^ see note [1]

// or use auto + size-preserving signed/unsigned helper [2]
<span style="background-color:yellow;">auto</span> total = <span style="background-color:yellow;">as_unsigned</span>( x+y );    // total is unsigned and size of x+y
</code></pre>
<ul>
<li>Still use <span style="color:#2e74b5;">auto</span> to naturally make this more self-documenting and make the code review easy, because <span style="color:#2e74b5;">auto</span> syntax makes it explicit that you&#8217;re performing a conversion.</li>
<li>
<div>Use a portable sized type name from the standard <span style="color:#2e74b5;">&lt;cstdint&gt;</span> header, because you almost certainly care about size and this makes the size portable.[1]</div>
<blockquote><p><strong>Guideline:</strong> Prefer using the <strong>&lt;cstdint&gt;</strong> type aliases in code that cares about the size of your numeric variables. Avoid relying on what your current platform(s) happen to do.</p></blockquote>
<blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, and won&#8217;t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use <strong>( )</strong> instead of <strong>{ }</strong>.</p></blockquote>
</li>
</ul>
<p>Case (d) is similar:</p>
<pre><code>// (d) x and y are of some built-in integral type
int diff = x - y;
if(diff &lt; 0) { /*...*/ }
</code></pre>
<p>This time, we&#8217;re doing a subtraction. No matter whether <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span> are signed or not, putting the answer in a signed variable like this is the right thing to do—the result could be negative, after all.</p>
<p>However, we have two issues. The first, again, is that <span style="color:#2e74b5;">int</span> may not be big enough to avoid truncating the result, so we might lose information if <span style="color:#2e74b5;">x &#8211; y</span> produces something larger than an <span style="color:#2e74b5;">int</span>. Using <span style="color:#2e74b5;">auto</span> can help with that.</p>
<p>The second is that <span style="color:#2e74b5;">x &#8211; y</span> might give a strange answer, which isn&#8217;t the programmer&#8217;s fault but is something you want to remember about arithmetic in C and C++. Consider this code:</p>
<pre><code>unsigned long x    = 42;
signed short  y    = 43;
<span style="color:#c00000;">auto          diff = x - y;   // one actual result: 18446744073709551615
if(diff &lt; 0) { /*...*/ }      // um, oops – branch won't be taken
</span></code></pre>
<p>&#8220;Wait, what?&#8221; you ask. On nearly all platforms, an <span style="color:#2e74b5;">unsigned long</span> is bigger than a <span style="color:#2e74b5;">signed short</span>, and because of the promotion rules the type of <span style="color:#2e74b5;">s &#8211; u</span>, and therefore of <span style="color:#2e74b5;">result</span>, will be… <span style="color:#2e74b5;">unsigned long</span>. Which is, well, not very signed. So depending on the types of <span style="color:#2e74b5;">x</span> and <span style="color:#2e74b5;">y</span>, and depending on your actual platform, it may be that the branch won&#8217;t be taken, which clearly isn&#8217;t the same as the original code.</p>
<blockquote><p><strong>Guideline:</strong> Combine signed and unsigned arithmetic carefully.</p></blockquote>
<p>Before you say, &#8220;then I always want signed!&#8221; remember that if you overflow then unsigned arithmetic wraps, which can be valid for your use, whereas signed arithmetic has undefined behavior, which is quite unlikely to be useful. Sometimes you really need signed, and sometimes you really need unsigned, even though often you won&#8217;t care.</p>
<p>From observing <span style="color:#2e74b5;">auto</span>&#8216;s effect in case (d), it might seem like <span style="color:#2e74b5;">auto</span> has helped one problem… but was it at the expense of creating another?</p>
<p>Yes, on the one hand, <span style="color:#2e74b5;">auto</span> did indeed help us: Using <span style="color:#2e74b5;">auto</span> ensured we could write portable and correct code where the result wasn&#8217;t needlessly narrowed. If we didn&#8217;t care about signedness, which is often true, that&#8217;s quite sufficient.</p>
<p>On the other hand, using <span style="color:#2e74b5;">auto</span> might not preserve signedness in a computation like <span style="color:#2e74b5;">x &#8211; y</span> that&#8217;s supposed to return something with a sign, or it might not preserve unsignedness when that&#8217;s desirable. But this isn&#8217;t so much an issue with <span style="color:#2e74b5;">auto</span> itself as that we have to be careful when combining signed and unsigned arithmetic, and by binding to an exact type <span style="color:#2e74b5;">auto</span> is exposing this issue with some code that might potentially be already nonportable, or have corner cases the developer wasn&#8217;t aware of when he wrote it.</p>
<p>So what&#8217;s a good answer? Consider using <span style="color:#2e74b5;">auto</span> together with the <span style="color:#2e74b5;">as_signed</span> or <span style="color:#2e74b5;">as_unsigned</span> conversion helper we saw before, which is used in lieu of a cast to a specific type; the helper is written out more fully in the endnotes. [2] Then we get the best of both worlds—we don&#8217;t commit to an explicit type, but we ensure the basic size and signedness in portable code that will work as intended on many different compilers and platforms.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to use <strong>auto x = as_signed(integer_expr);</strong> or <strong>auto x = as_unsigned(integer_expr);</strong> to store the result of an integer computation that should be signed or unsigned. Using <strong>auto</strong> together with <strong>as_signed</strong> or <strong>as_unsigned</strong> makes code more portable: the variable will both be large enough and preserve the required signedness on all platforms. (Signed/unsigned conversions within <strong>integer_expr</strong> may still occur.)</p></blockquote>
<p>Finally, case (e) brings floating point into the picture:</p>
<pre><code>// (e)
int i = f(1,2,3) * 42.0;
</code></pre>
<p>Here we have our by-now-yawnworthy-typical narrowing—and an easy case because it isn&#8217;t even hiding, it&#8217;s saying <span style="color:#2e74b5;">int</span> and <span style="color:#2e74b5;">42.0</span> right there in the same breath, which is narrowing almost regardless of what type <span style="color:#2e74b5;">f</span> returns.</p>
<p>Does <span style="color:#2e74b5;">auto</span> help? Yes, in making our code self-documenting and more reviewable, as we noted before. If we follow the <span style="color:#2e74b5;">auto x = type{expr};</span> declaration style, we would be (happily) forced to write the conversion explicitly, and when we initially use <span style="color:#2e74b5;">{ }</span> we get an error that in fact it&#8217;s a narrowing conversion, which we acknowledge (again explicitly) by switching to <span style="color:#2e74b5;">( )</span>:</p>
<pre><code><span style="background-color:yellow;">auto</span> i = int( f(1,2,3) * 42.0 );
</code></pre>
<p>This code is now free of implicit conversions, including implicit narrowing conversions. If our team&#8217;s coding style says to use <span style="color:#2e74b5;">auto x = expr;</span> or <span style="color:#2e74b5;">auto x = type{expr};</span> wherever possible, then in a code review just seeing the <span style="color:#2e74b5;">( )</span> parens can immediately connote explicit narrowing; adding a comment doesn&#8217;t hurt either.</p>
<p>But for floating point calculations, can using <span style="color:#2e74b5;">auto</span> by itself hurt? Consider this example, contributed by Andrei Alexandrescu:</p>
<pre><code>float f1 = /*...*/, f2 = /*...*/;

<span style="background-color:yellow;">auto</span>   f3 = f1 + f2;   // correct, but on some compilers/platforms...
<span style="background-color:yellow;">double</span> f4 = f1 + f2;   // ... this might keep more bits of precision
</code></pre>
<p>As Alexandrescu notes: &#8220;Machines are free to do intermediate calculations in a larger precision than the target, and in many cases (and traditionally in C) calculations are done in double precision. So for <span style="color:#2e74b5;">f3</span> we have a sum done in double precision, which is then <em>truncated</em> down to <span style="color:#2e74b5;">float</span>. For <span style="color:#2e74b5;">f4</span>, the sum is preserved at full precision.&#8221;</p>
<p>Does this mean using <span style="color:#2e74b5;">auto</span> creates a potential flaw here? Not really. In the language, the type of <span style="color:#2e74b5;">f1 + f2</span> is still <span style="color:#2e74b5;">float</span>, and the naked <span style="color:#2e74b5;">auto</span> maintains that exact type for us. However, if we do want to follow the pattern of switching to <span style="color:#2e74b5;">double</span> early in a complex computation, we can and should say so:</p>
<pre><code>float f1 = /*...*/, f2 = /*...*/;

<span style="background-color:yellow;">auto</span> f5 = <span style="background-color:yellow;">double</span>{f1} + f2;
</code></pre>
<h2>Summary</h2>
<p>We&#8217;ve seen a number of reasons to prefer to declare variables using <span style="color:#2e74b5;">auto</span>, optionally with an explicit type if you do want to commit to a specific type.</p>
<p>If you&#8217;re observed a pattern in this GotW&#8217;s Guidelines, you&#8217;ll already have a sense of what&#8217;s coming in GotW #94… a Special Edition on, you guessed it, <span style="color:#2e74b5;">auto</span> style.</p>
<h2>Notes</h2>
<p>[1] Another reason to prefer using the <span style="color:#2e74b5;">&lt;cstdint&gt;</span> typedef names is because, due to a quirk in the C++ language grammar, only a single-word type is allowed where <span style="color:#2e74b5;">uint64_t</span> appears in this example. That&#8217;s fine nearly always because it&#8217;s all you need for class types and all <span style="color:#2e74b5;">typedef</span> and <span style="color:#2e74b5;">using</span> alias names and most built-in types, but you can&#8217;t directly name arrays or the multi-word built-in types like <span style="color:#2e74b5;">unsigned int</span> or <span style="color:#2e74b5;">long long</span> in that position; for the latter, use the <span style="color:#2e74b5;">uintNN_t</span>-style typedef names instead. The exact ones, such as <span style="color:#2e74b5;">uint64_t</span>, are &#8220;optional&#8221; in the standard, but they are in the standard and expected to be widely implemented so I used them. The &#8220;least&#8221; and &#8220;fast&#8221; ones are required, so if you don&#8217;t have <span style="color:#2e74b5;">uint64_t</span> you can use <span style="color:#2e74b5;">uint_least64_t</span> or <span style="color:#2e74b5;">uint_fast64_t</span>.</p>
<p>[2] The helpers preserve the size of the type while changing only the signedness. Thanks to Andrei Alexandrescu for this basic idea; any errors are mine, not his. The C++98 way is to provide a set of overloads for each type, but a modern version might look something like the following which uses the C++11 <span style="color:#2e74b5;">std::make_signed</span>/<span style="color:#2e74b5;">make_unsigned</span> facilities.</p>
<pre><code>// C++11 version
//
template&lt;class T&gt;
typename make_signed&lt;T&gt;::type as_signed(T t)
    { return make_signed&lt;T&gt;::type(t); }

template&lt;class T&gt;
typename make_unsigned&lt;T&gt;::type as_unsigned(T t)
    { return make_unsigned&lt;T&gt;::type(t); }
</code></pre>
<p>Note that with C++14 this gets even sweeter, using <span style="color:#2e74b5;">auto</span> return type deduction to eliminate <span style="color:#2e74b5;">typename</span> and repetition, and the <span style="color:#2e74b5;">_t</span> alias to replace <span style="color:#2e74b5;">::type</span>:</p>
<pre><code>// C++14 version, option 1
//
template&lt;class T&gt; auto as_signed  (T t){ return make_signed_t  &lt;T&gt;(t); }
template&lt;class T&gt; auto as_unsigned(T t){ return make_unsigned_t&lt;T&gt;(t); }
</code></pre>
<p>or you can equivalently write these function templates as named lambdas:</p>
<pre><code>// C++14 version, option 2
//
auto as_signed   =[](auto x){ return make_signed_t  &lt;decltype(x)&gt;(x); };
auto as_unsigned =[](auto x){ return make_unsigned_t&lt;decltype(x)&gt;(x); };
</code></pre>
<p>Sweet, isn&#8217;t it? Once you have a compiler that supports these features, pick whichever suits your fancy.</p>
<h2>Acknowledgments</h2>
<p>Thanks in particular to Scott Meyers and Andrei Alexandrescu for their time and insights in reviewing and discussing drafts of this material. Thanks also to the following for their feedback to improve this article: mttpd, Jim Park, Yuri Khan, Arne, rhalbersma, Tom, Martin Ba, John, Frederic Dumont, Sebastian.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/feed/</wfw:commentRss>
		<slash:comments>42</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #93: Auto Variables, Part 2</title>
		<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/</link>
				<comments>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comments</comments>
				<pubDate>Fri, 07 Jun 2013 14:06:54 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2119</guid>
				<description><![CDATA[Why prefer declaring variables using auto? Let us count some of the reasons why…   Problem JG Question 1. In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using auto variable declarations fix, and why or why not? // (a)void traverser( const vector&#60;int&#62;&#38; [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Why prefer declaring variables using auto? Let us count some of the reasons why…<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// (a)<br />void traverser( const vector&lt;int&gt;&amp; v ) {<br />    for( vector&lt;int&gt;::iterator i = begin(v); i != end(v); i += 2 )<br />        // ...<br />}<br /><br />// (b)<br />vector&lt;int&gt; v1(5);<br />vector&lt;int&gt; v2 = 5;<br /><br />// (c)<br />gadget get_gadget();<br />// ...<br />widget w = get_gadget();<br /><br />// (d)<br />function&lt;void(vector&lt;int&gt;)&gt; get_size<br />    = [](vector&lt;int&gt; x) { return x.size(); };
</code></pre>
</p>
<h2>Guru Question<br />
</h2>
<p>2. Same question, subtler examples: In the following code, what actual or potential pitfalls exist in each labeled piece of code? Which of these pitfalls would using <span style="color:#2e74b5;">auto</span> variable declarations fix, and why or why not?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// (a)<br />widget w;<br /><br />// (b)<br />vector&lt;string&gt; v;<br />int size = v.size();<br /><br />// (c) x and y are of some built-in integral type<br />int total = x + y;<br /><br />// (d) x and y are of some built-in integral type<br />int diff = x - y;<br />if(diff &lt; 0) { /*...*/ }<br /><br />// (e)<br />int i = f(1,2,3) * 42.0;
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #92 Solution: Auto Variables, Part 1</title>
		<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/</link>
				<comments>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comments</comments>
				<pubDate>Fri, 07 Jun 2013 13:34:05 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2109</guid>
				<description><![CDATA[What does auto do on variable declarations, exactly? And how should we think about auto? In this GotW, we&#8217;ll start taking a look at C++&#8217;s oldest new feature.   Problem JG Questions 1. What is the oldest C++11 feature? Explain. 2. What does auto mean when declaring a local variable? Guru Questions 3. In the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>What does auto do on variable declarations, exactly? And how should we think about auto? In this GotW, we&#8217;ll start taking a look at C++&#8217;s oldest new feature.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is the oldest C++11 feature? Explain.
</p>
<p>2. What does <span style="color:#2e74b5;">auto</span> mean when declaring a local variable?
</p>
<h2>Guru Questions<br />
</h2>
<p>3. In the following code, what is the type of variables <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">k</span>, and why? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int         val = 0;<br />auto        a   = val;<br />auto&amp;       b   = val;<br />const auto  c   = val;<br />const auto&amp; d   = val;<br /><br />int&amp;        ir  = val;<br />auto        e   = ir;<br /><br />int*        ip  = &amp;val; <br />auto        f   = ip;<br /><br />const int   ci  = val;<br />auto        g   = ci;<br /><br />const int&amp;  cir = val;<br />auto        h   = cir;<br /><br />const int*  cip = &amp;val;<br />auto        i   = cip;<br /><br />int* const  ipc = &amp;val;<br />auto        j   = ipc;<br /><br />const int* const cipc = &amp;val;<br />auto             k    = cipc;
</code></pre>
</p>
<p>4. In the following code, what type does <span style="color:#2e74b5;">auto</span> deduce for variables <span style="color:#2e74b5;">a</span> and <span style="color:#2e74b5;">b</span>, and why? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int val = 0;<br /><br />auto a { val };<br />auto b = { val };
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What is the oldest C++11 feature? Explain.<br />
</h2>
<p><span style="color:#2e74b5;">auto x = something;</span> to declare a new local variable whose type is deduced from <span style="color:#2e74b5;">something</span>, and isn&#8217;t just always <span style="color:#2e74b5;">int</span>.
</p>
<p>Bjarne Stroustrup likes to point out that <span style="color:#2e74b5;">auto</span> for deducing the type of local variables is the oldest feature added in the 2011 release of the C++ standard. He implemented it in C++ 28 years earlier, in 1983—which incidentally was the same year the language&#8217;s name was changed to C++ from C with Classes (the new name was unveiled publicly on January 1, 1984), and the same year Stroustrup added other fundamental features including <span style="color:#2e74b5;">const</span> (later adopted by C), <span style="color:#2e74b5;">virtual</span> functions, <span style="color:#2e74b5;">&amp;</span> references, and BCPL-style <span style="color:#2e74b5;">//</span> comments.
</p>
<p>Alas, Stroustrup was forced to remove <span style="color:#2e74b5;">auto</span> because of compatibility concerns with C&#8217;s then-existing implicit <span style="color:#2e74b5;">int</span> rule, which has since been abandoned in C. We&#8217;re glad <span style="color:#2e74b5;">auto</span> is now back and here to stay.
</p>
<h2>2. What does auto mean when declaring a local variable?<br />
</h2>
<p>It means to deduce the type from the expression used to initialize the new variable. In particular, <span style="color:#2e74b5;">auto</span> local variables deduction is exactly the same as type deduction for parameters of function templates—by specification, the rule for <span style="color:#2e74b5;">auto</span> variables says &#8220;do what function templates are required to do&#8221;—plus they can capture <span style="color:#2e74b5;">initializer_list</span> as a type. For example:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>template&lt;class T&gt; void f( T ) { }<br /><br />int val = 0;<br /><br />f( val );                // deduces T == int, calls f&lt;int&gt;( val )<br />auto x = val;            // deduces T == int, x is of type int
</code></pre>
</p>
<p>When you&#8217;re new to <span style="color:#2e74b5;">auto</span>, the key thing to remember is that you really are declaring your own new local variable. That is, &#8220;what&#8217;s on the left&#8221; is my new variable, and &#8220;what&#8217;s on the right&#8221; is just its initial value:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>auto my_new_variable = its_initial_value;
</code></pre>
</p>
<p>You want <em>your new variable</em> to be just like <em>some existing variable</em> or expression over there, and be initialized from it, but that only means that you want the same basic type, not necessarily that other variable&#8217;s own personal secondary attributes such as top-level <span style="color:#2e74b5;">const</span>&#8211; or <span style="color:#2e74b5;">volatile</span>-ness and <span style="color:#2e74b5;">&amp;</span>/<span style="color:#2e74b5;">&amp;&amp;</span> reference-ness which are per-variable. For example, just because he&#8217;s <span style="color:#2e74b5;">const</span> doesn&#8217;t mean you&#8217;re <span style="color:#2e74b5;">const</span>, and vice versa.
</p>
<p>It&#8217;s kind of like being identical twins: Andy may be genetically <em>just like</em> his brother Bobby and is part of the same family, but he&#8217;s not the same person; he&#8217;s a distinct person and can make his own choice of clothes and/or jewelry, go to be seen on the scene in different parts of town, and so forth. So your new variable will be <em>just like</em> that other one and be part of the same type family, but it&#8217;s not the same variable; it&#8217;s a distinct variable with its own choice of whether it wants to be dressed with <span style="color:#2e74b5;">const</span>, <span style="color:#2e74b5;">volatile</span>, and/or a <span style="color:#2e74b5;">&amp;</span> or <span style="color:#2e74b5;">&amp;&amp;</span> reference, may be visible to different threads, and so forth.
</p>
<p>Remembering this will let us easily answer the rest of our questions.
</p>
<h2>3. In the following code, what is the type of variables a through k, and why? Explain.<br />
</h2>
<p>Quick reminder: <span style="color:#2e74b5;">auto</span> means &#8220;take exactly the type on the right-hand side, but strip off top-level <span style="color:#2e74b5;">const</span>/<span style="color:#2e74b5;">volatile</span> and <span style="color:#2e74b5;">&amp;</span>/<span style="color:#2e74b5;">&amp;&amp;</span>.&#8221; Armed with that, these are mostly pretty easy.
</p>
<p>For simplicity, these examples use <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">&amp;</span>. The rules for adding or removing <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">volatile</span> are the same, and the rules for adding or removing <span style="color:#2e74b5;">&amp;</span> and <span style="color:#2e74b5;">&amp;&amp;</span> are the same.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int         val = 0;<br />auto        a   = val;<br />auto&amp;       b   = val;<br />const auto  c   = val;<br />const auto&amp; d   = val;
</code></pre>
</p>
<p>For <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">d</span>, the type is what you get from replacing <span style="color:#2e74b5;">auto</span> with <span style="color:#2e74b5;">int</span>: <span style="color:#2e74b5;">int</span>, <span style="color:#2e74b5;">int&amp;</span>, <span style="color:#2e74b5;">const int</span>, and <span style="color:#2e74b5;">const int&amp;</span>, respectively. The same ability to add <span style="color:#2e74b5;">const</span> applies to <span style="color:#2e74b5;">volatile</span>, and the same ability to add <span style="color:#2e74b5;">&amp;</span> applies to <span style="color:#2e74b5;">&amp;&amp;</span>. (Note that <span style="color:#2e74b5;">&amp;&amp;</span> will be what Scott Meyers calls a universal reference, just as with templates, and does in some cases bring across the <span style="color:#2e74b5;">const</span>-ness if it&#8217;s binding to something <span style="color:#2e74b5;">const</span>.)
</p>
<p>Now that we&#8217;ve exercised adding top-level <span style="color:#2e74b5;">const</span> (or <span style="color:#2e74b5;">volatile</span>) and <span style="color:#2e74b5;">&amp;</span> (or <span style="color:#2e74b5;">&amp;&amp;</span>) on the left, let&#8217;s consider how they&#8217;re removed on the right. Note that the left hand side of <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">d</span> can be used in any combination with the right hand side of <span style="color:#2e74b5;">e</span> through <span style="color:#2e74b5;">k</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int&amp;        ir  = val;<br />auto        e   = ir;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">e</span> is <span style="color:#2e74b5;">int</span>. Because <span style="color:#2e74b5;">ir</span> is a reference to <span style="color:#2e74b5;">val</span>, which makes <span style="color:#2e74b5;">ir</span> just another name for <span style="color:#2e74b5;">val</span>, it&#8217;s exactly the same as if we had written <span style="color:#2e74b5;">auto e = val;</span> here.
</p>
<p>Remember, just because <span style="color:#2e74b5;">ir</span> is a reference (another name for the existing variable <span style="color:#2e74b5;">val</span>) doesn&#8217;t have any bearing on whether we want <span style="color:#2e74b5;">e</span> to be a reference. If we wanted <span style="color:#2e74b5;">e</span> to be a reference, we would have said <span style="color:#2e74b5;">auto&amp;</span> as we did in case <span style="color:#2e74b5;">b</span> above, and it would have been a reference irrespective of whether <span style="color:#2e74b5;">ir</span> happened to be a reference or not.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int*        ip  = &amp;val; <br />auto        f   = ip;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">f</span> is <span style="color:#2e74b5;">int*</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int   ci  = val;<br />auto        g   = ci;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">g</span> is <span style="color:#2e74b5;">int</span>.
</p>
<p>Remember, just because <span style="color:#2e74b5;">ci</span> is <span style="color:#2e74b5;">const</span> (read-only) doesn&#8217;t have any bearing on whether we want <span style="color:#2e74b5;">g</span> to be <span style="color:#2e74b5;">const</span>. It&#8217;s a separate variable. If we wanted <span style="color:#2e74b5;">g</span> to be const, we would have said <span style="color:#2e74b5;">const auto</span> as we did in case <span style="color:#2e74b5;">c</span> above, and it would have been <span style="color:#2e74b5;">const</span> irrespective of whether <span style="color:#2e74b5;">ci</span> happened to be <span style="color:#2e74b5;">const</span> or not.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int&amp;  cir = val;<br />auto        h   = cir;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">h</span> is <span style="color:#2e74b5;">int</span>.
</p>
<p>Again, remember we just drop top-level <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">&amp;</span> to get the basic type. If we wanted <span style="color:#2e74b5;">h</span> to be <span style="color:#2e74b5;">const</span> and/or <span style="color:#2e74b5;">&amp;</span>, we could just add it as shown with <span style="color:#2e74b5;">b</span>, <span style="color:#2e74b5;">c</span>, and <span style="color:#2e74b5;">d</span> above.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int*  cip = &amp;val;<br />auto        i   = cip;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">i</span> is <span style="color:#2e74b5;">const int*</span>.
</p>
<p>Note that this isn&#8217;t a top-level <span style="color:#2e74b5;">const</span>, so we don&#8217;t drop it. We pronounce <span style="color:#2e74b5;">cip</span>&#8216;s declaration right to left: The type of <span style="color:#2e74b5;">cip</span> is &#8220;pointer to <span style="color:#2e74b5;">const int</span>,&#8221; not &#8220;<span style="color:#2e74b5;">const</span> pointer to <span style="color:#2e74b5;">int</span>.&#8221; What&#8217;s <span style="color:#2e74b5;">const</span> is not <span style="color:#2e74b5;">cip</span>, but rather <span style="color:#2e74b5;">*cip</span>, the <span style="color:#2e74b5;">int</span> it&#8217;s pointing to.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int* const  ipc = &amp;val;<br />auto        j   = ipc;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">j</span> is <span style="color:#2e74b5;">int*</span>. This <span style="color:#2e74b5;">const</span> is a top-level <span style="color:#2e74b5;">const</span>, and <span style="color:#2e74b5;">ipc</span>&#8216;s being <span style="color:#2e74b5;">const</span> is immaterial to whether we want <span style="color:#2e74b5;">j</span> to be <span style="color:#2e74b5;">const</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const int* const cipc = &amp;val;<br />auto             k    = cipc;
</code></pre>
</p>
<p>The type of <span style="color:#2e74b5;">k</span> is <span style="color:#2e74b5;">const int*</span>.
</p>
<h2>4. In the following code, what type does auto deduce for variables a and b, and why? Explain.<br />
</h2>
<p>As we noted in #2, the only place where an <span style="color:#2e74b5;">auto</span> variable deduces anything different from a template parameter is that <span style="color:#2e74b5;">auto</span> deduces an <span style="color:#2e74b5;">initializer_list</span>. This brings us to the final cases:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int val = 0;<br /><br />auto a { val };<br />auto b = { val };
</code></pre>
</p>
<p>The type of both <span style="color:#2e74b5;">a</span> and <span style="color:#2e74b5;">b</span> is <span style="color:#2e74b5;">std::initializer_list&lt;int&gt;</span>.
</p>
<p>That&#8217;s the only difference between <span style="color:#2e74b5;">auto</span> variable deduction and template parameter deduction—by specification, because auto deduction is defined in the standard as &#8220;follow those rules over there in the templates clause, plus deduce <span style="color:#2e74b5;">initializer_list</span>.&#8221;
</p>
<p>If you&#8217;re familiar with templates and curious how <span style="color:#2e74b5;">auto</span> deduction and template deduction map to each other, the table below lists the main cases and shows the equivalent syntax between the two features. For the left column, I&#8217;ll put the variable and the initialization on separate lines to emphasize how they correspond to the separated template parameter and call site on the right.
</p>
<p style="text-align:center;"><img src="https://herbsutter.files.wordpress.com/2013/06/061013_1727_gotw92solut1.png?w=500" alt="" />
	</p>
<p>Not only are the cases equivalent in expressive power, but you might even feel that some of the <span style="color:#2e74b5;">auto</span> versions feel even slicker to you than their template counterparts.
</p>
<h2>Summary<br />
</h2>
<p>Having <span style="color:#2e74b5;">auto</span> variables really brings a feature we already had (template deduction) to an even wider audience. But so far we&#8217;ve only seen what <span style="color:#2e74b5;">auto</span> does. The even more interesting question is how to use it. Which brings us to our next GotW…
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: davidphilliposter, Phil Barila, Ralph Tandetzky, Marcel Wild.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/feed/</wfw:commentRss>
		<slash:comments>19</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2013/06/061013_1727_gotw92solut1.png" medium="image" />
	</item>
		<item>
		<title>GotW #92: Auto Variables, Part 1</title>
		<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/</link>
				<comments>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comments</comments>
				<pubDate>Wed, 05 Jun 2013 14:56:44 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2100</guid>
				<description><![CDATA[What does auto do on variable declarations, exactly? And how should we think about auto? In this GotW, we&#8217;ll start taking a look at C++&#8217;s oldest new feature.   Problem JG Questions 1. What is the oldest C++11 feature? Explain. 2. What does auto mean when declaring a local variable? Guru Questions 3. In the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>What does auto do on variable declarations, exactly? And how should we think about auto? In this GotW, we&#8217;ll start taking a look at C++&#8217;s oldest new feature.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is the oldest C++11 feature? Explain.
</p>
<p>2. What does <span style="color:#2e74b5;">auto</span> mean when declaring a local variable?
</p>
<h2>Guru Questions<br />
</h2>
<p>3. In the following code, what is the type of variables <span style="color:#2e74b5;">a</span> through <span style="color:#2e74b5;">k</span>, and why? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int         val = 0;<br />auto        a   = val;<br />auto&amp;       b   = val;<br />const auto  c   = val;<br />const auto&amp; d   = val;<br /><br />int&amp;        ir  = val;<br />auto        e   = ir;<br /><br />int*        ip  = &amp;val; <br />auto        f   = ip;<br /><br />const int   ci  = val;<br />auto        g   = ci;<br /><br />const int&amp;  cir = val;<br />auto        h   = cir;<br /><br />const int*  cip = &amp;val;<br />auto        i   = cip;<br /><br />int* const  ipc = &amp;val;<br />auto        j   = ipc;<br /><br />const int* const cipc = &amp;val;<br />auto             k    = cipc;
</code></pre>
</p>
<p>4. In the following code, what type does <span style="color:#2e74b5;">auto</span> deduce for variables <span style="color:#2e74b5;">a</span> and <span style="color:#2e74b5;">b</span>, and why? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int val = 0;<br /><br />auto a { val };<br />auto b = { val };
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/feed/</wfw:commentRss>
		<slash:comments>22</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #91 Solution: Smart Pointer Parameters</title>
		<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/</link>
				<comments>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comments</comments>
				<pubDate>Wed, 05 Jun 2013 14:42:12 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2090</guid>
				<description><![CDATA[NOTE: Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #105. How should you prefer to pass smart pointers, and why? Problem JG [&#8230;]]]></description>
								<content:encoded><![CDATA[<blockquote><p><strong>NOTE:</strong> Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #105.</p></blockquote>
<p><span style="color:#5a5a5a;"><em>How should you prefer to pass smart pointers, and why?<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. What are the <em>performance</em> implications of the following function declaration? Explain.</p>
<pre><code>void f( shared_ptr&lt;widget&gt; );
</code></pre>
<h2>Guru Questions</h2>
<p>2. What are the <em>correctness</em> implications of the function declaration in #1? Explain with clear examples.</p>
<p>3. A colleague is writing a function <span style="color:#2e74b5;">f</span> that takes an existing object of type <span style="color:#2e74b5;">widget</span> as a required input-only parameter, and trying to decide among the following basic ways to take the parameter (omitting <span style="color:#2e74b5;">const</span>):</p>
<pre><code>void f( widget* );              (a)
void f( widget&amp; );              (b)
void f( unique_ptr&lt;widget&gt; );   (c)
void f( unique_ptr&lt;widget&gt;&amp; );  (d)
void f( shared_ptr&lt;widget&gt; );   (e)
void f( shared_ptr&lt;widget&gt;&amp; );  (f)
</code></pre>
<p>Under what circumstances is each appropriate? Explain your answer, including where <span style="color:#2e74b5;">const</span> should or should not be added anywhere in the parameter type.</p>
<p>(There are other ways to pass the parameter, but we will consider only the ones shown above.)</p>
<h1>Solution</h1>
<h2>1. What are the <em>performance</em> implications of the following function declaration? Explain.</h2>
<pre><code>void f( shared_ptr&lt;widget&gt; );
</code></pre>
<p>A <span style="color:#2e74b5;">shared_ptr</span> stores strong and weak reference counts (see GotW #89). When you pass by value, you have to copy the argument (usually) on entry to the function, and then destroy it (always) on function exit. Let&#8217;s dig into what this means.</p>
<p>When you enter the function, the <span style="color:#2e74b5;">shared_ptr</span> is copy-constructed, and this requires incrementing the strong reference count. (Yes, if the caller passes a temporary <span style="color:#2e74b5;">shared_ptr</span>, you <em>move</em>-construct and so don&#8217;t have to update the count. But: (a) it&#8217;s quite rare to get a temporary <span style="color:#2e74b5;">shared_ptr</span> in normal code, other than taking one function&#8217;s return value and immediately passing that to a second function; and (b) besides as we&#8217;ll see most of the expense is on the destruction of the parameter anyway.)</p>
<p>When exiting the function, the <span style="color:#2e74b5;">shared_ptr</span> is destroyed, and this requires decrementing its internal reference count.</p>
<p>What&#8217;s so bad about a &#8220;shared reference count increment and decrement?&#8221; Two things, one related to the &#8220;shared reference count&#8221; and one related to the &#8220;increment and decrement.&#8221; It&#8217;s good to be aware of how this can incur performance costs for two reasons: one major and common, and one less likely in well-designed code and so probably more minor.</p>
<p>First, the major reason is the performance cost of the &#8220;increment and decrement&#8221;: Because the reference count is an <span style="color:#2e74b5;">atomic</span> shared variable (or equivalent), incrementing and decrementing it are internally-synchronized read-modify-write shared memory operations.</p>
<p>Second, the less-likely minor reason is the potentially scalability-bustingly contentious nature of the &#8220;shared reference count&#8221;: Both increment and decrement update the reference count, which means that at the processor and memory level only one core at a time can be executing such an instruction on the same reference count because it needs exclusive access to the count&#8217;s cache line. The net result is that this causes some contention on the count&#8217;s cache line, which can affect scalability if it&#8217;s a popular cache line being touched by multiple threads in tight loops—such as if two threads are calling functions like this one in tight loops and accessing <span style="color:#2e74b5;">shared_ptr</span>s that own the same object. &#8220;So don&#8217;t do that, thou heretic caller!&#8221; we might righteously say. Well and good, but the caller doesn&#8217;t always know when two <span style="color:#2e74b5;">shared_ptr</span>s used on two different threads refer to the same object, so let&#8217;s not be quick to pile the wood around his stake just yet.</p>
<p>As we will see, an essential best practice for any reference-counted smart pointer type is to <i>avoid copying it unless you really mean to add a new reference</i>. This cannot be stressed enough. This directly addresses both of these costs and pushes their performance impact down into the noise for most applications, and especially eliminates the second cost because it is an antipattern to add and remove references in tight loops.</p>
<p>At this point, we will be tempted to solve the problem by passing the <span style="color:#2e74b5;">shared_ptr</span> by reference. But is that really the right thing to do? It depends.</p>
<h2>2. What are the <em>correctness</em> implications of the function declaration in #1?</h2>
<p>The only correctness implication is that the function advertises in a clear type-enforced way that it will (or could) retain a copy of the <span style="color:#2e74b5;">shared_ptr</span>.</p>
<p>That this is the only correctness implication might surprise some people, because there would seem to be one other major correctness benefit to taking a copy of the argument, namely lifetime: Assuming the pointer is not already null, taking a copy of the <span style="color:#2e74b5;">shared_ptr</span> guarantees that the function itself holds a strong refcount on the owned object, and that therefore the object will remain alive for the duration of the function body, or until the function itself chooses to modify its parameter.</p>
<p>However, we already get this for free—thanks to structured lifetimes, the called function&#8217;s lifetime is a strict subset of the calling function&#8217;s call expression. Even if we passed the <span style="color:#2e74b5;">shared_ptr</span> by reference, our function would as good as hold a strong refcount because <em>the caller already has one</em>—he passed us the <span style="color:#2e74b5;">shared_ptr</span> in the first place, and won&#8217;t release it until we return. (Note this assumes the pointer is not aliased. You have to be careful if the smart pointer parameter could be aliased, but in this respect it&#8217;s no different than any other aliased object.)</p>
<blockquote><p><strong>Guideline:</strong> Don&#8217;t pass a smart pointer as a function parameter unless you want to use or manipulate the smart pointer itself, such as to share or transfer ownership.</p></blockquote>
<blockquote><p><strong>Guideline: </strong>Prefer passing objects by value, <strong>*</strong>, or <strong>&amp;</strong>, not by smart pointer.</p></blockquote>
<p>If you&#8217;re saying, &#8220;hey, aren&#8217;t raw pointers evil?&#8221;, that&#8217;s excellent, because we&#8217;ll address that next.</p>
<h2>3. A colleague is writing a function f that takes an existing object of type widget as a required input-only parameter, and trying to decide among the following basic ways to take the parameter (omitting const). Under what circumstances is each appropriate? Explain your answer, including where const should or should not be added anywhere in the parameter type.</h2>
<h3>(a) and (b): Prefer passing parameters by * or &amp;.</h3>
<pre><code>void f( widget* );              (a)
void f( widget&amp; );              (b)
</code></pre>
<p>These are the preferred way to pass normal object parameters, because they stay agnostic of whatever lifetime policy the caller happens to be using.</p>
<p>Non-owning raw <span style="color:#2e74b5;">*</span> pointers and <span style="color:#2e74b5;">&amp;</span> references are okay to observe an object whose lifetime we know exceeds that of the pointer or reference, which is usually true for function parameters. Thanks to structured lifetimes, by default arguments passed to <span style="color:#2e74b5;">f</span> in the caller outlive <span style="color:#2e74b5;">f</span>&#8216;s function call lifetime, which is extremely useful (not to mention efficient) and makes non-owning <span style="color:#2e74b5;">*</span> and <span style="color:#2e74b5;">&amp;</span> appropriate for parameters.</p>
<p>Pass by <span style="color:#2e74b5;">*</span> or <span style="color:#2e74b5;">&amp;</span> to accept a <span style="color:#2e74b5;">widget</span> independently of how the caller is managing its lifetime. Most of the time, we don&#8217;t want to commit to a lifetime policy in the parameter type, such as requiring the object be held by a specific smart pointer, because this is usually needlessly restrictive. As usual, use a <span style="color:#2e74b5;">*</span> if you need to express null (no <span style="color:#2e74b5;">widget</span>), otherwise prefer to use a <span style="color:#2e74b5;">&amp;</span>; and if the object is input-only, write <span style="color:#2e74b5;">const widget*</span> or <span style="color:#2e74b5;">const widget&amp;</span>.</p>
<h3>(c) Passing unique_ptr by value means &#8220;sink.&#8221;</h3>
<pre><code>void f( unique_ptr&lt;widget&gt; );   (c)
</code></pre>
<p>This is the preferred way to express a <span style="color:#2e74b5;">widget</span>-consuming function, also known as a &#8220;sink.&#8221;</p>
<p>Passing a <span style="color:#2e74b5;">unique_ptr</span> by value is only possible by moving the object and its unique ownership from the caller to the callee. Any function like (c) takes ownership of the object away from the caller, and either destroys it or moves it onward to somewhere else.</p>
<p>Note that, unlike some of the other options below, this use of a by-value <span style="color:#2e74b5;">unique_ptr</span> parameter actually doesn&#8217;t limit the kind of object that can be passed to those managed by a <span style="color:#2e74b5;">unique_ptr</span>. Why not? Because any pointer can be explicitly converted to a <span style="color:#2e74b5;">unique_ptr</span>. If we didn&#8217;t use a <span style="color:#2e74b5;">unique_ptr</span> here we would still have to express &#8220;sink&#8221; semantics, just in a more brittle way such as by accepting a raw <em>owning</em> pointer (anathema!) and documenting the semantics in comments. Using (c) is vastly superior because it documents the semantics in code, and requires the caller to explicitly move ownership.</p>
<p>Consider the major alternative:</p>
<pre><code>// Smelly 20th-century alternative
void bad_sink( widget* p );  // will destroy p; PLEASE READ THIS COMMENT

// Sweet self-documenting self-enforcing modern version (c)
void good_sink( unique_ptr&lt;widget&gt; p );
</code></pre>
<p>And how much better (c) is:</p>
<pre><code>// Older calling code that calls the new good_sink is safer, because
// it's clearer in the calling code that ownership transfer is going on
// (this older code has an owning * which we shouldn't do in new code)
//
widget* pw = ... ; 

bad_sink ( pw );             // compiles: remember not to use pw again!

good_sink( pw );             // error: good
good_sink( unique_ptr&lt;widget&gt;{pw} );  // need explicit conversion: good

// Modern calling code that calls good_sink is safer, and cleaner too
//
unique_ptr&lt;widget&gt; pw = ... ;

bad_sink ( pw.get() );       // compiles: icky! doesn't reset pw
bad_sink ( pw.release() );   // compiles: must remember to use this way

good_sink( pw );             // error: good!
good_sink( move(pw) );       // compiles: crystal clear what's going on
</code></pre>
<blockquote><p><strong>Guideline:</strong> Express a &#8220;sink&#8221; function using a by-value <strong>unique_ptr</strong> parameter.</p></blockquote>
<p>Because the callee will now own the object, usually there should be no <span style="color:#2e74b5;">const</span> on the parameter because the <span style="color:#2e74b5;">const</span> should be irrelevant.</p>
<h3>(d) Passing unique_ptr by reference is for in/out unique_ptr parameters.</h3>
<pre><code>void f( unique_ptr&lt;widget&gt;&amp; );  (d)
</code></pre>
<p>This should only be used to accept an in/out <span style="color:#2e74b5;">unique_ptr</span>, when the function is supposed to actually accept an existing <span style="color:#2e74b5;">unique_ptr</span> and potentially modify it to refer to a different object. It is a bad way to just accept a <span style="color:#2e74b5;">widget</span>, because it is restricted to a particular lifetime strategy in the caller.</p>
<blockquote><p><strong>Guideline:</strong> Use a non-const <strong>unique_ptr&amp;</strong> parameter only to modify the <strong>unique_ptr</strong>.</p></blockquote>
<p>Passing a <span style="color:#2e74b5;">const unique_ptr&lt;widget&gt;&amp;</span> is strange because it can accept only either null or a <span style="color:#2e74b5;">widget</span> whose lifetime happens to be managed in the calling code via a <span style="color:#2e74b5;">unique_ptr</span>, and the callee generally shouldn&#8217;t care about the caller&#8217;s lifetime management choice. Passing <span style="color:#2e74b5;">widget*</span> covers a strict superset of these cases and can accept &#8220;null or a <span style="color:#2e74b5;">widget</span>&#8221; regardless of the lifetime policy the caller happens to be using.</p>
<blockquote><p><strong>Guideline:</strong> Don&#8217;t use a <strong>const unique_ptr&amp;</strong> as a parameter; use <strong>widget*</strong> instead.</p></blockquote>
<p>I mention <span style="color:#2e74b5;">widget*</span> because that doesn&#8217;t change the (nullable) semantics; if you&#8217;re being tempted to pass <span style="color:#2e74b5;">const shared_ptr&lt;widget&gt;&amp;</span>, what you really meant was <span style="color:#2e74b5;">widget*</span> which expresses the same information. If you additionally know it can&#8217;t be null, though, of course use <span style="color:#2e74b5;">widget&amp;</span>.</p>
<h3>(e) Passing shared_ptr by value implies taking shared ownership.</h3>
<pre><code>void f( shared_ptr&lt;widget&gt; );   (e)
</code></pre>
<p>As we saw in #2, this is recommended only when the function wants to retain a copy of the <span style="color:#2e74b5;">shared_ptr</span> and share ownership. In that case, a copy is needed anyway so the copying cost is fine. If the local scope is not the final destination, just <span style="color:#2e74b5;">std::move</span> the <span style="color:#2e74b5;">shared_ptr</span> onward to wherever it needs to go.</p>
<blockquote><p><strong>Guideline:</strong> Express that a function will store and share ownership of a heap object using a by-value <strong>shared_ptr</strong> parameter.</p></blockquote>
<p>Otherwise, prefer passing a <span style="color:#2e74b5;">*</span> or <span style="color:#2e74b5;">&amp;</span> (possibly to <span style="color:#2e74b5;">const</span>) instead, since that doesn&#8217;t restrict the function to only objects that happen to be owned by <span style="color:#2e74b5;">shared_ptr</span>s.</p>
<h3>(f) Passing shared_ptr&amp; is useful for in/out shared_ptr manipulation.</h3>
<pre><code>void f( shared_ptr&lt;widget&gt;&amp; );  (f)
</code></pre>
<p>Similarly to (d), this should mainly be used to accept an in/out <span style="color:#2e74b5;">shared_ptr</span>, when the function is supposed to actually modify the <span style="color:#2e74b5;">shared_ptr</span> itself. It&#8217;s usually a bad way to accept a <span style="color:#2e74b5;">widget</span>, because it is restricted to a particular lifetime strategy in the caller.</p>
<p>Note that per (e) we pass a <span style="color:#2e74b5;">shared_ptr</span> by value if the function will share ownership. In the special case where the function <em>might</em> share ownership, but doesn&#8217;t necessarily take a copy of its parameter on a given call, then pass a <span style="color:#2e74b5;">const shared_ptr&amp;</span> to avoid the copy on the calls that don&#8217;t need it, and take a copy of the parameter if and when needed.</p>
<blockquote><p><strong>Guideline:</strong> Use a non-const <strong>shared_ptr&amp;</strong> parameter only to modify the <strong>shared_ptr</strong>. Use a <strong>const shared_ptr&amp;</strong> as a parameter only if you&#8217;re not sure whether or not you&#8217;ll take a copy and share ownership; otherwise use <strong>widget*</strong> instead (or if not nullable, a <strong>widget&amp;</strong>).</p></blockquote>
<h2>Acknowledgments</h2>
<p>Thanks in particular to the following for their feedback to improve this article: mttpd, zahirtezcan, Jon, GregM, Andrei Alexandrescu.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/feed/</wfw:commentRss>
		<slash:comments>57</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #91: Smart Pointer Parameters</title>
		<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/</link>
				<comments>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comments</comments>
				<pubDate>Thu, 30 May 2013 23:12:42 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2070</guid>
				<description><![CDATA[NOTE: Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #105.   How should you prefer to pass smart pointers, and why?   [&#8230;]]]></description>
								<content:encoded><![CDATA[<blockquote>
<p><strong>NOTE:</strong> Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #105.
</p>
</blockquote>
<p>
 </p>
<p><span style="color:#5a5a5a;"><em>How should you prefer to pass smart pointers, and why?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What are the <em>performance</em> implications of the following function declaration? Explain.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void f( shared_ptr&lt;widget&gt; );
</code></pre>
</p>
<h2>Guru Questions<br />
</h2>
<p>2. What are the <em>correctness</em> implications of the function declaration in #1? Explain with clear examples.
</p>
<p>3. A colleague is writing a function <span style="color:#2e74b5;">f</span> that takes an existing object of type <span style="color:#2e74b5;">widget</span> as a required input-only parameter, and trying to decide among the following basic ways to take the parameter (omitting <span style="color:#2e74b5;">const</span>):
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void f( widget* );              (a)<br />void f( widget&amp; );              (b)<br />void f( unique_ptr&lt;widget&gt; );   (c)<br />void f( unique_ptr&lt;widget&gt;&amp; );  (d)<br />void f( shared_ptr&lt;widget&gt; );   (e)<br />void f( shared_ptr&lt;widget&gt;&amp; );  (f)
</code></pre>
</p>
<p>Under what circumstances is each appropriate? Explain your answer, including where <span style="color:#2e74b5;">const</span> should or should not be added anywhere in the parameter type.
</p>
<p>(There are other ways to pass the parameter, but we will consider only the ones shown above.)</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #90 Solution: Factories</title>
		<link>https://herbsutter.com/2013/05/30/gotw-90-solution-factories/</link>
				<comments>https://herbsutter.com/2013/05/30/gotw-90-solution-factories/#comments</comments>
				<pubDate>Thu, 30 May 2013 23:04:45 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2068</guid>
				<description><![CDATA[NOTE: Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #104.   What should factory functions return, and why?   Problem While spelunking [&#8230;]]]></description>
								<content:encoded><![CDATA[<blockquote>
<p><strong>NOTE:</strong> Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #104.
</p>
</blockquote>
<p>
 </p>
<p><span style="color:#5a5a5a;"><em>What should factory functions return, and why?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<p>While spelunking through the code of a new project you recently joined, you find the following factory function declaration:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget* load_widget( widget::id desired );
</code></pre>
</p>
<h2>JG Question<br />
</h2>
<p>1. What&#8217;s wrong with this return type?
</p>
<h2>Guru Questions<br />
</h2>
<p>2. Assuming that <span style="color:#2e74b5;">widget</span> is a polymorphic type, what is the recommended return type? Explain your answer, including any tradeoffs.
</p>
<p>3. You&#8217;d like to actually change the return type to match the recommendation in #2, but at first you worry about breaking source compatibility with existing calling code; recompiling existing callers is fine, but having to go change them all is not. Then you have an &#8220;aha!&#8221; moment, realizing that this is a fairly new project and all of your calling code is written using modern C++ idioms, and you go ahead and change the return type without fear, knowing it will require few or no code changes to callers. What makes you so confident?
</p>
<p>4. If <span style="color:#2e74b5;">widget</span> is not a polymorphic type, what is the recommended return type? Explain.
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What&#8217;s wrong with this return type?<br />
</h2>
<p>First, what can we know or reasonably expect from the two-line problem description?
</p>
<p>We&#8217;re told <span style="color:#2e74b5;">load_widget</span> is a factory function. It produces an object by &#8220;loading&#8221; it in some way and then returning it to the caller. Since the return type is a pointer, the result might be null.
</p>
<p>The caller will reasonably expect to use the object, whether by calling member functions on it or passing it to other functions or in some other way. That isn&#8217;t safe unless the caller owns the object to ensure it is alive—either the caller gets exclusive ownership, or it gets shared ownership if the factory also maintains an internal strong or weak reference.
</p>
<p>Because the caller has or shares ownership, he has to do something when the object is no longer needed. If the ownership is exclusive, he should destroy the object somehow. Otherwise, if the ownership is shared, he should decrement some shared reference count.
</p>
<p>Unfortunately, returning a <span style="color:#2e74b5;">widget*</span> has two major problems. First, it&#8217;s unsafe by default, because the default mode of operation (i.e., when the caller writes whitespace) is to leak a <span style="color:#2e74b5;">widget</span>:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 1: Leak by default. Really, this is just so 20th-century...<br />// <br />widget* load_widget( widget::id desired );<br /><br />:::<br /><br />load_widget( some_id ); // oops
</code></pre>
</p>
<p>The Example 1 code compiles cleanly, runs, and (un)happily leaks the <span style="color:#2e74b5;">widget</span>.
</p>
<blockquote>
<p><strong>Guideline:</strong> Don&#8217;t use explicit <strong>new</strong>, <strong>delete</strong>, and owning <strong>*</strong> pointers, except in rare cases encapsulated inside the implementation of a low-level data structure.
</p>
</blockquote>
<p>Second, the signature conveys absolutely no information other than &#8220;a <span style="color:#2e74b5;">widget</span>? sure, here you go! enjoy.&#8221; The documentation may state that (and how) the caller is to own the object, but the function declaration doesn&#8217;t—it&#8217;s either exclusive ownership or shared ownership, but which? Read and remember the function&#8217;s documentation, because the function declaration isn&#8217;t telling. The signature alone doesn&#8217;t even say whether the caller shares in ownership at all.
</p>
<h2>2. Assuming that widget is a polymorphic type, what is the recommended return type? Explain your answer, including any tradeoffs.<br />
</h2>
<p>If <span style="color:#2e74b5;">widget</span> is a type that&#8217;s intended to be used polymorphically and held by pointer or reference, the factory should normally return a <span style="color:#2e74b5;">unique_ptr</span> to transfer ownership to the caller, or a <span style="color:#2e74b5;">shared_ptr</span> if the factory shares ownership by retaining a strong reference inside its internal data structures.
</p>
<blockquote>
<p><strong>Guideline:</strong> A factory that produces a reference type should return a <strong>unique_ptr</strong> by default, or a <strong>shared_ptr</strong> if ownership is to be shared with the factory.
</p>
</blockquote>
<p>This solves both problems: safety, and self-documentation.
</p>
<p>First, consider how this immediately solves the safety problem in Example 1:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 2: Clean up by default. Much better...<br />// <br />unique_ptr&lt;widget&gt; load_widget( widget::id desired );<br /><br />:::<br /><br />load_widget( some_id ); // cleans up
</code></pre>
</p>
<p>The Example 2 code compiles cleanly, runs, and happily cleans up the <span style="color:#2e74b5;">widget</span>. But it&#8217;s not just correct by default—it&#8217;s correct by construction, because there&#8217;s no way to make a mistake that results in a leak.
</p>
<p>Aside: Someone might say, &#8220;but can&#8217;t someone still write <span style="color:#2e74b5;">load_widget(some_id).release()</span>?&#8221; Of course they can, if they&#8217;re pathological; the correct answer is, &#8220;don&#8217;t do that.&#8221; Remember, our concern is to protect against Murphy, not Machiavelli—against bugs and mistakes, not deliberate crimes—and such pathological abuses fall into the latter category. That&#8217;s no different from, and doesn&#8217;t violate type safety any more than, explicitly calling <span style="color:#2e74b5;">Dispose</span> early in a C# <span style="color:#2e74b5;">using</span> block or explicitly calling <span style="color:#2e74b5;">close</span> early in a Java <span style="color:#2e74b5;">try</span>-with-resources block.
</p>
<p>What if the cleanup should be done by something other than a plain <span style="color:#2e74b5;">delete</span> call? Easy: Just use a custom deleter. The icing on the cake is that the factory itself knows which deleter is appropriate and can state it at the time it constructs the return value; the caller doesn&#8217;t need to worry about it, especially if he takes the result using an <span style="color:#2e74b5;">auto</span> variable.
</p>
<p>Second, this is self-documenting: A function that returns a <span style="color:#2e74b5;">unique_ptr</span> or a value clearly documents that it&#8217;s a pure &#8220;source&#8221; function, and one that returns a <span style="color:#2e74b5;">shared_ptr</span> clearly documents that it&#8217;s returning shared ownership and/or observation.
</p>
<p>Finally, why prefer <span style="color:#2e74b5;">unique_ptr</span> by default, if you don&#8217;t need to express shared ownership? Because it&#8217;s the Right Thing To Do for both performance and correctness, as noted in GotW #89, and leaves all options open to the caller:
</p>
<ul>
<li>Returning <span style="color:#2e74b5;">unique_ptr</span> expresses returning unique ownership, which is the norm for a pure &#8220;source&#8221; factory function.
</li>
<li><span style="color:#2e74b5;">unique_ptr</span> can&#8217;t be beat in efficiency—moving one is about as cheap as moving/copying a raw pointer.
</li>
<li>If the caller wants to manage the produced object&#8217;s lifetime via <span style="color:#2e74b5;">shared_ptr</span>, they can easily convert to <span style="color:#2e74b5;">shared_ptr</span> via an implicit move operation—no need to say <span style="color:#2e74b5;">std::move</span> because the compiler already knows that the returned value is a temporary object.
</li>
<li>If the caller is using any other arbitrary method of maintaining the object&#8217;s lifetime, he can convert to a custom smart pointer or other lifetime management scheme simply by calling <span style="color:#2e74b5;">.release()</span>. This can be useful, and isn&#8217;t  possible with <span style="color:#2e74b5;">shared_ptr</span>.
</li>
</ul>
<p>Here it is in action:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 2, continued<br />//<br /><br />// Accept as a unique_ptr (by default)<br />auto up = load_widget(1);<br /><br />// Accept as a shared_ptr (if desired)<br />auto sp = shared_ptr&lt;widget&gt;{ load_widget(2) };<br /><br />// Accept as your own smart pointer (if desired)<br />auto msp = my::smart_ptr&lt;widget&gt;{ load_widget(3).release() };
</code></pre>
</p>
<p>Of course, if the factory retains some shared ownership or observation, whether via an internal <span style="color:#2e74b5;">shared_ptr</span> or <span style="color:#2e74b5;">weak_ptr</span>, return <span style="color:#2e74b5;">shared_ptr</span>. The caller will be forced to continue using it as a <span style="color:#2e74b5;">shared_ptr</span>, but in that case that&#8217;s appropriate.
</p>
<h2>3. […] you go ahead and change the return type without fear, knowing it will require few or no code changes to callers. What makes you so confident?<br />
</h2>
<p>Modern portable C++ code uses <span style="color:#2e74b5;">unique_ptr</span>, <span style="color:#2e74b5;">shared_ptr</span>, and <span style="color:#2e74b5;">auto</span>. Returning <span style="color:#2e74b5;">unique_ptr</span> works with all three; returning <span style="color:#2e74b5;">shared_ptr</span> works with the last two.
</p>
<p>If the caller accepts the return value in an <span style="color:#2e74b5;">auto</span> variables, such as <span style="color:#2e74b5;">auto w = load_widget(whatever);</span>, then the type will just naturally be correct, normal dereferencing will just work, and the only source ripple will be if the caller tries to explicitly <span style="color:#2e74b5;">delete</span> (if so, the <span style="color:#2e74b5;">delete</span> line can rather appropriately be deleted) or tries to store into a non-local object of a different type.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer declaring variables using <strong>auto</strong>. It&#8217;s shorter, and helps to insulate your code from needless source ripples due to minor type changes.
</p>
</blockquote>
<p>Otherwise, if the caller isn&#8217;t using <span style="color:#2e74b5;">auto</span>, then it&#8217;s likely already using the result to initialize a <span style="color:#2e74b5;">unique_ptr</span> or <span style="color:#2e74b5;">shared_ptr</span> because modern C++ calling code does not traffick in raw pointers for non-parameter variables (more on this next time). In either case, returning a <span style="color:#2e74b5;">unique_ptr</span> just works: A <span style="color:#2e74b5;">unique_ptr</span> can be seamlessly moved into either of those types, and if the semantics are to return shared ownership and then the caller should already be using a <span style="color:#2e74b5;">shared_ptr</span> and things will again work just fine (only probably better than before, because for the original return by raw pointer to work correctly the return type was probably forced to jump through the <span style="color:#2e74b5;">enable_shared_from_this</span> hoop, which isn&#8217;t needed if we just return a <span style="color:#2e74b5;">shared_ptr</span> explicitly).
</p>
<h2>4. If widget is not a polymorphic type, what is the recommended return type? Explain.<br />
</h2>
<p>If <span style="color:#2e74b5;">widget</span> is not a polymorphic type, which typically means it&#8217;s a copyable value type or a move-only type, the factory should return a <span style="color:#2e74b5;">widget</span> by value. But what kind of value?
</p>
<p>In C++98, programmers would often resort to returning a large object by pointer just to avoid the penalty of copying its state:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 4(a): Obsolete convention: return a * just to avoid a copy <br />//<br />/*BAD*/ vector&lt;gadget&gt;* load_gadgets() {<br />    vector&lt;gadget&gt;* ret = new vector&lt;gadget&gt;();<br />    // ... populate *ret ...<br />    return ret;<br />}<br /><br />// Obsolete calling code (note: NOT exception-safe) <br />vector&lt;gadget&gt;* p = load_gadgets();<br />if(p) use(*p);<br />delete p;
</code></pre>
</p>
<p>This has all of the usability and fragility problems discussed in #1. Today, normally we should just return by value, because we will incur only a cheap move operation, not a deep copy, to hand the result to the caller:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 4(b): Default recommendation: return the value<br />//<br />vector&lt;gadget&gt; load_gadgets() {<br />    vector&lt;gadget&gt; ret;<br />    // ... populate ret ...<br />    return ret;<br />}<br /><br />// Calling code (exception-safe)<br />auto v = load_gadgets();<br />use(v);
</code></pre>
</p>
<p>Most of the time, return movable objects by value. That&#8217;s all there is to it, if the only reason for the pointer on the return type was to avoid the copy.
</p>
<p>There could be one additional reason the function might have returned a pointer, namely to return <span style="color:#2e74b5;">nullptr</span> to indicate failure to produce an object. Normally it&#8217;s better throw an exception to report an error if we fail to load the <span style="color:#2e74b5;">widget</span>. However, if not being able to load the <span style="color:#2e74b5;">widget</span> is normal operation and should not be considered an error, return an <span style="color:#2e74b5;">optional&lt;widget&gt;</span>, and probably make the factory <span style="color:#2e74b5;">noexcept</span> if no other kinds of errors need to be reported than are communicated well by returning an empty <span style="color:#2e74b5;">optional&lt;widget&gt;</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 4(c): Alternative if not returning an object is normal<br />//<br />optional&lt;vector&lt;gadget&gt;&gt; load_gadgets() noexcept {<br />    vector&lt;gadget&gt; ret;<br />    // ... populate ret ...<br />    if( success )            // return vector (might be empty)<br />        return move(ret);    // note: move() here to avoid a silent copy<br />    else<br />        return {};           // not returning anything<br />}<br /><br />// Calling code (exception-safe)<br />auto v = load_gadgets();<br />if(v) use(*v);
</code></pre>
</p>
<blockquote>
<p><strong>Guideline:</strong> A factory that produces a non-reference type should return a value by default, and throw an exception if it fails to create the object. If not creating the object can be a normal result, return an <strong>optional&lt;&gt;</strong> value.
</p>
</blockquote>
<h2>Coda<br />
</h2>
<p>By the way, see that test for <span style="color:#2e74b5;">if(v)</span> in the last line of Example 4(c)? It calls a cool function of <span style="color:#2e74b5;">optional&lt;T&gt;</span>, namely <span style="color:#2e74b5;">operator bool</span>. What makes bool so cool? In part because of how many C++ features it exercises. Here is its declaration… just think of what this lets you safely do, including at compile time! Enjoy.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>constexpr explicit optional&lt;T&gt;::operator bool() const noexcept;
</code></pre>
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: Johannes Schaub, Leo, Vincent Jacquet.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/30/gotw-90-solution-factories/feed/</wfw:commentRss>
		<slash:comments>29</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #90: Factories</title>
		<link>https://herbsutter.com/2013/05/29/gotw-90-factories/</link>
				<comments>https://herbsutter.com/2013/05/29/gotw-90-factories/#comments</comments>
				<pubDate>Wed, 29 May 2013 18:54:21 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2040</guid>
				<description><![CDATA[NOTE: Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #104.   What should factory functions return, and why?   Problem While spelunking [&#8230;]]]></description>
								<content:encoded><![CDATA[<blockquote>
<p><strong>NOTE:</strong> Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #104.
</p>
</blockquote>
<p>
 </p>
<p><span style="color:#5a5a5a;"><em>What should factory functions return, and why?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<p>While spelunking through the code of a new project you recently joined, you find the following factory function declaration:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget* load_widget( widget::id desired );
</code></pre>
</p>
<h2>JG Question<br />
</h2>
<p>1. What&#8217;s wrong with this return type?
</p>
<h2>Guru Questions<br />
</h2>
<p>2. Assuming that <span style="color:#2e74b5;">widget</span> is a polymorphic type, what is the recommended return type? Explain your answer, including any tradeoffs.
</p>
<p>3. You&#8217;d like to actually change the return type to match the recommendation in #2, but at first you worry about breaking source compatibility with existing calling code; recompiling existing callers is fine, but having to go change them all is not. Then you have an &#8220;aha!&#8221; moment, realizing that this is a fairly new project and all of your calling code is written using modern C++ idioms, and you go ahead and change the return type without fear, knowing it will require few or no code changes to callers. What makes you so confident?
</p>
<p>4. If <span style="color:#2e74b5;">widget</span> is not a polymorphic type, what is the recommended return type? Explain.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/29/gotw-90-factories/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #89 Solution: Smart Pointers</title>
		<link>https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/</link>
				<comments>https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/#comments</comments>
				<pubDate>Wed, 29 May 2013 18:49:21 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2035</guid>
				<description><![CDATA[NOTE: Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #103.   There&#8217;s a lot to love about standard smart pointers in general, [&#8230;]]]></description>
								<content:encoded><![CDATA[<blockquote>
<p><strong>NOTE:</strong> Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #103.
</p>
</blockquote>
<p>
 </p>
<p><span style="color:#5a5a5a;"><em>There&#8217;s a lot to love about standard smart pointers in general, and unique_ptr in particular.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. When should you use <span style="color:#2e74b5;">shared_ptr</span> vs. <span style="color:#2e74b5;">unique_ptr</span>? List as many considerations as you can.
</p>
<h2>Guru Question<br />
</h2>
<p>2. Why should you almost always use <span style="color:#2e74b5;">make_shared</span> to create an object to be owned by <span style="color:#2e74b5;">shared_ptr</span>s? Explain.
</p>
<p>3. Why should you almost always use <span style="color:#2e74b5;">make_unique</span> to create an object to be initially owned by a <span style="color:#2e74b5;">unique_ptr</span>? Explain.
</p>
<p>4. What&#8217;s the deal with <span style="color:#2e74b5;">auto_ptr</span>?
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. When should you use shared_ptr vs. unique_ptr?<br />
</h2>
<p>When in doubt, prefer <span style="color:#2e74b5;">unique_ptr</span> by default, and you can always later move-convert to <span style="color:#2e74b5;">shared_ptr</span> if you need it. If you do know from the start you need shared ownership, however, go directly to <span style="color:#2e74b5;">shared_ptr</span> via <span style="color:#2e74b5;">make_shared</span> (see #2 below).
</p>
<p>There are three major reasons to say &#8220;when in doubt, prefer <span style="color:#2e74b5;">unique_ptr</span>.&#8221;
</p>
<p>First, use the simplest semantics that are sufficient<em>:</em> Choose the right smart pointer to most directly express your intent, and what you need (now). If you are creating a new object and don&#8217;t know that you&#8217;ll eventually need shared ownership, use <span style="color:#2e74b5;">unique_ptr</span> which expresses unique ownership. You can still put it in a container (e.g., <span style="color:#2e74b5;">vector&lt;unique_ptr&lt;widget&gt;&gt;</span>) and do most other things you want to do with a raw pointer, only safely. If you later need shared ownership, you can always move-convert the <span style="color:#2e74b5;">unique_ptr</span> to a <span style="color:#2e74b5;">shared_ptr</span>.
</p>
<p>Second, a  <span style="color:#2e74b5;">unique_ptr</span> is more efficient than a <span style="color:#2e74b5;">shared_ptr</span>. A <span style="color:#2e74b5;">unique_ptr</span> doesn&#8217;t need to maintain reference count information and a control block under the covers, and is designed to be just about as cheap to move and use as a raw pointer. When you don&#8217;t ask for more than you need, you don&#8217;t incur overheads you won&#8217;t use.
</p>
<p>Third, starting with <span style="color:#2e74b5;">unique_ptr</span> is more flexible and keeps your options open. If you start with a <span style="color:#2e74b5;">unique_ptr</span>, you can always later convert to a <span style="color:#2e74b5;">shared_ptr</span> via move, or to another custom smart pointer (or even to a raw pointer) via <span style="color:#2e74b5;">.get()</span> or <span style="color:#2e74b5;">.release()</span>.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer to use the standard smart pointers, <strong>unique_ptr</strong> by default and <strong>shared_ptr</strong> if sharing is needed. They are the common types that all C++ libraries can understand. Use other smart pointer types only if necessary for interoperability with other libraries, or when necessary for custom behavior you can&#8217;t achieve with deleters and allocators on the standard pointers.
</p>
</blockquote>
<h2>2. Why should you almost always use make_shared to create an object to be owned by shared_ptrs? Explain.<br />
</h2>
<p>Note: If you need to create an object using a custom allocator, which is rare, you can use <span style="color:#2e74b5;">allocate_shared</span>. Note that even though its name is slightly different, <span style="color:#2e74b5;">allocate_shared</span> should be viewed as &#8220;just the flavor of <span style="color:#2e74b5;">make_shared</span> that lets you specify an allocator,&#8221; so I&#8217;m mainly going to talk about them both as <span style="color:#2e74b5;">make_shared</span> here and not distinguish much between them.
</p>
<p>There are two main cases where you can&#8217;t use <span style="color:#2e74b5;">make_shared</span> (or <span style="color:#2e74b5;">allocate_shared</span>) to create an object that you know will be owned by <span style="color:#2e74b5;">shared_ptr</span>s: (a) if you need a custom deleter, such as because of using <span style="color:#2e74b5;">shared_ptr</span>s to manage a non-memory resource or an object allocated in a nonstandard memory area, you can&#8217;t use <span style="color:#2e74b5;">make_shared</span> because it doesn&#8217;t support specifying a deleter; and (b) if you are adopting a raw pointer to an object being handed to you from other (usually legacy) code, you would construct a <span style="color:#2e74b5;">shared_ptr</span> from that raw pointer directly.
</p>
<blockquote>
<p><strong>Guideline:</strong> Use <strong>make_shared</strong> (or, if you need a custom allocator, <strong>allocate_shared</strong>) to create an object you know will be owned by <strong>shared_ptr</strong>s, unless you need a custom deleter or are adopting a raw pointer from elsewhere.
</p>
</blockquote>
<p>So, why use <span style="color:#2e74b5;">make_shared</span> (or, if you need a custom allocator, <span style="color:#2e74b5;">allocate_shared</span>) whenever you can, which is nearly always? There are two main reasons: simplicity, and efficiency.
</p>
<p>First, with <span style="color:#2e74b5;">make_shared</span> the code is simpler. Write for clarity and correctness first.
</p>
<p>Second, using <span style="color:#2e74b5;">make_shared</span> is more efficient. The <span style="color:#2e74b5;">shared_ptr</span> implementation has to maintain housekeeping information in a control block shared by all <span style="color:#2e74b5;">shared_ptr</span>s and <span style="color:#2e74b5;">weak_ptr</span>s referring to a given object. In particular, that housekeeping information has to include not just one but two reference counts:
</p>
<ul>
<li>A &#8220;strong reference&#8221; count to track the number of <span style="color:#2e74b5;">shared_ptr</span>s currently keeping the object alive. The shared object is destroyed (and possibly deallocated) when the last strong reference goes away.
</li>
<li>A &#8220;weak reference&#8221; count to track the number of <span style="color:#2e74b5;">weak_ptr</span>s currently observing the object. The shared housekeeping control block is destroyed and deallocated (and the shared object is deallocated if it was not already) when the last weak reference goes away.
</li>
</ul>
<p>If you allocate the object separately via a raw <span style="color:#2e74b5;">new</span> expression, then pass it to <span style="color:#2e74b5;">a shared_ptr</span>, the <span style="color:#2e74b5;">shared_ptr</span> implementation has no alternative but to allocate the control block separately, as shown in Example 2(a) and Figure 2(a).
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 2(a): Separate allocation<br />auto sp1 = shared_ptr&lt;widget&gt;{ new widget{} };<br />auto sp2 = sp1;
</code></pre>
</p>
<p style="text-align:center;"><img src="https://herbsutter.files.wordpress.com/2013/05/053013_2139_gotw89solut1.png?w=500" alt="" />
	</p>
<p style="text-align:center;">Figure 2(a): Approximate memory layout for Example 2(a).
</p>
<p>We&#8217;d like to avoid doing two separate allocations here. If you use <span style="color:#2e74b5;">make_shared</span> to allocate the object and the <span style="color:#2e74b5;">shared_ptr</span> all in one go, then the implementation can fold them together in a single allocation, as shown in Example 2(b) and Figure 2(b).
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Example 2(b): Single allocation<br />auto sp1 = make_shared&lt;widget&gt;();<br />auto sp2 = sp1;
</code></pre>
</p>
<p style="text-align:center;"><img src="https://herbsutter.files.wordpress.com/2013/05/053013_2139_gotw89solut2.png?w=500" alt="" />
	</p>
<p style="text-align:center;">Figure 2(b): Approximate memory layout for Example 2(b).
</p>
<p>Note that combining the allocations has two major advantages:
</p>
<ul>
<li>It reduces allocation overhead, including memory fragmentation. First, the most obvious way it does this is by reducing the number of allocation requests, which are typically more expensive operations. This also helps reduce contention on allocators (some allocators don&#8217;t scale well). Second, using only one chunk of memory instead of two reduces the per-allocation overhead. Whenever you ask for a chunk of memory, the system must give you at least that many bytes, and often gives you a few more because of using fixed-size pools or tacking on housekeeping information per allocation. So by using a single chunk of memory, we tend to reduce the total extra overhead. Finally, we also naturally reduce the number of &#8220;dead&#8221; extra in-between gaps that cause fragmentation.
</li>
<li>It improves locality. The reference counts are frequently used with the object, and for small objects are likely to be on the same cache line, which improves cache performance (as long as there isn&#8217;t some thread copying the smart pointer in a tight loop; don&#8217;t do that).
</li>
</ul>
<p>As always, when you can express more of what you&#8217;re trying to achieve as a single function call, you&#8217;re giving the system a better chance to figure out a way to do the job more efficiently. This is just as true when inserting 100 elements into a <span style="color:#2e74b5;">vector</span> using a single range-insert call to <span style="color:#2e74b5;">v.insert( first, last )</span> instead of 100 calls to <span style="color:#2e74b5;">v.insert( value )</span> as it is when using a single call to <span style="color:#2e74b5;">make_shared</span> instead of separate calls to <span style="color:#2e74b5;">new widget()</span> and <span style="color:#2e74b5;">shared_ptr( widget* )</span>.
</p>
<p>There are two more advantages: Using <span style="color:#2e74b5;">make_shared</span> avoids explicit <span style="color:#2e74b5;">new</span> and avoids an exception safety issue. Both of these also apply to <span style="color:#2e74b5;">make_unique</span>, so we&#8217;ll cover them under #3.
</p>
<h2>3. Why should you almost always use make_unique to create an object to be initially owned by a unique_ptr? Explain.<br />
</h2>
<p>As with <span style="color:#2e74b5;">make_shared</span>, there are two main cases where you can&#8217;t use <span style="color:#2e74b5;">make_unique</span> to create an object that you know will be owned (at least initially) by a <span style="color:#2e74b5;">unique_ptr</span>: if you need a custom deleter, or if you are adopting a raw pointer.
</p>
<p>Otherwise, which is nearly always, prefer <span style="color:#2e74b5;">make_unique</span>.
</p>
<blockquote>
<p><strong>Guideline:</strong> Use <strong>make_unique</strong> to create an object that isn&#8217;t shared (at least not yet), unless you need a custom deleter or are adopting a raw pointer from elsewhere.
</p>
</blockquote>
<p>Besides symmetry with <span style="color:#2e74b5;">make_shared</span>, <span style="color:#2e74b5;">make_unique</span> offers at least two other advantages. First, you should prefer use <span style="color:#2e74b5;">make_unique&lt;T&gt;()</span>  instead of the more-verbose <span style="color:#2e74b5;">unique_ptr&lt;T&gt;{ new T{} }</span> because you should avoid explicit <span style="color:#2e74b5;">new</span> in general:
</p>
<blockquote>
<p><strong>Guideline:</strong> Don&#8217;t use explicit <strong>new</strong>, <strong>delete</strong>, and owning <strong>*</strong> pointers, except in rare cases encapsulated inside the implementation of a low-level data structure.
</p>
</blockquote>
<p>Second, it avoids some known exception safety issues with naked <span style="color:#2e74b5;">new</span>. Here&#8217;s an example:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void sink( unique_ptr&lt;widget&gt;, unique_ptr&lt;gadget&gt; );<br /><br />sink( unique_ptr&lt;widget&gt;{new widget{}},<br />      unique_ptr&lt;gadget&gt;{new gadget{}} ); // Q1: do you see the problem?
</code></pre>
</p>
<p>Briefly, if you allocate and construct the <span style="color:#2e74b5;">new widget</span> first, then get an exception while allocating or constructing the <span style="color:#2e74b5;">new gadget</span>, the <span style="color:#2e74b5;">widget</span> is leaked. You might think: &#8220;Well, I could just change <span style="color:#2e74b5;">new widget{}</span> to <span style="color:#2e74b5;">make_unique&lt;widget&gt;()</span> and this problem would go away, right?&#8221; To wit:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>sink( make_unique&lt;widget&gt;(),<br />      unique_ptr&lt;gadget&gt;{new gadget{}} );         // Q2: is this better?
</code></pre>
</p>
<p>The answer is no, because C++ leaves the order of evaluation of function arguments unspecified and so either the <span style="color:#2e74b5;">new widget</span> or the <span style="color:#2e74b5;">new gadget</span> could be performed first. If the <span style="color:#2e74b5;">new gadget</span> is allocated and constructed first, then the <span style="color:#2e74b5;">make_unique&lt;widget&gt;</span> throws, we have the same problem.
</p>
<p>But while just changing one of the arguments to use <span style="color:#2e74b5;">make_unique</span> doesn&#8217;t close the hole, changing them both to <span style="color:#2e74b5;">make_unique</span> really does completely eliminate the problem:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>sink( make_unique&lt;widget&gt;(), make_unique&lt;gadget&gt;() );  // exception-safe
</code></pre>
</p>
<p>This exception safety issue is covered in more detail in GotW #56.
</p>
<blockquote>
<p><strong>Guideline:</strong> To allocate an object, prefer to write <strong>make_unique</strong> by default, and write <strong>make_shared</strong> when you know the object&#8217;s lifetime is going to be managed by using <strong>shared_ptr</strong>s.
</p>
</blockquote>
<h2>4. What&#8217;s the deal with auto_ptr?<br />
</h2>
<p><span style="color:#2e74b5;">auto_ptr</span> is most charitably characterized as a valiant attempt to create a <span style="color:#2e74b5;">unique_ptr</span> before C++ had move semantics. <span style="color:#2e74b5;">auto_ptr</span> is now deprecated, and should not be used in new code.
</p>
<p>If you have <span style="color:#2e74b5;">auto_ptr</span> in an existing code base, when you get a chance try doing a global search-and-replace of <span style="color:#2e74b5;">auto_ptr</span> to <span style="color:#2e74b5;">unique_ptr</span>; the vast majority of uses will work the same, and it might expose (as a compile-time error) or fix (silently) a bug or two you didn&#8217;t know you had.
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: celeborn2bealive, Andy Prowl, Chris Vine, Marek.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/feed/</wfw:commentRss>
		<slash:comments>53</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2013/05/053013_2139_gotw89solut1.png" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2013/05/053013_2139_gotw89solut2.png" medium="image" />
	</item>
		<item>
		<title>GotW #89: Smart Pointers</title>
		<link>https://herbsutter.com/2013/05/28/gotw-89-smart-pointers/</link>
				<comments>https://herbsutter.com/2013/05/28/gotw-89-smart-pointers/#comments</comments>
				<pubDate>Wed, 29 May 2013 00:08:38 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2025</guid>
				<description><![CDATA[NOTE: Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #103.   There&#8217;s a lot to love about standard smart pointers in general, [&#8230;]]]></description>
								<content:encoded><![CDATA[<blockquote>
<p><strong>NOTE:</strong> Last year, I posted three new GotWs numbered #103-105. I decided leaving a gap in the numbers wasn&#8217;t best after all, so I am renumbering them to #89-91 to continue the sequence. Here is the updated version of what was GotW #103.
</p>
</blockquote>
<p>
 </p>
<p><span style="color:#5a5a5a;"><em>There&#8217;s a lot to love about standard smart pointers in general, and unique_ptr in particular.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. When should you use <span style="color:#2e74b5;">shared_ptr</span> vs. <span style="color:#2e74b5;">unique_ptr</span>? List as many considerations as you can.
</p>
<h2>Guru Question<br />
</h2>
<p>2. Why should you almost always use <span style="color:#2e74b5;">make_shared</span> to create an object to be owned by <span style="color:#2e74b5;">shared_ptr</span>s? Explain.
</p>
<p>3. Why should you almost always use <span style="color:#2e74b5;">make_unique</span> to create an object to be initially owned by a <span style="color:#2e74b5;">unique_ptr</span>? Explain.
</p>
<p>4. What&#8217;s the deal with <span style="color:#2e74b5;">auto_ptr</span>?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/28/gotw-89-smart-pointers/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #6b Solution: Const-Correctness, Part 2</title>
		<link>https://herbsutter.com/2013/05/28/gotw-6b-solution-const-correctness-part-2/</link>
				<comments>https://herbsutter.com/2013/05/28/gotw-6b-solution-const-correctness-part-2/#comments</comments>
				<pubDate>Wed, 29 May 2013 00:05:43 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2023</guid>
				<description><![CDATA[const and mutable are powerful tools for writing safer code. Use them consistently. Problem Guru Question In the following code, add or remove const (including minor variants and related keywords) wherever appropriate. Note: Don&#8217;t comment on or change the structure of this program. It&#8217;s contrived and condensed for illustration only. For bonus points: In what [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>const and mutable are powerful tools for writing safer code. Use them consistently.</em></span>
	</p>
<h1>Problem<br />
</h1>
<h2>Guru Question<br />
</h2>
<p>In the following code, add or remove <span style="color:#2e74b5;">const</span> (including minor variants and related keywords) wherever appropriate. Note: Don&#8217;t comment on or change the structure of this program. It&#8217;s contrived and condensed for illustration only.
</p>
<p>For bonus points: In what places are the program&#8217;s results undefined or uncompilable due to <span style="color:#2e74b5;">const</span> errors?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class polygon {<br />public:<br />    polygon() : area{-1} {}<br /><br />    void add_point( const point pt ) { area = -1;<br />                                       points.push_back(pt); }<br /><br />    point get_point( const int i ) { return points[i]; }<br /><br />    int get_num_points() { return points.size(); }<br /><br />    double get_area() {<br />        if( area &lt; 0 )   // if not yet calculated and cached<br />            calc_area();     // calculate now<br />        return area;<br />    }<br /><br />private:<br />    void calc_area() {<br />        area = 0;<br />        vector&lt;point&gt;::iterator i;<br />        for( i = begin(points); i != end(points); ++i )<br />            area += /* some work using *i */;<br />    }<br /><br />    vector&lt;point&gt; points;<br />    double        area;<br />};<br /><br />polygon operator+( polygon&amp; lhs, polygon&amp; rhs ) {<br />    auto ret = lhs;<br />    auto last = rhs.get_num_points();<br />    for( auto i = 0; i &lt; last; ++i ) // concatenate<br />        ret.add_point( rhs.get_point(i) );<br />    return ret;<br />}<br /><br />void f( const polygon&amp; poly ) {<br />    const_cast&lt;polygon&amp;&gt;(poly).add_point( {0,0} );<br />}<br /><br />void g( polygon&amp; const poly ) { poly.add_point( {1,1} ); }<br /><br />void h( polygon* const poly ) { poly-&gt;add_point( {2,2} ); }<br /><br />int main() {<br />    polygon poly;<br />    const polygon cpoly;<br /><br />    f(poly);<br />    f(cpoly);<br />    g(poly);<br />    h(&amp;poly);<br />}
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<p>When I pose this kind of problem, I find that most people think the problem is on the easy side and address only the more-usual <span style="color:#2e74b5;">const</span> issues. There are, however, subtleties that are worth knowing, and hence this Item.
</p>
<h3>1. The point object is passed by value, so there is little benefit to declaring it const.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    void  add_point( const point pt )<span style="color:#2e74b5;">
				</span></code></pre>
</p>
<p>In this particular case, because the function is defined inline, the <span style="color:#2e74b5;">const</span> value parameter can make sense. This is because for inline functions the declaration and definition are the same. Otherwise, <span style="color:#2e74b5;">const</span> value parameters should appear only on the definition, not on the declaration. Let&#8217;s see why.
</p>
<p>Putting the <span style="color:#2e74b5;">const</span> on a value parameter in a function declaration is irrelevant <em>outside</em> the function—it makes no difference to the caller and can only confuse readers. To the compiler, the function signature is the same whether you include this <span style="color:#2e74b5;">const</span> in front of a value parameter or not. For example:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// value parameter: top-level const is not part of function signature<br />int f( int );<br />int f( const int );    // <span style="text-decoration:underline;">redeclares</span> f(int): this is the same function<br /><br />// non-value parameter: top-level const is part of function signature<br />int g( int&amp; );<br />int g( const int&amp; );   // overloads g(int&amp;): these are two functions<span style="color:#2e74b5;">
				</span></code></pre>
</p>
<p>But putting the <span style="color:#2e74b5;">const</span> on the value parameter does make a difference to how it can be used <em>inside</em> the function&#8217;s actual definition. Remember that, inside a function, the parameters are just the first set of local variables, so putting a <span style="color:#2e74b5;">const</span> on a value parameter simply means that the function can&#8217;t modify its local variable, which only happens to be a parameter. Here&#8217;s an example that declares and then defines the same function <span style="color:#2e74b5;">f</span>:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int f( int );          // declaration: no const<br /><br />int f( const int i ) { // definition: use const to express "read-only"<br /><br />    vector&lt;int&gt; v;<br />    v.push_back(i);    // ok, only reads from i<br /><br />    i = 42;            // error, attempts to modify i<br /><br />}
</code></pre>
</p>
<blockquote>
<p><strong>Guideline:</strong> Consider not writing <strong>const</strong> on pass-by-value function parameters when only forward-declaring a function. You can always add it on the definition to express a read-only parameter.
</p>
</blockquote>
<h3>2. get_point and get_num_points should be const.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    point get_point( const int i ) { return points[i]; }<br /><br />    int   get_num_points() { return points.size(); }
</code></pre>
</p>
<p>These functions should be marked <span style="color:#2e74b5;">const</span>, because they don&#8217;t change the state of the object.
</p>
<h3>3. get_area should be const.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    double get_area() {<br />        if( area &lt; 0 )   // if not yet calculated and cached<br />            calc_area();     // calculate now<br />        return area;<br />    }
</code></pre>
</p>
<p>Even though this function modifies the object&#8217;s internal state, we should consider making it <span style="color:#2e74b5;">const</span>. Why? Because this function does not modify the object&#8217;s <em>observable</em> state; we are doing some caching here, but that&#8217;s an internal implementation detail and the object is logically <span style="color:#2e74b5;">const</span> even if it isn&#8217;t physically <span style="color:#2e74b5;">const</span>.
</p>
<h3>4. Therefore calc_area should also be const.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    void calc_area() {<br />        area = 0;<br />        vector&lt;point&gt;::iterator i;<br />        for( i = begin(points); i != end(points); ++i )<br />            area += /* some work using *i */;<br />    }
</code></pre>
</p>
<p>Once we make <span style="color:#2e74b5;">get_area</span> be <span style="color:#2e74b5;">const</span>, this private helper function ought also to be <span style="color:#2e74b5;">const</span>.
</p>
<p>In turn, once you make this function <span style="color:#2e74b5;">const</span>, the compiler will tell you that you also need to do something about the member variable <span style="color:#2e74b5;">area</span>, which should be:
</p>
<ul>
<li>declared <span style="color:#2e74b5;">mutable</span>, so that it&#8217;s writable in a <span style="color:#2e74b5;">const</span> member function; and
</li>
<li>synchronized using a <span style="color:#2e74b5;">mutex</span> or made <span style="color:#2e74b5;">atomic&lt;&gt;</span>, so that it&#8217;s concurrency-safe, as discussed in GotW #6a.
</li>
</ul>
<h3>5. Also, calc_area should use a const_iterator.<br />
</h3>
<p>The iterator should not change the state of the <span style="color:#2e74b5;">points</span> collection, and so it ought to be a <span style="color:#2e74b5;">const_iterator</span>. We&#8217;re now forced to make this change anyway if we&#8217;re making <span style="color:#2e74b5;">calc_area</span> be a <span style="color:#2e74b5;">const</span> member function, but note that if we had said <span style="color:#2e74b5;">auto</span> for the iterator&#8217;s type we wouldn&#8217;t have had to make any change at all. While we&#8217;re at it, the <span style="color:#2e74b5;">for</span> loop inside <span style="color:#2e74b5;">calc_area</span>: It should prefer to use the range-based <span style="color:#2e74b5;">for</span> loop, as well as <span style="color:#2e74b5;">auto</span>.
</p>
<p>Combining all that, we get this simpler and <span style="color:#2e74b5;">const</span>-correct code:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>      for( auto&amp; pt : points )<br />          area += /* some work using pt */;
</code></pre>
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer declaring variables using <strong>auto</strong>.
</p>
</blockquote>
<blockquote>
<p><strong>Guideline:</strong> Prefer range-based <strong>for</strong> loops to naked iterator-incrementing <strong>for</strong> loops when visiting the elements of the range in order.
</p>
</blockquote>
<h3>6. area should be mutable and synchronized.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    double        area;
</code></pre>
</p>
<p>As noted already, in conjunction with the other changes the internal cache variable will <span style="color:#2e74b5;">area</span> now want to be <span style="color:#2e74b5;">mutable </span>so that it can be used correctly and safely inside <span style="color:#2e74b5;">const</span> member functions, and because it is now a shared variable potentially used by multiple concurrent <span style="color:#2e74b5;">const</span> operations it must also be synchronized—protected with a mutex or made <span style="color:#2e74b5;">atomic</span>.
</p>
<p><strong>Bonus Question: Before reading on, which should it be: Protected by a mutex? or made atomic&lt;double&gt;?<br />
</strong></p>
<p>Have you thought about it? All right, let&#8217;s continue…
</p>
<p>Both work, but a mutex is usually overkill for a single variable.
</p>
<p>Option 1 is to use a mutex in the perhaps-soon-to-be-canonical &#8220;<span style="color:#2e74b5;">mutable mutex mutables</span>&#8221; pattern:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Option 1: Use a mutex <br /><br />    double get_area() const {<br />        auto lock = unique_lock&lt;mutex&gt;{mutables};<br />        if( area &lt; 0 )   // if not yet calculated and cached<br />            calc_area();     // calculate now<br />        return area;<br />    }<br /><br />private:<br />    // ...<br />    mutable mutex  mutables;      // canonical pattern: mutex that<br />    mutable double area;          //   covers all mutable members
</code></pre>
</p>
<p>Option 1 generalizes well if you add more data members in the future. However, it&#8217;s also more invasive and generalizes less well if you add more <span style="color:#2e74b5;">const</span> member functions in the future that use <span style="color:#2e74b5;">area</span>, because they will all have to remember to acquire a lock on the mutex before using <span style="color:#2e74b5;">area</span>.
</p>
<p>Option 2 is to just change <span style="color:#2e74b5;">double</span> to <span style="color:#2e74b5;">mutable atomic&lt;double&gt;</span>. This is attractive because the &#8220;<span style="color:#2e74b5;">mutable</span> part&#8221; of <span style="color:#2e74b5;">polygon</span> is just a single variable. That can work, but you have to be careful because that&#8217;s not the only necessary change, for two reasons:
</p>
<ul>
<li>The minor reason is that <span style="color:#2e74b5;">atomic&lt;double&gt;</span> doesn&#8217;t support <span style="color:#2e74b5;">+=</span>, so if we only change <span style="color:#2e74b5;">area</span>&#8216;s type then <span style="color:#2e74b5;">calc_area</span> will no longer compile. That can be worked around, but leads us to the major reason…
</li>
<li>The major reason is that, because <span style="color:#2e74b5;">calc_area</span> is a compound operation and must be safe to run on multiple threads concurrently, we must restructure <span style="color:#2e74b5;">calc_area</span> to be safe to run concurrently. In particular it should not perform intermediate updates to <span style="color:#2e74b5;">area</span>, and should ensure that multiple competing concurrent updates to <span style="color:#2e74b5;">area</span> don&#8217;t cause overwrites that lose written values.
</li>
</ul>
<p>There are several ways to do it, but the simplest is probably to allow benign redundant recalculations in the case of concurrent calls to <span style="color:#2e74b5;">calc_area</span>, on the grounds that it&#8217;s probably no worse than blocking the concurrent calls which would have to wait anyway.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Option 2: Use an atomic<br /><br />    void calc_area() const {<br />        auto tmp = 0.0;              // do all the work off to the side<br />        for( auto&amp; pt : points )<br />            tmp += /* some work using pt */;<br />        area = tmp;                  // then commit with a single write<br />    }<br /><br />private:<br />    // ...<br />    mutable atomic&lt;double&gt; area;
</code></pre>
</p>
<p>Notice that concurrent <span style="color:#2e74b5;">const</span> operations that call to <span style="color:#2e74b5;">calc_area</span> can still overlap and overwrite each other&#8217;s results, but that&#8217;s benign because they&#8217;re <em>concurrent <span style="color:#2e74b5;">const</span> operations</em> so they will all calculate the same value. Also, concurrent <span style="color:#2e74b5;">calc_area</span> calls use the shared <span style="color:#2e74b5;">points</span> variable in a loop which should make us mentally check that it doesn&#8217;t cause cache contention, but because they&#8217;re all readers it won&#8217;t and so this too is fine.
</p>
<h3>7. operator+&#8217;s rhs parameter should be a reference to const.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>polygon operator+( polygon&amp; lhs, polygon&amp; rhs ) {
</code></pre>
</p>
<p>The <span style="color:#2e74b5;">rhs</span> parameter should be passed by reference to <span style="color:#2e74b5;">const</span>, of course.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer passing a read-only parameter by <strong>const&amp;</strong> if you are only going to read from it (not make a copy of it).
</p>
</blockquote>
<p>&#8220;But wait!&#8221; I can just hear some of you saying, &#8220;you forgot about <span style="color:#2e74b5;">lhs</span>! Shouldn&#8217;t it be <span style="color:#2e74b5;">const&amp;</span> too?&#8221; Actually, not so much:
</p>
<h3>8. operator+&#8217;s lhs parameter should be passed by value.<br />
</h3>
<p>The key point is that we&#8217;re going to copy from it anyway, in this case immediately:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    auto ret = lhs;
</code></pre>
</p>
<p>When you&#8217;re in the special case of &#8220;read-only parameter that you&#8217;re going to take copy of anyway,&#8221; there are several ways to accept the parameter, which I&#8217;ll cover in detail in another GotW. For now, suffice it to say that usually you shouldn&#8217;t overthink these options, and just use pass-by-value as the simplest method, which offers some advantages that we also touched on in GotW #4:
</p>
<ul>
<li>If the caller passes a named <span style="color:#2e74b5;">polygon</span> object (an lvalue), there&#8217;s no difference. Both pass-by-<span style="color:#2e74b5;">const&amp;</span> followed by an explicit copy and pass-by-value will perform one copy.
</li>
<li>
<div>If the caller passes a temporary <span style="color:#2e74b5;">polygon</span> object (an rvalue), the compiler automatically move-constructs <span style="color:#2e74b5;">lhs</span> from that, which probably makes no difference for a small type like <span style="color:#2e74b5;">polygon</span> but can be considerably cheaper for many types.
</div>
<blockquote>
<p><strong>Guideline:</strong> Prefer passing a read-only parameter by value if you&#8217;re going to make a copy of the parameter anyway, because it enables move from rvalue arguments.
</p>
</blockquote>
</li>
</ul>
<h3>9. Also in operator+, last should be const.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    auto last = rhs.get_num_points();<br />    for( auto i = 0; i &lt; last; ++i ) // concatenate<br />        ret.add_point( rhs.get_point(i) );<br />    return ret;<br />}
</code></pre>
</p>
<p>Since <span style="color:#2e74b5;">last</span> should never change, prefer to say so by making it <span style="color:#2e74b5;">const</span>.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer to make variables, including locals, <strong>const</strong> if they should not change.
</p>
</blockquote>
<p>Incidentally, notice that once we make <span style="color:#2e74b5;">rhs</span> a reference-to-<span style="color:#2e74b5;">const</span> parameter as noted above, we see another reason why <span style="color:#2e74b5;">get_point</span> should be a <span style="color:#2e74b5;">const</span> member function.
</p>
<h3>10. f&#8217;s const_cast may give undefined behavior, and is morally wrong anyway.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void f( const polygon&amp; poly ) {<br />    const_cast&lt;polygon&amp;&gt;(poly).add_point( {0,0} );<br />}
</code></pre>
</p>
<p>Bonus: The result of the <span style="color:#2e74b5;">const_cast</span> is undefined if the referenced object was declared as <span style="color:#2e74b5;">const</span>—which it is in the case of <span style="color:#2e74b5;">f(cpoly)</span> below.
</p>
<p>The parameter isn&#8217;t really <span style="color:#2e74b5;">const</span>, so don&#8217;t declare it as <span style="color:#2e74b5;">const</span> and then try to modify it anyway. Lying to the compiler, never mind to the caller, is a bad idea, never mind morally reprehensible in most value systems.
</p>
<h3>11. g&#8217;s const is illegal and useless.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void g( polygon&amp; const poly ) { poly.add_point( {1,1} ); }
</code></pre>
</p>
<p>This <span style="color:#2e74b5;">const</span> is illegal; you can&#8217;t apply <span style="color:#2e74b5;">const</span> directly to the reference itself, besides which references are already <span style="color:#2e74b5;">const</span> inasmuch as they cannot be reseated to refer to a different object.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void h( polygon* const poly ) { poly-&gt;add_point( {2,2} ); }
</code></pre>
</p>
<p>Note that <span style="color:#2e74b5;">h</span>&#8216;s <span style="color:#2e74b5;">const</span> merely ensures that <span style="color:#2e74b5;">h</span>&#8216;s body won&#8217;t modify the pointer value. This is the same as the <span style="color:#2e74b5;">const</span> value parameters in <span style="color:#2e74b5;">add_point</span> and <span style="color:#2e74b5;">get_point</span>, and perfectly fine on the definition.
</p>
<h3>12. Examining the mainline.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>int main() {<br />    polygon poly;<br />    const polygon cpoly;<br /><br />    f(poly);
</code></pre>
</p>
<p>This is fine.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    f(cpoly);
</code></pre>
</p>
<p>As already noted, this causes undefined results when <span style="color:#2e74b5;">f</span> tries to cast away the <span style="color:#2e74b5;">const</span>-ness of its parameter and then modify it.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    g(poly);
</code></pre>
</p>
<p>This is fine.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    h(&amp;poly);<br />}
</code></pre>
</p>
<p>This is fine.
</p>
<h3>Summary<br />
</h3>
<p>Here is a revised version of the code that corrects the <span style="color:#2e74b5;">const</span> issues noted above, but does not attempt to correct any other poor style. Note that because of the <span style="color:#2e74b5;">atomic</span> member, which is not copyable, we now provide <span style="color:#2e74b5;">polygon</span>&#8216;s copy and move operations explicitly.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class polygon {<br />public:<br />    polygon() : area{-1} {}<br /><br />    polygon( const polygon&amp; other ) : points{other.points}, area{-1} { }<br /><br />    polygon( polygon&amp;&amp; other ) <br />        : points{move(other.points)}, area{other.area.load()}<br />        { other.area = -1; }<br /><br />    polygon&amp; operator=( const polygon&amp; other )<br />        { points = other.points; area = -1; return *this; }<br /><br />    polygon&amp; operator=( polygon&amp;&amp; other ) {<br />        points = move(other.points);<br />        area = other.area.load();<br />        other.area = -1;<br />        return *this;<br />    }<br /><br />    void add_point( point pt ) <br />        { area = -1; points.push_back(pt); }<br /><br />    point get_point( int i ) const { return points[i]; }<br /><br />    int get_num_points() const { return points.size(); }<br /><br />    double get_area() const {<br />        if( area &lt; 0 )   // if not yet calculated and cached<br />            calc_area();     // calculate now<br />        return area;<br />    }<br /><br />private:<br />    void calc_area() const {<br />        auto tmp = 0.0;<br />        for( auto&amp; pt : points )<br />            tmp += /* some work using pt */;<br />        area = tmp;<br />    }<br /><br />    vector&lt;point&gt;          points;<br />    mutable atomic&lt;double&gt; area;<br />};<br /><br />polygon operator+( polygon lhs, const polygon&amp; rhs ) {<br />    const auto last = rhs.get_num_points();<br />    for( auto i = 0; i &lt; last; ++i ) // concatenate<br />        lhs.add_point( rhs.get_point(i) );<br />    return lhs;<br />}<br /><br />void f( polygon&amp; poly ) { poly.add_point( {0,0} ); }<br /><br />void g( polygon&amp; poly ) { poly.add_point( {1,1} ); }<br /><br />void h( polygon* poly ) { poly-&gt;add_point( {2,2} ); }<br /><br />int main() {<br />    auto poly = polygon{};<br /><br />    f(poly);<br />    g(poly);<br />    h(&amp;poly);<br />}
</code></pre>
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: mttpd, Vincent Lascaux, jlehrer, Motti, Fernando Pelliccioni, Leo, Mathias Stearn.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/28/gotw-6b-solution-const-correctness-part-2/feed/</wfw:commentRss>
		<slash:comments>54</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #6b: Const-Correctness, Part 2</title>
		<link>https://herbsutter.com/2013/05/24/gotw-6b-const-correctness-part-2/</link>
				<comments>https://herbsutter.com/2013/05/24/gotw-6b-const-correctness-part-2/#comments</comments>
				<pubDate>Fri, 24 May 2013 15:43:05 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2002</guid>
				<description><![CDATA[const and mutable are powerful tools for writing safer code. Use them consistently. Problem Guru Question In the following code, add or remove const (including minor variants and related keywords) wherever appropriate. Note: Don&#8217;t comment on or change the structure of this program. It&#8217;s contrived and condensed for illustration only. For bonus points: In what [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>const and mutable are powerful tools for writing safer code. Use them consistently.</em></span>
	</p>
<h1>Problem<br />
</h1>
<h2>Guru Question<br />
</h2>
<p>In the following code, add or remove <span style="color:#2e74b5;">const</span> (including minor variants and related keywords) wherever appropriate. Note: Don&#8217;t comment on or change the structure of this program. It&#8217;s contrived and condensed for illustration only.
</p>
<p>For bonus points: In what places are the program&#8217;s results undefined or uncompilable due to <span style="color:#2e74b5;">const</span> errors?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class polygon {<br />public:<br />    polygon() : area{-1} {}<br /><br />    void add_point( const point pt ) { area = -1;<br />                                       points.push_back(pt); }<br /><br />    point get_point( const int i ) { return points[i]; }<br /><br />    int get_num_points() { return points.size(); }<br /><br />    double get_area() {<br />        if( area &lt; 0 )   // if not yet calculated and cached<br />            calc_area();     // calculate now<br />        return area;<br />    }<br /><br />private:<br />    void calc_area() {<br />        area = 0;<br />        vector&lt;point&gt;::iterator i;<br />        for( i = begin(points); i != end(points); ++i )<br />            area += /* some work using *i */;<br />    }<br /><br />    vector&lt;point&gt; points;<br />    double        area;<br />};<br /><br />polygon operator+( polygon&amp; lhs, polygon&amp; rhs ) {<br />    auto ret = lhs;<br />    auto last = rhs.get_num_points();<br />    for( auto i = 0; i &lt; last; ++i ) // concatenate<br />        ret.add_point( rhs.get_point(i) );<br />    return ret;<br />}<br /><br />void f( const polygon&amp; poly ) {<br />    const_cast&lt;polygon&amp;&gt;(poly).add_point( {0,0} );<br />}<br /><br />void g( polygon&amp; const poly ) { poly.add_point( {1,1} ); }<br /><br />void h( polygon* const poly ) { poly-&gt;add_point( {2,2} ); }<br /><br />int main() {<br />    polygon poly;<br />    const polygon cpoly;<br /><br />    f(poly);<br />    f(cpoly);<br />    g(poly);<br />    h(&amp;poly);<br />}
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/24/gotw-6b-const-correctness-part-2/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #6a Solution: Const-Correctness, Part 1</title>
		<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/</link>
				<comments>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comments</comments>
				<pubDate>Fri, 24 May 2013 15:40:37 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2000</guid>
				<description><![CDATA[const and mutable have been in C++ for many years. How well do you know what they mean today? Problem JG Question 1. What is a &#8220;shared variable&#8221;? Guru Questions 2. What do const and mutable mean on shared variables? 3. How are const and mutable different in C++98 and C++11? Solution 1. What is [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>const and mutable have been in C++ for many years. How well do you know what they mean today?<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. What is a &#8220;shared variable&#8221;?</p>
<h2>Guru Questions</h2>
<p>2. What do <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">mutable</span> mean on shared variables?</p>
<p>3. How are <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">mutable</span> different in C++98 and C++11?</p>
<h1>Solution</h1>
<h2>1. What is a &#8220;shared variable&#8221;?</h2>
<p>A &#8220;shared variable&#8221; is one that could be accessed from more than one thread at the same time.</p>
<p>This concept is important in the C++ memory model. For example, the C++ memory model (the core of which is described in ISO C++ §1.10) prohibits the invention of a write to a &#8220;potentially shared memory location&#8221; that would not have been written to in a sequentially consistent execution of the program, and the C++ standard library refers to this section when it prohibits &#8220;modify[ing] objects accessible by [other] threads&#8221; through a <span style="color:#2e74b5;">const</span> function, as we will see in #2.</p>
<h2>2. What do const and mutable mean on shared variables?</h2>
<p>Starting with C++11, <span style="color:#2e74b5;">const</span> on a variable that is possibly shared means &#8220;read-only or as good as read-only&#8221; for the purposes of concurrency. Concurrent <span style="color:#2e74b5;">const</span> operations on the same object are required to be safe without the calling code doing external synchronization.</p>
<p>If you are implementing a type, unless you know objects of the type can never be shared (which is generally impossible), this means that each of your <span style="color:#2e74b5;">const</span> member functions must be either:</p>
<ul>
<li>truly physically/bitwise <span style="color:#2e74b5;">const</span> with respect to this object, meaning that they perform no writes to the object&#8217;s data; or else</li>
<li>internally synchronized so that if it does perform any actual writes to the object&#8217;s data, that data is correctly protected with a mutex or equivalent (or if appropriate are <span style="color:#2e74b5;">atomic&lt;&gt;</span>) so that any possible concurrent <span style="color:#2e74b5;">const</span> accesses by multiple callers can&#8217;t tell the difference.</li>
</ul>
<p>Types that do not respect this cannot be used with the standard library, which requires that:</p>
<blockquote><p>&#8220;… to prevent data races (1.10). … [a] C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads other than the current thread unless the objects are accessed directly or indirectly via the function&#8217;s non-<strong>const</strong> arguments, including <strong>this</strong>.&#8221;—ISO C++ §17.6.5.9</p></blockquote>
<p>Similarly, writing <span style="color:#2e74b5;">mutable</span> on a member variable means what it has always meant: The variable is &#8220;writable but logically <span style="color:#2e74b5;">const</span>.&#8221; Note what this implies:</p>
<ul>
<li>The &#8220;logically <span style="color:#2e74b5;">const</span>&#8221; part now means &#8220;can be used safely by multiple concurrent <span style="color:#2e74b5;">const</span> operations.&#8221;</li>
<li>The &#8220;<span style="color:#2e74b5;">mutable</span>&#8221; and &#8220;writable&#8221; part further means that some <span style="color:#2e74b5;">const</span> operations may actually be writers of the shared variable, which means it&#8217;s inherently got to be correct to read and write concurrently, so it should be protected with a mutex or similar, or made <span style="color:#2e74b5;">atomic&lt;&gt;</span>.</li>
</ul>
<p>In general, remember:</p>
<blockquote><p><strong>Guideline:</strong> Remember the &#8220;M&amp;M rule&#8221;: For a member variable, <strong>mutable</strong> and <strong>mutex</strong> (or <strong>atomic)</strong> go together.</p></blockquote>
<p>This applies in both directions, to wit:</p>
<blockquote><p><strong>(1) For a member variable, mutable implies mutex (or equivalent):</strong> A <strong>mutable</strong> member variable is presumed to be a mutable shared variable and so must be synchronized internally—protected with a <strong>mutex,</strong> made <strong>atomic,</strong> or similar.</p></blockquote>
<blockquote><p><strong>(2) For a member variable, mutex (or similar synchronization type) implies mutable<span style="color:#2e74b5;">:</span></strong> A member variable that is itself of a synchronization type, such as a <strong>mutex</strong> or a condition variable, naturally wants to be <strong>mutable,</strong> because you will want to use it in a non-<strong>const</strong> way (e.g., take a <strong>std::lock_guard&lt;mutex&gt;</strong>) inside concurrent <strong>const</strong> member functions.</p></blockquote>
<p>We&#8217;ll see an example of (2) in Part 2, GotW #6b.</p>
<h2>3. How are const and mutable different in C++98 and C++11?</h2>
<p>First, let&#8217;s be clear: C++98 single-threaded code still works. C++11 has excellent C++98 compatibility, and even though the meaning of <span style="color:#2e74b5;">const</span> has evolved, C++98 single-threaded code that uses the old &#8220;logically <span style="color:#2e74b5;">const</span>&#8221; meaning of <span style="color:#2e74b5;">const</span> is still valid.</p>
<p>With C++98, we taught a generation of C++ developers that &#8220;<span style="color:#2e74b5;">const</span> means logically <span style="color:#2e74b5;">const</span>, not physically/bitwise <span style="color:#2e74b5;">const</span>.&#8221; That is, in C++98 we taught that <span style="color:#2e74b5;">const</span> meant only that the observable state of the object (say, via its non-private member functions) should not change as far as the caller could tell, but its internal bits might change in order to update counters and instrumentation and other data not accessible via the type&#8217;s public or protected interface.</p>
<p>That definition is not sufficient for concurrency. With C++11 and onward, which now includes a concurrency memory model and thread safety specification for the standard library, this is now much simpler: <span style="color:#2e74b5;">const</span> now really does mean &#8220;read-only, or safe to read concurrently&#8221;—either truly physically/bitwise <span style="color:#2e74b5;">const</span>, or internally synchronized so that any actual writes are synchronized with any possible concurrent <span style="color:#2e74b5;">const</span> accesses so the callers can&#8217;t tell the difference.</p>
<p>Although existing C++98-era types still work just fine in C++98-era single-threaded code for compatibility, those types and any new ones you write today should obey the new stricter requirement if they could be used on multiple threads. The good news is that most existing types already followed that rule, and code that relies on casting away <span style="color:#2e74b5;">const</span> and/or using <span style="color:#2e74b5;">mutable</span> data members in single-threaded code has already been generally questionable and relatively rare.</p>
<h2>Summary</h2>
<p>Don&#8217;t shoot yourself (or your fellow programmers) in the foot. Write <span style="color:#2e74b5;">const</span>-correct code.</p>
<p>Using <span style="color:#2e74b5;">const</span> consistently is simply necessary for correctly-synchronized code. That by itself is ample reason to be consistently <span style="color:#2e74b5;">const</span>-correct, but there&#8217;s more: It lets you document interfaces and invariants far more effectively than any mere <span style="color:#2e74b5;">/* I promise not to change this */</span> comment can accomplish. It&#8217;s a powerful part of &#8220;design by contract.&#8221; It helps the compiler to stop you from accidentally writing bad code. It can even help the compiler generate tighter, faster, smaller code. That being the case, there&#8217;s no reason why you shouldn&#8217;t use it as much as possible, and every reason why you should.</p>
<p>Remember that the correct use of <span style="color:#2e74b5;">mutable</span> is a key part of <span style="color:#2e74b5;">const</span>-correctness. If your class contains a member that could change even for <span style="color:#2e74b5;">const</span> objects and operations, make that member <span style="color:#2e74b5;">mutable</span> and protect it with a mutex or make it <span style="color:#2e74b5;">atomic</span>. That way, you will be able to write your class&#8217; <span style="color:#2e74b5;">const</span> member functions easily and correctly, and users of your class will be able to correctly create and use <span style="color:#2e74b5;">const</span> and non-<span style="color:#2e74b5;">const</span> objects of your class&#8217; type.</p>
<p>It&#8217;s true that not all commercial libraries&#8217; interfaces are <span style="color:#2e74b5;">const</span>-correct. That isn&#8217;t an excuse for you to write <span style="color:#2e74b5;">const</span>-incorrect code, though. It is, however, one of the few good excuses to write <span style="color:#2e74b5;">const_cast</span>, plus a detailed comment nearby grumbling about the library vendor&#8217;s laziness and how you&#8217;re looking for a replacement product.</p>
<h2>Acknowledgments</h2>
<p>Thanks in particular to the following for their feedback to improve this article: mttpd, jlehrer, Chris Vine.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #6a: Const-Correctness, Part 1</title>
		<link>https://herbsutter.com/2013/05/22/gotw-6a-const-correctness-part-1/</link>
				<comments>https://herbsutter.com/2013/05/22/gotw-6a-const-correctness-part-1/#comments</comments>
				<pubDate>Wed, 22 May 2013 19:06:49 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1986</guid>
				<description><![CDATA[const and mutable have been in C++ for many years. How well do you know what they mean today?   Problem JG Question 1. What is a &#8220;shared variable&#8221;? Guru Questions 2. What do const and mutable mean on shared variables? 3. How are const and mutable different in C++98 and C++11?]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>const and mutable have been in C++ for many years. How well do you know what they mean today?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is a &#8220;shared variable&#8221;?
</p>
<h2>Guru Questions<br />
</h2>
<p>2. What do <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">mutable</span> mean on shared variables?
</p>
<p>3. How are <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">mutable</span> different in C++98 and C++11?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/22/gotw-6a-const-correctness-part-1/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #5 Solution: Overriding Virtual Functions</title>
		<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/</link>
				<comments>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comments</comments>
				<pubDate>Wed, 22 May 2013 19:06:19 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1984</guid>
				<description><![CDATA[Virtual functions are a pretty basic feature, but they occasionally harbor subtleties that trap the unwary. If you can answer questions like this one, then you know virtual functions cold, and you&#8217;re less likely to waste a lot of time debugging problems like the ones illustrated below. Problem JG Question 1. What do the override [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Virtual functions are a pretty basic feature, but they occasionally harbor subtleties that trap the unwary. If you can answer questions like this one, then you know virtual functions cold, and you&#8217;re less likely to waste a lot of time debugging problems like the ones illustrated below.<br />
</em></span></p>
<h1>Problem</h1>
<h2>JG Question</h2>
<p>1. What do the <span style="color:#2e74b5;">override</span> and <span style="color:#2e74b5;">final</span> keywords do? Why are they useful?</p>
<h2>Guru Question</h2>
<p>2. In your travels through the dusty corners of your company&#8217;s code archives, you come across the following program fragment written by an unknown programmer. The programmer seems to have been experimenting to see how some C++ features worked.</p>
<p style="margin-left:14pt;">(a) What could be improved in the code&#8217;s correctness or style?</p>
<p style="margin-left:14pt;">(b) What did the programmer probably expect the program to print, but what is the actual result?</p>
<pre><code>class base {
public:
    virtual void f( int );
    virtual void f( double );
    virtual void g( int i = 10 );
};

void base::f( int ) {
    cout &lt;&lt; "base::f(int)" &lt;&lt; endl;
}

void base::f( double ) {
    cout &lt;&lt; "base::f(double)" &lt;&lt; endl;
}

void base::g( int i ) {
    cout &lt;&lt; i &lt;&lt; endl;
}

class derived: public base {
public:
    void f( complex&lt;double&gt; );
    void g( int i = 20 );
};

void derived::f( complex&lt;double&gt; ) {
    cout &lt;&lt; "derived::f(complex)" &lt;&lt; endl;
}

void derived::g( int i ) {
    cout &lt;&lt; "derived::g() " &lt;&lt; i &lt;&lt; endl;
}

int main() {
    base    b;
    derived d;
    base*   pb = new derived;

    b.f(1.0);
    d.f(1.0);
    pb-&gt;f(1.0);

    b.g();
    d.g();
    pb-&gt;g();

    delete pb;
}
</code></pre>
<h1>Solution</h1>
<h2>1. What do the override and final keywords do? Why are they useful?</h2>
<p>These keywords give explicit control over virtual function overriding. Writing <span style="color:#2e74b5;">override</span> declares the intent to override a base class virtual function. Writing <span style="color:#2e74b5;">final</span> makes a virtual function no longer overrideable in further-derived classes, or a class no longer permitted to have further-derived classes.</p>
<p>They are useful because they let the programmer explicitly declare intent in a way the language can enforce at compile time. If you write <span style="color:#2e74b5;">override</span> but there is no matching base class function, or you write <span style="color:#2e74b5;">final</span> and a further-derived class tries to implicitly or explicitly override the function anyway, you get a compile-time error.</p>
<p>Of the two, by far the more commonly useful is <span style="color:#2e74b5;">override</span>; uses for <span style="color:#2e74b5;">final</span> are rarer.</p>
<h2>2. (a) What could be improved in the code&#8217;s correctness or style?</h2>
<p>First, let&#8217;s consider some style issues, and one real error:</p>
<h3>1. The code uses explicit new, delete, and an owning *.</h3>
<p>Avoid using owning raw pointers and explicit <span style="color:#2e74b5;">new</span> and <span style="color:#2e74b5;">delete</span> except in rare cases like when you&#8217;re writing the internal implementation details of a low-level data structure.</p>
<pre><code>{
    base*   pb = new derived;

    ...

    delete pb;
}
</code></pre>
<p>Instead of <span style="color:#2e74b5;">new</span> and <span style="color:#2e74b5;">base*</span>, use <span style="color:#2e74b5;">make_unique</span> and <span style="color:#2e74b5;">unique_ptr&lt;base&gt;</span>.</p>
<pre><code>{
    auto pb = unique_ptr&lt;base&gt;{ make_unique&lt;derived&gt;() };

    ...

} // automatic delete here
</code></pre>
<blockquote><p><strong>Guideline:</strong> Don&#8217;t use explicit <strong>new</strong>, <strong>delete</strong>, and owning <strong>*</strong> pointers, except in rare cases encapsulated inside the implementation of a low-level data structure.</p></blockquote>
<p>However, that <span style="color:#2e74b5;">delete</span> brings us to another issue unrelated to how we allocate and manage the lifetime of the object, namely:</p>
<h3>2. base&#8217;s destructor should be virtual or protected.</h3>
<pre><code>class base {
public:
    virtual void f( int );
    virtual void f( double );
    virtual void g( int i = 10 );
};
</code></pre>
<p>This looks innocuous, but the writer of <span style="color:#2e74b5;">base</span> forgot to make the destructor either <span style="color:#2e74b5;">virtual</span> or <span style="color:#2e74b5;">protected</span>. As it is, deleting via a pointer-to-base without a virtual destructor is evil, pure and simple, and corruption is the best thing you can hope for because the wrong destructor will get called, <span style="color:#2e74b5;">derived</span> class members won&#8217;t be destroyed, and <span style="color:#2e74b5;">operator delete</span> will be invoked with the wrong object size.</p>
<blockquote><p><strong>Guideline: </strong>Make base class destructors public and virtual, or protected and nonvirtual.</p></blockquote>
<p>Exactly one of the following can be true for a polymorphic type:</p>
<ul>
<li>Either destruction via a pointer to base is allowed, in which case the function has to be <span style="color:#2e74b5;">public</span> and had better be <span style="color:#2e74b5;">virtual</span>;</li>
<li>or else it isn&#8217;t, in which case the function has to be <span style="color:#2e74b5;">protected</span> (<span style="color:#2e74b5;">private</span> is not allowed because the derived destructor must be able to invoke the base destructor) and would naturally also be nonvirtual (when the derived destructor invokes the base destructor, it does so nonvirtually whether declared <span style="color:#2e74b5;">virtual</span> or not).</li>
</ul>
<h3>Interlude</h3>
<p>For the next few points, it&#8217;s important to differentiate three terms:</p>
<ul>
<li>To <strong>overload</strong> a function <span style="color:#2e74b5;">f</span> means to provide another function with the same name in the same scope but with different parameter types. When <span style="color:#2e74b5;">f</span> is actually called, the compiler will try to pick the best match based on the actual parameters that are supplied.</li>
<li>To <strong>override</strong> a virtual function <span style="color:#2e74b5;">f</span> means to provide another function with the same name and the same parameter types in a derived class.</li>
<li>To <strong>hide</strong> a function <span style="color:#2e74b5;">f</span> that exists in an enclosing scope (base class, outer class, or namespace) means to provide another function with the same name in an inner scope (derived class, nested class, or namespace), which will hide the same function name in an enclosing scope.</li>
</ul>
<h3>3. derived::f is neither an override nor an overload.</h3>
<pre><code>    void derived::f( complex&lt;double&gt; )
</code></pre>
<p><span style="color:#2e74b5;">derived</span> does not overload the <span style="color:#2e74b5;">base::f</span> functions, it hides them. This distinction is very important, because it means that <span style="color:#2e74b5;">base::f(int)</span> and <span style="color:#2e74b5;">base::f(double)</span> are not visible in the scope of <span style="color:#2e74b5;">derived</span>.</p>
<p>If the author of <span style="color:#2e74b5;">derived</span> intended to hide the base functions named <span style="color:#2e74b5;">f</span>, then this is all right. Usually, however, the hiding is inadvertent and surprising, and the correct way to bring the names into the scope of derived is to write the using-declaration <span style="color:#2e74b5;">using base::f;</span> inside <span style="color:#2e74b5;">derived</span>.</p>
<blockquote><p><strong>Guideline: </strong>When providing a non-overridden function with the same name as an inherited function, be sure to bring the inherited functions into scope with a <strong>using</strong>-declaration if you don&#8217;t want to hide them.</p></blockquote>
<h3>4. derived::g overrides base::g but doesn&#8217;t say &#8220;override.&#8221;</h3>
<pre><code>    void g( int i = 20 )  /* override */
</code></pre>
<p>This function overrides the base function, so it should say <span style="color:#2e74b5;">override</span> explicitly. This documents the intent, and lets the compiler tell you if you&#8217;re trying to override something that&#8217;s not virtual or you got the signature wrong by mistake.</p>
<blockquote><p><strong>Guideline: </strong>Always write<strong> override</strong> when you intend to override a virtual function.</p></blockquote>
<h3>5. derived::g overrides base::g but changes the default argument.</h3>
<pre><code>    void g( int i = 20 )
</code></pre>
<p>Changing the default argument is decidedly user-unfriendly. Unless you&#8217;re really out to confuse people, don&#8217;t change the default arguments of the inherited functions you override. Yes, this is legal C++, and yes, the result is well-defined; and no, don&#8217;t do it. Further below, we&#8217;ll see just how confusing this can be.</p>
<blockquote><p><strong>Guideline: </strong>Never change the default arguments of overridden inherited functions.</p></blockquote>
<p>We could go one step further:</p>
<blockquote><p><strong>Guideline:</strong> Avoid default arguments on virtual functions in general.</p></blockquote>
<p>Finally, public virtual functions are great when a class is acting as a pure abstract base class (ABC) that only specifies the virtual interface without implementations, like a C# or Java <span style="color:#2e74b5;">interface</span> does.</p>
<blockquote><p><strong>Guideline:</strong> Prefer to have a class contain only public virtual functions, or no public virtual functions (other than the destructor which is special).</p></blockquote>
<blockquote><p>A pure abstract base class should have only public virtual functions. …</p></blockquote>
<p>But when a class is both providing virtual functions and their implementations, consider the Non-Virtual Interface pattern (NVI) that makes the public interface and the virtual interface separate and distinct.</p>
<blockquote><p>… For any other base class, prefer making public member functions non-virtual, and virtual member functions non-public; the former should have any default arguments and can be implemented in terms of the latter.</p></blockquote>
<p>This cleanly separates the public interface from the derivation interface, lets each follow its natural form best suited for its distinct audience, and avoids having one function exist in tension from doing double duty with two responsibilities. Among other benefits, using NVI will often clarify your class&#8217;s design in important ways, including for example that the default arguments which matter to the caller therefore naturally belong on the public interface, not on the virtual interface. Following this pattern means that several classes of potential problems, including this one of virtuals with default arguments, just naturally don&#8217;t arise.</p>
<p>The C++ standard library follows NVI nearly universally, and other modern OO languages and environments have rediscovered this principle for their own library design guidelines, such as in the .NET <a href="http://www.amazon.com/Framework-Design-Guidelines-Conventions-Libraries/dp/0321545613"><em>Framework Design Guidelines</em></a>.</p>
<h2>2. (b) What did the programmer probably expect the program to print, but what is the actual result?</h2>
<p>Now that we have those issues out of the way, let&#8217;s look at the mainline and see whether it does that the programmer intended:</p>
<pre><code>int main() {
    base    b;
    derived d;
    base*   pb = new derived;

    b.f(1.0);
</code></pre>
<p>No problem. This first call invokes <span style="color:#2e74b5;">base::f( double )</span>, as expected.</p>
<pre><code>    d.f(1.0);
</code></pre>
<p>This calls <span style="color:#2e74b5;">derived::f( complex&lt;double&gt; )</span>. Why? Well, remember that <span style="color:#2e74b5;">derived</span> doesn&#8217;t declare <span style="color:#2e74b5;">using base::f;</span> to bring the base functions named <span style="color:#2e74b5;">f</span> into scope, and so clearly <span style="color:#2e74b5;">base::f( int )</span> and <span style="color:#2e74b5;">base::f( double )</span> can&#8217;t be called. They are not present in the same scope as <span style="color:#2e74b5;">derived::f( complex&lt;double&gt; )</span> so as to participate in overloading.</p>
<p>The programmer may have expected this to call <span style="color:#2e74b5;">base::f( double )</span>, but in this case there won&#8217;t even be a compile error because fortunately(?) <span style="color:#2e74b5;">complex&lt;double&gt;</span> provides an implicit conversion from <span style="color:#2e74b5;">double</span>, and so the compiler interprets this call to mean <span style="color:#2e74b5;">derived::f( complex&lt;double&gt;(1.0) )</span>.</p>
<pre><code>    pb-&gt;f(1.0);
</code></pre>
<p>Interestingly, even though the <span style="color:#2e74b5;">base* pb</span> is pointing to a <span style="color:#2e74b5;">derived</span> object, this calls <span style="color:#2e74b5;">base::f( double )</span> because overload resolution is done on the static type (here <span style="color:#2e74b5;">base</span>), not the dynamic type (here <span style="color:#2e74b5;">derived</span>). You have a <span style="color:#2e74b5;">base</span> pointer, you get the <span style="color:#2e74b5;">base</span> interface.</p>
<p>For the same reason, the call <span style="color:#2e74b5;">pb-&gt;f(complex&lt;double&gt;(1.0));</span> would not compile, because there is no satisfactory function in the base interface.</p>
<pre><code>    b.g();
</code></pre>
<p>This prints <span style="color:#2e74b5;">10</span>, because it simply invokes <span style="color:#2e74b5;">base::g( int )</span> whose parameter defaults to the value <span style="color:#2e74b5;">10</span>. No sweat.</p>
<pre><code>    d.g();
</code></pre>
<p>This prints <span style="color:#2e74b5;">derived::g() 20</span>, because it simply invokes <span style="color:#2e74b5;">derived::g( int )</span> whose parameter defaults to the value <span style="color:#2e74b5;">20</span>. Also no sweat.</p>
<pre><code>    pb-&gt;g();
</code></pre>
<p>This prints <span style="color:#2e74b5;">derived::g() 10</span>.</p>
<p>&#8220;Wait a minute!&#8221; you might protest. &#8220;What&#8217;s going on here?&#8221; This result may temporarily lock your mental brakes and bring you to a screeching halt until you realize that what the compiler has done is quite proper. (Although, of course, the programmer of <span style="color:#2e74b5;">derived</span> ought to be taken out into the back parking lot and yelled at.) The thing to remember is that, like overloads, default parameters are taken from the static type (here <span style="color:#2e74b5;">base</span>) of the object, hence the default value of <span style="color:#2e74b5;">10</span> is taken. However, the function happens to be virtual, and so the function actually called is based on the dynamic type (here <span style="color:#2e74b5;">derived</span>) of the object. Again, this can be avoided by avoiding default arguments on virtual functions, such as by following NVI and avoiding public virtual functions entirely.</p>
<pre><code>    delete pb;
}
</code></pre>
<p>Finally, as noted, this shouldn&#8217;t be needed because you should be using <span style="color:#2e74b5;">unique_ptr</span>s which do the cleanup for you, and <span style="color:#2e74b5;">base</span> should have a virtual destructor so that destruction via any pointer to <span style="color:#2e74b5;">base</span> is correct.</p>
<h2>Acknowledgments</h2>
<p>Thanks in particular to the following for their feedback to improve this article: litb1, KrzaQ, mttpd.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/feed/</wfw:commentRss>
		<slash:comments>45</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #5: Overriding Virtual Functions</title>
		<link>https://herbsutter.com/2013/05/20/gotw-5-overriding-virtual-functions/</link>
				<comments>https://herbsutter.com/2013/05/20/gotw-5-overriding-virtual-functions/#comments</comments>
				<pubDate>Mon, 20 May 2013 18:27:25 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1960</guid>
				<description><![CDATA[Virtual functions are a pretty basic feature, but they occasionally harbor subtleties that trap the unwary. If you can answer questions like this one, then you know virtual functions cold, and you&#8217;re less likely to waste a lot of time debugging problems like the ones illustrated below.   Problem JG Question 1. What do the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Virtual functions are a pretty basic feature, but they occasionally harbor subtleties that trap the unwary. If you can answer questions like this one, then you know virtual functions cold, and you&#8217;re less likely to waste a lot of time debugging problems like the ones illustrated below.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What do the <span style="color:#2e74b5;">override</span> and <span style="color:#2e74b5;">final</span> keywords do? Why are they useful?
</p>
<h2>Guru Question<br />
</h2>
<p>2. In your travels through the dusty corners of your company&#8217;s code archives, you come across the following program fragment written by an unknown programmer. The programmer seems to have been experimenting to see how some C++ features worked.
</p>
<p style="margin-left:14pt;">(a) What could be improved in the code&#8217;s correctness or style?
</p>
<p style="margin-left:14pt;">(b) What did the programmer probably expect the program to print, but what is the actual result?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class base {<br />public:<br />    virtual void f( int );<br />    virtual void f( double );<br />    virtual void g( int i = 10 );<br />};<br /><br />void base::f( int ) {<br />    cout &lt;&lt; "base::f(int)" &lt;&lt; endl;<br />}<br /><br />void base::f( double ) {<br />    cout &lt;&lt; "base::f(double)" &lt;&lt; endl;<br />}<br /><br />void base::g( int i ) {<br />    cout &lt;&lt; i &lt;&lt; endl;<br />}<br /><br />class derived: public base {<br />public:<br />    void f( complex&lt;double&gt; );<br />    void g( int i = 20 );<br />};<br /><br />void derived::f( complex&lt;double&gt; ) {<br />    cout &lt;&lt; "derived::f(complex)" &lt;&lt; endl;<br />}<br /><br />void derived::g( int i ) {<br />    cout &lt;&lt; "derived::g() " &lt;&lt; i &lt;&lt; endl;<br />}<br /><br />int main() {<br />    base    b;<br />    derived d;<br />    base*   pb = new derived;<br /><br />    b.f(1.0);<br />    d.f(1.0);<br />    pb-&gt;f(1.0);<br /><br />    b.g();<br />    d.g();<br />    pb-&gt;g();<br /><br />    delete pb;<br />}
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/20/gotw-5-overriding-virtual-functions/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #4 Solution: Class Mechanics</title>
		<link>https://herbsutter.com/2013/05/20/gotw-4-class-mechanics/</link>
				<comments>https://herbsutter.com/2013/05/20/gotw-4-class-mechanics/#comments</comments>
				<pubDate>Mon, 20 May 2013 18:22:22 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1957</guid>
				<description><![CDATA[How good are you at the details of writing classes? This item focuses not only on blatant errors, but even more so on professional style. Understanding these principles will help you to design classes that are easier to use and easier to maintain.   Problem JG Question 1. What makes interfaces &#8220;easy to use correctly, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>How good are you at the details of writing classes? This item focuses not only on blatant errors, but even more so on professional style. Understanding these principles will help you to design classes that are easier to use and easier to maintain.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What makes interfaces &#8220;easy to use correctly, hard to use incorrectly&#8221;? Explain.
</p>
<h2>Guru Question<br />
</h2>
<p>2. You are doing a code review. A programmer has written the following class, which shows some poor style and has some real errors. How many can you find, and how would you fix them?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class complex {<br />public:<br />    complex( double r, double i = 0 )<br />        : real(r), imag(i)<br />    { }<br /><br />    void operator+ ( complex other ) {<br />        real = real + other.real;<br />        imag = imag + other.imag;<br />    }<br /><br />    void operator&lt;&lt;( ostream os ) {<br />        os &lt;&lt; "(" &lt;&lt; real &lt;&lt; "," &lt;&lt; imag &lt;&lt; ")";<br />    }<br /><br />    complex operator++() {<br />        ++real;<br />        return *this;<br />    }<br /><br />    complex operator++( int ) {<br />        auto temp = *this;<br />        ++real;<br />        return temp;<br />    }<br /><br />    // ... more functions that complement the above ...<br /><br />private:<br />    double real, imag;<br />};
</code></pre>
</p>
<p>Note: This is not intended to be a complete class. For example, if you provide <span style="color:#2e74b5;">operator++</span> you would normally also provide <span style="color:#2e74b5;">operator&#8211;</span>. Rather, this is an instructive example to focus on the mechanics of writing correctly the kinds of functions this class is trying to support.
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What makes interfaces &#8220;easy to use correctly, hard to use incorrectly&#8221;? Explain.<br />
</h2>
<p>We want to enable a <a href="http://blogs.msdn.com/b/brada/archive/2003/10/02/50420.aspx">&#8220;pit of success&#8221;</a> where users of our type just naturally fall into good practices—they just naturally write code that is valid, correct, and efficient.
</p>
<p>On the other hand, we want to make it hard for our users to get into trouble—we want code that would be incorrect or inefficient to be invalid (a compile time error if possible) or at least inconvenient and hard to write silently so that we can protect the user from unwelcome surprises.
</p>
<p>Scott Meyers <a href="http://programmer.97things.oreilly.com/wiki/index.php/Make_Interfaces_Easy_to_Use_Correctly_and_Hard_to_Use_Incorrectly">popularized</a> this guidance. See his concise writeup for further examples.
</p>
<p>
 </p>
<h2>2. You are doing a code review. A programmer has written the following class, which shows some poor style and has some real errors. How many can you find, and how would you fix them?<br />
</h2>
<p>This class has a lot of problems—even more than I will show explicitly here. The point of this puzzle was primarily to highlight class mechanics (issues like &#8220;what is the canonical form of <span style="color:#2e74b5;">operator&lt;&lt;</span>?&#8221; and &#8220;should <span style="color:#2e74b5;">operator+</span> be a member?&#8221;) rather than point out where the interface is just plain poorly designed. However, I will start off with perhaps the two most useful observation first:
</p>
<p>First, this is a code review but the developer doesn&#8217;t seem to have tried to even unit-test his code, else he would have found some glaring problems.
</p>
<p>Second, why write a <span style="color:#2e74b5;">complex</span> class when one already exists in the standard library? And, what&#8217;s more, when the standard one isn&#8217;t plagued with any of the following problems and has been crafted based on years of practice by the best people in our industry? Humble thyself and reuse.
</p>
<blockquote>
<p><strong>Guideline:</strong> Reuse code—especially standard library code—instead of handcrafting your own. It&#8217;s faster, easier, and safer.
</p>
</blockquote>
<p>Perhaps the best way to fix the problems in the <span style="color:#2e74b5;">complex</span> code is to avoid using the class at all, and use the <span style="color:#2e74b5;">std::complex</span> template instead.
</p>
<p>Having said that, it&#8217;s an instructive example, so let&#8217;s go through the class as written and fix the problems as we go. First, the constructor:
</p>
<h3>1. The default constructor is missing.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    complex( double r, double i = 0 )<br />        : real(r), imag(i)<br />    { }
</code></pre>
</p>
<p>Once we supply a user-written constructor, we suppress the implicit generation of the default constructor. Beyond &#8220;easy to use correctly,&#8221; not having a default constructor makes the class annoying to use at all. In this case, we could either default both parameters, or provide a <span style="color:#2e74b5;">complex() = default;</span> and declare the data members with initializers such as <span style="color:#2e74b5;">double real = 0, imag = 0;</span> , or just delegate with <span style="color:#2e74b5;">complex() : complex(0) { }</span> . Just defaulting the parameter is the simplest here.
</p>
<p>Also, as explained in GotW #1, prefer to use <span style="color:#2e74b5;">{ }</span> consistently for initialization rather than <span style="color:#2e74b5;">( )</span> just as a good modern habit. The two mean exactly the same thing in this case, but <span style="color:#2e74b5;">{ }</span> lets us be more consistent, and could catch a few errors during maintenance, such as typos that would invoke <span style="color:#2e74b5;">double</span>-to-<span style="color:#2e74b5;">float</span> narrowing conversions.
</p>
<h3>2. operator+ passes by value.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    void operator+ ( complex other ) {<br />        real = real + other.real;<br />        imag = imag + other.imag;<br />    }
</code></pre>
</p>
<p>Although we&#8217;re about make other changes to this function in a moment, as written this parameter should be passed by <span style="color:#2e74b5;">const&amp;</span> because all we do is read from it.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer passing a read-only parameter by <strong>const&amp;</strong> if you are only going to read from it (not make a copy of it).
</p>
</blockquote>
<h3>3. operator+ modifies this object&#8217;s value.<br />
</h3>
<p>Instead of returning <span style="color:#2e74b5;">void</span>, <span style="color:#2e74b5;">operator+</span> should return a <span style="color:#2e74b5;">complex</span> containing the sum and not modify this object&#8217;s value. Users who write <span style="color:#2e74b5;">val1 + val2</span> and see <span style="color:#2e74b5;">val1</span> changed are unlikely to be impressed by these gratuitously weird semantics. As Scott Meyers is wont to say, when writing a value type, &#8220;do as the <span style="color:#2e74b5;">int</span>s do&#8221; and follow the conventions of the built-in types.
</p>
<h3>4. operator+ is not written in terms of operator+= (which is missing).<br />
</h3>
<p>Really, this <span style="color:#2e74b5;">operator+</span> is trying to be <span style="color:#2e74b5;">operator+=</span>. It should be split into an actual <span style="color:#2e74b5;">operator+</span> and <span style="color:#2e74b5;">operator+=</span>, with the former calling the latter.
</p>
<blockquote>
<p><strong>Guideline: </strong>If you supply a standalone version of an operator (e.g., <strong>operator+</strong>), always supply an assignment version of the same operator (e.g., <strong>operator+=</strong>) and prefer implementing the former in terms of the latter. Also, always preserve the natural relationship between op and op= (where op stands for any operator).
</p>
</blockquote>
<p>Having <span style="color:#2e74b5;">+=</span> is good, because users should prefer using it. Even in the above code, <span style="color:#2e74b5;">real = real + other.real;</span> should be <span style="color:#2e74b5;">real += other.real;</span> and similarly for the second line.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer writing <strong>a op= b</strong> instead of <strong>a = a op b</strong> (where op stands for any operator). It&#8217;s clearer, and it&#8217;s often more efficient.
</p>
</blockquote>
<p>The reason why <span style="color:#2e74b5;">operator+=</span> is more efficient is that it operates on the left-hand object directly and returns only a reference, not a temporary object. On the other hand, <span style="color:#2e74b5;">operator+</span> must return a temporary object. To see why, consider the following canonical forms for how <span style="color:#2e74b5;">operator+=</span> and <span style="color:#2e74b5;">operator+</span> should normally be implemented for some type <span style="color:#2e74b5;">T</span>.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>T&amp; T::operator+=( const T&amp; other ) {<br />    //...<br />    return *this;<br />}<br /><br />T operator+( T a, const T&amp; b ) {<br />    a += b;<br />    return a;<br />}
</code></pre>
</p>
<p>Did you notice that one parameter is passed by value, and one by reference? That&#8217;s because if you&#8217;re going to copy from a parameter anyway, it&#8217;s often better to pass it by value, which will naturally enable a move operation if the caller passes a temporary object such as in expressions like <span style="color:#2e74b5;">(val1 * val2) + val3</span>. This is a good habit to follow even in cases like <span style="color:#2e74b5;">complex</span> where a move is the same cost as a copy, since it doesn&#8217;t cost any efficiency when move and copy are the same, and arguably makes for cleaner code than passing by reference and adding an extra named local object. We&#8217;ll see more on parameter passing in a future GotW.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer passing a read-only parameter by value if you&#8217;re going to make a copy of the parameter anyway, because it enables move from rvalue arguments.
</p>
</blockquote>
<p>Implementing <span style="color:#2e74b5;">+</span> in terms of <span style="color:#2e74b5;">+=</span> both makes the code simpler and guarantees consistent semantics as the two functions are less likely to diverge during maintenance.
</p>
<h3>5. operator+ should not be a member function.<br />
</h3>
<p>If <span style="color:#2e74b5;">operator+</span> is made a member function, as it is here, then it won&#8217;t work as naturally as your users may expect when you do decide to allow implicit conversions from other types. Here, an implicit conversion from <span style="color:#2e74b5;">double</span> to <span style="color:#2e74b5;">complex</span> makes sense, but with the original class users have an asymmetry: Specifically, when adding <span style="color:#2e74b5;">complex</span> objects to numeric values, you can write <span style="color:#2e74b5;">a = b + 1.0</span> but not <span style="color:#2e74b5;">a = 1.0 + b</span> because a member <span style="color:#2e74b5;">operator+</span> requires a <span style="color:#2e74b5;">complex</span> (and not a <span style="color:#2e74b5;">double</span>) as its left-hand argument.
</p>
<p>Finally, the other reason to prefer non-members is because they provide better encapsulation, as <a href="http://www.drdobbs.com/cpp/how-non-member-functions-improve-encapsu/184401197">pointed out by Scott Meyers</a>.
</p>
<blockquote>
<p><strong>Guideline: </strong>Prefer these guidelines for making an operator a member vs. nonmember function: unary operators are members; <strong>= () []</strong> and <strong>-&gt;</strong> must be members; the assignment operators (<strong>+= –= /= *=</strong> etc.) must be members; all other binary operators are nonmembers.
</p>
</blockquote>
<h3>6. operator&lt;&lt; should not be a member function.<br />
</h3>
<p>The author of this code didn&#8217;t really mean to enable the syntax <span style="color:#2e74b5;">my_complex &lt;&lt; cout</span>, did they?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    void operator&lt;&lt;( ostream os ) {<br />        os &lt;&lt; "(" &lt;&lt; real &lt;&lt; "," &lt;&lt; imag &lt;&lt; ")";<br />    }
</code></pre>
</p>
<p>The same reasons already given to show why <span style="color:#2e74b5;">operator+</span> should be a nonmember apply also to <span style="color:#2e74b5;">operator&lt;&lt;</span>, only more so because a member the first parameter has to be a stream, not a <span style="color:#2e74b5;">complex</span>. Further, the parameters should be references: <span style="color:#2e74b5;">(ostream&amp;, const complex &amp;)</span>.
</p>
<p>Note also that the nonmember <span style="color:#2e74b5;">operator&lt;&lt;</span> should normally be implemented in terms of a(n often virtual) <span style="color:#2e74b5;">const</span> member function that does the work, usually named something like <span style="color:#2e74b5;">print</span>.
</p>
<h3>7. operator&lt;&lt; should return ostream&amp;.<br />
</h3>
<p>Further, <span style="color:#2e74b5;">operator&lt;&lt;</span> should have a return type of <span style="color:#2e74b5;">ostream&amp;</span> and should return a reference to the stream in order to permit chaining. That way, users can use your <span style="color:#2e74b5;">operator&lt;&lt;</span> naturally in code like <span style="color:#2e74b5;">cout &lt;&lt; a &lt;&lt; b;</span>.
</p>
<blockquote>
<p><strong>Guideline: </strong>Always return stream references from <strong>operator&lt;&lt;</strong> and <strong>operator&gt;&gt;</strong>.
</p>
</blockquote>
<h3>8. The preincrement operator&#8217;s return type is incorrect.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    complex operator++() {<br />        ++real;<br />        return *this;<br />    }
</code></pre>
</p>
<p>Ignoring for the sake of argument whether preincrement is meaningful for <span style="color:#2e74b5;">complex</span> numbers, if the function exists it should return a reference. This lets client code operate more intuitively and avoids needless inefficiency.
</p>
<blockquote>
<p><strong>Guideline: </strong>When you <strong>return *this</strong>, the return type should usually be a reference.
</p>
</blockquote>
<h3>9. Postincrement should be implemented in terms of preincrement.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    complex operator++( int ) {<br />        auto temp = *this;<br />        ++real;<br />        return temp;<br />    }
</code></pre>
</p>
<p>Instead of repeating the work, prefer to call <span style="color:#2e74b5;">++*this</span>. See GotW #2 for the full canonical form for postincrement.
</p>
<blockquote>
<p><strong>Guideline: </strong>For consistency, always implement postincrement in terms of preincrement, otherwise your users will get surprising (and often unpleasant) results.
</p>
</blockquote>
<h3>Summary<br />
</h3>
<p>That&#8217;s it. There are other modern C++ features we could apply here, but they would be arguably gratuitous and not appropriate for general recommendations. For example, this is a value type not designed to be inherited from, so we could prevent inheritance by making the class <span style="color:#2e74b5;">final</span>, but that would be protecting against Machiavelli, not Murphy, and there&#8217;s no need for a general guideline that tells everyone they should now write <span style="color:#2e74b5;">final</span> on every value type; that would just be tedious and unnecessary.
</p>
<p>Here&#8217;s a corrected version of the class, ignoring design and style issues not explicitly noted above:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class complex {<br />public:<br />    complex( double r = 0, double i = 0 )<br />        : real{r}, imag{i}<br />    { }<br /><br />    complex&amp; operator+=( const complex&amp; other ) {<br />        real += other.real;<br />        imag += other.imag;<br />        return *this;<br />    }<br /><br />    complex&amp; operator++() {<br />        ++real;<br />        return *this;<br />    }<br /><br />    complex operator++( int ) {<br />        auto temp = *this;<br />        ++*this;<br />        return temp;<br />    }<br /><br />    ostream&amp; print( ostream&amp; os ) const {<br />        return os &lt;&lt; "(" &lt;&lt; real &lt;&lt; "," &lt;&lt; imag &lt;&lt; ")";<br />    }<br /><br />private:<br />    double real, imag;<br />};<br /><br />complex operator+( complex lhs, const complex&amp; rhs ) {<br />    lhs += rhs;<br />    return lhs;<br />}<br /><br />ostream&amp; operator&lt;&lt;( ostream&amp; os, const complex&amp; c ) {<br />    return c.print(os);<br />}
</code></pre>
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: Mikhail Belyaev, jlehrer, Olaf van der Spek, Marshall, litb1, hm, Dave Harris, nosenseetal.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/20/gotw-4-class-mechanics/feed/</wfw:commentRss>
		<slash:comments>39</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #4: Class Mechanics (7/10)</title>
		<link>https://herbsutter.com/2013/05/16/gotw-4-class-mechanics-710/</link>
				<comments>https://herbsutter.com/2013/05/16/gotw-4-class-mechanics-710/#comments</comments>
				<pubDate>Thu, 16 May 2013 20:09:32 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1920</guid>
				<description><![CDATA[How good are you at the details of writing classes? This item focuses not only on blatant errors, but even more so on professional style. Understanding these principles will help you to design classes that are easier to use and easier to maintain.   Problem JG Question 1. What makes interfaces &#8220;easy to use correctly, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>How good are you at the details of writing classes? This item focuses not only on blatant errors, but even more so on professional style. Understanding these principles will help you to design classes that are easier to use and easier to maintain.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What makes interfaces &#8220;easy to use correctly, hard to use incorrectly&#8221;? Explain.
</p>
<h2>Guru Question<br />
</h2>
<p>2. You are doing a code review. A programmer has written the following class, which shows some poor style and has some real errors. How many can you find, and how would you fix them?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class complex {<br />public:<br />    complex( double r, double i = 0 )<br />        : real(r), imag(i)<br />    { }<br /><br />    void operator+ ( complex other ) {<br />        real = real + other.real;<br />        imag = imag + other.imag;<br />    }<br /><br />    void operator&lt;&lt;( ostream os ) {<br />        os &lt;&lt; "(" &lt;&lt; real &lt;&lt; "," &lt;&lt; imag &lt;&lt; ")";<br />    }<br /><br />    complex operator++() {<br />        ++real;<br />        return *this;<br />    }<br /><br />    complex operator++( int ) {<br />        auto temp = *this;<br />        ++real;<br />        return temp;<br />    }<br /><br />    // ... more functions that complement the above ...<br /><br />private:<br />    double real, imag;<br />};
</code></pre>
</p>
<p>Note: This is not intended to be a complete class. For example, if you provide <span style="color:#2e74b5;">operator++</span> you would normally also provide <span style="color:#2e74b5;">operator&#8211;</span>. Rather, this is an instructive example to focus on the mechanics of writing correctly the kinds of functions this class is trying to support.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/16/gotw-4-class-mechanics-710/feed/</wfw:commentRss>
		<slash:comments>34</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #3 Solution: Using the Standard Library (or, Temporaries Revisited)</title>
		<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/</link>
				<comments>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comments</comments>
				<pubDate>Thu, 16 May 2013 19:58:23 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1912</guid>
				<description><![CDATA[Effective reuse is an important part of good software engineering. To demonstrate how much better off you can be by using standard library algorithms instead of handcrafting your own, let&#8217;s reconsider the previous question to demonstrate how many of the problems could have been avoided by simply reusing what&#8217;s already available in the standard library. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Effective reuse is an important part of good software engineering. To demonstrate how much better off you can be by using standard library algorithms instead of handcrafting your own, let&#8217;s reconsider the previous question to demonstrate how many of the problems could have been avoided by simply reusing what&#8217;s already available in the standard library.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the most widely used C++ library?
</p>
<h2>Guru Question<br />
</h2>
<p>2. How many of the pitfalls in GotW #2 could have been avoided in the first place, if only the programmer had replaced the explicit iterator-based <span style="color:#2e74b5;">for</span> loop with:
</p>
<p style="margin-left:36pt;">(a) a range-based <span style="color:#2e74b5;">for</span> loop?
</p>
<p style="margin-left:36pt;">(b) a standard library algorithm call?
</p>
<p>Demonstrate. (Note: As with GotW #2, don&#8217;t change the semantics of the function, even though they could be improved.)
</p>
<p>To recap, here is the mostly-fixed function:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {<br />    for( auto i = begin(emps);  i != end(emps); ++i ) {<br />        if( i-&gt;name() == name ) {<br />            return i-&gt;addr;<br />        }<br />    }<br />    return "";<br />}
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What is the most widely used C++ library?<br />
</h2>
<p>The C++ standard library, with its implementations on every platform.
</p>
<p>
 </p>
<h2>2. (a) How many of the pitfalls in GotW #2 could have been avoided with a range-based for loop?<br />
</h2>
<p>Astute readers of GotW #2 will have been champing at the bit to say: &#8220;Why aren&#8217;t you using a range-based <span style="color:#2e74b5;">for</span> loop?&#8221; Indeed, why not? That would solve several of the temporaries, never mind be easier to write.
</p>
<p>Compare the original unimproved explicit iterator loop:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    for( auto i = begin(emps); i != end(emps); i++ ) {<br />        if( *i == name ) {<br />            return i-&gt;addr;<br />        }<br />    }
</code></pre>
</p>
<p>with the range-based <span style="color:#2e74b5;">for</span> loop (bonus points if you remembered to write the <span style="color:#2e74b5;">const auto&amp;</span>):
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    for( const auto&amp; e : emps ) {<br />        if( e == name ) {<br />            return e.addr;<br />        }<br />    }
</code></pre>
</p>
<p>The expressions <span style="color:#2e74b5;">e == name</span> and <span style="color:#2e74b5;">return e.addr;</span> are unchanged in terms of their possible or actual temporaries. But the questions in the naked loop code about whether or not the <span style="color:#2e74b5;">=</span> causes a temporary (recall: it doesn&#8217;t), whether or not <span style="color:#2e74b5;">end()</span> recalculation matters and should be hoisted (recall: probably not, but maybe), and whether or not <span style="color:#2e74b5;">i++</span> should be rewritten <span style="color:#2e74b5;">++i</span> (recall: it should) all simply don&#8217;t arise in the range-<span style="color:#2e74b5;">for</span> code. Such is the power of clear code, and using a higher level of abstraction.
</p>
<p>A key advantage is that using the range-based <span style="color:#2e74b5;">for</span> loop has increased our level of abstraction, the information density in our code. Consider: What can you say about the following two pieces of code without reading what comes next?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    for( auto i = begin(emps); i != end(emps); i++ ) {   // A<br /><br />    for( const auto&amp; e : emps ) {                        // B
</code></pre>
</p>
<p>At first it might seem that lines A and B convey the same information, but they don&#8217;t. When you see A, all you know is that there&#8217;s a loop of some sort that uses an iterator over <span style="color:#2e74b5;">emps</span>. Granted, we&#8217;re so used to A that our eye&#8217;s peripheral vision tends to &#8220;autocomplete&#8221; it in our heads into &#8220;a loop that visits the elements of <span style="color:#2e74b5;">emps</span> in order&#8221; and our autocomplete is often correct—except when it isn&#8217;t: was that a <span style="color:#2e74b5;">++</span>, or a s<span style="color:#2e74b5;">+= 2</span> in a strided loop? is the index modified inside the body? Our peripheral vision might be wrong.
</p>
<p>On the other hand, B conveys more information to the reader. When you see B, you know for certain without inspecting the body of the loop that it is a loop that visits the element of <span style="color:#2e74b5;">emps</span> in order. What&#8217;s more, you&#8217;ve simplified the loop control because there&#8217;s no need for an iterator indirection. Both of these are raising the level of abstraction of our code, and that&#8217;s a good thing.
</p>
<p>Note that, as discussed in GotW #2, the naked <span style="color:#2e74b5;">for</span> loop didn&#8217;t naturally allow consolidating to a single <span style="color:#2e74b5;">return</span> statement without resorting to making the code more complex by adding an additional variable and performing extra computation (a default construction followed by an assignment, instead of just a construction). That&#8217;s still true of the range-based <span style="color:#2e74b5;">for</span> loop form, because it still has the two <span style="color:#2e74b5;">return</span> statements in different scopes.
</p>
<h2>2. (b) … with a standard library algorithm call?<br />
</h2>
<p>With no other changes, simply using the standard <span style="color:#2e74b5;">find</span> algorithm could do everything the range-based <span style="color:#2e74b5;">for</span> loop did to avoid needless temporaries (and questions about them):
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Better (focusing on internals)<br />//<br />string find_addr( /*...*/ ) {<br />    const auto i = find( begin(emps), end(emps), name );   // TFTFY<br />    return i != end(emps) ? i-&gt;addr : "";<br />}
</code></pre>
</p>
<p>This naturally eliminates the same temporaries as the range-<span style="color:#2e74b5;">for</span> version, and it further increases our level of abstraction. As with the range-based <span style="color:#2e74b5;">for</span> loop, we can see at a glance and for certain that the loop will visit the elements of <span style="color:#2e74b5;">emps</span> in order, but on top of that we also know we&#8217;re trying to <span style="color:#2e74b5;">find</span> something and will get back an iterator to the first matching element if one exists. We do still have an iterator indirection, but only a single-use iterator object and no iterator arithmetic as in the original naked iterator <span style="color:#2e74b5;">for</span> loop.
</p>
<p>Further, we have eliminated a loop nested scope entirely and flattened out the function to a single scope which can simplify this calling function in ways even the range-<span style="color:#2e74b5;">for</span> couldn&#8217;t. To demonstrate still more just how fundamental this point is, note that what else the flattening out of the body buys us: Now, because the <span style="color:#2e74b5;">return</span> statements are in the same scope (possible only because we eliminated the loop scope), we have the option of naturally combining them. You could still write <span style="color:#2e74b5;">if( i != end(emps) ) return i-&gt;addr; else return &#8220;&#8221;;</span> here, on one or two or four lines, but there&#8217;s no need to. To be clear, the point here is not that reducing <span style="color:#2e74b5;">return</span> statements should be a goal in itself—it shouldn&#8217;t be, and &#8220;single exit&#8221; thinking has always been flawed as we already saw in GotW #2. Rather, the point is that using an algorithm often simplifies our code more than an explicit loop, even a range-<span style="color:#2e74b5;">for</span> loop, can do—not only directly by removing extra indirections and extra variables and a loop nested scope, but often also by permitting additional simplifications in nearby code.
</p>
<p>The above code might still cause a temporary when comparing an <span style="color:#2e74b5;">employee</span> with a <span style="color:#2e74b5;">string</span>, and we can eliminate even that temporary if we go one small step further and use <span style="color:#2e74b5;">find_if</span> with a custom comparison that compares <span style="color:#2e74b5;">e.name() == name</span> to avoid a possible conversion, assuming something like a suitable <span style="color:#2e74b5;">employee::name()</span> is available as we did in GotW #2. Combining this with the other fixes to pass parameters by reference, we get:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Better still (complete)<br />//<br />string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {<br />    const auto i = find_if( begin(emps), end(emps),<br />                      [&amp;](const auto&amp; e) { return e.name() == name; } );<br />    return i != end(emps) ? i-&gt;addr : "";<br />}
</code></pre>
</p>
<p>
 </p>
<h2>Summary<br />
</h2>
<p>Prefer algorithm calls over explicit loops, when you have or can write a suitable algorithm that does what you want. They raise the level of abstraction and the clarity of our code. Scott Meyers&#8217; advice in <em>Effective STL</em> is still true, and more applicable than even now that lambdas make algorithms much more usable than before:
</p>
<blockquote>
<p><strong>Guideline: </strong>Prefer algorithm calls to explicit loops. Algorithm calls are often clearer and reduce complexity. If no suitable algorithm exists, why not write it? You&#8217;ll use it again.
</p>
</blockquote>
<p>Prefer reusing existing library code to handcrafting your own. The more widely used the library, the more likely it is to come well-designed, pre-debugged, and pre-optimized for many common requirements. And what library is more widely used than the standard library? In your C++ program, your standard library implementation is the most widely used library code you&#8217;re likely to use. This helps you both in the library&#8217;s design and its implementation: It&#8217;s full of code that&#8217;s intended to be used and reused, and to that end a lot of thought and care has gone into the design of its features, including its standard algorithms like <span style="color:#2e74b5;">find</span> and <span style="color:#2e74b5;">sort</span>. Implementers have also spent hours sweating over efficiency details, and usability details, and all sorts of other considerations so that you don&#8217;t have to—including performing optimizations you should almost never resort to in application-level code, such as using nonportable OS- and CPU-target specific optimizations.
</p>
<p>So, always prefer to reuse code, especially algorithms and especially the standard library, and escape the trap of &#8220;I&#8217;ll-write-my-own-just-&#8217;cause-I-can.&#8221;
</p>
<blockquote>
<p><strong>Guideline: </strong>Reuse code—especially standard library code—instead of handcrafting your own. It&#8217;s faster, easier, and safer.
</p>
</blockquote>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: Olaf ven der Spek, Sam Kramer.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/feed/</wfw:commentRss>
		<slash:comments>32</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #3: Using the Standard Library (or, Temporaries Revisited) (3/10)</title>
		<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/</link>
				<comments>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comments</comments>
				<pubDate>Mon, 13 May 2013 12:31:55 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1888</guid>
				<description><![CDATA[Effective reuse is an important part of good software engineering. To demonstrate how much better off you can be by using standard library algorithms instead of handcrafting your own, let&#8217;s reconsider the previous question to demonstrate how many of the problems could have been avoided by simply reusing what&#8217;s already available in the standard library. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Effective reuse is an important part of good software engineering. To demonstrate how much better off you can be by using standard library algorithms instead of handcrafting your own, let&#8217;s reconsider the previous question to demonstrate how many of the problems could have been avoided by simply reusing what&#8217;s already available in the standard library.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the most widely used C++ library?
</p>
<h2>Guru Question<br />
</h2>
<p>2. How many of the pitfalls in GotW #2 could have been avoided in the first place, if only the programmer had replaced the explicit iterator-based <span style="color:#2e74b5;">for</span> loop with:
</p>
<p style="margin-left:36pt;">(a) a range-based <span style="color:#2e74b5;">for</span> loop?
</p>
<p style="margin-left:36pt;">(b) a standard library algorithm call?
</p>
<p>Demonstrate. (Note: As with GotW #2, don&#8217;t change the semantics of the function, even though they could be improved.)
</p>
<p>To recap, here is the mostly-fixed function:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {<br />    for( auto i = begin(emps);  i != end(emps); ++i ) {<br />        if( i-&gt;name() == name ) {<br />            return i-&gt;addr;<br />        }<br />    }<br />    return "";<br />}
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/feed/</wfw:commentRss>
		<slash:comments>35</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #2 Solution: Temporary Objects</title>
		<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/</link>
				<comments>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comments</comments>
				<pubDate>Mon, 13 May 2013 12:30:54 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1874</guid>
				<description><![CDATA[Unnecessary and/or temporary objects are frequent culprits that can throw all your hard work—and your program&#8217;s performance—right out the window. How can you spot them and avoid them?   Problem JG Question 1. What is a temporary object? Guru Question 2. You are doing a code review. A programmer has written the following function, which [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Unnecessary and/or temporary objects are frequent culprits that can throw all your hard work—and your program&#8217;s performance—right out the window. How can you spot them and avoid them?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is a temporary object?
</p>
<h2>Guru Question<br />
</h2>
<p>2. You are doing a code review. A programmer has written the following function, which uses unnecessary temporary or extra objects in at least three places. How many can you identify, and how should the programmer fix them?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>string find_addr( list&lt;employee&gt; emps, string name ) {<br />    for( auto i = begin(emps); i != end(emps); i++ ) {<br />        if( *i == name ) {<br />            return i-&gt;addr;<br />        }<br />    }<br />    return "";<br />}
</code></pre>
</p>
<p>Do not change the operational semantics of this function, even though they could be improved.
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What is a temporary object?<br />
</h2>
<p>Informally, a temporary object is an unnamed object that you can&#8217;t take the address of. A temporary is often created as an intermediate value during the evaluation of an expression, such as an object created by returning a value from a function, performing an implicit conversion, or throwing an exception. We usually call a temporary object an &#8220;rvalue,&#8221; so named because it can appear on the &#8220;r&#8221;ight hand side of an assignment. Here are some simple examples:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code><span style="background-color:yellow;">widget</span> f();            // f returns a temporary widget object<br /><br />auto a = 0, b = 1;<br />auto c = <span style="background-color:yellow;">a + b</span>;        // "a+b" creates a temporary int object
</code></pre>
</p>
<p>In contrast, in the same code we have objects like <span style="color:#2e74b5;">a</span> and <span style="color:#2e74b5;">c</span> that do each have a name and a memory address. Such an object is usually called an &#8220;lvalue,&#8221; because it can appear on the &#8220;l&#8221;eft hand side of an assignment.
</p>
<p>That&#8217;s a simplification of the truth, but it&#8217;s generally all you need to know. More precisely, C++ now has five categories of values, but distinguishing them is primarily useful for writing down the language specification, and you can mostly ignore them and just think about &#8220;rvalues&#8221; for temporary objects without names and whose addresses can&#8217;t be taken, and &#8220;lvalues&#8221; for non-temporary objects that have names and whose addresses can be taken.
</p>
<p>
 </p>
<h2>2. How many unnecessary temporary objects can you identify, and how should the programmer fix them?<br />
</h2>
<p>Believe it or not, this short function harbors three obvious cases of unnecessary temporaries or extra copies of objects, two subtler ones, and three red herrings.
</p>
<h3>The parameters are passed by value.<br />
</h3>
<p>The most obvious extra copies are buried in the function signature itself:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>  string find_addr( list&lt;employee&gt; emps, string name )
</code></pre>
</p>
<p>The parameters should be passed by <span style="color:#2e74b5;">const&amp;</span>—that is, <span style="color:#2e74b5;">const list&lt;employee&gt;&amp;</span> and <span style="color:#2e74b5;">const string&amp;</span>, respectively—instead of by value. Pass-by-value forces the compiler to make complete copy of both objects, which can be expensive and, here, is completely unnecessary.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer passing a read-only parameter by <strong>const&amp;</strong> if you are only going to read from it (not make a copy of it).
</p>
</blockquote>
<p>Pedantic note: Yes, with pass-by-value, if the caller passed a temporary <span style="color:#2e74b5;">list</span> or <span style="color:#2e74b5;">string</span> argument then it could be moved from rather than copied. But I&#8217;m deliberately saying &#8220;forces the compiler to make a complete copy&#8221; here because no caller is realistically going to be passing a temporary <span style="color:#2e74b5;">list</span> to <span style="color:#2e74b5;">find_addr</span>, except by mistake.
</p>
<h3>Non-issue: Initializing with &#8220;=&#8221;.<br />
</h3>
<p>Next we come to the first red herring, in the <span style="color:#2e74b5;">for</span> loop&#8217;s initialization:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    for( auto i = begin(emps); /*...*/ )
</code></pre>
</p>
<p>You might be tempted to say that this code should prefer to be spelled <span style="color:#2e74b5;">auto i(begin(emps))</span> rather than <span style="color:#2e74b5;">auto i = begin(emps)</span>, on the grounds that the <span style="color:#2e74b5;">=</span> syntax incurs an extra temporary object, even if it might be optimized away. After all, as we saw in GotW #1, usually that extra <span style="color:#2e74b5;">=</span> means the two-step &#8220;convert to a temporary then copy/move&#8221; of copy-initialization—but recall that doesn&#8217;t apply when using <span style="color:#2e74b5;">auto</span> like this. Why?
</p>
<p>Remember that <span style="color:#2e74b5;">auto</span> always deduces the exact type of the initializer expression, minus top-level <span style="color:#2e74b5;">const</span> and <span style="color:#2e74b5;">&amp;</span> which don&#8217;t matter for conversions, and so… presto! there cannot be any need for a conversion and we directly construct <span style="color:#2e74b5;">i</span>.
</p>
<p>So there is no difference between <span style="color:#2e74b5;">auto i(begin(emps))</span> and <span style="color:#2e74b5;">auto i = begin(emps)</span>. Which syntax you choose is up to you, but it depends only on taste, not on temporaries or any other performance or semantic difference.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer declaring variables using <strong>auto</strong>. Among other reasons to do so, it naturally guarantees zero extra temporaries due to implicit conversions.
</p>
</blockquote>
<h3>The end of the range is recalculated on each loop iteration.<br />
</h3>
<p>Another potential avoidable temporary occurs in the <span style="color:#2e74b5;">for</span> loop&#8217;s termination condition:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>  for( /*...*/ ; i != end(emps); /*...*/ )
</code></pre>
</p>
<p>For most containers, including <span style="color:#2e74b5;">list</span>, calling <span style="color:#2e74b5;">end()</span> returns a temporary object that must be constructed and destroyed, even though the value will not change.
</p>
<p>Normally when a value will not change, instead of recomputing it (and reconstructing and redestroying it) on every loop iteration, we would want to compute the value only once, store it in a local object, and reuse it.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer precomputing values that won&#8217;t change, instead of recreating objects unnecessarily.
</p>
</blockquote>
<p>However, a caution is in order: In practice, for simple inline functions like <span style="color:#2e74b5;">list&lt;T&gt;::end()</span> in particular used in a loop, compilers routinely notice their values won&#8217;t change and hoist them out of the loop for you without you having to do it yourself. So I actually don&#8217;t recommend any change to hoist the <span style="color:#2e74b5;">end</span> calculation here, because that would make the code slightly more complex and the definition of premature optimization is making the code more complex in the name of efficiency without data that it&#8217;s actually needed. Clarity comes first:
</p>
<blockquote>
<p><strong><em>Definition</em>: Premature optimization</strong> is when you make code more complex in the name of efficiency without data that it&#8217;s actually needed.
</p>
</blockquote>
<blockquote>
<p><strong>Guideline:</strong> Write for clarity and correctness first. Don&#8217;t optimize prematurely, before you have profiler data proving the optimization is needed, especially in the case of calls to simple inline calls to short functions that compilers normally can handle for you.
</p>
</blockquote>
<h3>The iterator increment uses postincrement.<br />
</h3>
<p>Next, consider the way we increment <span style="color:#2e74b5;">i</span> in the for loop:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>  for( /*...*/ ; i++ )
</code></pre>
</p>
<p>This temporary is more subtle, but it&#8217;s easy to understand once you remember how preincrement and postincrement differ. Postincrement is usually less efficient than preincrement because it has to remember and return its original value.
</p>
<p>Postincrement for a class <span style="color:#2e74b5;">T</span> should normally be implemented using the canonical form as follows:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>T T::operator++(int)() {<br />    auto old = *this; // remember our original value<br />    ++*this;          // always implement postincr in terms of preincr<br />    return old;       // return our original value<br />}
</code></pre>
</p>
<p>Now it&#8217;s easy to see why postincrement is less efficient than preincrement: Postincrement has to do all the same work as preincrement, but in addition it also has to construct and return another object containing the original value.
</p>
<blockquote>
<p><strong>Guideline:</strong> For consistency, always implement postincrement in terms of preincrement, otherwise your users will get surprising (and often unpleasant) results.
</p>
</blockquote>
<p>In the problem&#8217;s code, the original value is never used, and so there&#8217;s no reason to use postincrement. Preincrement should be used instead. Although the difference is unlikely to matter for a built-in type or a simple iterator type, where the compiler can often optimize away the extra unneeded work for you, it&#8217;s still a good habit not to ask for more than you need.
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer preincrement. Only use postincrement if you&#8217;re going to use the original value.
</p>
</blockquote>
<p> &#8220;But wait, you&#8217;re being inconsistent!&#8221; I can just hear someone saying. &#8220;That&#8217;s premature optimization. You said that compilers can hoist the <span style="color:#2e74b5;">end()</span> call out of the loop, and it&#8217;s just as easy for a compiler to optimize away this postincrement temporary.&#8221;
</p>
<p>That&#8217;s true, but it doesn&#8217;t imply premature optimization. Preferring <span style="color:#2e74b5;">++i</span> does not mean writing more complex code in the name of performance before you can prove it&#8217;s needed—<span style="color:#2e74b5;">++i</span> is not more complex than <span style="color:#2e74b5;">i++</span>, so it&#8217;s not as if you need performance data to justify using it! Rather, preferring <span style="color:#2e74b5;">++i</span> is <em>avoiding premature pessimization</em>, which means avoiding writing equivalently complex code that needlessly asks for extra work that it&#8217;s just going to ignore anyway.
</p>
<blockquote>
<p><strong><em>Definition</em>: Premature pessimization</strong> is when you write code that is slower than it needs to be, usually by asking for unnecessary extra work, when equivalently complex code would be faster and should just naturally flow out of your fingers.
</p>
</blockquote>
<h3>The comparison might use an implicit conversion.<br />
</h3>
<p>Next, we come to this:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    if( *i == name )
</code></pre>
</p>
<p>The <span style="color:#2e74b5;">employee</span> class isn&#8217;t shown in the problem, but we can deduce a few things about it. For this code to work, <span style="color:#2e74b5;">employee</span> likely must either have a conversion to <span style="color:#2e74b5;">string</span> or a conversion constructor taking a <span style="color:#2e74b5;">string</span>. Both cases create a temporary object, invoking either <span style="color:#2e74b5;">operator==</span> for <span style="color:#2e74b5;">string</span>s or <span style="color:#2e74b5;">operator==</span> for <span style="color:#2e74b5;">employee</span>s. (Only if there does happen to be an <span style="color:#2e74b5;">operator==</span> that takes one of each, or <span style="color:#2e74b5;">employee</span> has a conversion to a reference, that is, <span style="color:#2e74b5;">string&amp;</span>, is a temporary not needed.)
</p>
<blockquote>
<p><strong>Guideline: </strong>Watch out for hidden temporaries created by implicit conversions. One good way to avoid this is to make constructors and conversion operators <strong>explicit</strong> by default unless implicit conversions are really desirable.
</p>
</blockquote>
<h3>Probably a non-issue: return &#8220;&#8221;.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    return "";
</code></pre>
</p>
<p>Here we unavoidably create a temporary (unless we change the return type, but we shouldn&#8217;t; see below), but the question is: Is there a better way?
</p>
<p>As written, <span style="color:#2e74b5;">return &#8220;&#8221;;</span> calls the <span style="color:#2e74b5;">string</span> constructor that takes a <span style="color:#2e74b5;">const char*</span>, and if the <span style="color:#2e74b5;">string</span> implementation you&#8217;re using either (a) is smart enough to check for the case where it&#8217;s being passed an empty string, or (b) uses the small string optimization (SSO) that stores strings up to a certain size directly within the string object instead of on the heap, no heap allocation will happen.
</p>
<p>Indeed, every <span style="color:#2e74b5;">string</span> implementation I checked is smart enough not to perform an allocation here, which is maximally efficient for <span style="color:#2e74b5;">string</span>, and so in practice there&#8217;s nothing to optimize. But what alternatives do we have? Let&#8217;s consider two.
</p>
<p>First, you might consider re-spelling this as <span style="color:#2e74b5;">return &#8220;&#8221;s;</span> which is new in C++14. That essentially relies on the same implementation smarts to check for empty strings or to use SSO, just in a different function—the literal <span style="color:#2e74b5;">operator&#8221;&#8221;</span>.
</p>
<p>Second, you might consider re-spelling this as <span style="color:#2e74b5;">return { };</span>. On implementations that are both non-smart <em>and</em> non-SSO, this might have a slight advantage over the others because it invokes the default constructor, and so even the most naïve implementation is likely not to do an allocation since clearly no value is needed.
</p>
<p>In summary, there&#8217;s no difference in practice among returning <span style="color:#2e74b5;">&#8220;&#8221;</span>, <span style="color:#2e74b5;">&#8220;&#8221;s</span>, or <span style="color:#2e74b5;">{ }</span>; use whichever you prefer for stylistic reasons. If your <span style="color:#2e74b5;">string</span> implementation is either smart or uses SSO, which covers all implementations I know of, there&#8217;s exactly zero allocation difference.
</p>
<p>Note: SSO is a wonderful optimization for avoiding allocation overhead and contention, and every modern <span style="color:#2e74b5;">string</span> ought to use it. If your <span style="color:#2e74b5;">string</span> implementation doesn&#8217;t use SSO (as of this writing, I&#8217;m looking at you, libstdc++), write to your standard library implementer—it really should.
</p>
<h3>Non-issue: Multiple returns.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>    return i-&gt;addr;<br />    return "";
</code></pre>
</p>
<p>This was a second subtle red herring, designed to lure in errant disciples of the &#8220;single-entry/single-exit&#8221; (SE/SE) persuasion.
</p>
<p>I In the past, I&#8217;ve heard some people argue that it&#8217;s better to declare a local <span style="color:#2e74b5;">string</span> object to hold the return value and have a single <span style="color:#2e74b5;">return</span> statement that returns that <span style="color:#2e74b5;">string</span>, such as writing <span style="color:#2e74b5;">string ret; &#8230; ret = i-&gt;addr; break; &#8230; return ret;</span>. The idea, they say, is that this will assist the optimizer perform the &#8216;named return value optimization.&#8217;
</p>
<p>The truth is that whether single-return will improve or degrade performance can depend greatly on your actual code and compiler. In this case, the problem is that creating a single local <span style="color:#2e74b5;">string</span> object and then assigning it would mean calling string&#8217;s default constructor <em>and</em> then possibly its assignment  operator, instead of just a single constructor as in our original code. &#8220;But,&#8221; you ask, &#8220;how expensive could a plain old <span style="color:#2e74b5;">string</span> default constructor be?&#8221; Well, here&#8217;s how the &#8220;two-return&#8221; version performed on one popular compiler last time I tried it:
</p>
<ul>
<li>with optimizations disabled: two-return 5% faster than a &#8220;return value&#8221; <span style="color:#2e74b5;">string</span> object
</li>
<li>with aggressive optimizations: two-return 40% faster than a &#8220;return value&#8221; <span style="color:#2e74b5;">string</span> object
</li>
</ul>
<p>Note what this means: Not only did the single-return version generate slower code on this particular compiler on this particular day, but the slowdown was greater with optimizations turned on. In other words, a single-return version didn&#8217;t assist optimization, but actively interfered with it by making the code more complex.
</p>
<p>In general, note that SE/SE is an obsolete idea and has always been wrong. &#8220;Single entry,&#8221; or the idea that functions should always be entered in one place (at their start) and not with <span style="color:#2e74b5;">goto</span> jumps from the caller&#8217;s code directly to random places inside the function body, was and is an immensely valuable advance in computer science. It&#8217;s what made libraries possible, because it meant you could package up a function and reuse it and the function would always know its starting state, where it begins, regardless of the calling code. &#8220;Single exit,&#8221; on the other hand, got unfairly popular on the basis of optimization (&#8216;if there&#8217;s a single <span style="color:#2e74b5;">return</span> the compiler can perform return value optimization better&#8217;—see counterexample above) and symmetry (&#8216;if single entry is good, single exit must be good too&#8217;) but that is wrong because the reasons don&#8217;t hold in reverse—allowing a caller to jump in is bad because it&#8217;s not under the function&#8217;s control, but allowing the function itself to return early when it knows it&#8217;s done is perfectly fine and fully under the function&#8217;s control. To put the final nail in the coffin, note that &#8220;single exit&#8221; has always been a fiction in any language that has exceptions, because you can get an early exceptional return from any point where you call something that could throw an exception.
</p>
<h3>Non-issue: Return by value.<br />
</h3>
<p>Which brings us to the third red herring:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>string find_addr( /*...*/ )
</code></pre>
</p>
<p>Because C++ naturally enables move semantics for returned values like this <span style="color:#2e74b5;">string</span> object, there&#8217;s usually little to be gained by trying to avoid the temporary when you return by value. For example, if the caller writes <span style="color:#2e74b5;">auto address = find_addr( mylist, &#8220;Marvin the Robot&#8221; );</span>, there will be at most a cheap move (not a deep copy) of the returned temporary into <span style="color:#2e74b5;">address</span>, and compilers are allowed to optimize away even that cheap move and construct the result into <span style="color:#2e74b5;">address</span> directly.
</p>
<p>But what if you did feel tempted to try to avoid a temporary in all return cases by returning a <span style="color:#2e74b5;">string&amp;</span> instead of <span style="color:#2e74b5;">string</span>? Here&#8217;s one way you might try doing it that avoids the pitfall of returning a dangling reference to a local or temporary object:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>const string&amp; find_addr( /* ... */ ) {<br />    for( /* ... */ ) {<br />        if( /* found */ ) {<br />            return i-&gt;addr;<br />        }<br />    }<br />    static const string empty;<br />    return empty;<br />}
</code></pre>
</p>
<p>To demonstrate why this is brittle, here&#8217;s an extra question:
</p>
<p><strong>For the above function, write the documentation for how long the returned reference is valid.<br />
</strong></p>
<p>Go ahead, we&#8217;ll wait.
</p>
<p>Done? Okay, let&#8217;s consider: If the object is found, we are returning a reference to a <span style="color:#2e74b5;">string</span> inside an <span style="color:#2e74b5;">employee</span> object inside the <span style="color:#2e74b5;">list</span>, and so the reference itself is only valid for the lifetime of said <span style="color:#2e74b5;">employee</span> object inside the <span style="color:#2e74b5;">list</span>. So we might try something like this (assuming an empty address is not valid for any employee):
</p>
<blockquote>
<p>&#8220;If the returned string is nonempty, then the reference is valid until the next time you modify the employee object for which this is the address, including if you remove that employee from the list.&#8221;
</p>
</blockquote>
<p>Those are very brittle semantics, not least because the first (but far from only) problem that immediately arises is that the caller has no idea which employee that is—not only doesn&#8217;t he have a pointer or reference to the right <span style="color:#2e74b5;">employee</span> object, but he may not even be able to easily figure out which one it is if two employees could have the same address. Second, calling code can be notoriously forgetful and careless about the lifetimes of the returned reference, as in the following code which compiles just fine:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>auto&amp; a = find_addr( emps, "John Doe" );  // yay, avoided temporary!<br />emps.clear();<br />cout &lt;&lt; a;                                // oops
</code></pre>
</p>
<p>When the calling code does something like this and uses a reference beyond its lifetime, the bug will typically be intermittent and very difficult to diagnose. Indeed, one of the most common mistakes programmers make with the standard library is to use iterators after they are no longer valid, which is pretty much the same thing as using a reference beyond its lifetime; see GotW #18 for details about the accidental use of invalid iterators.
</p>
<h2>Summary<br />
</h2>
<p>There are some other optimization opportunities. Ignoring these for now, here is one possible corrected version of <span style="color:#2e74b5;">find_addr</span> which fixes the unnecessary temporaries. To avoid a possible conversion in the <span style="color:#2e74b5;">employee</span>/<span style="color:#2e74b5;">string</span> comparison, we&#8217;ll assume there&#8217;s something like an <span style="color:#2e74b5;">employee::name()</span> function and that <span style="color:#2e74b5;">.name() == name</span> has equivalent semantics.
</p>
<p>Note another reason to prefer declaring local variables with <span style="color:#2e74b5;">auto</span>: Because the <span style="color:#2e74b5;">list&lt;employee&gt;</span> parameter is now <span style="color:#2e74b5;">const</span>, calling <span style="color:#2e74b5;">begin</span> and <span style="color:#2e74b5;">end</span> return a different type—not <span style="color:#2e74b5;">iterator</span>s but <span style="color:#2e74b5;">const_iterator</span>s—but <span style="color:#2e74b5;">auto</span> naturally deduces the right thing so you don&#8217;t have to remember to make that change in your code.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {<br />    for( auto i = begin(emps);  i != end(emps); ++i ) {<br />        if( i-&gt;name() == name ) {<br />            return i-&gt;addr;<br />        }<br />    }<br />    return "";<br />}
</code></pre>
</p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: &#8220;litb1,&#8221; Daan Nusman, &#8220;Adrian,&#8221; Michael Marcin, Ville Voutilainen, Rick Yorgason, &#8220;kkoehne,&#8221; and Olaf van der Spek.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/feed/</wfw:commentRss>
		<slash:comments>59</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #2: Temporary Objects</title>
		<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/</link>
				<comments>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comments</comments>
				<pubDate>Thu, 09 May 2013 16:42:09 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1855</guid>
				<description><![CDATA[Unnecessary and/or temporary objects are frequent culprits that can throw all your hard work — and your program&#8217;s performance — right out the window. How can you spot them and avoid them?   Problem JG Question 1. What is a temporary object? Guru Question 2. You are doing a code review. A programmer has written [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Unnecessary and/or temporary objects are frequent culprits that can throw all your hard work — and your program&#8217;s performance — right out the window. How can you spot them and avoid them?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is a temporary object?
</p>
<h2>Guru Question<br />
</h2>
<p>2. You are doing a code review. A programmer has written the following function, which uses unnecessary temporary objects in at least three places. How many can you identify, and how should the programmer fix them?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>string find_addr( list&lt;employee&gt; emps, string name ) {<br />    for( auto i = begin(emps); i != end(emps); i++ ) {<br />        if( *i == name ) {<br />            return i-&gt;addr;<br />        }<br />    }<br />    return "";<br />}
</code></pre>
</p>
<p>Do not change the operational semantics of this function, even though they could be improved.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/feed/</wfw:commentRss>
		<slash:comments>56</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #1 Solution: Variable Initialization – or Is It?</title>
		<link>https://herbsutter.com/2013/05/09/gotw-1-solution/</link>
				<comments>https://herbsutter.com/2013/05/09/gotw-1-solution/#comments</comments>
				<pubDate>Thu, 09 May 2013 16:30:01 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1831</guid>
				<description><![CDATA[This first problem highlights the importance of understanding what you write. Here we have a few simple lines of code—most of which mean something different from all the others, even though the syntax varies only slightly.   Problem JG Question 1. What is the difference, if any, among the following? widget w; // (a)widget w(); [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>This first problem highlights the importance of understanding what you write. Here we have a few simple lines of code—most of which mean something different from all the others, even though the syntax varies only slightly.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the difference, if any, among the following?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w;                   // (a)<br /><br />widget w();                 // (b)<br />widget w{};                 // (c)<br /><br />widget w(x);                // (d)<br />widget w{x};                // (e)<br /><br />widget w = x;               // (f)<br />widget w = {x};             // (g)<br /><br />auto w = x;                 // (h)<br />auto w = widget{x};         // (i)
</code></pre>
</p>
<h2>Guru Questions<br />
</h2>
<p>2. What do each of the following lines do?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>vector&lt;int&gt; v1( 10, 20 );   // (a)<br /><br />vector&lt;int&gt; v2{ 10, 20 };   // (b)
</code></pre>
</p>
<p>3. Besides the cases above, what other benefits are there to using <span style="color:#1f4e79;">{ }</span> to initialize objects?
</p>
<p>4. When should you use <span style="color:#1f4e79;">( )</span> vs. <span style="color:#1f4e79;">{ }</span> syntax to initialize objects? Why?
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<p>This puzzle demonstrates several things:
</p>
<ul>
<li>The difference between default initialization, direct initialization, copy initialization, and list initialization.
</li>
<li>The difference between using <span style="color:#1f4e79;">( )</span> and using <span style="color:#1f4e79;">{ }</span> for initialization.
</li>
<li>A red herring that isn&#8217;t initialization at all, and which modern C++ entirely avoids.
</li>
</ul>
<p>But, most important of all: If you stick to two simple Guidelines, which we&#8217;ll cover in #4, you can ignore most of these cases and the rules are pretty simple and deliver efficient performance by default.
</p>
<p>
 </p>
<h2>1. What is the difference, if any, among the following?<br />
</h2>
<p>Let&#8217;s consider the cases one by one.
</p>
<h3>(a) is default initialization.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w;                   // (a)
</code></pre>
</p>
<p>This code declares a variable named <span style="color:#1f4e79;">w</span>, of type <span style="color:#1f4e79;">widget</span>. For most types, it is initialized using the default constructor <span style="color:#1f4e79;">widget::widget()</span>.
</p>
<p>Note that <span style="color:#1f4e79;">w</span> is not initialized and contains garbage values if <span style="color:#1f4e79;">widget</span> happens to be a built-in type like <span style="color:#1f4e79;">int</span>, or a simple &#8220;<span style="color:#1f4e79;">int</span>-like&#8221; class type with what&#8217;s called a &#8220;trivial&#8221; default constructor—a type that relies on the compiler-generated default constructor, has no virtual functions or virtual base classes or data member initializers, and all its bases and members satisfy the same restrictions.
</p>
<h3> (b) is a &#8220;vexing&#8221; red herring, now mostly a historical curiosity.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w();                 // (b)
</code></pre>
</p>
<p>This is a pre-modern C++ pitfall: At first glance, it may look like just another variable declaration calling a default constructor <span style="color:#1f4e79;">widget::widget()</span>; in reality, thanks to a grammar ambiguity, it&#8217;s a function declaration for a function named <span style="color:#1f4e79;">w</span> that takes no parameters and returns a <span style="color:#1f4e79;">widget</span> object by value. (If you can&#8217;t see this at first, consider that the above code is no different from writing something like <span style="color:#1f4e79;">int f();</span> which is clearly a function declaration.)
</p>
<p>Lest you think &#8220;aw, but those <span style="color:#1f4e79;">( )</span> parentheses are redundant, it&#8217;s the programmer&#8217;s own fault for not just writing <span style="color:#1f4e79;">widget w;</span> there!&#8221;, note that the same problem arises in those occasional cases where you think you&#8217;re initializing a variable with temporary objects:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// same problem (gadget and doodad are types)<br />//<br />widget w( gadget(), doodad() );  // pitfall: not a variable declaration
</code></pre>
</p>
<p>Scott Meyers long ago named this &#8220;C++&#8217;s most vexing parse,&#8221; because the standard resolves the parsing ambiguity by saying: &#8220;if it can be a function declaration, it is.&#8221;
</p>
<p>The good news is that this is now mostly a historical curiosity, not something you should encounter in new code, because C++11 removed this pitfall. Note that C++11 does not change the meaning of the code—C++11 has great backward compatibility with C++98, including that this ambiguity still has the same meaning it always had. Rather, C++11 solves this by providing a syntax that supersedes case (b) in nearly all cases, so that we don&#8217;t need to ever fall into this pit anymore:
</p>
<h3>(c) is non-vexing and clear.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w{};                 // (c)
</code></pre>
</p>
<p>Here we have the first reason to prefer <span style="color:#1f4e79;">{ }</span> to <span style="color:#1f4e79;">( )</span>: For any class type <span style="color:#1f4e79;">widget</span>, line (c) does the &#8220;best parts&#8221; of (a) and (b)—it always initializes the variable, and is never ambiguous with a function declaration. No vex, no fuss, no muss.
</p>
<p>&#8220;Aha, but wait, it&#8217;s not that simple!&#8221; someone might object. &#8220;What if <span style="color:#1f4e79;">widget</span> has a constructor that takes a <span style="color:#1f4e79;">std::initializer_list</span>? Those are greedy (preferred), so if <span style="color:#1f4e79;">widget</span> has one of those wouldn&#8217;t this call that?&#8221;
</p>
<p>The answer is no, this really is just as simple as it looks, because the standard is explicit that an empty <span style="color:#1f4e79;">{ }</span> list means to call the default constructor if available. However, it&#8217;s good to be aware of <span style="color:#1f4e79;">initializer_list</span>s, so let&#8217;s talk about those next.
</p>
<h3>(d) and (e) are direct initialization.<br />
</h3>
<p>Now let&#8217;s consider cases where we actually initialize <span style="color:#1f4e79;">w</span> from some existing variable:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w(x);                // (d)<br />widget w{x};                // (e)
</code></pre>
</p>
<p>Assuming <span style="color:#1f4e79;">x</span> is not the name of a type, these are both direct initialization. That&#8217;s because the variable <span style="color:#1f4e79;">w</span> is initialized &#8220;directly&#8221; from the value of <span style="color:#1f4e79;">x</span> by calling <span style="color:#1f4e79;">widget::widget(x)</span>. If <span style="color:#1f4e79;">x</span> is also of type <span style="color:#1f4e79;">widget</span>, this invokes the copy constructor. Otherwise, it invokes a converting constructor.
</p>
<p>However, note that the syntax <span style="color:#1f4e79;">{x}</span> creates an <span style="color:#1f4e79;">initializer_list</span>. If <span style="color:#1f4e79;">widget</span> has a constructor that takes an <span style="color:#1f4e79;">initializer_list</span>, that constructor is preferred; otherwise, if <span style="color:#1f4e79;">widget</span> has a constructor that takes whatever type <span style="color:#1f4e79;">x</span> is (possibly with conversions), that constructor is used.
</p>
<p>There are two major differences that make (e) superior to (d): First, like (c), syntax (e) is unambiguous and avoids the vexing parse. If <span style="color:#1f4e79;">x</span> is a type name, then (d) is a function declaration even if there is also a variable named <span style="color:#1f4e79;">x</span> in scope (see above), whereas (e) is never a function declaration.
</p>
<p>Second, syntax (e) is safer because it does not allow narrowing (a.k.a. &#8220;lossy&#8221;) conversions that are otherwise allowed for some built-in types. Consider:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code><span style="color:#c00000;">int i1( 12.345 );           // ok: toss .345, we didn't like it anyway<br /><span style="color:#00b050;">int i2{ 12.345 };           // error: would be lossy implicit narrowing
</span></span></code></pre>
</p>
<h3>(f) and (g) are copy initialization and copy list initialization.<br />
</h3>
<p>This brings us to our final two non-<span style="color:#1f4e79;">auto</span> cases:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w = x;               // (f)
</code></pre>
</p>
<p>This is called &#8220;copy initialization.&#8221; Conceptually, the variable <span style="color:#1f4e79;">w</span> is initialized using <span style="color:#1f4e79;">widget</span>&#8216;s move or copy constructor, possibly after calling another function to convert the argument implicitly (<span style="color:#1f4e79;">explicit</span> conversions won&#8217;t be invoked here).
</p>
<blockquote>
<p><strong>Common Mistake:</strong> This is always initialization; it is never assignment, and so it never calls <strong>T::operator=()</strong>. Yes, I know there&#8217;s an &#8220;<strong>=</strong>&#8221; character in there, but don&#8217;t let that throw you — that&#8217;s just a syntax holdover from C, not an assignment operation.
</p>
</blockquote>
<p>Here are the semantics:
</p>
<ul>
<li>If <span style="color:#1f4e79;">x</span> is of type <span style="color:#1f4e79;">widget</span>, line (f) means the same as (d) <span style="color:#1f4e79;">widget w(x);</span> except that <span style="color:#1f4e79;">explicit</span> constructors cannot be used. It&#8217;s guaranteed that only a single constructor is called.
</li>
<li>If <span style="color:#1f4e79;">x</span> is of some other type, <em>conceptually</em> the compiler first implicitly converts <span style="color:#1f4e79;">x</span> to a temporary <span style="color:#1f4e79;">widget</span> object, then move-constructs <span style="color:#1f4e79;">w</span> from that temporary rvalue, using copy construction as &#8220;the slow way to move&#8221; as a backup if no better move constructor is available. Assuming that an implicit conversion is available, (f) means the same as <span style="color:#1f4e79;">widget w( widget(x) );</span>.
</li>
</ul>
<p>Note that I said &#8220;conceptually&#8221; a few times above. That&#8217;s because <em>practically</em> compilers are allowed to, and routinely do, optimize away the temporary and, if an implicit conversion is available, convert (f) to (d), thus optimizing away the extra move operation. However, even when the compiler does this, the <span style="color:#1f4e79;">widget</span> copy constructor must still be accessible, even if is not called—the copy constructor&#8217;s side effects may or may not happen, that&#8217;s all.
</p>
<p>Now note the related syntax that adds &#8220;<span style="color:#1f4e79;">=</span>&#8220;:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w = {x};             // (g)
</code></pre>
</p>
<p>This is called &#8220;copy list initialization.&#8221; It means the same as <span style="color:#1f4e79;">widget w{x};</span> except that <span style="color:#1f4e79;">explicit</span> constructors cannot be used. It&#8217;s guaranteed that only a single constructor is called.
</p>
<h3>(h) and (i) are also copy initialization, but simpler.<br />
</h3>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>auto w = x;                 // (h)<br />auto w = widget{x};         // (i)
</code></pre>
</p>
<p>The semantics are just like (f) and (g), except simpler to teach, learn, and use because using <span style="color:#1f4e79;">auto</span> guarantees the right-hand expression&#8217;s type will be deduced exactly. Note that the (i) syntax works fine for both implicit and <span style="color:#1f4e79;">explicit</span> conversions.
</p>
<p>Line (h) means the same as (d), <span style="color:#1f4e79;"><em>type_of_x</em> w(x);</span>. Only a single copy constructor is called. This is <em>guaranteed to stay true</em> as the program evolves: Because line (h) does not commit to an explicit type, it is guaranteed to be both maximally efficient because there can be no conversion involved, and maximally robust under maintenance as the type of <span style="color:#1f4e79;">w</span> &#8220;auto&#8221;-matically tracks the type of <span style="color:#1f4e79;">x</span> which may change as the program is maintained.
</p>
<p>Line (i) is the most consistent spelling when you do want to commit to a specific type and explicitly request a conversion if needed, and once again the <span style="color:#1f4e79;">{ }</span> syntax happily avoids lossy narrowing conversions. In practice on most compilers, only a single constructor is called—similarly to what we saw with (f) and (g), conceptually there are two constructor calls, a converting or copy constructor to create a temporary <span style="color:#1f4e79;">widget{x}</span> followed by a move to move it to <span style="color:#1f4e79;">w</span>, but compilers routinely elide the latter.
</p>
<p>In general, I recommend that you try out these two forms, and increasingly prefer using them as you grow comfortable with them. I&#8217;m at the point where I&#8217;m now inclined to write virtually all of my local variable declarations this way. (I know some of you will be skeptical about this broad claim—more on &#8220;the <span style="color:#1f4e79;">auto</span> question&#8221; in another GotW.)
</p>
<p>
 </p>
<h2>2. What do each of the following lines do?<br />
</h2>
<p>In the Question 2 code, we&#8217;re creating a <span style="color:#1f4e79;">vector&lt;int&gt;</span> and passing the arguments <span style="color:#1f4e79;">10</span> and <span style="color:#1f4e79;">20</span> to its constructor—in the first case as <span style="color:#1f4e79;">( 10, 20 )</span> and in the second case as <span style="color:#1f4e79;">{ 10, 20 }</span>.
</p>
<p>Both will call a constructor, but which one(s)? Well, <span style="color:#1f4e79;">vector&lt;int&gt;</span> has several constructors that can take two parameters, but only two could be correctly called with the parameters <span style="color:#1f4e79;">10</span> and <span style="color:#1f4e79;">20</span>. Ignoring defaulted optional allocator parameters for simplicity, the two constructors are:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>vector( size_t n, const int&amp; value );    // A: n copies of value<br /><br />vector( initializer_list&lt;int&gt; values );  // B: copy of values
</code></pre>
</p>
<p>There are two simple C++ rules that tell us which one will be called for the code in question:
</p>
<ul>
<li>The syntax <span style="color:#1f4e79;">{ /*…*/ }</span> used in an expression context gives you an <span style="color:#1f4e79;">initializer_list</span>.
</li>
<li>Constructors that take an <span style="color:#1f4e79;">initializer_list</span> are preferred over other constructors, and so can hide other constructors that might otherwise be viable.
</li>
</ul>
<p>Armed with those two tidbits, the answer is simple:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>vector&lt;int&gt; v1( 10, 20 );    // (a) calls A: 10 copies of the value 20<br />assert( v1.size() == 10 );<br /><br />vector&lt;int&gt; v2{ 10, 20 };    // (b) calls B: the values 10 and 20<br />assert( v2.size() == 2 );
</code></pre>
</p>
<p>
 </p>
<h2>3. Besides the cases above, what other benefits are there to using { } to initialize objects?<br />
</h2>
<p>For one thing, it&#8217;s called &#8220;uniform initialization&#8221; because it&#8217;s, well, uniform—the same for all types, including aggregate structs and arrays and <span style="color:#1f4e79;">std::</span> containers, and without the &#8220;vexing parse&#8221; annoyance:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>struct mystruct { int x, y; };<br /><br />// C++98 <br />rectangle       w( origin(), extents() );       // oops, vexing parse <br />complex&lt;double&gt; c( 2.71828, 3.14159 ); <br />mystruct        m = { 1, 2 };<br />int             a[] = { 1, 2, 3, 4 };<br />vector&lt;int&gt;     v;                              // urk, need more code<br />for( int i = 1; i &lt;= 4; ++i ) v.push_back(i);   //   to initialize this<br /><br />// C++11 (note: "=" is mostly optional)<br />rectangle       w   = { origin(), extents() }; <br />complex&lt;double&gt; c   = { 2.71828, 3.14159 }; <br />mystruct        m   = { 1, 2 }; <br />int             a[] = { 1, 2, 3, 4 };<br />vector&lt;int&gt;     v   = { 1, 2, 3, 4 };
</code></pre>
</p>
<p>And note that this isn&#8217;t just an aesthetic issue. Consider writing generic code that should be able to initialize any type… and while we&#8217;re at it, let&#8217;s gratuitously use perfect forwarding as an example:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>template&lt;typename T, typename ...Args&gt;<br />void forwarder( Args&amp;&amp;... args ) {<br />    // ...<br />    T local <span style="background-color:yellow;">= {</span> std::forward&lt;Args&gt;(args)... <span style="background-color:yellow;">}</span>;<br />    // ...<br />}<br /><br />forwarder&lt;int&gt;            ( 42 );                  // ok<br />forwarder&lt;rectangle&gt;      ( origin(), extents() ); // ok<br />forwarder&lt;complex&lt;double&gt;&gt;( 2.71828, 3.14159 );    // ok<br />forwarder&lt;mystruct&gt;       ( 1, 2 );                // ok because of {}<br />forwarder&lt;int[]&gt;          ( 1, 2, 3, 4 );          // ok because of {}<br />forwarder&lt;vector&lt;int&gt;&gt;    ( 1, 2, 3, 4 );          // ok because of {}
</code></pre>
</p>
<p>The last three lines would not be legal if <span style="color:#1f4e79;">forwarder</span> used <span style="color:#1f4e79;">( )</span> initialization syntax internally.
</p>
<p>The new <span style="color:#1f4e79;">{ }</span> syntax works pretty much everywhere, including to initialize members:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget::widget( /*...*/ ) : mem1<span style="background-color:yellow;">{</span>init1<span style="background-color:yellow;">}</span>, mem2<span style="background-color:yellow;">{</span>init2, init3<span style="background-color:yellow;">}</span> { /*...*/ } 
</code></pre>
</p>
<p>And, as icing on the take, it&#8217;s often just plain convenient to pass function arguments, or return a value, without a type-named temporary:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>void draw_rect( rectangle ); <br /><br />draw_rect( rectangle(origin, selection) );         // C++98<br />draw_rect(<span style="background-color:yellow;">{</span> origin, selection <span style="background-color:yellow;">}</span>);                  // C++11<br /><br />rectangle compute_rect() {<br />   // ...<br />   if(cpp98) return rectangle(origin, selection);  // C++98<br />   else      return <span style="background-color:yellow;">{</span>origin, selection<span style="background-color:yellow;">}</span>;           // C++11<br />}
</code></pre>
</p>
<p>
 </p>
<h2>4. When should you use ( ) vs. { } syntax to initialize objects? Why?<br />
</h2>
<p>Here&#8217;s the simple <span style="color:#5b9bd5;">g</span>uideline:
</p>
<blockquote>
<p><strong>Guideline:</strong> Prefer to use initialization with <strong>{ }</strong>, such as <strong>vector&lt;int&gt; v = { 1, 2, 3, 4 };</strong> or <strong>auto v = vector&lt;int&gt;{ 1, 2, 3, 4 };</strong>, because it&#8217;s more consistent, more correct, and avoids having to know about old-style pitfalls at all. In single-argument cases where you prefer to see only the <strong>=</strong> sign, such as <strong>int i = 42;</strong> and <strong>auto x = anything</strong>; omitting the braces is fine. …
</p>
</blockquote>
<p>That covers the vast majority of cases. There is only one main exception:
</p>
<blockquote>
<p>… In rare cases, such as <strong>vector&lt;int&gt; v(10,20);</strong> or <strong>auto v = vector&lt;int&gt;(10,20);</strong>, use initialization with <strong>( )</strong> to explicitly call a constructor that is otherwise hidden by an <strong>initializer_list</strong> constructor.
</p>
</blockquote>
<p>However, the reason this should be generally &#8220;rare&#8221; is because default and copy construction are already special and work fine with <span style="color:#5b9bd5;">{ }</span>, and good class design now mostly avoids the resort-to-<span style="color:#5b9bd5;">( )</span> case for user-defined constructors because of this final design guideline:
</p>
<blockquote>
<p><strong>Guideline: </strong>When you design a class, avoid providing a constructor that ambiguously overloads with an <strong>initializer_list</strong> constructor, so that users won&#8217;t need to use <strong>( )</strong> to reach such a hidden constructor.
</p>
</blockquote>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: Michal Mocny, Jay Miller, &#8220;Alexey,&#8221; &#8220;praetorian20,&#8221; Francisco Lopes, &#8220;Neil,&#8221; Daryle Walker.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/09/gotw-1-solution/feed/</wfw:commentRss>
		<slash:comments>55</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #1: Variable Initialization—or Is It? (3/10)</title>
		<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/</link>
				<comments>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comments</comments>
				<pubDate>Mon, 06 May 2013 08:26:40 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=1828</guid>
				<description><![CDATA[This first problem highlights the importance of understanding what you write. Here we have a few simple lines of code — most of which mean something different from all the others, even though the syntax varies only slightly.   Problem JG Question 1. What is the difference, if any, among the following? widget w; // [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>This first problem highlights the importance of understanding what you write. Here we have a few simple lines of code — most of which mean something different from all the others, even though the syntax varies only slightly.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the difference, if any, among the following?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>widget w;                   // (a)<br /><br />widget w();                 // (b)<br />widget w{};                 // (c)<br /><br />widget w(x);                // (d)<br />widget w{x};                // (e)<br /><br />widget w = x;               // (f)<br />widget w = {x};             // (g)<br /><br />auto w = x;                 // (h)<br />auto w = widget{x};         // (i)
</code></pre>
</p>
<h2>Guru Questions<br />
</h2>
<p>2. What do each of the following lines do?
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>vector&lt;int&gt; v1( 10, 20 );   // (a)<br /><br />vector&lt;int&gt; v2{ 10, 20 };   // (b)
</code></pre>
</p>
<p>3. Besides the cases above, what other benefits are there to using <span style="color:#2e74b5;">{ }</span> to initialize objects?
</p>
<p>4. When should you use <span style="color:#2e74b5;">( )</span> vs. <span style="color:#2e74b5;">{ }</span> syntax to initialize objects? Why?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Guru of the Week and the Exceptional C++ Series</title>
		<link>https://herbsutter.com/2013/05/04/guru-of-the-week-and-the-exceptional-c-series/</link>
				<comments>https://herbsutter.com/2013/05/04/guru-of-the-week-and-the-exceptional-c-series/#comments</comments>
				<pubDate>Sat, 04 May 2013 19:58:26 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1817</guid>
				<description><![CDATA[It’s time for me to pick up Guru of the Week (GotW) again in earnest, as part of work on revising my three Exceptional C++ books for today’s C++. Most Exceptional C++ Items are enhanced versions of GotW issues, after all, so the simplest and best place to start is with GotW. It’s also much [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>It’s time for me to pick up <em>Guru of the Week</em> (GotW) again in earnest, as part of work on revising my three <em>Exceptional C++</em> books for today’s C++. Most <em>Exceptional C++</em> Items are enhanced versions of GotW issues, after all, so the simplest and best place to start is with GotW. It’s also much easier to write (and read) one short piece at a time.</p>
<p>Last spring I wrote a few GotWs, but life got busy with the <a href="http://isocpp.org/about">Standard C++ Foundation</a>, <a href="http://isocpp.org">isocpp.org</a>, and <a href="http://isocpp.org/blog/2013/04/trip-report-iso-c-spring-2013-meeting">C++14</a>. I was also trying to figure out what reasonable tools to use to write new Items, since I wanted to publish the same Item on this blog and then in e-book and dead tree editions, all with a single source while maintaining a pleasing format. I’ve found a provisional promising tool (Word!) and format for that I’ll try out for now, and you’ll see it in the next GotW issue to be posted soon.</p>
<p>But a major issue was figuring out the right balance between updating existing GotW issues and writing new ones.</p>
<p>Here’s where I landed…</p>
<p>&#160;</p>
<p><strong>First, I’ve decided to keep and revise nearly all of my existing Items.</strong> This is not an obvious choice: As a counterexample, some authors have decided to not revise their existing books, but to write new books about C++11, for various reasons including that they expect the advice in the earlier books is still current. I think the latter is partly true, because of course the topics are still current and the code still compiles – C++11 has a great backward compatibility story with C++98.</p>
<p>However, when I looked through my own articles and Items, every single one I looked at had two qualities: </p>
<ul>
<li>The topic was still current and useful, so it should still be covered. (With very rare exceptions like material discussing the now-removed <em>export</em> template feature.)</li>
<li>The code and discussion were addressed with C++98-era advice that is now dated and/or incomplete.</li>
</ul>
<p>For example, nearly every GotW’s code should just naturally use <em>auto </em>and <em>{ }</em> initialization. Most should use or actively discuss move semantics, lambdas, and other C++11 features. And it’s hard to write about existing features like virtual function overriding (as in GotW #5) without feeling something important is missing unless there’s also discussion of the way C++ has extended the existing feature, such as with <em>override</em> and <em>final</em>.</p>
<p>&#160;</p>
<p><strong>Second, I’ve decided not to target C++11 – rather, I’m going to write for C++14.</strong> Why would I do that, when C++ compilers <em>[preemptive snarky remark: including my own team’s]</em> are still catching up to C++11? For several good reasons:</p>
<ul>
<li>C++14 is going to be current C++ soon. As of April, it’s now feature-complete, and the detailed technical specification should be frozen this fall or winter (leaving time for ISO ballots and “’14” publication). Compilers and libraries are already aggressively implementing it. I wouldn’t be surprised if we had multiple fully-conforming C++14 implementations by the end of next year.</li>
<li>C++14 is a small delta, a minor release aimed mainly at “completing C++11.” And it <em>does </em>complete C++11 well, to the point where as an author I really want to teach the complete story. I want to teach the complete “avoid writing <em>new</em> and <em>delete</em>” guidance that C++14 <em>make_unique</em> fully enables so that I can stop mumbling “except when you create a <em>unique_ptr</em>” as a special case. I want to write generic lambdas with C++14’s terse <em>auto</em> parameters that makes lambdas shorter to write and more flexible, and stop repeating parameter type names. I want to use C++14 move-capture in lambdas that makes them complete, and not feel obliged to talk about artificially putting objects on the heap and capturing <em>shared_ptr</em>s to them by value as a workaround for lack of move capture. And, in a few places where appropriate, I want to be free to use a few smaller C++14 tidbits like <em>optional&lt;T&gt;</em> that can affect interface design guidance now that they’re in the draft standard.</li>
</ul>
<p>In addition, I’ve found that C++11/14 is changing my coding style, including my basic variable declaration style. I now think <em>auto </em>should be used consistently to declare local variables, even when you want to commit to a specific type(!) – this certainly surprised me, and likely will surprise you too, so I’ll cover that this year in a GotW and a recorded talk, no later than at <a href="http://cppandbeyond.com"><em>C++ and Beyond</em></a> later this year and possibly sooner.</p>
<p>&#160;</p>
<p>I’ve converged on the above by updating the first dozen <em>Exceptional C++</em> Items (in GotW order), trying out alternatives and seeing how well each one worked out. Those first dozen Items are now done and I’m pleased with the result, showing off <em>auto</em> and move and generic lambdas and mutexes/atomics and the new meanings of <em>const</em> and <em>mutable</em> and everything else, most of their code tested against various of the latest compilers, their advice updated to be current with current C++. And in every single GotW, no matter how short, it just felt <em>right</em> to:</p>
<ul>
<li>keep the topic, because each topic is still as relevant and useful as ever;</li>
<li>revise the C++98 code and advice, because in every case both the code examples and the discussion was dated and/or incomplete, usually both; and</li>
<li>skip C++11 to write directly for the complete story in C++14 without apology, because it let me avoid digressions for workarounds not needed in C++14, which made the text cleaner and simpler.</li>
</ul>
<p>As I’ve revised Items, I’ve found that some updates are small but pervasive, such as using <em>auto</em>. Others are extensive, with entire subsections completely rewritten, thrown out as no longer relevant, or newly added to cover essential new sides of the story in modern C++. For example, GotW #6 about <em>const</em>-correctness is now a two-parter, covering the new meanings of <em>const</em> and <em>mutable</em>. Watch for it soon.</p>
<p>&#160;</p>
<p>A word about numbering and sequence: My plan is to update and post most GotWs in numerical order starting with GotW #1, but every so often we’ll jump forward to new high numbers (starting with #89) as I create ones that weren’t originally a GotW – a Sutter’s Mill magazine article that wasn’t originally published as a GotW, or a brand-new C++14 topic. So for example you might see a sequence like “… 23, 24, <strong>91</strong>, 25, 26, …”. All GotWs will have substantial new material, but the newly minted high numbers will be entirely on brand-new topics that didn’t arise in C++98 or just weren’t covered in GotW form before. (The handful of GotWs I wrote last year will be renumbered as they’re folded into the original series, either as updates or with new numbers in the original sequence if they’re on completely new topics. )</p>
<p>&#160;</p>
<p>I’ll start posting fresh C++11/14 GotWs in the next few days. As usual, I’ll first post a problem by itself to invite discussion about possible solutions, then after there’s been time for comments I’ll post my own solution and the next problem.</p>
<p>It’s kind of exciting to write “GotW14” – today’s C++ really does feel like a fresh new language.</p>
<p>I hope you enjoy them as much as I enjoy writing them. </p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/05/04/guru-of-the-week-and-the-exceptional-c-series/feed/</wfw:commentRss>
		<slash:comments>23</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #105: Smart Pointers, Part 3 (Difficulty: 7/10)</title>
		<link>https://herbsutter.com/2012/06/05/gotw-105-smart-pointers-part-3-difficulty-710/</link>
				<comments>https://herbsutter.com/2012/06/05/gotw-105-smart-pointers-part-3-difficulty-710/#comments</comments>
				<pubDate>Tue, 05 Jun 2012 19:10:01 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1567</guid>
				<description><![CDATA[JG Question 1. What are the performance and correctness implications of the following function declaration? Explain. &#160; Guru Question 2. A colleague is writing a function f that takes an existing object of type widget as a required input-only parameter, and trying to decide among the following basic ways to take the parameter (omitting const): [&#8230;]]]></description>
								<content:encoded><![CDATA[<h3>JG Question</h3>
<p>1. What are the performance and correctness implications of the following function declaration? Explain.</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:a6d2ebea-842b-4a0a-8179-cab0a7ff2b75" class="wlWriterEditableSmartContent" style="float:none;margin:0;display:inline;padding:0;">
<pre style="white-space:normal;">
<pre class="brush: cpp; gutter: false; pad-line-numbers: true; title: ; notranslate">
void f( shared_ptr&lt;widget&gt; );
</pre>
</div>
<p>&#160;</p>
<h3>Guru Question</h3>
<p>2. A colleague is writing a function <em>f</em> that takes an existing object of type <em>widget</em> as a required input-only parameter, and trying to decide among the following basic ways to take the parameter (omitting <em>const</em>):</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:e9729faf-fb8d-4c47-8154-6c6d0bc2915f" class="wlWriterEditableSmartContent" style="float:none;margin:0;display:inline;padding:0;">
<pre style="white-space:normal;">
<pre class="brush: cpp; gutter: false; title: ; notranslate">
void f( widget&amp; );
void f( unique_ptr&lt;widget&gt; );
void f( unique_ptr&lt;widget&gt;&amp; );
void f( shared_ptr&lt;widget&gt; );
void f( shared_ptr&lt;widget&gt;&amp; );
</pre>
</div>
<p>Under what circumstances is each appropriate? Explain your answer, including where <em>const</em> should or should not be added anywhere in the parameter type.</p>
<p>(There are other ways to pass the parameter, but we will consider only the ones shown above.)</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/06/05/gotw-105-smart-pointers-part-3-difficulty-710/feed/</wfw:commentRss>
		<slash:comments>28</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #104: Solution</title>
		<link>https://herbsutter.com/2012/06/05/gotw-104-solution/</link>
				<comments>https://herbsutter.com/2012/06/05/gotw-104-solution/#comments</comments>
				<pubDate>Tue, 05 Jun 2012 19:03:20 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1565</guid>
				<description><![CDATA[The solution to GotW #104 is now live.]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.com/gotw/_104/">The solution to GotW #104 is now live.</a></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/06/05/gotw-104-solution/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #104: Smart Pointers, Part 2 (Difficulty: 5/10)</title>
		<link>https://herbsutter.com/2012/04/21/gotw-104-smart-pointers-part-2-difficulty-510/</link>
				<comments>https://herbsutter.com/2012/04/21/gotw-104-smart-pointers-part-2-difficulty-510/#comments</comments>
				<pubDate>Sun, 22 Apr 2012 01:17:32 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1485</guid>
				<description><![CDATA[While spelunking through the code of a new project you recently joined, you find the following factory function declaration: &#160; JG Question 1. What’s wrong with this return type? &#160; Guru Questions 2. What is the recommended return type? Explain your answer, including any tradeoffs. 3. You’d like to actually change the return type to [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>While spelunking through the code of a new project you recently joined, you find the following factory function declaration:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:aa686094-3ba9-45fb-8b37-b6830c3f4a8e" class="wlWriterEditableSmartContent" style="float:none;margin:0;display:inline;padding:0;">
<pre style="white-space:normal;">
<pre class="brush: cpp; gutter: false; pad-line-numbers: true; title: ; notranslate">
widget* load_widget( widget::id desired );
</pre>
</div>
<p>&#160;</p>
<h3>JG Question</h3>
<p>1. What’s wrong with this return type?</p>
<p>&#160;</p>
<h3>Guru Questions</h3>
<p>2. What is the recommended return type? Explain your answer, including any tradeoffs.</p>
<p>3. You’d like to actually change the return type to match the recommendation in #2, but at first you worry about breaking source compatibility with existing calling code; recompiling existing callers is fine, but having to go change them all is not. Then you have an “aha!” moment, realizing that this is a fairly new project and all of your calling code is written using modern C++ idioms, and you go ahead and change the return type without fear, knowing it will require few or no code changes to callers. What makes you so confident?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/21/gotw-104-smart-pointers-part-2-difficulty-510/feed/</wfw:commentRss>
		<slash:comments>25</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #103: Solution</title>
		<link>https://herbsutter.com/2012/04/21/gotw-103-solution/</link>
				<comments>https://herbsutter.com/2012/04/21/gotw-103-solution/#comments</comments>
				<pubDate>Sun, 22 Apr 2012 01:05:35 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1483</guid>
				<description><![CDATA[The solution to GotW #103 is now live.]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.com/gotw/_103/">The solution to GotW #103 is now live.</a></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/04/21/gotw-103-solution/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #103: Smart Pointers, Part 1 (Difficulty: 3/10)</title>
		<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/</link>
				<comments>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comments</comments>
				<pubDate>Fri, 20 Jan 2012 20:46:53 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346</guid>
				<description><![CDATA[JG Question 1. When should you use shared_ptr vs. unique_ptr? List as many considerations as you can. &#160; Guru Questions 2. Why should you always use make_shared to allocate objects whose lifetimes will be managed by shared_ptr? Explain. 3. What’s the deal with auto_ptr?]]></description>
								<content:encoded><![CDATA[<h3>JG Question</h3>
<p>1. When should you use <em>shared_ptr</em> vs. <em>unique_ptr</em>? List as many considerations as you can.</p>
<p>&nbsp;</p>
<h3>Guru Questions</h3>
<p>2. Why should you always use <em>make_shared</em> to allocate objects whose lifetimes will be managed by <em>shared_ptr</em>? Explain.</p>
<p>3. What’s the deal with <em>auto_ptr</em>?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #102: Solution</title>
		<link>https://herbsutter.com/2012/01/20/gotw-102-solution/</link>
				<pubDate>Fri, 20 Jan 2012 20:42:33 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1344</guid>
				<description><![CDATA[The solution to GotW #102 is now live.]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.com/gotw/_102/">The solution to GotW #102 is now live.</a></p>
]]></content:encoded>
									
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #102: Exception-Safe Function Calls (Difficulty: 7/10)</title>
		<link>https://herbsutter.com/2011/12/02/gotw-102-exception-safe-function-calls-difficulty-710/</link>
				<comments>https://herbsutter.com/2011/12/02/gotw-102-exception-safe-function-calls-difficulty-710/#comments</comments>
				<pubDate>Sat, 03 Dec 2011 01:17:53 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1109</guid>
				<description><![CDATA[JG Question 1. In each of the following statements, what can you say about the order of evaluation of the functions f, g, and h and the expressions expr1 and expr2? Assume that expr1 and expr2 do not contain more function calls. Guru Questions 2. In your travels through the dusty corners of your company&#8217;s [&#8230;]]]></description>
								<content:encoded><![CDATA[<h3><img style="display:inline;float:right;margin:0 0 0 10px;" src="https://herbsutter.files.wordpress.com/2011/11/image4.png?w=137&amp;h=244" alt="" align="right" />JG Question</h3>
<p>1. In each of the following statements, what can you say about the order of evaluation of the functions <em>f</em>, <em>g</em>, and <em>h</em> and the expressions <em>expr1 </em>and <em>expr2</em>? Assume that <em>expr1 </em>and <em>expr2 </em>do not contain more function calls.</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:cd0f240e-8c2b-4bfa-b87e-c20e281fd52a" class="wlWriterEditableSmartContent" style="display:inline;float:none;margin:0;padding:0;">
<pre class="brush: cpp; gutter: false; highlight: [1,5]; pad-line-numbers: true; title: ; notranslate">
// Example 1(a)
//
f( expr1, expr2 );

// Example 1(b)
//
f( g( expr1 ), h( expr2 ) );
</pre>
</div>
<h3>Guru Questions</h3>
<p>2. In your travels through the dusty corners of your company&#8217;s code archives, you find the following code fragment:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:c21ad45f-ae91-4a41-9ad4-0d7b4b9fbf4f" class="wlWriterEditableSmartContent" style="display:inline;float:none;margin:0;padding:0;">
<pre class="brush: cpp; first-line: 1; gutter: false; highlight: [1]; title: ; notranslate">
//  Example 2

//  In some header file:
void f( T1*, T2* );

//  At some call site:
f( new T1, new T2 );
</pre>
</div>
<p>Does this code have any potential exception safety or other problems? Explain.</p>
<p>3. As you continue to root through the archives, you see that someone must not have liked Example 2 because later versions of the files in question were changed as follows:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:24d44790-97b4-4cce-bc9e-43e70523f575" class="wlWriterEditableSmartContent" style="display:inline;float:none;margin:0;padding:0;">
<pre class="brush: cpp; gutter: false; highlight: [1]; title: ; notranslate">
//  Example 3

//  In some header file:
void f( std::unique_ptr&lt;T1&gt;, std::unique_ptr&lt;T2&gt; );

//  At some call site:
f( std::unique_ptr&lt;T1&gt;{ new T1 }, std::unique_ptr&lt;T2&gt;{ new T2 } );
</pre>
</div>
<p>What are the semantics of this call? What improvements does this version offer over Example 2, if any? Do any exception safety problems remain? Explain.</p>
<p>4. Demonstrate how to write a <em>make_unique</em> facility that solves the safety problems in Question 3 and can be invoked as follows:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:791a704a-8978-410f-8fc9-e85bc951c4b1" class="wlWriterEditableSmartContent" style="display:inline;float:none;margin:0;padding:0;">
<pre class="brush: cpp; gutter: false; highlight: [1]; title: ; notranslate">
//  Example 4

//  In some header file:
void f( std::unique_ptr&lt;T1&gt;, std::unique_ptr&lt;T2&gt; );

//  At some call site:
f( make_unique&lt;T1&gt;(), make_unique&lt;T2&gt;() );
</pre>
</div>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2011/12/02/gotw-102-exception-safe-function-calls-difficulty-710/feed/</wfw:commentRss>
		<slash:comments>30</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2011/11/image4.png?w=137&#038;h=244" medium="image" />
	</item>
		<item>
		<title>GotW #101: Solution</title>
		<link>https://herbsutter.com/2011/12/02/gotw-101-solution/</link>
				<comments>https://herbsutter.com/2011/12/02/gotw-101-solution/#comments</comments>
				<pubDate>Sat, 03 Dec 2011 01:06:11 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107</guid>
				<description><![CDATA[The solution to GotW #101 is now live.]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.com/gotw/_101/"><img style="display:inline;float:right;margin:0 0 0 10px;" src="https://herbsutter.files.wordpress.com/2011/11/image_thumb31.png?w=500" alt="" align="right" /></a><a href="https://herbsutter.com/gotw/_101/">The solution to GotW #101 is now live.</a></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2011/12/02/gotw-101-solution/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2011/11/image_thumb31.png" medium="image" />
	</item>
		<item>
		<title>GotW #101: Compilation Firewalls, Part 2 (Difficulty: 8/10)</title>
		<link>https://herbsutter.com/2011/11/16/gotw-101/</link>
				<comments>https://herbsutter.com/2011/11/16/gotw-101/#comments</comments>
				<pubDate>Wed, 16 Nov 2011 19:03:10 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1014</guid>
				<description><![CDATA[GotW #100 demonstrated the best way to express the Pimpl idiom using only standard C++11 features: Guru Question Is it possible to make the widget code easier to write by wrapping the Pimpl pattern in some sort of library helper? If so, how? Try to make the widget code as convenient and concise as possible [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>GotW #100 demonstrated the best way to express the Pimpl idiom using only standard C++11 features:</p>
<div id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:25a06b6b-e8fa-4092-8bfa-3054ee27e6c3" class="wlWriterEditableSmartContent" style="display:inline;float:none;margin:0;padding:10px;">
<pre class="brush: cpp; gutter: false; highlight: [1,11]; title: ; notranslate">
// in header file
class widget {
public:
    widget();
    ~widget();
private:
    class impl;
    unique_ptr&lt;impl&gt; pimpl;
};

// in implementation file
class widget::impl {
    // :::
};

widget::widget() : pimpl{ new impl{ /*...*/ } } { }
widget::~widget() { }                   // or =default
</pre>
</div>
<p><a href="https://herbsutter.files.wordpress.com/2011/11/image23.png"><img style="background-image:none;padding-left:10px;padding-right:0;display:inline;padding-top:0;border-width:0;" title="image" src="https://herbsutter.files.wordpress.com/2011/11/image_thumb17.png?w=244&#038;h=123" alt="image" width="244" height="123" align="right" border="0" /></a></p>
<h3>Guru Question</h3>
<p>Is it possible to make the <em>widget</em> code easier to write by wrapping the Pimpl pattern in some sort of library helper? If so, how?</p>
<p>Try to make the <em>widget</em> code as convenient and concise as possible to write, with any compiler-generated semantics either correct by default or producing compile-time errors if the <em>widget</em> author forgets to write them.</p>
<p>&nbsp;</p>
<p><em>[Update: Removed move operations from the basic pattern. Since not all Pimpl’d types need to be move-aware, it’s not really part of the core pattern.]</em></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2011/11/16/gotw-101/feed/</wfw:commentRss>
		<slash:comments>10</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2011/11/image_thumb17.png" medium="image">
			<media:title type="html">image</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #100: Solution</title>
		<link>https://herbsutter.com/2011/11/16/gotw-100-solution/</link>
				<comments>https://herbsutter.com/2011/11/16/gotw-100-solution/#comments</comments>
				<pubDate>Wed, 16 Nov 2011 18:55:23 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/16/gotw-100-solution/</guid>
				<description><![CDATA[The solution to GotW #100 is now live.]]></description>
								<content:encoded><![CDATA[<p><a href="https://herbsutter.files.wordpress.com/2011/11/image_thumb31.png"><img style="background-image:none;border-bottom:0;border-left:0;padding-left:0;padding-right:0;display:inline;float:right;border-top:0;border-right:0;padding-top:0;" title="image_thumb[3]" border="0" alt="image_thumb[3]" align="right" src="https://herbsutter.files.wordpress.com/2011/11/image_thumb3_thumb.png?w=364&#038;h=181" width="364" height="181" /></a></p>
<p>The <a href="https://herbsutter.com/gotw/_100/">solution to GotW #100 is now live</a>.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2011/11/16/gotw-100-solution/feed/</wfw:commentRss>
		<slash:comments>10</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2011/11/image_thumb3_thumb.png" medium="image">
			<media:title type="html">image_thumb[3]</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #100: Compilation Firewalls</title>
		<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/</link>
				<comments>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comments</comments>
				<pubDate>Fri, 04 Nov 2011 22:52:20 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/</guid>
				<description><![CDATA[JG Questions 1. What is the Pimpl Idiom, and why is it useful? Guru Questions 2. What is the best way to express the basic Pimpl Idiom in C++11? 3. What parts of the class should go into the impl object? Some potential options include: put all private data (but not functions) into impl; put [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><img style="background-image:none;border-bottom:0;border-left:0;padding-left:0;padding-right:0;display:inline;float:right;border-top:0;border-right:0;padding-top:0;" title="image" border="0" alt="image" align="right" src="https://herbsutter.files.wordpress.com/2011/11/image4.png?w=137&#038;h=244" width="137" height="244" /></p>
<h3>JG Questions</h3>
<p>1. What is the Pimpl Idiom, and why is it useful?</p>
<h3>Guru Questions</h3>
<p>2. What is the best way to express the basic Pimpl Idiom in C++11?</p>
<p>3. What parts of the class should go into the <em>impl</em> object? Some potential options include:</p>
<ul>
<li>put all private data (but not functions) into <em>impl</em>; </li>
<li>put all private members into <em>impl</em>; </li>
<li>put all private and protected members into <em>impl</em>; </li>
<li>put all private nonvirtual members into <em>impl</em>; </li>
<li>put everything into <em>impl</em>, and write the public class itself as only the public interface, each implemented as a simple forwarding function (a handle/body variant).</li>
</ul>
<p>What are the advantages/drawbacks of each? How would you choose among them?</p>
<p>4. Does the <em>impl </em>require a back pointer to the public object? If yes, what is the best way to provide it? If not, why not?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/feed/</wfw:commentRss>
		<slash:comments>23</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2011/11/image4.png" medium="image">
			<media:title type="html">image</media:title>
		</media:content>
	</item>
	</channel>
</rss>
