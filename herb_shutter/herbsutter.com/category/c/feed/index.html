<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	>

<channel>
	<title>C++ &#8211; Sutter’s Mill</title>
	<atom:link href="https://herbsutter.com/category/c/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Fri, 23 Nov 2018 09:30:53 +0000	</lastBuildDate>
	<language>en</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
<cloud domain='herbsutter.com' port='80' path='/?rsscloud=notify' registerProcedure='' protocol='http-post' />
<image>
		<url>https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=96&#038;d=https%3A%2F%2Fs0.wp.com%2Fi%2Fbuttonw-com.png</url>
		<title>C++ &#8211; Sutter’s Mill</title>
		<link>https://herbsutter.com</link>
	</image>
	<atom:link rel="search" type="application/opensearchdescription+xml" href="https://herbsutter.com/osd.xml" title="Sutter’s Mill" />
	<atom:link rel='hub' href='https://herbsutter.com/?pushpress=hub'/>
	<item>
		<title>Trip report: Summer ISO C++ standards meeting (Rapperswil)</title>
		<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/</link>
				<comments>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comments</comments>
				<pubDate>Mon, 02 Jul 2018 18:31:12 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3673</guid>
				<description><![CDATA[On Saturday June 9, the ISO C++ committee completed its summer meeting in beautiful Rapperswil, Switzerland, hosted with thanks by HSR Rapperswil, Zühlke, Netcetera, Bbv, SNV, Crealogix, Meeting C++, and BMW Car IT GmbH. We had some 140 people at the meeting, representing 11 national bodies. As usual, we met for six days Monday through [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>On Saturday June 9, the ISO C++ committee completed its summer meeting in beautiful Rapperswil, Switzerland, hosted with thanks by HSR Rapperswil, Zühlke, Netcetera, Bbv, SNV, Crealogix, Meeting C++, and BMW Car IT GmbH. We had some 140 people at the meeting, representing 11 national bodies. As usual, we met for six days Monday through Saturday, this time including all evenings.</p>
<p>Per our <a href="https://wg21.link/P1000">C++20 schedule</a>, this was the second-last meeting for merging major language features into C++20. So we gave priority to the major proposals that might make C++20 or otherwise could make solid progress, and we deferred other proposals to be considered at a future meeting — not at all as a comment on the proposals, but just for lack of time. We expect to get to these soon once C++20 is well in hand.</p>
<h1>Top news: Contracts adopted for C++20</h1>
<p><a href="https://wg21.link/p0542"><strong>Contracts (Gabriel Dos Reis, J. Daniel Garcia, John Lakos, Alisdair Meredith, Nathan Myers, Bjarne Stroustrup)</strong></a> was formally adopted for C++20.</p>
<p>Contracts allow preconditions, postconditions, and assertions to be expressed in code using a uniform syntax, with options to have different contract levels, custom violation handlers, and more.</p>
<p>Here are a few quick examples to get the flavor. Let’s start with perhaps the most familiar contract, <strong>assert</strong>:</p>
<pre>void f() {
    int x = g();
    int y = h();
<span style="color:#008000;"><strong>    [[assert: x+y &gt; 0]]</strong></span>
}</pre>
<p>“But wait,” someone might say, “C&#8217;s <strong>assert</strong> macro was good enough for my grandpappy, so shouldn’t it be good enough for me?” Never fear, you can still <strong>assert(x)</strong>, but if you respell it as <span style="color:#339966;"><strong>[[assert:x]]</strong></span> you get some benefits. For example:</p>
<ul>
<li>You’re not relying on a macro (unlike C assert). Yes, this matters, because macros are outside the language and routinely cause problems when using language features. For example, this was demonstrated again just a few days ago on Twitter by Nico Josuttis (HT: Alisdair Meredith), who pointed out that <strong>assert(c==std::complex&lt;float&gt;{0,0})</strong> does not compile; the reason is because macros don&#8217;t understand language commas, but <span style="color:#008000;"><strong>[[assert: c==std::complex&lt;float&gt;{0,0}]]</strong></span> works just fine without any surprises.</li>
<li>You get to install your own violation handler and ship a release build with the option of turning on enforcement at run time.</li>
<li>You get to express <span style="color:#008000;"><strong>audit</strong></span> to distinguish expensive checks to be run only when explicitly requested.</li>
<li>You get to express <span style="color:#008000;"><strong>axiom</strong></span> contracts that are intended to never generate run-time code but are available to static analysis tools.</li>
<li>Finally, you will likely get better performance, because contracts should enable compilers to perform more optimizations, more easily, than expressing them using assertions.</li>
</ul>
<p>But there’s more, because of course contracts are not just about assertions. They also include expects preconditions and ensures postconditions, which are part of the function declaration and so are visible at call sites:</p>
<pre>double sqrt(double x) <span style="color:#008000;"><strong>[[expects: x &gt;= 0]]</strong></span>;

void sort(vector&lt;emp&gt;&amp; v) <span style="color:#008000;"><strong>[[ensures audit: is_sorted(v)]]</strong></span>;
    // could be expensive, check only when audit is requested</pre>
<p>In addition to similar benefits as for assert, expects preconditions in particular deliver some enforcement benefits that are very desirable and difficult or impossible to get by hand:</p>
<ul>
<li>Preconditions are usually enforced at the call site, which is what we want most of the time because a precondition violation always means a programming bug in the calling code.</li>
<li>But preconditions can also be enforced in the callee, which can sometimes be necessary for pragmatic reasons, such as when the function is invoked through an opaque function pointer.</li>
<li>Preconditions and postconditions that are known at the call site also give the optimizer more information to potentially make your code fast.</li>
</ul>
<p>As a cheeky aside, if you noticed that I mentioned optimization several times, it’s for the usual reason: The simplest way to get C++ programmers to want a feature is to show that it can make their code faster, even if performance isn’t the only motivation or benefit.</p>
<h1>Why contracts are a big deal, and related Rapperswil progress</h1>
<p>In my opinion, contracts is the most impactful feature of C++20 so far, and arguably the most impactful feature we have added to C++ since C++11. That statement might surprise you, so let me elaborate why I think so.</p>
<p><strong>Having first-class contracts support it is the first major &#8220;step 1&#8221; of reforming error handling in C++</strong> and applying 30 years’ worth of learnings.</p>
<p><strong>Step 2 is to (gradually) migrate std:: standard library precondition violations in particular from exceptions (or error codes) to contracts.</strong> The programming world now broadly recognizes that programming bugs (e.g., out-of-bounds access, null dereference, and in general all pre/post/assert-condition violations) cause a corrupted state that cannot be recovered from programmatically, and so they should never be reported to the calling code as exceptions or error codes that code could somehow handle. Over the past three meetings (Albuquerque through Rapperswil), the Library Evolution Working Group (LEWG) voted unanimously to pursue <strong><a href="https://wg21.link/p0788r2">P0788R2 (Walter Brown)</a></strong> and relatedly in Rapperswil voted unanimously to pursue section 4.2 of <strong><a href="https://wg21.link/p0709">P0709 (my paper)</a></strong>, which includes pursuing a path of gradually migrating all standard library preconditions from exceptions toward contracts. (Note that in the near term, the idea is for implementations to be allowed, but not required, to use contracts. We are bringing the community forward gently here.)</p>
<p>Why is step 2 so important? Because it’s not just window dressing: Gradually switching precondition violations from exceptions to contracts promises to eventually remove a majority of all exceptions thrown by the standard library(!). This principle applies across programming languages; for examples, in Java and .NET some 90% of all exceptions are thrown for precondition violations (e.g., <strong>ArgumentNullException</strong>). Being able to eliminate a majority of all exceptions, which eventually enables many more functions to be <strong>noexcept</strong>, is a huge improvement for both correctness and performance:</p>
<ul>
<li><strong>Correctness: It eliminates a majority of the invisible control flow paths in our code.</strong> For example, over 20 years ago I wrote GotW #20 [<a href="http://gotw.ca/gotw/020.htm">Sutter 1997</a>] that shows how today a 4-line function has 3 normal execution paths and <em>20 invisible</em> exceptional execution paths; if we can eliminate a majority of the functions that can throw, we immediately remove a majority of the invisible possible execution paths in functions like this one, in all calling code.</li>
<li><strong>Performance: More </strong><strong>noexcept</strong><strong> enables more optimization and faster code.</strong> (You knew that was coming, right?)</li>
</ul>
<p>Once you change all preconditions (and postconditions and assertions) from exceptions to contracts, eliminating some of the largest categories of exceptions, one specific kind of exception dominates all others: <strong>bad_alloc</strong>. Which brings us to step 3…</p>
<p><strong>Step 3 is to consider handling heap exhaustion (out-of-memory, OOM) differently from other errors.</strong> If in addition to not throwing on precondition violations we also do not throw on OOM, the vast majority of all C++ standard library functions can be <strong>noexcept</strong>. — Needless to say, this would be a huge change where we need to tread carefully and measure impact and high-fidelity compatibility in major real code bases, and we don’t want people to panic about it or think we’ve lost our minds: We are serious about bringing code forward gently after validating good adoptability and low impact long before this gets near an actual standard.</p>
<p>Nevertheless, we are also serious about improving this, and the fundamental change is simple and already fully supported in C++ today: In Rapperswil, LEWG also voted unanimously to pursue section 4.3 of <strong><a href="https://wg21.link/p0709">P0709 (my paper)</a></strong> which proposes pursuing a path of gradually migrating all OOM from <strong>bad_alloc</strong> to <strong>new(nothrow)</strong>-like mechanisms. The initial contemplated step, definitely not for C++20, would be to change the default <strong>new_handler</strong> from throwing <strong>bad_alloc</strong> to calling <strong>terminate</strong>. That might sound like a big change, but it’s not, it’s already fully supported in C++ today because you can already change the <strong>new_handler</strong> to terminate today with a single line of code (<strong>std::set_new_handler([]{terminate();});</strong>), and this would just be changing the default and existing code that wants to keep the current behavior could still write simply the reverse single line of code (<strong>std::set_new_handler([]{throw std::bad_alloc();});</strong>) to get exactly the current behavior.</p>
<p>To repeat, this is a feature that will want a clear high-fidelity zero-breakage migration path, and we’re treating that compatibility seriously, even as we are also treating solving this problem seriously to modernize C++ error handling and move toward a mostly-<strong>noexcept</strong> world.</p>
<p>You can find a more detailed writeup in my new proposal <a href="https://wg21.link/p0709"><strong>P0709</strong></a>, particularly sections 1.1, 4.2, and 4.3. Again, P0709 is not for C++20, it is to illustrate a direction and potential path. The other parts of P0709 have not yet been reviewed by the full committee, so for now they should not be treated as anything more than a proposal, subject to much discussion and feedback over the coming several years.</p>
<h1>Other new features approved for C++20</h1>
<p>We adopted several other new features into the draft standard.</p>
<p><strong><a href="https://wg21.link/p0941">Feature test macros (Ville Voutilainen, Jonathan Wakely).</a></strong> This enables code to portably test whether a certain new C++ feature exists. “Why would I do that?” someone might ask. The primary and biggest benefit is <strong>they help your team to start to adopt new C++ features even before all your compilers support them</strong>; just write</p>
<pre>#if /*new feature is present*/ // temporary
<strong>    nice clean modern code!    // &lt;-- keep this long-term</strong>
#else                          // temporary
    do it the old way          // temporary
#endif                         // temporary</pre>
<p>and eventually drop the #if test and the whole #else block as soon as all your compilers are up to date. This is so much better than today, where one of two things happens: (1) Teams often wait until all their compilers support a given new C++ feature before they start to use it, which slows down adopting the new features and getting their benefits at least on the compilers that do support it. Or, (2) teams roll their own nonstandard nonportable compiler-specific “approximate” feature tests (e.g., write their own macro for “I know this feature is available on version ## of MSVC and version ## of GCC” by hand).</p>
<p>We all agree we don’t like macros. However, we don’t yet have replacements for all uses of macros, including this one, and these standard macros are better than rolling your own nonstandard ones or, more likely, just not using new C++ features at all for a longer time.</p>
<p>Some experts still disagree, and we respect their views, but in my view these feature test macros are an important and pragmatic help to improve the speed of adoption of new standard C++ features.</p>
<p><strong><a href="https://wg21.link/p0898">Standard library concepts (Casey Carter, Eric Niebler).</a></strong> This is the first part of the Ranges TS to be merged into C++20 at an upcoming meeting, and contains the core concepts from the Ranges TS. It is also the first appearance of the concepts language feature in the standard library. Expect more to come for C++20 (see Ranges, below).</p>
<p><strong><a href="https://wg21.link/p0732">Class Types in Non-Type Template Parameters (Jeff Snyder, Louis Dionne).</a></strong> Yes, you can now have types other than int and char as non-type template parameters. For example, in addition to <strong>template&lt;int Size&gt;</strong>, you can now have things like <strong>template&lt;fixed_string S&gt;</strong> for a suitably defined class type. It turns out that this builds on the <strong>&lt;=&gt;</strong> spaceship comparison operator; and if you’re wondering why, it’s because we know the semantics of a defaulted <strong>&lt;=&gt;</strong> comparison, which is essential because the compiler has to perform comparisons to determine whether two template instantiations are the same.</p>
<p>Note: I did not have this benefit in mind at all when I proposed <strong>&lt;=&gt;</strong>. I think this is a great example where, when you let programmers express intent explicitly as with <strong>&lt;=&gt;</strong>, and provide useful defaults, you are inherently adding more reliable information to the source code and will reap additional benefits because you can now build on knowledge of that clear programmer intent.</p>
<p><a href="https://wg21.link/p0892"><strong>explicit(bool) (Barry Revzin).</strong></a> This is conditional <strong>explicit</strong>, along the same lines as conditional <strong>noexcept</strong>. It lets library writers write <strong>explicit</strong> at a finer granularity, to turn off conversions where possible and feasible, without having to write two functions all the time.</p>
<p><strong><a href="https://wg21.link/p0476">Bit-casting object representations (JF Bastien).</a></strong> Header <strong>&lt;bit&gt;</strong> now lets you <strong>bit_cast.</strong> “But wait,” someone may be thinking, “don’t we already have <strong>reinterpret_cast</strong>?” Yes we do, and this is still a reinterpreting operation, but <strong>bit_cast</strong> has less unsafety and some additional flexibility: it ensures the sizes of the From and To types match, guarantees that they are both actually trivially copyable, and as a bonus makes the operation <strong>constexpr</strong> wherever possible.</p>
<p>Speaking of constexpr bit_cast, here are some more items in the “constexpr all the things!” department:</p>
<ul>
<li><strong><a href="https://wg21.link/p0879">“Constexpr for swap and swap related functions” (Antony Polukhin).</a></strong> Don’t be misled by the title, there are a lot of algorithms mentioned here.</li>
<li><strong><a href="https://wg21.link/p1064">“Allowing Virtual Function Calls in Constant Expressions” (Peter Dimov, Vassil Vassilev).</a></strong> Even if you weren’t surprised that we were thinking of <strong>constexpr new</strong> (we are), you might still be surprised about <strong>constexpr virtual</strong> functions. After all, virtual functions are dynamic, right? Yes they are… except when they run at compile time. So here’s another step to general C++ compile-time code.</li>
</ul>
<h1>Other progress and decisions</h1>
<p><strong>Reflection TS is feature-complete</strong>: The Reflection TS was declared feature-complete and is being sent out for its main comment ballot over the summer. Note again that the TS’s current template metaprogramming-based syntax is just a placeholder; the feedback being requested is on the core “guts” of the design, and the committee already knows it intends to replace the surface syntax with a simpler programming model that uses ordinary compile-time code and not <strong>&lt;&gt;</strong>-style metaprogramming.</p>
<p><strong>Parallelism TS2 is done</strong>: The second Parallelism TS is done! We completed ballot comment resolution, and approved the final TS for publication. This TS includes more execution policies, an <strong>exception_list</strong> type to communicate multiple parallel exceptions, and more parallel algorithms including wavefront, reductions, inductions, parallel for, and more. It also includes <strong>task_block</strong> support to enable writing custom parallel algorithms.</p>
<p><strong>Graphics (io2d) is deferred</strong>: Many thanks to Michael McLaughlin especially, and to Guy Davidson, Michael Kazakov, and David Ludwig for their assistance with the design, specification, and implementation of this cross-platform library. This is a project that has been worked on for several years, and for the past two years has been primarily responding to committee tweak requests; unfortunately, although the committee requested a series of updates to the proposal that have been applied, at this meeting the committee decided that it does not have interest to pursue further work on graphics in any form at this time after all. However, the io2d project will continue, and be available on package managers (Conan, vcpkg), and we expect a renewed proposal in the medium term; in the meantime, watch <a href="https://hatcat.com">Guy Davidson’s blog</a> for news and updates.</p>
<p>Also, LEWG adopted <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0921r2.pdf">P0921r2</a> as a statement of their direction for future C++ standard library evolution compatibility guarantees.</p>
<h1>Updates on other major proposals</h1>
<p>Here are other major items in progress. You’ll notice that the first six (6!) of them mention expectations for our next meeting this November in San Diego. Not all of those items will make C++20 in San Diego, but people are going to try. It’s not surprising that San Diego is going to be a busy meeting, though; that was expected, because it’s the last meeting to merge major features into C++20, and deadlines are famously motivational. — Just <strong>do not</strong> expect all of the following to make C++20, and I’m listing them in rough order starting with the most likely to make it in.</p>
<p><strong>(very likely for C++20) Ranges</strong>: In my previous trip report I mentioned that the core concepts from the Ranges TS were expected to make C++20, but the rest of the Ranges TS would be “C++20 or C++23.” Since then we have made faster than expected progress, and it now looks like Ranges is “likely” to make C++20 in the next meeting or two. For those interested in details, in addition to all of the Ranges TS, also paper P0789 on Range Adaptors and Utilities have now progressed to detailed wording review and are targeting C++20. In sum, to quote Eric Niebler: “If you liked the Ranges TS, you’ll love C++20.”</p>
<p><strong>(likely for C++20) Concepts: “convenience” notation for constrained templates</strong>: We already added the concepts core feature to C++20, and at this meeting we had further discussions on adding a convenience syntax to write constrained templates without resorting to the low-level “<strong>requires</strong>” keyword. The two major active proposals that received discussion were from Bjarne Stroustrup and from me. The good news is that the Evolution Working Group (EWG) liked both, which means that for the first time we have a proposal based on the TS syntax (Bjarne’s preference) that could get consensus to be approved!</p>
<p>The key people are continuing to work to come up with a merged proposal that might be adoptable for C++20 in November in San Diego, and I’m pleased to report that as of this post-meeting mailing we for the first time have a unified proposal that lists most of the previous authors of papers in this area as coauthors, you can find it here: <strong><a href="https://wg21.link/P1141">P1141R0: “Yet another approach for constrained declarations.”</a></strong> I’m guardedly optimistic that we may have a winner here; we’ll know in San Diego. (I sometimes delay my trip report until the post-meeting mailing is available so that everyone can see the latest papers, and knowing that this new paper was coming was one reason I delayed this report.)</p>
<p><strong>(maybe for C++20) Coroutines</strong>: EWG considered an alternative, then decided to go forward with the TS approach. That came up for full committee vote but fell just short and was not adopted for C++20; the proposers will continue to work on improving consensus over the summer by addressing remaining concerns and we expect coroutines to be proposed again for C++20 at our November meeting in San Diego.</p>
<p><strong>Modules</strong>: For the first time, the committee saw a merged approach that both major proposers said satisfies their requirements; that announcement was met by applause in the room. The merged proposal aims to combine the “best of” the Modules TS and the Atom alternative proposal, and that direction was approved by EWG. EWG did not approve the poll to incorporate a subset of it into C++20 at this meeting; it is not yet clear whether part of the proposal can make C++20 but we are going to have an extra two-day meeting in September to help make progress and we expect it to be proposed again for C++20 at our November meeting in San Diego.</p>
<p><strong>Executors</strong>: This is still not expected to be part of C++20, but key people have not given up and are trying to make it happen, and one never can tell. We are going to hold an extra two-day meeting in September to help make progress on Executors, and expect to have a lively discussion about options to merge all or parts of it into C++20 in November in San Diego.</p>
<p><strong>Networking</strong>: This is pretty much ready except that it depends on Executors. Soon after Executors are ready for C++20, Networking is ready to slide in right behind it.</p>
<p>Clearly San Diego is going to be a busy meeting. But before then we have two extra design meetings on modules and executors to help improve their chances of progress; those will be co-located with <strong><a href="https://cppcon.org/">CppCon in September</a></strong>, to take place near the CppCon site on the days just before the conference begins. On top of that, there will also be an extra library wording issues meeting in the Chicago area in August… all in all, it’ll be a full summer and fall before we even get to San Diego.</p>
<p>Additionally, <strong>SG12</strong> had productive discussions about undefined behavior (including with participation from our sister ISO working group WG23, Programming Language Vulnerabilities), and <strong>SG15</strong> had a second exploratory evening session focusing on package managers for C++.</p>
<h1>What’s next</h1>
<p>Here is a cheat-sheet summary of our current expectations for some of the major pieces of work. Note that, as always, this is an estimate only. The bolded parts are the major changes from last time, including that Ranges as a whole is looking very likely for C++20.</p>
<p><img data-attachment-id="3675" data-permalink="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/wg21-schedule-2018-06/" data-orig-file="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500" data-orig-size="1357,617" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wg21-schedule-2018-06" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500?w=300" data-large-file="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500?w=500" class="alignnone size-full wp-image-3675" src="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500" alt="wg21-schedule-2018-06" srcset="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500 500w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=150 150w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=300 300w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=768 768w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>And here is an updated snapshot of where we are on the timeline for C++20 and the TSes that are completed, in flight, or expected to begin:</p>
<p><img data-attachment-id="3674" data-permalink="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/wg21-timeline-2018-06/" data-orig-file="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500" data-orig-size="1943,1339" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wg21-timeline-2018-06" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500?w=300" data-large-file="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500?w=500" class="alignnone size-full wp-image-3674" src="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500" alt="wg21-timeline-2018-06" srcset="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500 500w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=150 150w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=300 300w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=768 768w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>Thank you again to the approximately 140 experts who attended this meeting, and the many more who participate in standardization through their national bodies! Have a good spring… we look forward now to our next “extra” meetings in September (Bellevue, WA, USA) and the next regular WG21 meeting in November (San Diego, CA, USA).</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/feed/</wfw:commentRss>
		<slash:comments>25</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png" medium="image">
			<media:title type="html">wg21-schedule-2018-06</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png" medium="image">
			<media:title type="html">wg21-timeline-2018-06</media:title>
		</media:content>
	</item>
		<item>
		<title>Interview: On simplifying C++</title>
		<link>https://herbsutter.com/2017/11/02/interview-on-clion-on-simplifying-c/</link>
				<comments>https://herbsutter.com/2017/11/02/interview-on-clion-on-simplifying-c/#comments</comments>
				<pubDate>Thu, 02 Nov 2017 17:29:59 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3602</guid>
				<description><![CDATA[I was also interviewed recently by Anastasia Kazakova for the CLion blog, and that interview is now live: Toward a more powerful and simpler C++ with Herb Sutter Topics include: Concepts and modules (and coroutines) as the true hot topics right now How my work on metaclasses was motivated and developed Obligatory aside on operator&#60;=&#62; [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I was also interviewed recently by Anastasia Kazakova for the CLion blog, and that interview is now live:</p>
<blockquote>
<h3><a href="https://blog.jetbrains.com/clion/2017/11/towards-a-more-powerful-and-simpler-cpp-with-herb-sutter/">Toward a more powerful and simpler C++ with Herb Sutter</a></h3>
</blockquote>
<p>Topics include:</p>
<ul>
<li>Concepts and modules (and coroutines) as the true hot topics right now</li>
<li>How my work on metaclasses was motivated and developed</li>
<li>Obligatory aside on operator&lt;=&gt; which grew out of the same work</li>
<li>Good and bad ways to learn from other languages and their experience</li>
<li>What are the next questions to be answered for metaclasses proposal</li>
<li>What has been the committee&#8217;s feedback so far</li>
<li>How can we expect to see reflection, compile-time code, injection, and metaclasses both progress in committee and get built into production compilers</li>
<li>How toolable are today&#8217;s C++11/14/17 features, and what about toolability for metaclasses</li>
</ul>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/11/02/interview-on-clion-on-simplifying-c/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>My Qt World Summit keynote video is now online</title>
		<link>https://herbsutter.com/2017/10/25/my-qt-world-summit-keynote-video-is-now-online/</link>
				<comments>https://herbsutter.com/2017/10/25/my-qt-world-summit-keynote-video-is-now-online/#comments</comments>
				<pubDate>Wed, 25 Oct 2017 18:31:51 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3578</guid>
				<description><![CDATA[The Qt World Summit videos were just posted, including my talk which was a condensed (40-minute) version of my CppCon 2017 metaclasses talk with some small tweaks for a Qt-specific audience. Here it is below:]]></description>
								<content:encoded><![CDATA[<p>The Qt World Summit videos were just posted, including my talk which was a condensed (40-minute) version of my <a href="https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/">CppCon 2017 metaclasses talk</a> with some small tweaks for a Qt-specific audience.</p>
<p>Here it is below:</p>
<iframe class='youtube-player' type='text/html' width='500' height='282' src='https://www.youtube.com/embed/NunSS_ppDsI?version=3&#038;rel=0&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;start=77&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/10/25/my-qt-world-summit-keynote-video-is-now-online/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Interview with InfoQ: C++17, and beyond&#8230;</title>
		<link>https://herbsutter.com/2017/10/23/interview-with-infoq-c17-and-beyond/</link>
				<pubDate>Tue, 24 Oct 2017 00:54:28 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3563</guid>
				<description><![CDATA[Last week I did an interview by email with InfoQ. It just went live: C++17 is Here: Interview with Herb Sutter Topics include: What parts of C++17 should developers get most excited about? Why didn&#8217;t concepts make it into C++17? What will be the major focus areas for C++20? What do you find interesting or [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Last week I did an interview by email with InfoQ. It just went live:</p>
<blockquote>
<h3 class="general"><a href="https://www.infoq.com/news/2017/10/cpp-17-herb-sutter-interview">C++17 is Here: Interview with Herb Sutter</a></h3>
</blockquote>
<p>Topics include:</p>
<ul>
<li>What parts of C++17 should developers get most excited about?</li>
<li>Why didn&#8217;t concepts make it into C++17?</li>
<li>What will be the major focus areas for C++20?</li>
<li>What do you find interesting or inspiring about new languages like Rust, Swift, and Go?</li>
<li>Any new books coming? What&#8217;s your main focus today?</li>
</ul>
]]></content:encoded>
									
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Update on October seminar in London</title>
		<link>https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/</link>
				<comments>https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/#comments</comments>
				<pubDate>Tue, 05 Sep 2017 18:23:12 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Effective Concurrency]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3325</guid>
				<description><![CDATA[As I mentioned earlier, part of my fall schedule is to give a repeat of this spring&#8217;s sold-out seminar: &#8220;High-Performance and Low-Latency C++&#8221; (October 9-11, London, UK). I am still getting mails about whether there are alternative/additional European dates for this seminar. Unfortunately, the answer is still no, but since I&#8217;m getting inquiries about it let [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>As I mentioned earlier, part of my fall schedule is to give a repeat of <a href="https://herbsutter.com/2017/02/13/this-spring-high-performance-and-low-latency-c-stockholm-and-accu-bristol/">this spring&#8217;s</a> sold-out seminar: <a href="https://www.alfasoft.com/en/events/other/683-683-high-performance-and-low-latency-c-with-herb-sutter.html">&#8220;High-Performance and Low-Latency C++&#8221; (October 9-11, London, UK)</a>.</p>
<p>I am still getting mails about whether there are alternative/additional European dates for this seminar. Unfortunately, the answer is still no, but since I&#8217;m getting inquiries about it let me repeat that part of the earlier post:</p>
<blockquote><p>On October 9-11, I’ll be in London giving a one-time repeat of <a href="https://www.alfasoft.com/en/events/other/683-683-high-performance-and-low-latency-c-with-herb-sutter.html"><strong>“High-Performance and Low-Latency C++” </strong>(course details page)</a>. This is the same as the public course I gave in Stockholm [in April]; because that course sold out, and I was coming to Europe again for Qt World Summit anyway, we decided to do a single repeat that same week, this time in London.</p>
<p>Notes: (1) Some of you have emailed me asking if there will be other dates/cities, and the answer is no, sorry, I do seminars very rarely and this is the last one I have time to do for the foreseeable future. So if you are interested then this is the one to attend. (2) Some of you have also emailed me to ask whether the seminar will be recorded, and the answer is again no, sorry, the organizers are not set up for that. However, you can find all of my past <em>Effective Concurrency</em> writing (on which parts of this course are based) freely available via this blog, just search for that phrase or use the category tag — there’s a book’s worth of free material written by me in individual-article form.</p></blockquote>
<p>So, if you&#8217;re interested, I hope you&#8217;ll be able to attend this October, and I look forward to seeing many of you there.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Metaclasses: Thoughts on generative C++</title>
		<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/</link>
				<comments>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comments</comments>
				<pubDate>Wed, 26 Jul 2017 15:34:32 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3292</guid>
				<description><![CDATA[I’ve been working on an experimental new C++ language feature tentatively called “metaclasses” that aims to make C++ programming both more powerful and simpler. You can find out about it here: Current proposal paper: P0707R1. I hope the first ten pages give a readable motivation and overview. (The best two pages to start with are [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I’ve been working on an experimental new C++ language feature tentatively called “metaclasses” that aims to make C++ programming both more powerful and simpler. You can find out about it here:</p>
<ul>
<li><a href="https://herbsutter.files.wordpress.com/2017/07/p0707r1.pdf"><strong>Current proposal paper: P0707R1.</strong></a> I hope the first ten pages give a readable motivation and overview. (The best two pages to start with are 9 and 10, which probably means I need to reorder the paper…)</li>
<li><a href="https://youtu.be/6nsyX37nsRs"><strong>Initial intro talk video: ACCU 2017 (YouTube).</strong></a> This is the initial public presentation three months ago. Thank you to <strong>Roger Orr, Russel Winder, Julie Archer, and the other ACCU organizers</strong> for inviting me and for holding back the video until we could have the ISO C++ summer meeting about a week ago, so it could go live along with a report (herein) on the results of this feature’s first presentation to the ISO C++ committee. And special thanks to <strong>Ina and Arvid</strong>, the two audience volunteers who graciously agreed to come on-stage to participate in a live mini UX study. There’s a lot of subtle information in their nuanced reactions to the code examples; pay special attention when their responses are different or as their responses evolve.</li>
<li><strong>“Incomplete and experimental” prototype compiler.</strong> The Clang-based prototype by <strong>Andrew Sutton</strong> is available as an online live compiler at <a href="https://cppx.godbolt.org/">cppx.godbolt.org</a>, and as source at <a href="https://github.com/asutton/clang">github.com/asutton/clang</a>. It’s incomplete but can compile a number of the examples in the paper (see the paper for example code links). Thanks to <strong>Matt Godbolt</strong> for hosting it on godbolt.org!</li>
</ul>
<p>Please see the paper and video to answer “what are metaclasses and why should I care?” If you’re the “show me code first, English later” kind of person, try the live compiler and these quick examples: <a href="https://godbolt.org/g/Uzw5iJ">interface</a>, <a href="https://godbolt.org/g/sXmhkN">base_class</a>, <a href="https://godbolt.org/g/59LSSZ">value</a> (regular type), <a href="https://godbolt.org/g/2uMpF5">plain_struct</a> (these links are also in the paper).</p>
<p>The rest of this post aims not to duplicate any information above, but to provide some context about the broader journey, and what I and others are attempting to accomplish.</p>
<h1>A journey: Toward more powerful and simpler C++ programming</h1>
<h2>Phase 1: By using the existing language better</h2>
<p>About five years ago, I started working on long-term effort toward making using C++ simpler and safer.</p>
<p>In the first phase, a small group of us—centered on <strong>Bjarne Stroustrup, Gabriel Dos Reis, Neil MacIntosh </strong>and <strong>Andrew Pardoe</strong>—pushed to see how far we could get with “C++ as it is” plus just a few well-chosen library-only extensions, with a particular goal of improving type and memory safety. Bjarne, Neil, and I first publicly reported on this effort in the two CppCon 2015 plenary sessions <a href="https://www.youtube.com/watch?v=1OEu9C51K2A">“Writing Good C++14”</a> and <a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">“Writing Good C++14… By Default.”</a> The results of that work so far have manifested as the <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a> and its support library <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-gsl">GSL</a> that adds a limited number of library types (e.g., <a href="https://wg21.link/P0122"><em>span</em>, now being standardized</a>); and I led the Lifetime design in particular (available in the <a href="https://github.com/isocpp/CppCoreGuidelines/tree/master/docs">Guidelines /docs folder</a>) which Neil and I and others continue to work on formalizing with the aim of sharing a “draft” static analysis spec later this year.</p>
<p>One of the goals of this phase was to answer the question: “How much progress can we make toward simplifying the existing C++ language with only a few key library extensions?” The answer as I see it turned out to be: “Some solid progress, but probably not a major simplification.” And so that answer led to phase two…</p>
<h2>Phase 2: By evolving the language</h2>
<p>Two years ago, I started to focus specifically on exploring ways that we might evolve the C++ language itself to make C++ programming both more powerful and simpler. The only way to accomplish both of those goals at the same time is by adding abstractions that let programmers directly express their intent—to elevate comments and documentation to testable code, and elevate coding patterns and idioms into compiler-checkable declarations. The work came up with several potential candidate features where judiciously adding some power to the language could simplify code dramatically.</p>
<p>Of those potential candidate features, metaclasses is the first major piece I picked to propose for ISO C++. [*] We presented it for the first time at the summer ISO C++ meeting earlier this month, and it received a warm reception. There was (rare) unanimous support for pursuing this kind of capability, but also some concern about how best to expose it and specific design change feedback the committee wants us to apply to improve the proposal. [**] We’ll work to include in a revision for the November standards meeting as we start the multi-year process of vetting and refining the proposal. So this is good progress, but note that it (only) means encouragement to continue the experiment and see where it leads; it’s far too early to talk about potential ship vehicles.</p>
<p>So do expect change: The proposal is still evolving, and it in turn assumes and builds on the <a href="https://wg21.link/P0578">static reflection proposal (P0578 et al.)</a> and the <a href="https://wg21.link/P0633">compile-time programming proposal (P0633)</a>, both of which are actively evolving in their own right. Incidentally, one of the contributions of Andrew Sutton’s prototype metaclasses compiler is that it is implementing those other proposals too(!), since the metaclasses feature needs them. The aim is to keep the latest compiler and the latest P0707 paper in sync with each other and with those related proposals, but there will doubtless be occasional drift in between syncs.</p>
<h1>What’s next</h1>
<p>I’ll talk about metaclasses more in my upcoming <a href="https://cppcon.org/2017-keynote-speakers/">CppCon 2017 talk</a> this September, and<strong> Andrew Sutton </strong>will also be giving two CppCon talks about metaclasses—one about implementing them in Clang, and one about using them for a real project.</p>
<p>This is just the beginning, and we’ll see whether it all pans out and leads somewhere, but I hope you enjoy this exploration and I look forward to talking with many of you about it at CppCon this September.</p>
<p>&nbsp;</p>
<p>———</p>
<h1>Notes</h1>
<p>[*] I actually brought a smaller piece from this same work to the committee at the previous meeting, the winter meeting in Kona: <a href="https://wg21.link/P0515">P0515</a> (consistent comparisons), which proposes adding the three-way <strong>&lt;=&gt;</strong> comparison operator. P0515 is only about a minor feature, and not one of the most important things that can help improve C++, so normally I wouldn’t have picked that piece to contribute first; but the committee was already continuing to actively discuss comparisons, so I cherry-picked it from my design work and contributed it since I had the design in my pocket anyway. Happily the committee liked what they saw and both EWG and LEWG accepted it, and it is now progressing well and on track to hopefully be voted into draft C++20 in the next meeting or two. Thanks to <strong>Jens Maurer</strong> and <strong>Walter Brown</strong> for the heavy lifting of writing the core language and library standardese wording, respectively, for that P0515 proposal.</p>
<p>[**] The committee’s design feedback was primarily about how to wrap up the transformation code: Instead of putting it inside a new “meta” class-like abstraction, how about wrapping the same code inside a compile-time function-like abstraction that takes an input meta::type parameter and returns a generated meta::type return value? This doesn’t affect the proposal’s basic engine, just the shape of its steering wheel—for example, we could change the first line of each example metaclass definition from the class-like syntax</p>
<pre>$class <strong>interface</strong> {
    constexpr {
        // … basically same code …
    }
};</pre>
<p>to the decorator-function-like syntax</p>
<pre>meta::type <strong>interface</strong>(const meta::type source) {
    // … basically same code …
};</pre>
<p>where the latter has the advantage that it’s easy to see that we’re reading one type and generating another type. Interestingly, I think this dovetails with the mini UX study in the video where most of the difficulty the UX participants seemed to encounter was in understanding the $class syntax, not the metaclass bodies and not later using the metaclasses to author new types.</p>
<p>But we’ll explore this and other options and validate/invalidate it with more experiments… and feel free to express your thoughts in the comments if you like one of these styles better, or perhaps another variation.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/feed/</wfw:commentRss>
		<slash:comments>78</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Summer ISO C++ standards meeting (Toronto)</title>
		<link>https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/</link>
				<comments>https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/#comments</comments>
				<pubDate>Sat, 15 Jul 2017 15:39:08 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3259</guid>
				<description><![CDATA[[This post will be updated with additional details as mentioned in the comments section at bottom.] A few minutes ago, the ISO C++ committee completed its summer meeting in Toronto, Ontario, Canada. We had some 120 people at the meeting, representing nine national bodies. As usual, we met for six days Monday through Saturday, including [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><img data-attachment-id="3267" data-permalink="https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/wg21-toronto-city/" data-orig-file="https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png" data-orig-size="645,861" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wg21-toronto-city" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=225" data-large-file="https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=500" class="alignright size-medium wp-image-3267" src="https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=225&#038;h=300" alt="No, we didn't meet at city hall, but this shot was taken from the primary hotel which was across the street from city hall. Also, this building appears in Star Trek: http://spacing.ca/toronto/2013/10/01/star-trek-toronto-city-hall/" width="225" height="300" srcset="https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=225&amp;h=300 225w, https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=450&amp;h=600 450w, https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=112&amp;h=150 112w" sizes="(max-width: 225px) 100vw, 225px" /><em>[This post will be updated with additional details as mentioned in the comments section at bottom.]</em></p>
<p>A few minutes ago, the ISO C++ committee completed its summer meeting in Toronto, Ontario, Canada. We had some 120 people at the meeting, representing nine national bodies. As usual, we met for six days Monday through Saturday, including several evenings.</p>
<p>The following are some highlights of what we achieved this week. You can find a brief summary of ISO procedures <a href="https://isocpp.org/std/iso-iec-jtc1-procedures">here</a>. The main things to note are:</p>
<ul>
<li>“IS” means “international standard.” In our case, it’s the core C++ standard itself. Think of this as “trunk.”</li>
<li>“TS” means “technical specification,” a document separate from the main standard where we can gain experience with new features before putting them into the IS. We have several of these, summarized on the <a href="http://isocpp.org/std/status">status page</a>. Think of these as “beta branches.”</li>
</ul>
<p>Note: As I reported in my <a href="https://herbsutter.com/2017/03/24/trip-report-winter-iso-c-standards-meeting-kona-c17-is-complete/">previous trip report</a> for the winter meeting (Kona 2017), we have already completed our work on C++17, which is now still going through its final ISO approval steps. Nothing we did this week affects C++17, but we did begin work on C++20…</p>
<h2>First meeting for C++20</h2>
<p>This was the first meeting where we could vote changes into Draft C++20. And we did!</p>
<p>First, the<strong> Concepts TS </strong>was merged into draft C++20. Yes, Concepts are back in the draft international standard and better than C++0x, which makes the famous concepts feature (principally driven by Bjarne Stroustrup, Gabriel Dos Reis, and Andrew Sutton) the first major language feature voted into draft C++20. Recall that Concepts was published as a separate TS two years ago, and available in GCC; today we voted to adopt nearly of it, except only the “introducer syntax” and “terse/natural syntax” for now because that syntax still has a handful of remaining issues that don’t have consensus, but it’s close and Evolution also voted unanimously to aggressively pursue adding the terse syntax as soon as possible once those design questions can be addressed. A few specific Concepts changes were also approved along with the merge, notably removing the need to write &#8220;bool&#8221; and removing function concepts until we see a need to overload concepts.</p>
<p>Here are some other features that were added to C++20 at this meeting. Note: These links currently find the most recent pre-meeting papers and so may not reflect the exact wording adopted at the meeting, but the links will light up to the post-meeting versions of the papers that were actually adopted as soon as those are available in the post-meeting mailing about three weeks from now.</p>
<ul>
<li><a href="https://wg21.link/p0409">Allow lambda capture [=, this].</a> Mostly a style issue, but it extends the legal syntax for C++17’s capture of “this” so that programmers can write this stylistically if they want to be explicit in their code.</li>
<li><a href="https://wg21.link/p0329">Add designated initializers.</a> Draft C++20 now allows code like: struct A { int x; int y; int z; }; A b{<strong>.x =</strong> 1, <strong>.z =</strong> 2};</li>
<li><a href="https://wg21.link/p0428">Allow template parameter lists on lambdas.</a> For example: auto f = []<strong>&lt;typename T&gt;</strong>(std::vector&lt;T&gt; vector) { /*&#8230;*/ };</li>
</ul>
<h2>One TS sent for its ISO ballot, three TSes completed to be published</h2>
<p>We also spent quite a bit of the week working on three TSes that completed their review ballots, and sending out one more: The <strong>Modules TS</strong> is sent out for its comment and approval (PDTS) ballot. And the <strong>Coroutines TS</strong>, <strong>Networking TS</strong>, and <strong>Ranges TS</strong> are all done, as the groups worked hard to process and address all the comments from their ballots and we are sending them out for final publication. – It’s not every meeting that we publish three specifications! Some of them would have been handled at our last meeting, but we were busy finishing C++17 so they stacked up for this meeting.</p>
<p>Thank you very much again to all the volunteers who helped progress our proposals, send out our PDTSes, address our ballot comments and publish three (3) TSes, and get the C++20 cycle off to a roaring start.</p>
<h2>Other progress</h2>
<p>We considered merging one other published TS, the <strong>Concurrency TS</strong>. The feeling was that its three major features were in different stages of readiness, and some are advancing toward bring merged into C++20, possibly at our next meeting:</p>
<ul>
<li><strong>atomic_shared_ptr&lt;T&gt;</strong> is on track to be merged into C++20 with changes, in detailed standardese wording review and expected to be put up for approval at our next meeting. Interestingly, some of the changes are to make it more like the original design I proposed, including to name it atomic&lt;shared_ptr&lt;T&gt;&gt;.</li>
<li><strong>Latches</strong> are also approved, essentially as-is, and the feature is in wording review for the next meeting.</li>
<li><strong>Barriers</strong> are also potentially on track for C++20 but SG1 is still discussing open design problems. Its design can be expected to change substantially from the TS version.</li>
<li>Some minor pieces of the <strong>future</strong> extensions are moving ahead, but the extension has several unresolved design issues including to coordinate with the (we hope soon-coming) executors design.</li>
</ul>
<p>Other items making progress for possible consideration to be adopted in the fall meeting:</p>
<ul>
<li>The first part of <a href="https://wg21.link/P0194">compile-time reflection</a> is in wording review.</li>
<li>The library groups are starting to <a href="https://issues.isocpp.org/show_bug.cgi?id=311">remove deprecated features</a>.</li>
</ul>
<p>The Library Evolution group has started discussing at how to integrate modules and contracts into the standard library. They expect to start integrating concepts next meeting, which is a big benefit of getting a major feature merged early in the C++20 cycle. They are also actively working on <a href="https://wg21.link/P0244">Unicode support</a>, several new containers, and a <a href="https://wg21.link/P0355">date library</a>, among other things.</p>
<p>We also continued incubating other work. In particular, the <strong>Reflection</strong> study group had presentations, and gave direction and feedback, on a few additions to the static reflection proposal that is already progressing in the main subgroups, the compile-time programming proposal, and my new metaclasses paper. (I’ll post a separate report on the metaclasses part soon, probably in the next week or so, with a link to the ACCU video.)</p>
<h2>What’s next</h2>
<p>In my <a href="https://herbsutter.com/2016/11/15/trip-report-fall-iso-c-standards-meeting-issaquah/">trip report last fall</a>, two meetings ago, I wrote: “Then, once C++17 ships next year and possibly as soon as our July meeting, I expect we’ll start looking at merging more of the TS ‘beta branches’ into the C++ ‘trunk.’”</p>
<p>Well, that’s exactly what happened: We did finish C++17 at the next meeting, and now at the meeting after that we did merge our first major TS into the C++ trunk.</p>
<p>Here’s an updated snapshot of our status (the latest is always on the <a href="https://isocpp.org/std/status">isocpp.org/std/status</a> page):</p>
<p><a href="https://isocpp.org/files/img/wg21-timeline-2017-07b.png"><img data-attachment-id="3263" data-permalink="https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/wg21-timeline-2017-07b/" data-orig-file="https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=500" data-orig-size="1937,1427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wg21-timeline-2017-07b" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=500?w=300" data-large-file="https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=500?w=500" class="alignnone size-full wp-image-3263" src="https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=500" alt="wg21-timeline-2017-07b" srcset="https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=500 500w, https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=150 150w, https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=300 300w, https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png?w=768 768w" sizes="(max-width: 500px) 100vw, 500px"   /></a></p>
<p>Thank you again to the 120 experts in Toronto this week, and the many more who participate in standardization through their national bodies! Have a good summer – and see you at <a href="https://cppcon.org/">CppCon</a>!</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2017/07/wg21-toronto-city-e1500123984972.png?w=450" medium="image">
			<media:title type="html">No, we didn&#039;t meet at city hall, but this shot was taken from the primary hotel which was across the street from city hall. Also, this building appears in Star Trek: http://spacing.ca/toronto/2013/10/01/star-trek-toronto-city-hall/</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2017/07/wg21-timeline-2017-07b.png" medium="image">
			<media:title type="html">wg21-timeline-2017-07b</media:title>
		</media:content>
	</item>
		<item>
		<title>This fall: ACAT &#038; CppCon (Seattle), High-Performance/Low-Latency C++ (London), Qt World Summit (Berlin)</title>
		<link>https://herbsutter.com/2017/06/25/this-fall-cppcon-seattle-high-performancelow-latency-c-london-qt-world-summit-berlin/</link>
				<comments>https://herbsutter.com/2017/06/25/this-fall-cppcon-seattle-high-performancelow-latency-c-london-qt-world-summit-berlin/#comments</comments>
				<pubDate>Mon, 26 Jun 2017 05:52:01 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Talks & Events]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=3125</guid>
				<description><![CDATA[[6/26: Updated to add ACAT] I can&#8217;t remember the last time I&#8217;ve gone to Europe twice in one year, but this is the year&#8230; up first are ACAT in August and CppCon in September, then a week later in early October I&#8217;ll be heading to London to give a single repeat of the three-day High-Performance and [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><em>[6/26: Updated to add ACAT]</em></p>
<p>I can&#8217;t remember the last time I&#8217;ve gone to Europe twice in one year, but this is the year&#8230; up first are ACAT in August and CppCon in September, then a week later in early October I&#8217;ll be heading to London to give a single repeat of the three-day <em>High-Performance and Low Latency C++</em> course, in the same week that I&#8217;ll be in Europe already to give a keynote at Qt World Summit in Berlin.</p>
<h3>Aug 21-25: ACAT</h3>
<p>This year I&#8217;ll be giving a keynote at <strong><a href="https://indico.cern.ch/event/567550/">ACAT</a></strong> (topic and day tbd). Unfortunately I cannot be there in person due to conflicts, but the organizers are graciously making arrangements for a remote presentation.</p>
<h3>Mon-Fri Sep 25-29*: CppCon (Seattle)</h3>
<p>I&#8217;ll be giving a brand-new talk at <a href="https://cppcon.org/2017-keynote-speakers/"><strong>CppCon</strong></a>. If you haven&#8217;t <a href="https://cppcon.org/registration/">registered</a> yet for CppCon but are thinking of coming, note that the Early Bird discount ends on July 7, the end of next week.</p>
<p>* Those are the dates of the 5-day core conference, but technically the full dates are Sep 23 &#8211; Oct 1 because CppCon has grown into, somewhat incredibly, a <em>nine-day</em> event this year. How it happened: Last year, we added two days of optional pre-conference tutorials on the weekend before the conference as an experiment; those were so successful that this year there are tutorials on both weekends, before <em>and </em>after the conference, again as an experiment&#8230; but I know that at least a few of you have already signed up for all 9 days (wow).</p>
<h3>Mon-Wed Oct 9-11: High-Performance and Low-Latency C++ (London)</h3>
<p>On October 9-11, I&#8217;ll be in London giving a one-time repeat of <a href="https://www.alfasoft.com/en/events/other/683-683-high-performance-and-low-latency-c-with-herb-sutter.html"><strong>&#8220;High-Performance and Low-Latency C++&#8221; </strong>(course details page)</a>. This is the same as the public course I gave in Stockholm two months ago; because that course sold out, and I was coming to Europe again for Qt World Summit anyway, we decided to do a single repeat that same week, this time in London.</p>
<p>Notes: (1) Some of you have emailed me asking if there will be other dates/cities, and the answer is no, sorry, I do seminars very rarely and this is the last one I have time to do for the foreseeable future. So if you are interested then this is the one to attend. (2) Some of you have also emailed me to ask whether the seminar will be recorded, and the answer is again no, sorry, the organizers are not set up for that. However, you can find all of my past <em>Effective Concurrency</em> writing (on which parts of this course are based) freely available via this blog, just search for that phrase or use the category tag &#8212; there&#8217;s a book&#8217;s worth of free material written by me in individual-article form.</p>
<h3>Thu Oct 12: Qt World Summit (Berlin)</h3>
<p>The next day, I&#8217;ll be in Berlin giving one of the keynotes at <a href="https://www.qtworldsummit.com/"><strong>Qt World Summit</strong></a>. I&#8217;m not sure yet whether it&#8217;ll be the closing keynote; for more details, please check their conference schedule once it&#8217;s posted.</p>
<p>I look forward to seeing many of you at these events.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/06/25/this-fall-cppcon-seattle-high-performancelow-latency-c-london-qt-world-summit-berlin/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>This spring: High-Performance and Low-Latency C++ (Stockholm) and ACCU (Bristol)</title>
		<link>https://herbsutter.com/2017/02/13/this-spring-high-performance-and-low-latency-c-stockholm-and-accu-bristol/</link>
				<comments>https://herbsutter.com/2017/02/13/this-spring-high-performance-and-low-latency-c-stockholm-and-accu-bristol/#comments</comments>
				<pubDate>Mon, 13 Feb 2017 18:13:49 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Effective Concurrency]]></category>
		<category><![CDATA[Software Development]]></category>
		<category><![CDATA[Talks & Events]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2879</guid>
				<description><![CDATA[I don&#8217;t get to Europe very often apart from ISO C++ standards meetings, but this spring I&#8217;ve been able to accept invitations for two English-language European events in the last week of April. If you&#8217;re interested in attending, please check out the links, and I look forward to meeting and re-meeting many of you there. Tue-Thu [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I don&#8217;t get to Europe very often apart from ISO C++ standards meetings, but this spring I&#8217;ve been able to accept invitations for two English-language European events in the last week of April. If you&#8217;re interested in attending, please check out the links, and I look forward to meeting and re-meeting many of you there.</p>
<h3>Tue-Thu Apr 25-27: High-Performance and Low-Latency C++ (Stockholm)</h3>
<p>On April 25-27, I&#8217;ll be in Stockholm (Kista) giving a three-day seminar on <strong><a href="https://www.alfasoft.com/en/events/intel/578-high-performance-and-low-latency-c-with-herb-sutter.html">&#8220;High-Performance and Low-Latency C++.&#8221;</a></strong> This contains updated and new material that reflects the latest C++ standards and compilers, with a focus to using modern C++11/14/17 effectively on modern hardware and memory architectures.</p>
<p>Note that the class size is limited to about 100, so that I&#8217;ll be able to interact with most attendees directly. Registration just opened recently and hasn&#8217;t been widely publicized yet, but today I was told that it&#8217;s already over 1/3 full. So if you or your colleagues might be interested in attending, please check out the link above; for group registrations, please contact Alfasoft directly.</p>
<p>Here is the summary, below; for a more detailed topic breakdown see the link above.</p>
<blockquote><p><strong>Description</strong></p>
<p>Performance and efficiency are C++’s bread and butter, and they matter more than ever on modern hardware: In processors, single-threaded performance improvements are slowing down (unless your code is parallel); in Internet of Things, we are often asked to do more work with less hardware; and in cloud computing, processor/hardware time is often the major component of cost and so making code twice as efficient often means saving close to half the processing cost. Today, getting the highest performance and the lowest latency on modern hardware often means being aware of the hardware in ways that most other programming languages can’t – from hardware caches where simply arranging our data in the right order can give 50x speedups with otherwise identical code, to hardware parallelism where using parallel algorithms turns on high-performance parallel and vector processor hardware that otherwise sits idle.</p>
<p>Additionally, low latency increasingly matters at all scales: In user interfaces, low latency means responsive apps and productive users without the dreaded “wait…” donut; in financial trading, low latency regularly saves large amounts of cash; in embedded real-time systems, low latency is crucial to meeting deadlines and can even save lives. Today, this makes concurrency more important than ever, because it delivers two things: It hides latencies we have to deal with and cannot remove, from disk I/O latency to speed-of-light network latency; and it makes our code responsive by not introducing needless latencies of our own even when we’re not hiding someone else’s latency.</p>
<p><strong>Goal</strong></p>
<p>This intensive three day course will provide developers with the knowledge and skills required to write high-performance and low-latency code on today’s modern systems using modern C++11/14/17. During the training you’ll learn how to get the highest performance and the lowest latency on modern hardware in ways that are unique to C++, including how to arrange data to use hardware caches effectively, and how to use standard and your own custom-written parallel algorithms to harness high-performance parallel and vector processor hardware to compute results faster. You’ll also learn how to manage latency for responsive apps and for real-time systems, and techniques to hide the underlying latencies we have to deal with and cannot remove such as disk and network latency, and to make your own code responsive by not introducing needless latencies in your own code.</p></blockquote>
<h3>Sat Apr 29: ACCU closing keynote (Bristol)</h3>
<p>Next, I&#8217;ll be heading to Bristol to catch the end of the ACCU 2017 conference, and give the closing talk on <strong><a href="https://conference.accu.org/site/stories/2017/sessions.html#XSomethingsNewincpp">&#8220;Something(s) New in C++.&#8221;</a></strong> No, the title is not intentionally a tease; it&#8217;s just that I have several topics available, and I won&#8217;t be sure until about a month before the event which will be the best one to speak about. Here is the current abstract:</p>
<blockquote><p>By the time the ACCU 2017 conference begins, C++17 is expected to be technically complete and in its final approval ballot. What comes next? Will C++ continue growing forever? Can C++ code be simplified? This is a brand-new talk of material I’ve never given before, in which I’ll present one (or more) of three proposals I’m personally working on to further improve C++ post-C++17. All follow a common theme – adding a strategic language and/or library feature to C++ that leads to significant, and sometimes dramatic, simplification of real-world C++ code. I’ll pick which one (or more) of those topics to present sometime in March.</p></blockquote>
<p>What I can say is that, whichever topic it ends up being, it&#8217;ll be something you haven&#8217;t seen before that&#8217;s forward-looking and aimed directly toward making C++ code simpler and easier&#8230; and of course without compromising C++&#8217;s model of efficient machine-near abstraction.</p>
<p>I look forward to seeing many of you in Europe this spring.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2017/02/13/this-spring-high-performance-and-low-latency-c-stockholm-and-accu-bristol/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Summer ISO C++ standards meeting (Oulu)</title>
		<link>https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/</link>
				<comments>https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/#comments</comments>
				<pubDate>Thu, 30 Jun 2016 23:17:09 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2660</guid>
				<description><![CDATA[On June 25, the ISO C++ committee completed its summer meeting in Oulu, Finland, hosted by Symbio and the Finnish national body. We again had some 100 experts officially representing nine national bodies. As usual, we met for six days Monday through Saturday, and around the clock from 8:30am till 11pm most days – evening [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>On June 25, the ISO C++ committee completed its summer meeting in Oulu, Finland, hosted by Symbio and the Finnish national body.</p>
<p>We again had some 100 experts officially representing nine national bodies. As usual, we met for six days Monday through Saturday, and around the clock from 8:30am till 11pm most days – evening sessions regularly went a little later than the usual 10pm because it was Midsummer and there was literally no full night all week long at that short distance from the Arctic Circle, and people commonly did a double take when they looked at their watches and were surprised to find that it was already nearly midnight.</p>
<p>Here’s a summary of what happened, with some details about the current ISO C++ process so you can see just how the work is progressing and getting released. I’ve tried to add some links to the relevant feature design papers, or to the papers that summarize what was done which in turn usually carry more links to the design papers.</p>
<h1>C++17 is feature-complete, enters review period</h1>
<p>The big news is that C++ is feature-complete, and on time! We added several more features to the C++17 working paper (see next section), then approved the result to be sent out this summer for its major ISO international comment ballot, which is the Committee Draft or “CD” ballot.</p>
<p>Between now and our November meeting, national bodies around the world will be reviewing the draft and reporting any concerns about feature design details and wording correctness or consistency. Then for probably the next two meetings we’ll be addressing every national body comment and recording its resolution, as well as continuing to process our own known issues lists to fine-tune the text of the standard. That usually takes two meetings, and if that’s the case again this time then we’ll be putting the finishing touches on C++17 in our November and March meetings and then, we hope, sending C++17 out for its possibly-final ballot in the spring. If we need an extra meeting, then that would extend to the July meeting next year and the possibly-final ballot in late summer.</p>
<p>So C++17 is and tracking to ship on schedule next year. In my <a href="https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/">March trip report</a>, I mentioned that after completing C++11 we switched to a “train model” where we have been shipping the standard consistently every three years. So far, we have been running the trains on time: C++14 was actually the first C++ standard ever that shipped when expected, and now C++17 is on track to do it again. This is excellent news for the community because it enables implementers to track the standard closely, whereas in previous releases they often held back from implementing new features aggressively because with an open-ended schedule the committee could (and did) change its mind again about the design of some feature before the standard actually shipped. The ISO C++ committee is now sticking to a high quality bar, voting features in when they’re stable and releasing on time, which removes uncertainty and is a major reason why compilers are more in sync than ever before: After C++98 shipped, it took 5 years before we saw the first complete conforming compiler that implemented all language features (modulo bugs of course); after C++11 shipped, it took 3 years; when C++14 shipped, it took months. Now, many C++17 features are already available in major compilers, and I wouldn’t be surprised if C++17 repeated C++14’s synchronization with the community so that we see at least one major implementation that has all C++17 features in the same year that C++17 is published. This is great news for the community, because it means we have to play less of the “which compilers actually implement which features” game; true, we still need to deal with older compilers, and some compilers are still not as quick as others to ship the latest features, but all of the major compilers’ current releases are in closer sync with the standard than they’ve ever been before and even the delta between them continues to shrink, which is good news for all C++ users.</p>
<p style="padding-left:30px;"><strong>Note:</strong> Last time I mentioned that there was some thought of moving to a two-year cadence after C++17, but for now we’re staying with three years, so the next standard after C++17 will be C++20.</p>
<h1>More features added to C++17</h1>
<p>At this meeting, we added several more features into C++17; you can find a good summary of those features in <a href="https://www.reddit.com/r/cpp/comments/4pmlpz/what_the_iso_c_committee_added_to_the_c17_working/">Bryce Lelbach’s Reddit post</a>. Again, note that these are just the ones we added at this meeting; the complete list of C++17 features is longer. For example, see my <a href="https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/">March trip report</a> for what was added at the spring meeting.</p>
<h2>Language features</h2>
<p>Here are some of the more noticeable language features we added to C++17 in Oulu. I’ll merge from Bryce’s nice list (thanks Bryce!), my own comments in the previous trip report, and some new comments and examples:</p>
<p><strong><a href="http://wg21.link/P0035">Dynamic memory allocation for over-aligned data</a>:</strong> Extending the C++11 <em>alignof</em>/<em>alignas</em> for heap allocated memory control.</p>
<p><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0091r1.html">Template argument deduction for constructors</a></strong>, so that you can write just <em>pair p(2, 4.5);</em> instead of <em>pair<strong>&lt;int,double&gt;</strong> p(2, 4.5);</em> or <em>auto p = <strong>make_</strong>pair(2, 4.5);</em>. This is pretty sweet, including that it obsoletes many “make” helpers.</p>
<p><strong><em><a href="http://wg21.link/P0127">template &lt;auto&gt;</a></em>:</strong> Recall that templates can take “non-type parameters,” or ordinary compile-time values; a familiar example is <em>std::array&lt;widget,10&gt;</em> which is an array of 10 <em>widget</em> objects, passing 10 as a compile-time number. Well, as of C++11 we allow “auto”matically deducing the type of local variables:</p>
<pre>auto i = 10;           // deduces int</pre>
<p>and in the Concepts TS we allow “auto”matically deducing the type of parameters:</p>
<pre>void f(auto value) { } // same as template &lt;class T&gt; void f(T value);

f(10);                 // deduces int</pre>
<p>Now, with the <em>template&lt;auto&gt;</em> extension, C++17 will additionally allow the same to happen when you pass a value as a template parameter, which is just another place you can pass a value:</p>
<pre>template &lt;auto value&gt; void f() { }

f&lt;10&gt;();               // deduces int</pre>
<p><strong><a href="http://wg21.link/P0135">Guaranteed copy elision</a>:</strong> When you call a function that returns an object by value, and you use the copy to initialize a local variable, the language has always said that you copy (or move) twice. You may know that, since forever, C++ has also added, “but by the way, the compiler is allowed to elide (disappear) the extra copy.” With guaranteed copy elision, in many cases the C++17 language now says you copy (or move) once; that is, compiler is now <em>required</em> not to perform an extra copy or move, so that copy elision is no longer an optimization but a guaranteed language feature.</p>
<p>Richard Smith, the proposal author, provided the following additional notes and examples that show how the copy elision guarantee depends on what happens inside the function. In some cases, such as when the function returns a temporary of the right type, the new rules guarantee that zero copies will be performed, and the return type is not even required to be copyable or movable any more:</p>
<pre>T f() {
  return T{}; // no copy here (C++17)
}

T x = f();    // no copy here either (C++17)</pre>
<p>In other cases, where the named return value optimization (NRVO) would apply today, there is one copy and the compiler may elide the copy, but is not guaranteed to do so because there are cases where that could not be guaranteed:</p>
<pre>T g() {
  T t;
  return t;   // one copy, can be elided but elision is not guaranteed
}

T y = g();    // no copy here (C++17)</pre>
<p>And if the function returns something that really requires a copy, such as returning a reference parameter, you get exactly one copy:</p>
<pre>T h(T &amp;t) {
  return t;   // one guaranteed copy (by necessity)
}

T z = h(x);   // no copy here (C++17)</pre>
<p><strong><a href="http://wg21.link/P0145R2">Order of expression evaluation guarantees</a>:</strong> This removes portability and usability bugs. In a nutshell, a number of code examples that you thought worked, now actually do work. In particular, this solves the long-standing <a href="http://gotw.ca/gotw/056.htm"><em>f(new T, new T)</em> bug</a> that I wrote about nearly 20 years ago, fixes some examples in published books, and makes the brand-new <em>future&lt;T&gt;::then</em> chaining actually work correctly.</p>
<p><strong><a href="http://wg21.link/N4424">Inline variables</a>: </strong>This feature makes it easier to define global variables (that’s the bad news) correctly (that’s the good news), including in header files. The net effect is that some code people already write in practice, but shouldn’t have because it had subtle pitfalls, now works.</p>
<p><strong><em><u><a href="http://wg21.link/P0292R1">if constexpr</a></u>:</em></strong> This is a very powerful feature that allows branches that are evaluated at compile time. Note that this is a disciplined compile-time “if”, not just text substitution; the code in a false branch needs to be syntactically well-formed, but doesn’t need to be semantically valid.</p>
<p>This lets you express some pretty powerful stuff, including that a function template can write all the special cases of its algorithm right within its body (e.g., a fast algorithm for random-access iterators, and a fallback for less powerful iterators), without writing a set of template specializations.</p>
<p>It also works very nicely with C++14’s “auto” return type deduction for inline functions: It’s perfectly fine for two mutually exclusive <em>if constexpr</em> branches to return unrelated types since only one of the branches can be taken for a given set of inputs, and the correct return type will be deduced. Of course, within the same <em>if constexpr</em> branch the return types have to be compatible according to the current rules. In fact, we’ll see an example of this in the next topic…</p>
<p><strong><a href="http://wg21.link/P0144r2">Structured bindings</a>:</strong> This allows taking a value that contains multiple elements, such as a tuple or a struct, and binding convenient names to the individual elements – much like <em>std::tie</em>, except without having to have variables of the correct type already available. I was pleasantly surprised to see this one make it into C++17 even though it came in late in the cycle. Here’s a simple example of what it enables:</p>
<pre>tuple&lt;T1,T2,T3&gt; f();
auto [x,y,z] = f(); // types are: T1, T2, T3

map&lt;int,string&gt; mymap;
auto [iter, success] = mymap.insert(value); // types are: iterator, bool

struct mystruct { int i; string s; double d; };
mystruct s = { 1, “xyzzy”s, 3.14 };
auto [x,y,z] = s; // types are: int, string, double</pre>
<p>What if you want to add structured bindings for your own type that isn’t a struct or a tuple? I’m glad you asked, because it&#8217;s an excuse to also show off also how you can use <em>if constexpr</em>. Let’s say you&#8217;re the author of a type <em>S:</em></p>
<pre>class S {
   int i;
   char c[27];
   double d;
public:
   // ...
};</pre>
<p>Now you want to allow structured bindings for your type <em>S</em>, and for extra marks you don’t want to bind directly to the private variables but perhaps want member <em>c</em> to be bound as a <em>string_view</em> (also adopted for C++17; see below). Here’s how do add this ability; it’s a few lines, but you only have to do it once for all users of type <em>S</em>:</p>
<pre>// 1. Add tuple_size and tuple_element support
namespace std {
   template&lt;&gt; struct tuple_element&lt;0,S&gt; { using type = int; };
   template&lt;&gt; struct tuple_element&lt;1,S&gt; { using type = string_view; };
   template&lt;&gt; struct tuple_element&lt;2,S&gt; { using type = double; };
   template&lt;&gt; struct tuple_size&lt;S&gt;: public integral_constant&lt;size_t,3&gt; {};
}

// 2. Now add get&lt;&gt; support (using C++17, because why not; it’s better
// than =delete’ing the primary get&lt;&gt; template and adding specializations)
template&lt;int I&gt;
auto get(const S&amp;) {
   if      constexpr(I == 0) return x.i;
   else if constexpr(I == 1) return string_view{x.c}; }
   else if constexpr(I == 2) return x.d;
}</pre>
<p>Now all users of <em>S</em> can write code like this:</p>
<pre>S f();  // some function that returns an S

auto [ n, s, val ] = f(); // types are int, std::string_view, and double</pre>
<p><strong><a href="http://wg21.link/P0305r0"><em>if (init; condition)</em> and <em>switch (init; condition)</em></a>:</strong> Just like the venerable <em>for (int i = 0; /*&#8230;*/)</em> loop has always allowed declaring a variable (in that example, <em>i</em>) that exists for the scope of the loop, we will now be able to do the same for <em>if</em> and <em>switch</em> without having to resort to today’s workaround of declaring the variable before the <em>if</em> or <em>switch</em> and then wrapping it up in <em>{ }</em> to restrict its scope. Here’s an example of the new cleaner syntax, which allows more tightly-scoped variables:</p>
<pre>map&lt;int,string&gt; mymap;

if (auto result = mymap.insert(value); result.second) {
    // insert succeeded, and result is valid for this block
    use(result.first);  // ok
    // ...
} // result is destroyed here</pre>
<p>In fact, you might have noticed that I used a similar example for both structured bindings and for <em>if/switch</em> initialization. It took Reddit about 30 minutes to discover that they’re great together, like peanut butter and jelly:</p>
<pre>// better together: structured bindings + if initializer

if (auto [iter, succeeded] = mymap.insert(value); succeeded) {
    use(iter);  // ok
    // ...
} // iter and succeeded are destroyed here</pre>
<h2>Two language features that didn’t make it (yet)</h2>
<p>Of the new language features I mentioned last time, only two didn’t make it into C++17:</p>
<ul>
<li><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0252r0.pdf"><em>operator.</em> (dot)</a> </strong>to allow smart references (in parallel with smart pointers) and much more. During final core language wording review, the authors discovered a problem that couldn’t be fixed in real time at this meeting, and was pulled back while the authors fix the proposal. This proposal is still active and is expected to come back with a fix to that problem very soon, possibly as soon as in the next week or two for the post-meeting mailing; I’m hearing some rumblings that national bodies might mention this in their summer ballot comments, so we might see it again during C++17 ballot resolution, else I’d expect it to be one of the first things added to the draft standard once C++17 ships.</li>
<li><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0221r0.html">Defaulted comparisons</a></strong>, to generate <em>==, !=, &lt;, &lt;=, &gt;, &gt;=</em> for types that don’t write them by hand. The current version of the proposal is opt-out, and would generate comparisons for existing types. When the proposal got to the full committee, we discovered that the committee didn’t have consensus to approve the paper’s opt-out model; a number of people spoke up for an opt-in model instead. This proposal might eventually come back but probably not soon.</li>
</ul>
<h2>Standard library features</h2>
<p>Here are some of the library features that made it into C++17 at this meeting:</p>
<p><strong><em><a href="http://wg21.link/P0088r2">variant&lt;&gt;</a></em>:</strong> Don’t use raw unions any more. This addition completes the trifecta of <em>std::any</em> and <em>std::optional</em> (which were already added to C++17). The new <em>std::variant</em> is a type-safe union; for more background see also my <a href="https://herbsutter.com/2015/10/25/2568/">fall meeting trip report</a>. Here’s an example adapted from the paper that shows how you can use it:</p>
<pre>variant&lt;int, float, string&gt; v, w;
v = “xyzzy”;         // now v contains a string
v = 12;              // now v contains an int

int i = get&lt;int&gt;(v); // ok, because it contains an int

w = get&lt;int&gt;(v);     // ok, assign to another variant
w = get&lt;0&gt;(v);       // same effect as the previous line
w = v;               // same effect as the previous line

get&lt;double&gt;(v);      // compile-time error: v can’t contain a double
get&lt;3&gt;(v);           // compile-time error: v doesn’t have 4 types

try {
  get&lt;float&gt;(w);     // will throw: w contains an int, not a float
}
catch (bad_variant_access&amp;) {}</pre>
<p><strong><a href="http://wg21.link/P0083r2">Moving nodes between <em>map&lt;&gt;</em>, <em>unordered_map&lt;&gt;</em>, <em>set&lt;&gt;</em>, and <em>unordered_set&lt;&gt;</em></a>:</strong> You will now be able to directly move internal nodes from one node-based container directly into another container of the same type (differing at most in the comparator template parameter), either one node at a time or the whole container. Why is that important? Because it guarantees no memory allocation overhead, no copying of keys or values, and even no exceptions if the container’s comparison function doesn’t throw. The mechanics are provided by new functions <em>.extract</em> and <em>.move</em>, and corresponding new <em>.insert</em> overloads. Here’s an example adapted from the paper:</p>
<pre>map&lt;int, string&gt; src {{1,”one”}, {2,”two”}, {3,”buckle my shoe”}};
map&lt;int, string&gt; dst {{3,”three”}};

dst.insert(src.extract(src.find(1))); // iterator version
dst.insert(src.extract(2));           // key type version
auto r = dst.insert(src.extract(3));  // key type version
    // note: this last one will fail because dst already contains 3;
    // the node is owned by r, the returned struct

// At this point we have the following state:
//   src == {}
//   dst == {{1,“one”}, {2,“two”}, {3,“three”}}
//   r.position == dst.begin() + 2
//   r.inserted == false
//   r.node == {3,“buckle my shoe”}

// We can go back and retry the failed insert with a different key:
r.node.key() = 4;                      // use a non-conflicting value
dst.insert(r.position, std::move(r.node));  // now succeeds</pre>
<p><strong><a href="http://wg21.link/P0040r2">Extended memory management tools for in-place construction and destruction:</a></strong> These include <em>destroy(_at|_n), uninitialized_move(_n), uninitialized_value_construct(_n),</em> and <em>uninitialized_default_construct(_n)</em>.</p>
<h2>In case you missed it: <em>string_view</em> also in C++17</h2>
<p>C++17 also contains a number of other useful features. I’ve mentioned these before, including “small” but widely-used features like <em>optional</em> and <em>any</em>, right up to Parallel STL. But let me just take a moment to remark again on the wonderfulness of <em>string_view</em>, which is a non-owning view of a contiguous string owned by someone else.</p>
<p>If you have a <em>const string&amp;</em> parameter, consider just changing it to <em>string_view</em>. As Mark Isaacson mentioned in <a href="http://maintainablecode.logdown.com/posts/745037-tech-talk-exploring-c-17">his NDC talk</a> earlier this month, it’s pretty rare that you can get a performance boost by just doing a global search-and-replace, but Mark points out you can pretty much do that by globally replacing <em>const string&amp;</em> with <em>string_view</em> (with one exception noted in the next paragraph). Why is this often more efficient? In particular, when the caller passes something like a string literal as an argument, if your function takes it via a <em>const string&amp;</em> parameter that means the caller has to convert the string literal to a temporary <em>string</em> object, which typically incurs a heap allocation and deallocation, whereas passing it to a <em>string_view</em> incurs no allocation overhead at all.</p>
<p>However, beware one potential pitfall, especially until more of the world has migrated to <em>string_view</em>: If your function <em>f(/*some string*/ x)</em> internally calls one or more <em>other</em> functions that still take a <em>string&amp;</em> (either const or non-const), then let your function <em>f</em> continue to take <em>x</em> by <em>const string&amp;</em> and don’t change it to <em>string_view</em>. The reason is that if <em>f</em> is called with an actual <em>string</em> object, then <em>f(const string&amp; x)</em> can pass it along painlessly by reference, whereas <em>f(string_view x)</em> would avoid a copy when entering <em>f</em> but would need to create a new <em>string</em> internally just to pass it along to the other function that needs a <em>string</em>. Bottom line: If you know your function needs to call other functions that you don’t control and that take (possibly const) <em>string&amp;</em>, then you should probably leave your function taking <em>const string&amp;</em> too.</p>
<h1>C++17: Recognizably new</h1>
<p>C++17 will pervasively change the way we write C++ code, just as C++11 did. As these and other new features become available, we’re going to see new code using structured bindings, if/switch scope variables, <em>string_view</em>, <em>optional, any, variant,</em> Parallel STL, and more all over the place.</p>
<p>Here&#8217;s my personal litmus test for whether we’ve changed the way people program: Just as you can take a look at a screenful of code and tell that it’s C++11 (not C++98), if you can look at a screenful of code and tell that it’s C++17, then we’ve changed the way we program C++. I think C++17 will meet that bar.</p>
<p>Here’s a little “C++17 demo” put together by committee member Thomas Köppe, who is the author of the if/switch initializer proposal. It shows off a few of the features that will soon be available as part of C++17, and how they work together. Note this uses some other new C++17 features I didn’t specifically mention. I’ll let the comments speak for themselves; thanks, Thomas, for providing this demo.</p>
<pre>unordered_map&lt;string, unique_ptr&lt;Foo&gt;&gt; items;
vector&lt;unique_ptr&lt;Foo&gt;&gt; standby;

// Desired semantics of f: If there is currently no item 'id', install
// 'foo' as item 'id'. Otherwise, put 'foo' on the standby list for later.

//------------------------------------------------
// Before C++17: 7 lines + 4 pitfalls
//
void f(string id, unique_ptr&lt;Foo&gt; foo) {
   auto it = items.find(id);
   if (it == items.end()) {
      auto p = items.emplace(move(id), move(foo));
      p.first-&gt;second-&gt;launch();
   } else {
      standby.push_back(move(foo));
      standby.back()-&gt;wait_for_notification();
   }

   // Notes:  
   // * Variable 'id' can no longer be used (moved-from); or...  
   // * ...would need to pass by 'const string&amp; id' and force copying.
   // * Map lookup performed twice. Ordered map could use lower_bound +
   //   hint, but unordered map cannot.  
   // * (Cannot emplace unconditionally, because it might destroy *foo.)
}

//------------------------------------------------
// With C++17: 4 lines + none of those pitfalls
//
void f(string_view id, unique_ptr&lt;Foo&gt; foo) {
   if (auto [pos, inserted] = items.try_emplace(id, move(foo)); inserted){
      pos-&gt;second-&gt;launch();
   } else {
      standby.emplace_back(move(foo))-&gt;wait_for_notification();
   }
}</pre>
<h1>Other progress</h1>
<p>Because this time our focus was on completing C++17, we didn’t spend as much time on the other TSes as we did at a normal meeting, but we made progress on some of the TSes and will continue with all of them next time. In particular, the Reflection and 2D Graphics proposals received several hours of review each and are making great progress; at our next meeting we’ll continue with Ranges, Networking, Library Fundamentals 2, Parallelism 2, Modules, Coroutines, Contracts, and more.</p>
<h1>What’s next</h1>
<p>This summer, we’re going to send out the feature-complete C++17 out for its major international comment ballot. After that, we’ll address ballot comments at the <a href="https://isocpp.org/files/papers/N4571.pdf">November 2016</a> and <a href="https://isocpp.org/files/papers/n4573.txt">February-March 2017</a> meetings and plan to send C++17 out for its final approval ballot then.</p>
<p>Once C++17 ships next year, I expect we’ll start looking at merging more of the TS “beta branches” into the C++ “trunk.” Here’s an updated snapshot of our status:</p>
<p><img data-attachment-id="2724" data-permalink="https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/wg21-timeline-2/" data-orig-file="https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=500" data-orig-size="1901,1352" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wg21-timeline" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=500?w=300" data-large-file="https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=500?w=500" class="alignnone size-full wp-image-2724" src="https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=500" alt="wg21-timeline" srcset="https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=500 500w, https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=150 150w, https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=300 300w, https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png?w=768 768w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>Thank you again to our host Symbio, to the over 100 experts at Oulu last week, and to the many more who participate in standardization through their national bodies, without whose efforts and willing collaborative spirit these results would not be achievable. The over four million C++ users worldwide benefit, and appreciate it very much too. Thank you, all, for your many contributions to Standard C++.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2016/06/30/trip-report-summer-iso-c-standards-meeting-oulu/feed/</wfw:commentRss>
		<slash:comments>54</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2016/06/wg21-timeline.png" medium="image">
			<media:title type="html">wg21-timeline</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Winter ISO C++ standards meeting</title>
		<link>https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/</link>
				<comments>https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/#comments</comments>
				<pubDate>Fri, 11 Mar 2016 23:50:44 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2579</guid>
				<description><![CDATA[On March 5, the ISO C++ committee completed its winter meeting in Jacksonville, FL, USA. We had record-tying attendance, with over 110 experts officially representing eight national bodies. As usual, we met for six days Monday through Saturday, and around the clock from 8:30am till 10pm most days, after which many people still went back [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>On March 5, the ISO C++ committee completed its winter meeting in Jacksonville, FL, USA. We had record-tying attendance, with over 110 experts officially representing eight national bodies. As usual, we met for six days Monday through Saturday, and around the clock from 8:30am till 10pm most days, after which many people still went back to hang out in the lobby or their rooms to update papers. — The hotel had a baby grand piano outside the main meeting room lobby, and so late at night you could often walk by and find one of several committee members playing a tune, while as usual people collaborated on their proposals, perched on couches and tables clustered around glowing rectangles, incanting standardese to the soft strains of Russian folk ballads and arena rock.</p>
<p>Here’s a summary of what happened, with some details about the current ISO C++ process so you can see just how the work is progressing and getting released. I’ve tried to add some links to the relevant feature design papers, or to the papers that summarize what was done which in turn usually carry more links to the design papers.</p>
<blockquote><p><strong>Note:</strong> The features listed below are those approved for C++17 at this meeting only. Previous meetings added other features that are already in the working draft.</p></blockquote>
<h1>What we did: Merging into C++17</h1>
<p>This meeting was a major milestone in two ways.</p>
<p>First, we largely completed choosing the target set of features the committee felt were ready for C++17. Some had their specification wording adopted last week into the working draft for the C++ international standard (IS), and a few more are targeted to be adopted at our next meeting in June in Oulu, Finland, following which C++17 is intended to be sent out for its major international comment ballot.</p>
<p>Second, and perhaps even more importantly, we had the first merge of the new Technical Specification (TS) “beta feature branches” into the C++ international standard “trunk.” The committee considered five candidates, and adopted the first four as ready for C++17, with reports from implementers and users that the features were baked and unlikely to need future breaking design changes. The criteria for whether the committee thinks a given feature is ready to merge will vary by feature; this time, the committee ended up merging all the ones that had been completed and in beta testing for a year or more.</p>
<p>The four accepted branches merged into C++17 were:</p>
<ul>
<li><strong><a href="http://isocpp.org/files/papers/P0024R2.html">The Parallelism TS</a>, a.k.a. “Parallel STL.”</strong> This includes parallelized versions of most STL algorithms, which get a new execution policy where you can opt into running them in parallel on multiple cores and/or on multiple vector lanes—hardware that is now ubiquitous in the mainstream, as most medium- and high-end smartphones are both multicore and have vector units built in. For example, C++17 now allows: <em>for_each(std::par, first, last, [](auto&amp; x){ process(x); });</em>.</li>
<li><strong><a href="http://isocpp.org/files/papers/p0220r1.html">The Library Fundamentals 1 TS (most parts)</a></strong>, adding a new round of library components for C++17 including <em>any, optional, string_view, shared_ptr</em> for arrays, memory pools, <em>search</em> and sampling algorithms, and more. (An example of “more”: Have you ever wanted to pass a <em>tuple</em> that contains a function call’s argument list and expand it into the individual arguments? Now you can, using built-in standard functionality.)</li>
<li><strong><a href="http://isocpp.org/files/papers/P0218r1.html">The File System TS</a></strong>, which allows portable handling of files, paths, symbolic links, and more.</li>
<li><strong><a href="http://isocpp.org/files/papers/P0226R1.pdf">The Mathematical Special Functions IS</a></strong>, which was originally part of the first Library TR back in the 2000s and has now finally gained approval to be added to the standard for C++17.</li>
</ul>
<p>We also voted the following other features directly into C++17 without going through a TS beta first:</p>
<ul>
<li>Lambdas are now <a href="http://isocpp.org/files/papers/P0170R1.pdf">allowed inside constexpr functions</a>.</li>
<li>Lambdas can now <a href="http://isocpp.org/files/papers/p0018r3.html">capture a copy of <em>*this</em></a> object by value, using the notation <em>[*this]</em>. It also works in combination with default capture, so <em>[=, *this]</em> is also allowed.</li>
<li>The range-<em>for</em> loop <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0184r0.html">can now deal with generalized ranges</a> where the “end” type is different from the “begin” type, such as sentinel-based and counted ranges, which will work well with the Ranges TS work.</li>
<li>The <a href="http://isocpp.org/files/papers/P0188R1.pdf"><em>[[fallthrough]]</em> attribute</a> lets you designate that you are intentionally letting a switch’s case block fall through to the next block without a break.</li>
<li>The <a href="http://isocpp.org/files/papers/P0189R1.pdf"><em>[[nodiscard]]</em> attribute</a> lets you annotate a return value to say that it should not be ignored by the caller, or annotate a type to apply to all uses of that type as a returned value. Canonical examples include the return value of <em>std::async</em> where ignoring the return value would mean being not async at all, and the return value of a container’s <em>empty()</em> function where people sometimes confuse <em>empty()</em> and <em>clear()</em> and we don’t want them to think calling <em>empty()</em> has side effects if they call it by mistake.</li>
<li>The <a href="http://isocpp.org/files/papers/P0212R1.pdf"><em>[[maybe_unused]]</em> attribute</a> lets you annotate an intentionally unused variable or parameter.</li>
<li>Various other minor improvements and fixes.</li>
</ul>
<p>Evolution also approved the following features that were not voted in at this meeting, but are currently on track for possible approval for C++17 at our next meeting in June for inclusion in the C++17 international comment ballot (note the links are to the pre-meeting paper versions; for example, in the paper that proposed <em>constexpr_if</em> the committee changed the syntax to <em>if constexpr</em> at the meeting):</p>
<ul>
<li><em><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0128r1.html">if constexpr</a></em> to allow branches that are evaluated at compile time. This is very powerful.</li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0091r1.html">Template parameter deduction for constructors</a>, so that you can write just <em>pair p(2, 4.5);</em> instead of <em>pair&lt;int,double&gt; p(2, 4.5);</em> or <em>auto p = make_pair(2, 4.5);</em>. This is sweet, including that it obsoletes many “make” helpers.</li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0145r1.pdf">Defining the order of expression evaluation</a> to reduce portability and usability bugs.</li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0252r0.pdf">operator. (dot)</a> to allow smart references (in parallel with smart pointers) and much more.</li>
<li><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0221r0.html">Defaulted comparisons</a>, to generate ==, !=, &lt;, &lt;=, &gt;, &gt;= for types that don’t write them by hand.</li>
</ul>
<p>A few more, such as structured bindings, might make it too but have not yet received Evolution design approval, so we’ll see in June if there’s support in Evolution and Core to call them ready.</p>
<p>C++17 will change the way we write C++ code, just as C++11 and C++14 did. For example, string_view and optional are expected to be heavily used in writing interfaces. And with parallel STL often you can just add <em>std::par</em> or <em>std::par_vec</em>, and your algorithm will speed up by a factor of 2-4 on ordinary hardware; we had a compelling story with C++11 move semantics where we could say “just recompile your code and it’ll often be noticeably faster,” and this is likely to be an even bigger improvement.</p>
<h1>Other progress</h1>
<p>We also made significant progress on other work, including that we now have opened five TSes to launch our next round of beta feature branches, most of which we expect to be sent out for their “debutante” international comment ballots in the next handful of meetings:</p>
<ul>
<li><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4569.pdf">Ranges</a>, <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4575.pdf">Networking</a>, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4562.html">Library Fundamentals 2</a>, and <a href="https://isocpp.org/files/papers/N4352.html">Parallelism 2</a>: </strong>We approved creating these at our last meeting, and officially adopted the first working drafts for all four of these TSes at this meeting. These form the “first four” nucleus of the next round of TSes to be developed by the committee and are now being officially specified in detail.</li>
<li><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0143r1.pdf">Modules</a>:</strong> Recall that at the last meeting we reached design agreement to start work on Modules. At this meeting, we approved the initial wording to officially start active work on a Modules specification as a TS. That brings us to five active TSes in this second round.</li>
</ul>
<p>And there are more to come:</p>
<ul>
<li><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0057r2.pdf">Coroutines</a>:</strong> These are being targeted for a new TS (possibly Concurrency 2 or their own TS) so that we have additional time to finish investigating an alternative proposal. I expect this to settle out within another couple of years and then make progress in some form (either the current proposal, or the alternative one if it pans out equally well, or possibly both) into the following C++ standard.</li>
<li><strong>Concurrency 2:</strong> The concurrency group reports that they hope to launch a second Concurrency TS later this year at the Issaquah meeting. This might include coroutines as above. It might include features like <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0126r1.pdf">synchronic</a>, and there is still hope that the group might yet get design agreement on executors (a way to control where to execute work, such as where to run a parallel task, or where to execute a callback or continuation); if so, it would naturally go into the second Concurrency TS.</li>
<li><strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0267r0.pdf">2D Graphics</a>:</strong> The 2D Graphics proposal that specifies a portable C++ library to wrap the Cairo C API has progressed to design and wording review. It’s big, so it will take a couple of meetings to process it, but it’s looking good that we could get an initial TS draft started this year.</li>
</ul>
<p>At this meeting we also reached a design agreement on <strong>contracts</strong>, so that we now think we have a design that the <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0287r0.pdf">competing</a> <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0246r0.pdf">proposers</a> agree on and that the committee as a whole likes, and we hope to get initial draft specification wording later this year if this trend continues. Once we see the work, the committee can decide on a preferred target vehicle (TS or straight into the IS).</p>
<p>The committee also continued to spend time at the meeting incubating other work, including <strong>reflection</strong> APIs.</p>
<p>The main surprise last week was that the <strong><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0251r0.pdf">“part 1” unified call syntax proposal</a></strong> made it to full committee but we there discovered that there wasn’t yet consensus to adopt it. The authors (Bjarne Stroustrup and myself with the help of a number of experts) are continuing to work between meetings to see if consensus can be achieved by the June meeting.</p>
<p>Finally, we retired a TS that was not completed: We ended up not getting consensus on the experimental material intended for the <strong>Arrays</strong> TS, so last week we made the decision to retire that one.</p>
<h1>Status of concepts and modules</h1>
<p>Here are some specific notes about two particular TSes that everyone agrees are important and game-changing for how we will write C++ code: Concepts and modules.</p>
<p><strong>Concepts</strong> was published as a TS less than a year ago, with the first production compiler implementation to ship soon as part of GCC 6.0. Despite its relative newness and lack of field experience, the committee <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0248r0.pdf">seriously</a> <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0225r0.html">considered</a> adopting it already for C++17 at this meeting. It was right on the edge: There was already a strong minority who felt it was ready to add to C++17, and a modest majority preferred to wait another year or two and get more experience with shipping implementations and field use of the feature.</p>
<p>Virtually everyone who spoke praised the feature as important, and either ready or getting close to ready, for adopting into the C++ standard. The only major distinction of opinion was whether or not they supported putting it specifically in C++17; those who spoke against that generally expressed that this feature was so important that we want to be sure we get it right and approve it once we have more experience using it in real world users’ code. My impression is that concepts is now one of the strongest feature candidates moving along well in the pipeline and adoption in the trunk IS working draft post-C++17.</p>
<p>At the October meeting, <strong>modules</strong> for the first time achieved a design consensus in the Evolution working group (EWG), with a “phase 1” that everyone agreed on and a “phase 2” that could be added. The most notable part of “phase 2” is determining whether and how to allow a module to carry and export macros. In October, EWG decided to aim modules for a TS covering “phase 1” and asked the proposers to come back with detailed specification wording, which they did for this meeting.</p>
<p>Last week, the whole committee voted to start a TS project and turn that document into the first working draft. Here’s a subtle but important note: This milestone of “create an initial working draft” is important, but usually not all that impactful to the community. The reason this one is different, and is actually very important to users, is that we knew that there are likely two major vendor implementation efforts waiting to start work on implementing support for modules in major compilers, but who were waiting until there was some draft specification that had been approved as a basis for development by the committee. We knew that having “at least an initial working draft” was a sufficient bar for the implementers to get started, and so despite our heavy workload this week focusing on C++17-targeted items (which this is not), I asked the Core working group to make a special effort to prioritize getting this project to this stage because we knew it would unblock new implementation efforts. We are very pleased to see this succeed, and look forward to active work beginning soon on more implementations of modules in several major compilers.</p>
<h1>The pipeline</h1>
<p>There are members who are very disappointed that we didn’t include more in C++17, especially concepts which was very close. To understand where we’re at, consider the following snapshot of our current “trunk” and “beta feature branches” status, shown in the context of three eras of C++ standardization laid side by side: C++9x, C++0x, and C++1x.</p>
<p><img data-attachment-id="2613" data-permalink="https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/wg21-timeline/" data-orig-file="https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=500" data-orig-size="1900,1427" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;0&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;0&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;0&quot;,&quot;iso&quot;:&quot;0&quot;,&quot;shutter_speed&quot;:&quot;0&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;0&quot;}" data-image-title="wg21-timeline" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=500?w=300" data-large-file="https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=500?w=500" class="alignnone size-full wp-image-2613" src="https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=500" alt="wg21-timeline" srcset="https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=500 500w, https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=150 150w, https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=300 300w, https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png?w=768 768w" sizes="(max-width: 500px) 100vw, 500px"   /></p>
<p>The C++ international standard (IS) is the “trunk” containing everything that is formally part of C++. Every time it is published, we have a new official international legal specification for C++.</p>
<p>A Technical Specification (TS) is a “beta feature branch” shipped as a separate published document. The contents of a TS are the committee’s best guess at what C++ users need, with a lower confidence bar on that guess because it is a “beta” and we do get a chance to make corrections before setting it in stone in the standard. In 2015, we completed our first round of six published major TSes, and are launching a second round.</p>
<p>This is a turning point: We just finished filling the pipeline, and this meeting saw the first merge from the beta branches. The disappointment came from that some would have liked to merge another branch or two. The good news is that, those branches are already shipped beta specifications that vendors can implement—in fact, most of them already have at least one supported implementation in a production compiler or library product. The branches that did not quite land in time to merge for C++17 can be expected to merge early in the next cycle—and in the meantime we’re still shipping the “trunk” and its ready features too. Now that the pipeline is full, we can expect features to leave the pipeline and merge regularly at high quality, which is essential with over four million C++ users worldwide relying on our work.</p>
<p>Notes:</p>
<ul>
<li>Each bar starts at the meeting where the detailed specification work officially began (usually “adopt initial draft”) and ends at the meeting that technical work was completed (usually “start final ballot / send for publication”).</li>
<li>Arrowheads join the IS at the meeting at which a TS feature branch was merged into the IS trunk.</li>
<li>In the current decade, the smaller boxes show full ISO C++ meetings—sometimes two per year, sometimes three per year—and highlights the meetings where we launch a C++ CD (ISO comment ballot, light blue) or DIS (ISO approval ballot, dark blue).</li>
<li>I’ve omitted the 1998-2001 hiatus because no new features were under active development in that period. The committee was voluntarily taking a break, and also catching up with C++98 bug reports while compilers caught up with the standard.</li>
</ul>
<h1>From “what” to “when”: C++0x to C++1x</h1>
<p>During C++0x, the best and most solid parts of C++0x were the parts that shipped first as “beta” in the Library Extensions TR. That’s the model we’ve now embraced as the norm, rather than as the exception.</p>
<p><strong>C++0x followed the “what” or “feature” model:</strong> We picked “what” features were in the standard and released whenever they turned out to be ready. That means we giving up on being able to predict “when” we’d ship, and even while C++0x was repeatedly delayed and the “0x is hex” jokes started, we released nothing in the standard the meantime; even features that had been approved into the C++ draft standard in 2004 had to wait until 2011 before they appeared in an official final standard. C++11 was a good release, but we underestimated “when” it would be ready by as much as five years.</p>
<p><strong>C++1x follows the “when” or “train” model:</strong> We’re picking “when” to release the standard regularly, currently every three years, and including whatever features are ready. This still allows big long-pole features to be worked on; they’re just worked on concurrently until ready to merge. I’m pleased that the committee seems to be generally quite happy with the result. In Jacksonville, several experts came up to me to say that they had noticed how we had shipped more work in six years than in any other six-year period in the history of ISO C++. This would not be possible without the committee’s help and support; thank you again, everyone!</p>
<p>Although the train model has benefits, any model is also a tradeoff. The train model means we can’t slip a few meetings to try to “squeak in” another feature, and in fact we didn’t ship everything we hoped to ship in C++17, notably concepts… but neither did we at the same point in the C++0x cycle, in 2007. Now as in 2007, we are at a point where we have some good new features ready to ship in the standard, and at the same time we have several large desirable features in flight that are “almost but not quite” ready yet. In 2007, items on the edge or “just over the horizon” included work like threads and C++0x concepts, and in 2016 they include concepts “lite” and ranges. In both cases, those features are actually 3-4 years away (whether we knew it then or not). The difference is that in 2016, we’re shipping what is ready while still continuing development at full speed on the others.</p>
<p>Also, we initially thought a train model would let us alternate “minor” and “major” releases. The idea was that C++14 could be a “minor” release, and C++17 a “major” release. What actually happened was that we learned the pipeline+train model leads to regular “medium” releases as the pipeline moves at a steady pace and we regularly release what’s ready. As it turns out, C++14 was more than a fine-tuning release; it included powerful features like generic lambdas. Conversely, C++17 won’t be a “major release” on the scale of C++11, but neither could it be because C++11 took nine years to develop.</p>
<p>Never before in the history of C++ has the standard maintained such high specification quality, never before has it released on a regular predictable schedule… and as we removed that quality and schedule uncertainty, it’s no accident that never before have all the major compilers tracked the standard so closely, which benefits the whole worldwide C++ community.</p>
<h1>How to define “progress”: Being unblocked to move to the next stage</h1>
<p>How do we know we’re making progress? There is a tendency to emphasize “what features ship in C++.next,” a specific version; this was the committee’s mental model during C++0x.</p>
<p>In C++1x, the key is to keep the pipeline moving. What I monitor is that that major proposals are unblocked so the proposers can do work toward the next stage between meetings. As long as each proposal is not blocked, it’s moving forward toward the IS and “what ships in C++.next” will take care of itself as soon as it’s baked and ready.</p>
<p>Take a few minutes to read <a href="https://isocpp.org/std/the-life-of-an-iso-proposal">The life of an ISO proposal: From “cool idea” to “international standard.”</a> Here are how some major work moved along at this meeting, in the context of those Stages:</p>
<ul>
<li><strong>Ranges, Networking, Library Fundamentals 3, and Parallelism 2: Stage 6 -&gt; 7.</strong> All of these reached Stage 6 at our last meeting, and reached Stage 7 at this meeting. They’re all moving, and they’re well along in their development cycles and getting ready to debut in their international TS comment ballots in the near future.</li>
<li><strong>Modules: Stage 3 -&gt; 6.</strong> This reached Stage 3 at our previous meeting in November, and is already at Stage 6 at this meeting—that’s very rapid progress in one meeting!</li>
<li><strong>Contracts: Stage 2 -&gt; 3.</strong> This was stalled for a long time in Stage 2, and thanks to lots of work by the proposers (brokered personally by Bjarne Stroustrup) at the last meeting in November and then between meetings, it finally broke the logjam and reached Stage 3 at this meeting. Now it’s finally unblocked and on track again.</li>
<li><strong>Coroutines, and 2D Graphics: Stage 3.</strong> These have both been at Stage 3 for a couple of meetings, and should reach Stages 4 and 5 over the next meeting or three.</li>
</ul>
<p>If we focus primarily on each proposal moving incrementally to Stage N+1 and identifying and removing impediments, getting great new work in each new C++.next release of the standard becomes very nearly automatic.</p>
<h1>What’s next</h1>
<p>Our next meeting is <a href="https://isocpp.org/files/papers/N4570.pdf">this June in Oulu, Finland</a>, where we plan to send a feature-complete C++17 out for its major international comment ballot. After that, we’ll address ballot comments at the <a href="https://isocpp.org/files/papers/N4571.pdf">November 2016</a> and <a href="https://isocpp.org/files/papers/n4573.txt">February-March 2017</a> meetings and plan to send C++17 out for its final approval ballot then.</p>
<p>What’s after C++17? The default is to continue on the 3-year cycle (aim for C++20 then C++23), but we’re also thinking about whether to try out going to a 2-year cycle (aim for C++19, and if that works then C++21 and C++23). We’ll discuss that later this year as we see how C++17 and current/future TS plans are coming together, and should have more definite plans to report in a meeting or two.</p>
<p>Thank you again to the over 110 experts at Jacksonville last week, and the many more who participate in standardization through their national bodies, without whose efforts and willing collaborative spirit these results would not be achievable. The over four million C++ users worldwide benefit, and appreciate it very much too. Thank you, all, for your many contributions to Standard C++.</p>
<h1>Acknowledgments</h1>
<p>Thank you to everyone who provided input data and/or review of drafts of this trip report, including but not limited to: JF Bastien, Steve Clamage, Marshall Clow, Gabriel Dos Reis, William M. (Mike) Miller, Nathan Myers, Clark Nelson, Gor Nishanov, Peter Sommerlad, John Spicer, Bjarne Stroustrup, Ville Voutilainen, Jonathan Wakely, Nathan Wilson, and Jeffrey Yasskin.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2016/03/11/trip-report-winter-iso-c-standards-meeting/feed/</wfw:commentRss>
		<slash:comments>31</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2016/03/wg21-timeline.png" medium="image">
			<media:title type="html">wg21-timeline</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Fall 2015 ISO C++ standards meeting</title>
		<link>https://herbsutter.com/2015/10/25/2568/</link>
				<comments>https://herbsutter.com/2015/10/25/2568/#comments</comments>
				<pubDate>Sun, 25 Oct 2015 21:28:43 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2568</guid>
				<description><![CDATA[Yesterday we just wrapped up our fall ISO C++ committee meeting in Kona, HI, USA. We normally meet in windowless rooms all week, but because of the committee&#8217;s current size we had to use the hotel&#8217;s largest space which was open-air (though technically still windowless). It was a busy week. During the days from 8:00am-5:00pm, [&#8230;]]]></description>
								<content:encoded><![CDATA[<div data-shortcode="caption" id="attachment_2569" style="width: 510px" class="wp-caption aligncenter"><img data-attachment-id="2569" data-permalink="https://herbsutter.com/2015/10/25/2568/20151024_012338818_ios/" data-orig-file="https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg" data-orig-size="7840,3064" data-comments-opened="1" data-image-meta="{&quot;aperture&quot;:&quot;2.2&quot;,&quot;credit&quot;:&quot;&quot;,&quot;camera&quot;:&quot;iPhone 6 Plus&quot;,&quot;caption&quot;:&quot;&quot;,&quot;created_timestamp&quot;:&quot;1445613818&quot;,&quot;copyright&quot;:&quot;&quot;,&quot;focal_length&quot;:&quot;4.15&quot;,&quot;iso&quot;:&quot;500&quot;,&quot;shutter_speed&quot;:&quot;0.0083333333333333&quot;,&quot;title&quot;:&quot;&quot;,&quot;orientation&quot;:&quot;1&quot;}" data-image-title="20151024_012338818_iOS" data-image-description="" data-medium-file="https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=300" data-large-file="https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=500" class="wp-image-2569 size-large" src="https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=500&#038;h=195" alt="20151024_012338818_iOS" srcset="https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=500&amp;h=195 500w, https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=998&amp;h=390 998w, https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=150&amp;h=59 150w, https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=300&amp;h=117 300w, https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=768&amp;h=300 768w" sizes="(max-width: 500px) 100vw, 500px"   /><p class="wp-caption-text">Taking polls during the Friday afternoon plenary session &#8212; the room is hotter than it looks</p></div>
<p>Yesterday we just wrapped up our fall ISO C++ committee meeting in Kona, HI, USA. We normally meet in windowless rooms all week, but because of the committee&#8217;s current size we had to use the hotel&#8217;s largest space which was open-air (though technically still windowless).</p>
<p>It was a busy week. During the days from 8:00am-5:00pm, usually six sessions ran concurrently: Core (CWG), Evolution (EWG), Library (LWG), Library Evolution (LEWG), Concurrency (SG1), and usually at least one more subgroup such as Numerics. In the evenings, from 7:30-10:00pm, there were more evening sessions than evenings, and sometimes three would run concurrently. Daily sessions started at 8:00am, and most of us attended the evening sessions until 10:00pm each day, after which many people still went back to their rooms to update papers until midnight. (This schedule is pretty usual for ISO C++ meetings.)</p>
<h2>What we did</h2>
<p>We approved a number of actions &#8212; see <a href="https://www.reddit.com/r/cpp/comments/3q4agc/c17_progress_update_oct_2015/">STL&#8217;s great Reddit post</a> for a summary, and some details on the library parts. Here are a few more notes from my own perspective.</p>
<p>First, actual major deliverables:</p>
<p><strong>Concepts TS:</strong> It&#8217;s published! We did that between meetings, but it&#8217;s worth mentioning again here. There was initial discussion about putting it directly into C++17; we expect to seriously consider that at our next meeting.</p>
<p><strong>Concurrency TS:</strong> We approved the final Concurrency TS for publication. It&#8217;s done!</p>
<p><strong>Parallelism TS:</strong> The Concurrency group decided to pursue airlifting version 1 of this TS (which has already been published) into the draft for C++17, and we expect to see that proposed to the full committee at our next meeting. This week, we went ahead and also approved starting official work on version 2 of the Parallelism TS.</p>
<p><strong>Ranges TS:</strong> We approved starting official work on a Ranges TS based on Eric Niebler&#8217;s great working text. The goal is to send it out for its main ballot in March following our next meeting.</p>
<p><strong>Networking TS:</strong> We approved starting official work on a Networking TS based on Chris Kohlhoff&#8217;s excellent wording, evolved from his Boost.ASIO library.</p>
<p>Next, other major work:</p>
<p><strong>Modules</strong> has reached a milestone: design agreement! This was done by separating &#8220;phase 1&#8221; and &#8220;phase 2&#8221; of modules, and greenlighting phase 1 to proceed to wordsmithing for adoption (hopefully at our next meeting) into a new Modules TS, while in parallel continuing work on an expanded phase 2 which can follow.</p>
<p><strong>Variant</strong> has reached a milestone: design agreement! This consumed our main Monday evening session. For the first time, the broader set of committee members agreed on its design and we expect to see (and hopefully approve) actual wording at our next meeting. Its initial target will likely be Library Fundamentals v2. (Spoiler for those following along at home: It&#8217;s the same variant that LEWG approved at our last meeting in Lenexa, but after an exception renders the variant invalid, attempting to access the invalid variant causes defined behavior, such as throwing an exception, instead of undefined behavior. This was acceptable to three major constituencies: people who wanted a zero-overhead variant, people who wanted a variant without an omnipresent empty state, and people who wanted a variant without undefined behavior.)</p>
<p><strong>Contracts</strong> seem to have made a breakthrough in getting the various parties to agree on the nitty-gritty details of a design. This consumed two three-hour evening sessions on Tuesday and Wednesday nights. If this holds, we expect to see a combined proposal that for the first time achieves broad agreement in time for our next meeting.</p>
<p><strong>Reflection</strong> continues to make slow but steady progress. Chandler Carruth reminded us that several initial proposals have already started progressing through the committee.</p>
<p>There&#8217;s more, but those are some of the highlights.</p>
<h2>Next meetings</h2>
<p>Our next meetings (always <a href="https://isocpp.org/std/meetings-and-participation/upcoming-meetings">listed here</a>) will be Jacksonville, FL, USA on Feb 29 &#8211; Mar 5, 2016 and Oulu, Finland on Jun 20-25, 2016. Note that the Oulu meeting is when we plan to feature-complete C++17 and send it out for its main comment ballot, so that will be a big meeting. (It will also be within a few dozen kilometers of the Arctic Circle and is deliberately scheduled so that the summer solstice occurs during the meeting, so the joke is that there will likely again be lots of post-dinner sessions in Oulu, but for once we can guarantee there will be no evening sessions!)</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/10/25/2568/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2015/09/20151024_012338818_ios.jpg?w=660" medium="image">
			<media:title type="html">20151024_012338818_iOS</media:title>
		</media:content>
	</item>
		<item>
		<title>My talk at CppCon</title>
		<link>https://herbsutter.com/2015/09/27/my-talk-at-cppcon/</link>
				<comments>https://herbsutter.com/2015/09/27/my-talk-at-cppcon/#comments</comments>
				<pubDate>Sun, 27 Sep 2015 15:51:33 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2566</guid>
				<description><![CDATA[My talk at CppCon is now available online: &#8220;Writing Good C++14&#8230; By Default&#8221; (slides)  It&#8217;s about type and memory safety for C++ &#8212; not a small target. Definitely watch Bjarne&#8217;s keynote first. This talk is largely designed to be &#8220;part 2&#8221; of his keynote. I&#8217;m very excited about the C++ Core Guidelines to promote modern C++14 style [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>My talk at CppCon is now available online: <a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">&#8220;Writing Good C++14&#8230; By Default&#8221;</a> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/talks/Sutter%20-%20CppCon%202015%20day%202%20plenary%20.pdf">(slides)</a>  It&#8217;s about type and memory safety for C++ &#8212; not a small target.</p>
<p>Definitely watch <a href="https://isocpp.org/blog/2015/09/stroustrup-cppcon15-keynote">Bjarne&#8217;s keynote</a> first. This talk is largely designed to be &#8220;part 2&#8221; of his keynote.</p>
<p>I&#8217;m very excited about the C++ Core Guidelines to promote modern C++14 style and this effort to achieve type and memory safety dovetails with that. Bjarne and I merged our efforts last winter, and with the help of many people brought it to this point where it&#8217;s ready to open up, and we hope this work can continue making progress.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/09/27/my-talk-at-cppcon/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>CppCon program online</title>
		<link>https://herbsutter.com/2015/07/31/cppcon-program-online/</link>
				<comments>https://herbsutter.com/2015/07/31/cppcon-program-online/#comments</comments>
				<pubDate>Sat, 01 Aug 2015 02:10:53 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2564</guid>
				<description><![CDATA[The CppCon 2015 program is up! If anything this is an even stronger program than last year, which is saying something. My name isn&#8217;t on it yet, but yes, I am giving a talk at CppCon. It should be announced this week.]]></description>
								<content:encoded><![CDATA[<p><a href="http://cppcon.org/2015program">The CppCon 2015 program is up!</a> If anything this is an even stronger program than last year, which is saying something.</p>
<p>My name isn&#8217;t on it yet, but yes, I am giving a talk at CppCon. It should be announced this week.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/07/31/cppcon-program-online/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Spring ISO C++ meeting</title>
		<link>https://herbsutter.com/2015/06/05/trip-report-spring-iso-c-meeting/</link>
				<comments>https://herbsutter.com/2015/06/05/trip-report-spring-iso-c-meeting/#comments</comments>
				<pubDate>Fri, 05 Jun 2015 18:01:01 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2562</guid>
				<description><![CDATA[I just posted my Lenexa ISO C++ trip report over on isocpp.org covering our recent meeting. The ISO C++ committee is shipping more work sooner via concurrent Technical Specifications, but it’s still fairly new to find ourselves doing so much work that the “new normal” is to issue an international ballot from every ISO C++ meeting. This [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I just <a href="https://isocpp.org/blog/2015/06/trip-report-spring-iso-cpp-meeting">posted my Lenexa ISO C++ trip report</a> over on isocpp.org covering our recent meeting.</p>
<p>The ISO C++ committee is shipping more work sooner via concurrent Technical Specifications, but it’s still fairly new to find ourselves doing so much work that the “new normal” is to issue an international ballot from every ISO C++ meeting. This time, we completed three Technical Specifications (Transactional Memory, Library Fundamentals, and Parallelism) and sent out another for its comment ballot (Concurrency). We also did quite a bit of forward-looking planning for C++17, which is much closer than one would think since we&#8217;re aiming for a comment draft in mid/late 2016.</p>
<p>And check out the CppCon angle&#8230; it&#8217;s great to see the committee/community interaction and collaboration, and I can&#8217;t wait for CppCon in September and the fall ISO C++ meeting in October.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/06/05/trip-report-spring-iso-c-meeting/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Announcing a financial assistance policy for ISO C++ meetings</title>
		<link>https://herbsutter.com/2015/05/04/announcing-a-financial-assistance-policy-for-iso-c-meetings/</link>
				<comments>https://herbsutter.com/2015/05/04/announcing-a-financial-assistance-policy-for-iso-c-meetings/#comments</comments>
				<pubDate>Tue, 05 May 2015 03:49:25 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2560</guid>
				<description><![CDATA[Today it was my pleasure to announce a financial assistance policy for ISO C++ meetings. You can read about it at the announcement here.]]></description>
								<content:encoded><![CDATA[<p>Today it was my pleasure to announce a financial assistance policy for ISO C++ meetings. <a href="https://isocpp.org/blog/2015/05/financial-assistance-policy">You can read about it at the announcement here.</a></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/05/04/announcing-a-financial-assistance-policy-for-iso-c-meetings/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: Why was implicit int removed?</title>
		<link>https://herbsutter.com/2015/04/16/reader-qa-why-was-implicit-int-removed/</link>
				<comments>https://herbsutter.com/2015/04/16/reader-qa-why-was-implicit-int-removed/#comments</comments>
				<pubDate>Thu, 16 Apr 2015 19:08:14 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2557</guid>
				<description><![CDATA[Today, Vikram Ojha asked via email: I was just thinking why we removed &#8220;int&#8221; as default return type from C++ which was there in our traditional C type. Why we made such changes, is it to make language more safer? Short answer: Because it&#8217;s &#8216;inherently dangerous&#8217; in the words of the C committee. For C++, see [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Today, Vikram Ojha asked via email:</p>
<blockquote><p>I was just thinking why we removed &#8220;int&#8221; as default return type from C++ which was there in our traditional C type. Why we made such changes, is it to make language more safer?</p></blockquote>
<p>Short answer: Because it&#8217;s &#8216;inherently dangerous&#8217; in the words of the C committee.</p>
<p>For C++, see D&amp;E (The Design and Evolution of C++) index &#8220;implicit int&#8221; which takes you to section 2.8.1. For C, see the <a href="http://port70.net/~nsz/c/c99/C99RationaleV5.10.pdf">C99 Rationale</a> section 6.7.2 &#8212; interestingly, you can&#8217;t search for &#8220;implicit int&#8221; because that term isn&#8217;t used &#8212; this is where the string to search for is &#8220;inherent danger&#8221; :).</p>
<p>Cribbing from Bjarne&#8217;s writeup, “implicit int” was removed some 20 years ago for several reasons, including code clarity and in additional avoiding special cases, to simplify C++ code and/or the C++ grammar.</p>
<p>For example, what does this mean?</p>
<pre>void f(const T);</pre>
<p>In modern C++, it can mean only that f has a const parameter of type T that is unnamed.</p>
<p>If we had implicit int, this would be less obvious: Could it also be a const parameter of type int named T?</p>
<p>There are a number of other cases where just omitting the type, with the meaning that it&#8217;s a certain fixed type, makes the grammar and/or the program harder to think about than it should be. So the ability to do that was removed in both C and C++.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/04/16/reader-qa-why-was-implicit-int-removed/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: auto and for loop index variables</title>
		<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/</link>
				<comments>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comments</comments>
				<pubDate>Thu, 15 Jan 2015 01:23:38 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2552</guid>
				<description><![CDATA[[Edit: I really like the &#8216;range of values&#8217; several commenters proposed. We do need something like that in the standard library, and it may well come in with ranges, but as you can see there are several simple ways to roll your own in the meantime, and some third-party libraries have similar features already.] Today [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><em>[Edit: I really like the &#8216;range of values&#8217; several commenters proposed. We do need something like that in the standard library, and it may well come in with ranges, but as you can see there are several simple ways to roll your own in the meantime, and some third-party libraries have similar features already.]</em></p>
<p>Today a reader asked the following question:</p>
<blockquote><p><span style="color:#000000;font-family:Calibri;font-size:medium;">So I’ve been reading all I can about c++11/c++14 and beyond when time permits.  I like auto, I really do, I believe in it.  I have a small problem I’m trying to decide what to do about.  So in old legacy code we have things like this:</span></p>
<p><span style="color:#000000;font-family:Calibri;font-size:medium;">for (int i = 0; i &lt; someObject.size(); i++) { &#8230; }</span></p>
<p><span style="color:#000000;font-family:Calibri;font-size:medium;">For some object types size might be unsigned, size_t, int, int64_t etc…</span></p>
<p><span style="color:#000000;font-family:Calibri;font-size:medium;">Is there a proper way to handle this generically with auto?  The best I could come up with is:</span></p>
<p><span style="color:#000000;font-family:Calibri;font-size:medium;">auto mySize = someObject.size();</span></p>
<p><span style="color:#000000;font-family:Calibri;font-size:medium;">for (auto i = decltype(mySize){0}; i &lt; mySize; i++) { &#8230; }</span></p>
<p><span style="color:#000000;font-family:Calibri;font-size:medium;">But I feel dirty for doing it because although it actually is very concise, it’s not newbie friendly to my surrounding coworkers who aren’t as motivated to be on the bleeding edge.</span></p></blockquote>
<p>Good question.</p>
<p>First, of course, I&#8217;m sure you know the best choice is to use range-for where that&#8217;s natural, or failing that consider iterators and <strong>begin()/end()</strong> where auto naturally gets the iterator types right. Having said that, sometimes you do need an index variable (including for performance) so I&#8217;ll assume you&#8217;re in that case.</p>
<p>So here&#8217;s my off-the-cuff answer:</p>
<ul>
<li>If this isn’t in a template, then I think <strong>for( auto i = 0;</strong> etc. is fine, and if you get a warning about signed/unsigned mismatch just write <strong>for(auto i = 0u;</strong> etc. This is all I&#8217;ve usually needed to do.</li>
</ul>
<ul>
<li>If this is truly generic code in a template, then I suppose <strong>for( auto i = 0*mySize;</strong> etc. isn’t too bad – it gets the type and it’s not terribly ugly. Disclaimer: I&#8217;ve never written this, personally, as I haven&#8217;t had a need (yet). And I definitely don&#8217;t know that I like it&#8230; just throwing it out as an idea.</li>
</ul>
<p>But that&#8217;s an off-the-cuff answer. Dear readers, if you know other/better answers please tell us in the comments.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/feed/</wfw:commentRss>
		<slash:comments>52</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>A quick poll about order of evaluation&#8230;</title>
		<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/</link>
				<comments>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comments</comments>
				<pubDate>Mon, 01 Dec 2014 20:46:43 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2547</guid>
				<description><![CDATA[Consider this program fragment: std::vector&#60;int&#62; v = { 0, 0 }; int i = 0; v[i++] = i++; std::cout &#60;&#60; v[0] &#60;&#60; v[1] &#60;&#60; endl; My question is not what it might print under today&#8217;s C++ rules. The third line runs afoul of two different categories of undefined and unspecified behavior. Rather, my question is [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Consider this program fragment:</p>
<pre>std::vector&lt;int&gt; v = { 0, 0 };
int i = 0;
v[i++] = i++;
std::cout &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;</pre>
<p>My question is not what it might print under today&#8217;s C++ rules. The third line runs afoul of two different categories of undefined and unspecified behavior.</p>
<p>Rather, my question is what you would <em>like</em> the result to be. Please let me know.</p>
<a name="pd_a_8490486"></a>
<div class="PDS_Poll" id="PDI_container8490486" data-settings="{&quot;url&quot;:&quot;https:\/\/secure.polldaddy.com\/p\/8490486.js&quot;}" style="display:inline-block;"></div>
<div id="PD_superContainer"></div>
<noscript><a href="https://polldaddy.com/poll/8490486">Take Our Poll</a></noscript><script type='text/javascript'>
(function(d,c,j){if(!d.getElementById(j)){var pd=d.createElement(c),s;pd.id=j;pd.src='https://s2.wp.com/wp-content/mu-plugins/shortcodes/js/polldaddy-shortcode.js';s=d.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd,s);}  else if(typeof jQuery !=='undefined')jQuery(d.body).trigger('pd-script-load');}(document,'script','pd-polldaddy-loader'));
</script>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/feed/</wfw:commentRss>
		<slash:comments>116</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Updates to my trip report</title>
		<link>https://herbsutter.com/2014/11/24/updates-to-my-trip-report/</link>
				<comments>https://herbsutter.com/2014/11/24/updates-to-my-trip-report/#comments</comments>
				<pubDate>Mon, 24 Nov 2014 19:16:19 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2545</guid>
				<description><![CDATA[(this is an echo of what I also just posted on isocpp.org) I wanted to add a few more things to my meeting trip report. I updated the trip report in-place, but for those who want to see the &#8220;diffs&#8221; I&#8217;ll also post just the new parts here as a standalone post: There were 106 [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><em>(this is an echo of what I also just posted on isocpp.org)<br />
</em></p>
<p>I wanted to add a few more things to <a href="https://isocpp.org/blog/2014/11/trip-report-fall">my meeting trip report</a>. I updated the trip report in-place, but for those who want to see the &#8220;diffs&#8221; I&#8217;ll also post just the new parts here as a standalone post:</p>
<p>There were 106 experts at this meeting, officially representing 7 nations. This meeting saw a recent-record number of papers, including over 120 in the pre-meeting mailing.</p>
<p>In addition to the other things I mentioned, we also approved several other interesting changes, including the following highlights:</p>
<ul>
<li>Adopted N4230, which allows nested namespace definitions like <em>namespace A::B::C { }</em> as a convenient shorthand for <em>namespace A { namespace B { namespace C { } } }</em>.</li>
<li>Adopted N3922, which fixes the most common pitfall with <em>auto</em> and <em>{}</em>, so that <em>auto x{y};</em> now deduces the sane and expected thing, namely the type of <em>y</em>. Before this, it deduced <em>initializer_list</em> which was unfortunate and surprising. So, fixed.</li>
<li>Adopted N4086, which removes trigraphs. Yes, we removed something from C++… and something that was inherited from C! But wait, there&#8217;s more…</li>
<li>Adopted N4190, and actually removed (not just deprecated) several archaic things from the C++ standard library, including <em>auto_ptr</em>, <em>bind1st</em>/<em>bind2nd</em>, <em>ptr_fun</em>/<em>mem_fun</em>/<em>mem_fun_ref</em>, <em>random_shuffle</em>, and a few more. Those are now all removed from the draft C++17 standard library and will not be part of future portable C++.</li>
</ul>
<p>We also did work and made progress on a lot of other proposals, including <strong>modules</strong>. See the pre-meeting mailing for details about papers considered at this meeting.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/11/24/updates-to-my-trip-report/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip Report: Fall ISO C++ Meeting</title>
		<link>https://herbsutter.com/2014/11/22/trip-report-fall-iso-c-meeting/</link>
				<comments>https://herbsutter.com/2014/11/22/trip-report-fall-iso-c-meeting/#comments</comments>
				<pubDate>Sun, 23 Nov 2014 00:19:54 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2541</guid>
				<description><![CDATA[I just posted my ISO C++ meeting trip report over on isocpp.org covering our meeting in Urbana-Champaign earlier this month. The ISO C++ committee is shipping more work sooner via concurrent Technical Specifications, but it&#8217;s still fairly new to find ourselves doing so much work that the &#8220;new normal&#8221; is to issue an international ballot from every [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I just <a href="https://isocpp.org/blog/2014/11/trip-report-fall">posted my ISO C++ meeting trip report</a> over on isocpp.org covering our meeting in Urbana-Champaign earlier this month.</p>
<p>The ISO C++ committee is shipping more work sooner via concurrent Technical Specifications, but it&#8217;s still fairly new to find ourselves doing so much work that the &#8220;new normal&#8221; is to issue an international ballot from every ISO C++ meeting. This time, we have <em>four</em> ballots coming out of this meeting &#8212; the first (of two) ballots for the Transactional Memory TS, the final ballots for the Library Fundamentals TS and the Parallelism TS, and a new work item for C++17 since this was the first meeting of the C++17 era.</p>
<p>Oh, and we had evening sessions. Did I mention evening sessions? Five nights&#8217; worth.</p>
<p>Now, two weeks later, I&#8217;m almost caught up on sleep.</p>
<p>Almost.</p>
<p>But what a blast. I&#8217;m looking forward to the next few smaller meetings over the winter, and the next full one in May.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/11/22/trip-report-fall-iso-c-meeting/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>VS, Clang, cross-platform, and a short video</title>
		<link>https://herbsutter.com/2014/11/12/vs-clang-cross-platform-and-a-short-video/</link>
				<comments>https://herbsutter.com/2014/11/12/vs-clang-cross-platform-and-a-short-video/#comments</comments>
				<pubDate>Wed, 12 Nov 2014 17:25:26 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2538</guid>
				<description><![CDATA[Today my team was part of the Visual Studio 2015 Preview announcement, and it&#8217;s nice to be able to share that Visual Studio is now going to support targeting Android and soon iOS, using the Clang compiler, from right inside VS. This is in addition to continued conformance and other improvements in our own VC++ compiler [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Today my team was part of the Visual Studio 2015 Preview announcement, and it&#8217;s nice to be able to share that Visual Studio is now going to support targeting Android and soon iOS, using the Clang compiler, from right inside VS. This is in addition to continued conformance and other improvements in our own VC++ compiler for targeting Microsoft platforms.</p>
<p>I recorded <a href="http://channel9.msdn.com/Events/Visual-Studio/Connect-event-2014/311">an 8-minute video</a> about Visual C++&#8217;s conformance improvements in our existing compiler that you can get now in the Preview available today, and why using a single source code base in C++ built using VC++ to target Windows/WP and also Clang/LLVM to target Android and iOS is a hot ticket right now. The Resources slide at the end includes links to two CppCon videos I hope you&#8217;ll check out if you haven&#8217;t already.</p>
<p>I hope you enjoy the news, and the Preview.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/11/12/vs-clang-cross-platform-and-a-short-video/feed/</wfw:commentRss>
		<slash:comments>12</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>My CppCon talks</title>
		<link>https://herbsutter.com/2014/10/18/my-cppcon-talks-2/</link>
				<comments>https://herbsutter.com/2014/10/18/my-cppcon-talks-2/#comments</comments>
				<pubDate>Sun, 19 Oct 2014 01:01:43 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2535</guid>
				<description><![CDATA[Also, my CppCon talks are all up on the CppCon YouTube channel. You can find them here: Back to the Basics! Essentials of Modern C++ Style: Loops, pointers and references, smart pointers, variable declarations, and parameter passing Lock-Free Programming (or, Juggling Razor Blades), Part 1: Lazy initialization with DCL vs. call_once vs. function local statics, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Also, my CppCon talks are all up on the <a href="https://www.youtube.com/user/CppCon">CppCon YouTube channel</a>. You can find them here:</p>
<ul>
<li><a href="http://youtu.be/xnqTKD8uD64">Back to the Basics! Essentials of Modern C++ Style</a>: Loops, pointers and references, smart pointers, variable declarations, and parameter passing</li>
<li><a href="http://youtu.be/c1gO9aB9nbs">Lock-Free Programming (or, Juggling Razor Blades), Part 1</a>: Lazy initialization with DCL vs. call_once vs. function local statics, and lock-free mailbox algorithms</li>
<li><a href="http://youtu.be/CmxkPChOcvw">Lock-Free Programming (or, Juggling Razor Blades), Part 2</a>: Lock-free linked lists, the ABA problem, and atomic smart pointers</li>
</ul>
<p>I hope you find them useful.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/10/18/my-cppcon-talks-2/feed/</wfw:commentRss>
		<slash:comments>13</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>New Interview</title>
		<link>https://herbsutter.com/2014/10/18/new-interview/</link>
				<pubDate>Sun, 19 Oct 2014 00:51:51 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2533</guid>
				<description><![CDATA[While we were both at CppCon last month and had cameras around, Brian Overland interviewed me for InformIT. The video just went up a couple of days ago. You can find it here. If you&#8217;ve seen my interviews before, the first 14 minutes is stuff you&#8217;ve heard before, but I think you&#8217;ll find the last [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><img src="https://herbsutter.files.wordpress.com/2014/10/101914_0051_newintervie1.png?w=500" alt="" align="right" />While we were both at CppCon last month and had cameras around, Brian Overland interviewed me for InformIT. The video just went up a couple of days ago. <a href="http://youtu.be/dTZvKAo8-Qg">You can find it here.</a></p>
<p>If you&#8217;ve seen my interviews before, the first 14 minutes is stuff you&#8217;ve heard before, but I think you&#8217;ll find <a href="https://www.youtube.com/watch?v=dTZvKAo8-Qg&amp;feature=youtu.be&amp;t=14m23s">the last five minutes starting at 14:23</a> to be interesting new material.</p>
]]></content:encoded>
									
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/10/101914_0051_newintervie1.png" medium="image" />
	</item>
		<item>
		<title>Next stop: Stuttgart</title>
		<link>https://herbsutter.com/2014/09/16/next-stop-stuttgart/</link>
				<comments>https://herbsutter.com/2014/09/16/next-stop-stuttgart/#comments</comments>
				<pubDate>Tue, 16 Sep 2014 15:48:42 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2529</guid>
				<description><![CDATA[CppCon was a blast. I can&#8217;t wait till next year. But there&#8217;s something coming up sooner than that: In two weeks, Scott and Andrei and I will be holding the C++ and Beyond 2014 &#8220;Road Show&#8221; in Stuttgart, Germany. The key to this event is not new material, but a new location. Whereas all other [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>CppCon was a blast. I can&#8217;t wait till next year.</p>
<p>But there&#8217;s something coming up sooner than that: In two weeks, Scott and Andrei and I will be holding the <a href="http://www.qa-systems.com/academy/single-view.html?tuid=64"><em>C++ and Beyond</em> 2014 &#8220;Road Show&#8221; in Stuttgart, Germany</a>.</p>
<p>The key to this event is not new material, but a new location. Whereas all other C&amp;B&#8217;s have been in North America, this is the first time ever that Scott and Andrei and I are doing an event together in Europe. That&#8217;s exciting! (At least for us.) If you&#8217;ve been to C&amp;B you will have seen most of this material before, but if you haven&#8217;t been able to get to C&amp;B until now you may find it convenient to have the event be more local to European attendees. The talks are all talks we&#8217;ve given at C&amp;B before, but there will be updates.</p>
<p><a href="http://cppandbeyond.com/2014/09/15/cb-stuttgart-just-two-weeks-away/">Scott seems to be looking forward</a> to a debate with me about parameter passing. I&#8217;m glad he thinks I&#8217;m &#8220;seeing more reason than [I] used to, (i.e., having moved closer to [Scott&#8217;s] point of view)&#8221; – by which he means that he has moved closer to my point of view. :) Should be fun! The boring truth, as I presented at CppCon on Friday, is that <strong><em>everyone</em></strong> agrees that the default parameter passing rules are the same as C++98… <a href="http://acronyms.thefreedictionary.com/Grin+Duck+%26+Run">&lt;gd&amp;r&gt;</a> and let the games begin!</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/09/16/next-stop-stuttgart/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip Report: CppCon 2014</title>
		<link>https://herbsutter.com/2014/09/15/trip-report-cppcon-2014/</link>
				<comments>https://herbsutter.com/2014/09/15/trip-report-cppcon-2014/#comments</comments>
				<pubDate>Mon, 15 Sep 2014 17:13:04 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2527</guid>
				<description><![CDATA[I just posted my CppCon trip report over at isocpp.org. I&#8217;ll repeat just the last part here: Huge thanks again to the 150+ speakers, planners, and volunteers without whom this wonderful &#8220;C++ festival&#8221; (as several people spontaneously called it) would not have been possible. I had guardedly high hopes for the event, but I think [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I just <a href="https://isocpp.org/blog/2014/09/trip-report-cppcon-2014">posted my CppCon trip report</a> over at isocpp.org.</p>
<p>I&#8217;ll repeat just the last part here:</p>
<blockquote><p><strong>Huge thanks again to the 150+ speakers, planners, and volunteers without whom this wonderful &#8220;C++ festival&#8221; (as several people spontaneously called it) would not have been possible.</strong> I had guardedly high hopes for the event, but I think it exceeded all our expectations. This was the most exciting and enlightening week I&#8217;ve experienced in my 20 years of C++, and I&#8217;m still catching my breath. I can&#8217;t wait until September 2015.</p></blockquote>
<p><span style="color:black;">Here are a few pics I and others took. You&#8217;ll find more <a href="https://twitter.com/search?q=%23cppcon&amp;src=typd">on Twitter tagged #cppcon</a>.<br />
</span></p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc1.jpg?w=500" alt="" /> Mark Maimone of NASA and Mars Rover fame.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc2.jpg?w=500" alt="" /> Bjarne taking questions after his talk.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc3.jpg?w=500" alt="" /> &#8220;We&#8217;re sold out of <em>A Tour of C++</em> again… how about this instead?&#8221; [photo credit: Artur Laksberg]</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc4.jpg?w=500" alt="" /> [photo credit: Artur Laksberg]</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc5.jpg?w=500" alt="" /> [photo credit: Artur Laksberg]</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc6.jpg?w=500" alt="" /> Walter Brown speaking in one of the six concurrent breakout sessions.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc7.jpg?w=500" alt="" /> Jon Kalb speaking in one of the other rooms.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc8.jpg?w=500" alt="" /> Possibly the youngest attendee? [photo credit: Artur Laksberg]</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc9.jpg?w=500" alt="" /> Accessibility and community.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc10.jpg?w=500" alt="" /> Yup. Modern C++.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc11.jpg?w=500" alt="" /> View from the CppCon balcony before diving into more evening sessions.</p>
<p><img src="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc12.jpg?w=500" alt="" /> So long, Meydenbauer Center… see you next year! [photo credit: Hyrum Wright]</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/09/15/trip-report-cppcon-2014/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc1.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc2.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc3.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc4.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc5.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc6.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc7.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc8.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc9.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc10.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc11.jpg" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/09/091514_1712_tripreportc12.jpg" medium="image" />
	</item>
		<item>
		<title>My CppCon Plenary (updated)</title>
		<link>https://herbsutter.com/2014/08/19/my-cppcon-plenary-updated/</link>
				<comments>https://herbsutter.com/2014/08/19/my-cppcon-plenary-updated/#comments</comments>
				<pubDate>Tue, 19 Aug 2014 15:44:57 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2510</guid>
				<description><![CDATA[When we announced the CppCon conference program and I posted my final talk selection, the original plan for my Friday &#8216;endnote&#8217; plenary was for it to focus on giving an update on future standardization plans. However, quite a few people immediately wrote me to express disappointment that I wouldn&#8217;t cover my Modern C++ Style material, [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>When we announced the CppCon conference program and I <a href="https://herbsutter.com/2014/07/02/my-cppcon-talks/">posted my final talk selection</a>, the original plan for my Friday &#8216;endnote&#8217; plenary was for it to focus on giving an update on future standardization plans. However, quite a few people immediately wrote me to express disappointment that I wouldn&#8217;t cover my <em>Modern C++ Style</em> material, which they felt was sorely needed as we build updated C++ usage guidance in the presence of everything that&#8217;s new in C++11 and C++14 which really do make C++ feel like a new and fresh language. At the same time, I noticed that the standardization material I had planned to cover will be covered very well in the Monday CppCon talk <a href="http://sched.co/1iGEi0Q">&#8220;What the Committee Did Next!&#8221;</a> by Alisdair Meredith, chair of the Library Working Group of the C++ standards committee.
</p>
<p>So I suggested that maybe we ought to repurpose my Friday plenary session with the other highly-requested topic instead, and <a href="http://cppcon.org/final-plenary-session-2014/">the organizers agreed</a>. Here&#8217;s the new description:
</p>
<p style="margin-left:36pt;"><a href="http://sched.co/1v016xH"><strong>Back to the Basics! Elements of Modern C++ Style</strong></a><strong><br />
		</strong></p>
<p style="margin-left:36pt;">by Herb Sutter
</p>
<p style="margin-left:36pt;">This talk revisits basic questions, such as how to declare and initialize a variable, how to pass a value to a function, how to write a simple loop, and how to use smart pointers, in the light of experience with C++11 and the latest C++14 refinements. This involves examining auto, rvalue references, range-for loops, uniform initialization, lambda expressions, unique_ptr and shared_ptr, and more.
</p>
<p>Like all CppCon sessions, this talk will be recorded and is expected to be available online a month or two after the conference.
</p>
<p><strong>Note:</strong> If you&#8217;re in the Seattle area, note that <a href="http://cppcon.org/final-plenary-session-2014/">Friday admission is free and open to all</a>, as are evening and breakfast sessions, even if you don&#8217;t have a registration to see the other 100+ daytime technical sessions. (Though if you&#8217;re in the Seattle area and a C++ developer, why wouldn&#8217;t you register for the whole conference? Airfare and hotel are the majority of the total cost for most attendees, so if you&#8217;re local anyway this is some of the most inexpensive high-quality training there is. Just sayin&#8217;. Note that I am one of the CppCon organizers but I have no personal financial stake in CppCon – I&#8217;m not getting a penny from it – I&#8217;m just a delighted participant and attendee.)
</p>
<p>I&#8217;m looking forward to seeing many of you at CppCon!</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/08/19/my-cppcon-plenary-updated/feed/</wfw:commentRss>
		<slash:comments>3</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Summer ISO C++ meeting</title>
		<link>https://herbsutter.com/2014/07/03/trip-report-summer-iso-c-meeting/</link>
				<comments>https://herbsutter.com/2014/07/03/trip-report-summer-iso-c-meeting/#comments</comments>
				<pubDate>Fri, 04 Jul 2014 03:05:09 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2507</guid>
				<description><![CDATA[I just posted my isocpp.org trip report from the recently concluded ISO C++ meeting in Switzerland. We sent three documents out for ballot. This is the first time in ISO C++ history that we have sent three documents out for ballot out of a single meeting. Wow. See the full trip report for more details&#8230;]]></description>
								<content:encoded><![CDATA[<p><img align="right" src="https://herbsutter.files.wordpress.com/2014/07/070414_0305_tripreports1.png?w=500" alt="" />
	</p>
<p>I just posted my <a href="https://isocpp.org/blog/2014/07/trip-report-summer-iso-c-meeting"><em>isocpp.org</em> trip report</a> from the recently concluded ISO C++ meeting in Switzerland.
</p>
<p>We sent three documents out for ballot. This is the first time in ISO C++ history that we have sent three documents out for ballot out of a single meeting. Wow.
</p>
<p>See the full trip report for more details&#8230;</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/07/03/trip-report-summer-iso-c-meeting/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/07/070414_0305_tripreports1.png" medium="image" />
	</item>
		<item>
		<title>My CppCon talks</title>
		<link>https://herbsutter.com/2014/07/02/my-cppcon-talks/</link>
				<comments>https://herbsutter.com/2014/07/02/my-cppcon-talks/#comments</comments>
				<pubDate>Wed, 02 Jul 2014 23:50:54 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2504</guid>
				<description><![CDATA[A few weeks ago, here and here, I posted the five talks I submitted for CppCon. Good news (really): The CppCon program (posted today) is so strong that some of my talks legitimately fell below the cut line. Instead of giving five talks, I&#8217;ll be giving two – one as I proposed it, one a [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><a href="http://cppcon.org/conference-program/"><img align="right" src="https://herbsutter.files.wordpress.com/2014/07/070214_2350_mycppcontal1.png?w=500" alt="" border="0" /></a>
	</p>
<p>A few weeks ago, <a href="https://herbsutter.com/2014/05/20/cppcon-my-proposed-talks-part-1/">here</a> and <a href="https://herbsutter.com/2014/05/21/cppcon-my-proposed-talks-part-2/">here</a>, I posted the five talks I submitted for CppCon.
</p>
<p>Good news (really): The <a href="http://cppcon.org/conference-program/">CppCon program (posted today)</a> is so strong that some of my talks legitimately fell below the cut line. Instead of giving five talks, I&#8217;ll be giving two – one as I proposed it, one a plenary session condensed from three proposed talks. The fifth proposed talk fell under &#8220;thanks but there&#8217;s just no room, maybe next year.&#8221;
</p>
<p>This is an awesome problem to have. Seeing the other sessions I am sincerely happy to see some of my material and proposed topics have to be condensed and/or cut to make room for the high-quality content in the program from other speakers. Little did we know what a strong response there would be to the call for session proposals, with well over 100 speakers proposing talks, but the response was just, well, awesome. Now that the Program Committee has done its work (thanks again, PC members!), here&#8217;s how it came down for me:
</p>
<p>First, I&#8217;m doing a plenary session in the main hall which will be 90 minutes instead of 60 and so will let me combine and condense material from my proposed talks on Standardization Update, Garbage Collection, and C++ ABI, to make a single forward-looking &#8216;endnote-y&#8217; session. Here&#8217;s the merged title and abstract:
</p>
<h3>C++ Today and Tomorrow: C++14, a Gaggle of TSes, and Beyond<br />
</h3>
<p style="margin-left:36pt;">This talk starts with a standardization update: By the time we meet at CppCon, C++14 might already be ratified. But that&#8217;s only one of eight (so far) work items now in flight. This session will start off with a summary of the new features coming in C++14 itself, followed by a tour of the seven (7) near-term separate Technical Specifications already underway – think of these as the &#8220;C++14 wave&#8221; of deliverables, covering standard support for everything from file system access and networking, to concurrency and parallelism, to concepts and transactional memory. In each case, we&#8217;ll get a feel for what each major feature looks like and how to use it, and why it&#8217;s important for the standard and for your own portable C++ code.
</p>
<p style="margin-left:36pt;">Then we turn to future directions: What two features are expected to be pillars of C++17? What other work is being done, and what other problems need to be addressed, and how, for C++ to continue to fulfill its mission to be a modern close-to-the-metal systems programming language? Sutter will share thoughts on two specific forward-looking topics: First, how garbage collection can be added well to C++, directly complementing (not competing with) C++&#8217;s existing strengths and demonstrating why, as Stroustrup says, &#8220;C++ is the best language for garbage collection.&#8221; And second, why and how we might develop a standard C++ ABI, including directly addressing the #1 valid reason to use C instead of C++, and removing a major obstacle to sharing binary C++ libraries in a modern way.
</p>
<p>Second, I&#8217;m doing the lock-free programming talk as a regular talk:
</p>
<h3>Lock-Free Programming (or, Juggling Razor Blades)<br />
</h3>
<p style="margin-left:36pt;">Example-driven talk on how to design and write lock-free algorithms and data structures using C++ <em>atomic</em> – something that can look deceptively simple, but contains very deep topics. (Important note: This is not the same as my &#8220;atomic Weapons&#8221; talk; that talk was about the &#8220;what they are and why&#8221; of the C++ memory model and atomics, and did not cover how to actually use atomics to implement highly concurrent algorithms and data structures.)
</p>
<p>The talk that didn&#8217;t make the bar this time was <em>Modern C++ Style: Idioms of C++11/14</em>. It&#8217;s a shame, because I think it&#8217;s a strong talk, but some of its material will be covered well in talks by other speakers, and the 1-3 hours this talk would have occupied will be put to even better use by up to three other talks on other modern topics.
</p>
<p>I&#8217;m really looking forward to being in the audience for the talks that take the place of this one, even as I look forward to re-proposing this talk for next year&#8217;s CppCon.
</p>
<p>I hope to see many of you at CppCon.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/07/02/my-cppcon-talks/feed/</wfw:commentRss>
		<slash:comments>11</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/07/070214_2350_mycppcontal1.png" medium="image" />
	</item>
		<item>
		<title>CppCon: My Proposed Talks (Part 2)</title>
		<link>https://herbsutter.com/2014/05/21/cppcon-my-proposed-talks-part-2/</link>
				<comments>https://herbsutter.com/2014/05/21/cppcon-my-proposed-talks-part-2/#comments</comments>
				<pubDate>Wed, 21 May 2014 11:21:46 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2493</guid>
				<description><![CDATA[Yesterday I posted three of my proposed talks for CppCon. These are the ones I&#8217;ve given publicly before, but they&#8217;re not retreads – all are fresh and up to date, with refreshed or new material. But I&#8217;ve also proposed two brand new talks – titles and abstracts are below. Note: The CppCon program committee will [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Yesterday I <a href="https://herbsutter.com/2014/05/20/cppcon-my-proposed-talks-part-1/">posted three</a> of my proposed talks for CppCon. These are the ones I&#8217;ve given publicly before, but they&#8217;re not retreads – all are fresh and up to date, with refreshed or new material.
</p>
<p>But I&#8217;ve also proposed two brand new talks – titles and abstracts are below.
</p>
<blockquote>
<p>Note: The CppCon program committee will be considering the talk proposals to come up with a balanced program, so it&#8217;s possible that not all of these will be in the final program, but I have high hopes for most of these…
</p>
</blockquote>
<p>CppCon is building well. I don&#8217;t know how many talks there will be in the end as this depends on the program committee including in part how long the accepted talks are, but FWIW my talks are submissions #41 and #126-129. There&#8217;s some really great stuff in the pipeline on all sorts of topics of interest to C++ developers, not just about the language itself but also tools, specific domains, and lots of cool stuff that will be shown for the first time at CppCon.
</p>
<p>I look forward to seeing many of you at CppCon this fall! If we have the right equipment in the main auditorium, there might even be a wind of change…
</p>
<p style="text-align:center;">
 </p>
<h2>GC for C++, and C++ for GC: &#8220;Right&#8221; and &#8220;Wrong&#8221; Ways to Add Garbage Collection to C++ (1 to 2 hours)<br />
</h2>
<p><span style="font-family:Verdana;font-size:10pt;">&#8220;Garbage collection is essential to modern programming!&#8221; &#8220;Garbage collection is silly, who needs it!&#8221;<br />
</span></p>
<p><span style="font-family:Verdana;font-size:10pt;">As is usual with extremes, both of these statements are wrong. Garbage collection (GC) is not needed for most C++ programs; we&#8217;re very happy with determinism and smart pointers, and GC is absolutely penalizing when overused, especially as a default (or, <em>shudder</em>, only) memory allocator. However, the truth is that GC is also important to certain high-performance and highly-concurrent data structures, because it helps solve advanced lock-free problems like the ABA problem better than workarounds like hazard pointers.<br />
</span></p>
<p><span style="font-family:Verdana;font-size:10pt;">This talk presents thoughts about how GC can be added well to C++, directly complementing (not competing with) C++&#8217;s existing strengths and demonstrating why, as Stroustrup says, &#8220;C++ is the best language for garbage collection.&#8221;</span>
	</p>
<p>
 </p>
<h2>Addressing C++&#8217;s #1 Problem: Defining a C++ ABI (1 hour)<br />
</h2>
<p>&#8220;Why can&#8217;t I share C++ libraries even between my own internal teams without using the identical compiler and switch settings?&#8221; &#8220;Why are operating system APIs written in unsafe C, instead of C++?&#8221; &#8220;Why can&#8217;t I use <em>std::string</em> in a public shared library interface; it&#8217;s the C++ string, isn&#8217;t it?!&#8221;
</p>
<p>These and more perennial questions are caused by the same underlying problem: For various historical reasons, C++ does not have a standard binary interface, or ABI. Partial solutions exist, from the Itanium ABI which addresses only the language and only on some platforms, to COM and CORBA which do both less and far more than is needed.
</p>
<p>It is deeply ironic that there actually is a way to write an API in C++ so that it has a de facto stable binary ABI on every platform: <em>extern &#8220;C&#8221;</em>.
</p>
<p>This session describes current work driven by the presenter to develop a standard C++ ABI. This does not mean having identical binaries on all platforms. It does mean tackling all of the above problems, including directly addressing the #1 valid reason to use C instead of C++, and removing a major obstacle to sharing binary C++ libraries in a modern way.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/05/21/cppcon-my-proposed-talks-part-2/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>CppCon: My Proposed Talks (Part 1)</title>
		<link>https://herbsutter.com/2014/05/20/cppcon-my-proposed-talks-part-1/</link>
				<comments>https://herbsutter.com/2014/05/20/cppcon-my-proposed-talks-part-1/#comments</comments>
				<pubDate>Tue, 20 May 2014 12:24:16 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2490</guid>
				<description><![CDATA[I&#8217;ve been watching the talk proposals rolling in for CppCon, now well over 100 of them, and I was already looking forward to this conference but I just keep getting more jazzed. For my part, I&#8217;ve proposed five talks, with between 5 and 10 hours of material. I thought I&#8217;d share some of them here. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I&#8217;ve been watching the talk proposals rolling in for <a href="http://cppcon.org/">CppCon</a>, now well over 100 of them, and I was already looking forward to this conference but I just keep getting more jazzed.
</p>
<p>For my part, I&#8217;ve proposed <strong>five talks</strong>, with between <strong>5 and 10 hours</strong> of material. I thought I&#8217;d share some of them here.
</p>
<blockquote>
<p>Note: The CppCon program committee will be considering the talk proposals to come up with a balanced program, so it&#8217;s possible that not all of these will be in the final program, but I have high hopes for most of these…
</p>
</blockquote>
<p>Below are three of the five proposed talks. These are the ones I&#8217;ve given publicly before, but they&#8217;re not retreads – all are fresh and up to date, with refreshed or new material.
</p>
<p>I&#8217;ll cover the other two new talks in a separate post soon.
</p>
<p>I hope to see you at CppCon this fall to talk about these and many more interesting topics by scores of great speakers!
</p>
<p style="text-align:center;">
 </p>
<h2>Lock-Free Programming – or, How to Juggle Razor Blades (~2 hours)<br />
</h2>
<p><span style="font-family:Verdana;font-size:10pt;">Example-driven talk on how to design and write lock-free algorithms and data structures using C++ atomic&lt;&gt; – something that can look deceptively simple, but contains very deep topics. (Important note: This is not the same as my &#8220;atomic&lt;&gt; Weapons&#8221; talk; that talk was about the &#8220;what they are and why&#8221; of the C++ memory model and atomics, and did not cover how to actually use atomics to implement highly concurrent algorithms and data structures.)</span>
	</p>
<p>This talk is about the &#8220;how to use them successfully&#8221; part of atomics, including:
</p>
<ul>
<li>Best practices and style for using atomic&lt;&gt;s
</li>
<li>Three or more examples, including lock-free mail slots and iterations of a lock-free linked list, all in portable Standard C++
</li>
<li>Defining and applying the different levels of &#8220;lock-freedom&#8221; (wait-free, lock-free, obstruction-free) to develop highly concurrent algorithms and data structures
</li>
<li>Explaining and applying key concepts including especially: linearizability; trading off concurrency vs. promptness; and trading off concurrency vs. throughput/utilization
</li>
<li>Demonstrating and solving the ABA problem, with clean and simple code – that&#8217;s right, did you know that in C++11 you can solve this without relying on esoterica like double-wide CAS (which isn&#8217;t always available) or hazard pointers (which are deeply complex) or garbage collection (which isn&#8217;t in the C++ standard&#8230; yet)?
</li>
</ul>
<p>
 </p>
<h2>Standardization Update: C++14 and the Seven Dwarfs (1 hour)<br />
</h2>
<p>Standardization has accelerated: By the time we meet at CppCon, C++14 might already be ratified. But that&#8217;s only one of eight (so far) work items now in flight. In this session, I&#8217;ll give a brief summary of the new features coming in C++14 itself, and then a tour of the seven (7) near-term separate Technical Specifications already underway – think of these as the &#8220;C++14 wave&#8221; of deliverables.
</p>
<p>The ISO C++ committee has transitioned to a &#8220;decoupled&#8221; model where updated versions of the standard are published more frequently, while at the same time major pieces of work can progress and be published independently from the Standard itself and delivered asynchronously in the form of Technical Specifications (TS&#8217;s) that are separate from the main Standard and can later be incorporated into the Standard. Come to this session to see how this is helping both the standard and C++ compiler implementations near you stay current with the latest in C++.
</p>
<p>The topics covered will be:
</p>
<ul>
<li>C++14: What&#8217;s new in the new standard due this year
</li>
<li>File System TS: Portable file system access
</li>
<li>Library Fundamentals TS (small): string_view and optional&lt;&gt;
</li>
<li>Array Extensions TS: Language and library dynamic arrays
</li>
<li>Concepts Lite TS: Templates + constraints = ++usability and ++diagnostics
</li>
<li>Concurrency TS: Nonblocking futures (.then, .when_*), executors, and (maybe) await
</li>
<li>Parallelism TS: A whole new Parallel STL with both parallel and vector execution support
</li>
<li>One of:<br />    &#8211; Networking TS (small): IP addresses, URIs, byte ordering<br />    &#8211; Transactional Memory TS: Language and library extensions for transactional memory instead of mutexes for many kinds of concurrency control
</li>
</ul>
<p>This session will present an overview of each set of features, what it looks like and how to use it, and why it&#8217;s important for the standard and for your own portable C++ code.
</p>
<p>
 </p>
<h2>Modern C++ Style: Idioms of C++11/14 (1 to 3 hours)<br />
</h2>
<p>This session will cover modern and current C++ style, focusing on C++14. It will demonstrate how major features and idioms from C++98 are now entirely replaced or subsumed and should be used no more; how other major features and idioms have been dramatically improved to the point where your code is cleaner and safer and you&#8217;ll even think in a different style; and how pervasive styles as common as variable declarations are changed forever, and not just for style but for serious technical safety and efficiency benefits. For one thing, you&#8217;ll never look at auto the same way again &#8211; and if hearing that makes you worry, worry not, just attend the session to dig deep into the good reasons for the new reality.
</p>
<p>Why C++14? Two reasons: First, it really does &#8220;complete C++11&#8221; with small but important consistency features like generic lambdas and make_unique that let us teach modern C++ style with fewer &#8220;except for&#8221; footnotes.  Second, C++14 &#8220;is&#8221; C++ for the next several years and it&#8217;s real; it is feature-complete and in the final stages of standardization, and more importantly we are already seeing near-complete conforming implementations becoming widely available around the same time C++14 is expected to be formally published.
</p>
<p>C++14 is a small but important improvement on C++11 that really does complete the language. What this means is that we&#8217;re going to have a complete and simpler set of idioms and styles to learn and use.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/05/20/cppcon-my-proposed-talks-part-1/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Reader Q&#038;A: How can I prevent a type from being instantiated on the stack?</title>
		<link>https://herbsutter.com/2014/05/03/reader-qa-how-can-i-prevent-a-type-from-being-instantiated-on-the-stack/</link>
				<comments>https://herbsutter.com/2014/05/03/reader-qa-how-can-i-prevent-a-type-from-being-instantiated-on-the-stack/#comments</comments>
				<pubDate>Sun, 04 May 2014 03:35:46 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2481</guid>
				<description><![CDATA[Anubhav asked: An interesting question has come up in our project while debating operator new as a class member function. Specifically, the question is about whether such a class should be allowed to be instantiated on stack. The understanding is that a class providing its own operator new would likely have special layout considerations which [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Anubhav asked:
</p>
<blockquote>
<p>An interesting question has come up in our project while debating operator new as a class member function. Specifically, the question is about whether such a class should be allowed to be instantiated on stack. The understanding is that a class providing its own operator new would likely have special layout considerations which would not be met if the object of such a class is instantiated locally.
</p>
</blockquote>
<p>The class specific operator new is used when allocating on the heap, but objects can still be allocated on the stack. The only way I know to prevent an object from being instantiated on the stack is by forcing creation through a factory function that always allocates on the heap, for example:
</p>
<p><pre><code>#include &lt;memory&gt;<br /><br />class X {<br />    // make all ctors private<br />    X();<br />    X(const X&amp;);<br />    // and any other ctors go here<br /><br />public:<br />    // Factory function (or it could be a nonmember friend)<br />    static auto make( /*…*/ ) { return std::unique_ptr&lt;X&gt;(new X( /*…*/ )); }<br /><br />    // the usual public member functions go here<br />};<br /><br />int main()<br />{<br />    X x;                  // error <br />    auto x2 = X::make();  // ok<br />}</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/05/03/reader-qa-how-can-i-prevent-a-type-from-being-instantiated-on-the-stack/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>C++ and Beyond ‘Encore’ in 2014: Sep 29 – Oct 1, Stuttgart, Germany</title>
		<link>https://herbsutter.com/2014/04/07/c-and-beyond-encore-in-2014-sep-29-oct-1-stuttgart-germany/</link>
				<comments>https://herbsutter.com/2014/04/07/c-and-beyond-encore-in-2014-sep-29-oct-1-stuttgart-germany/#comments</comments>
				<pubDate>Mon, 07 Apr 2014 16:46:17 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Talks & Events]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2478</guid>
				<description><![CDATA[A lot of you have been asking me whether there will be some sort of C++ and Beyond in 2014. Also, over the past few years many of you have also asked me if there will ever be a C&#38;B outside North America. I&#8217;m pleased to report that we are doing a &#8216;European Encore&#8217; event [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>A lot of you have been asking me whether there will be some sort of <em>C++ and Beyond</em> in 2014. Also, over the past few years many of you have also asked me if there will ever be a C&amp;B outside North America. I&#8217;m pleased to report that we are doing a &#8216;European Encore&#8217; event reprising previous C&amp;B material.
</p>
<p>Today on the C&amp;B blog, Scott announced that yes, <a href="http://cppandbeyond.com/2014/04/07/cb-2014-september-29-october-1-in-stuttgart/">there will be a &#8220;<em>C++ and Beyond</em> Road Show&#8221; in 2014… in Germany!</a> Note that this is different from previous C&amp;B&#8217;s because the purpose is to largely repeat the C&amp;B 2013 program at an event in Europe, in order to make it accessible to people who were not able to fly to North America for previous C&amp;Bs. So think of it as a &#8220;C&amp;B Encore&#8221; or &#8220;C&amp;B Greatest Hits Roadshow Edition.&#8221;
</p>
<p>From the announcement:
</p>
<blockquote>
<p>You can think of this event as the C&amp;B Road Show, because the organization is a little different from how we&#8217;ve done things in the past:
</p>
<blockquote>
<ul>
<li><strong>Most of the talks will be updated versions of the presentations we gave at C&amp;B 2013.</strong> (See the schedule <a href="http://www.qa-systems.de/akademie/einzelansicht.html?tuid=63">here</a>.) If you were unable to attend C&amp;B this past December, this is your chance to see what you missed.
</li>
<li><strong>A group dinner on the first day is included.</strong>
				</li>
<li><strong>The schedule is a bit compressed</strong>, so some aspects of previous C&amp;Bs are not present. These include group breakfasts and evening discussion sessions.
</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p>For this event, we&#8217;ve partnered with<a href="http://www.qa-systems.de/"> QA Systems</a>, the same company I&#8217;ve worked with since 1999 on technical seminars in Europe. They&#8217;ll be handling registration and all other logistical and administrative aspects of the event. Consult their <a href="http://www.qa-systems.de/akademie/einzelansicht.html?tuid=63"><strong>web page for C&amp;B 2014</strong></a> for all the details of this event.
</p>
</blockquote>
<blockquote>
<p>This will be the only C&amp;B in 2014, so we hope to see you in Stuttgart at the end of September for the first-ever C&amp;B in Europe!
</p>
</blockquote>
<p>For those of you who have attended C&amp;B before and others who&#8217;ve been asking me whether there will be a &#8220;regular&#8221; <em>C++ and Beyond</em> in North America this year with new material, the answer is not this year; we don&#8217;t do a new one every year, and we&#8217;re skipping this year. If you are looking for a C++ event in North America with new material, do check out <a href="cppcon.org">CppCon on September 7-12 in the Seattle area</a> – I am currently planning to create some new talks for CppCon, as well as to repeat some of my C&amp;B talks there. I hear tell that Scott and Andrei might be there too, as well as dozens and dozens of our closest speaker friends.
</p>
<p>I&#8217;m looking forward to seeing many of you at C&amp;B Europe and CppCon this fall!</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/04/07/c-and-beyond-encore-in-2014-sep-29-oct-1-stuttgart-germany/feed/</wfw:commentRss>
		<slash:comments>7</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Yesterday’s Build talk is now online</title>
		<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/</link>
				<comments>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comments</comments>
				<pubDate>Fri, 04 Apr 2014 16:45:22 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Microsoft]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2474</guid>
				<description><![CDATA[That was fast!]]></description>
								<content:encoded><![CDATA[<p>That was fast!
</p>
<p><a href="http://channel9.msdn.com/Events/Build/2014/2-661"><img src="https://herbsutter.files.wordpress.com/2014/04/040414_1646_yesterdaysb1.png?w=500" alt="" border="0" /></a></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/feed/</wfw:commentRss>
		<slash:comments>9</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/04/040414_1646_yesterdaysb1.png" medium="image" />
	</item>
		<item>
		<title>Build talk tomorrow: Modern C++ — What you need to know</title>
		<link>https://herbsutter.com/2014/04/02/build-talk-tomorrow-modern-c-what-you-need-to-know/</link>
				<comments>https://herbsutter.com/2014/04/02/build-talk-tomorrow-modern-c-what-you-need-to-know/#comments</comments>
				<pubDate>Wed, 02 Apr 2014 20:44:20 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Microsoft]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2466</guid>
				<description><![CDATA[If you&#8217;re at Build in San Francisco tomorrow afternoon, I invite you to swing by and spend an hour with us in session 2-661: Modern C++: What you need to know by Herb Sutter Build 2014, Room 20052:30-3:30 pm, Thursday April 3, 2014 If you&#8217;re new to C++, this talk is aimed directly at you. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>If you&#8217;re at Build in San Francisco tomorrow afternoon, I invite you to swing by and spend an hour with us in session 2-661:
</p>
<blockquote>
<p><a href="http://channel9.msdn.com/Events/Build/2014/2-661"><strong>Modern C++: What you need to know</strong></a><strong></p>
<p></strong>by Herb Sutter</p>
<p>Build 2014, Room 2005<br />2:30-3:30 pm, Thursday April 3, 2014
</p>
</blockquote>
<p>If you&#8217;re new to C++, this talk is aimed directly at you. I was asked to give a &#8220;foundational talk&#8221; about C++, and I decided that meant I should focus on addressing two questions that I get a lot these days:
</p>
<ul>
<li>FAQ #1 (1-2 slides): When should I use C++ compared to another language – on all platforms in general, and on Microsoft platforms in particular?
</li>
<li><strong>FAQ #2 (lots of slides): What should I know about C++ if I&#8217;m a {Java|C#|JavaScript|Python|…} developer?<br />
</strong></li>
</ul>
<p>Even if you&#8217;re a seasoned C++ developer, there are some nuggets and data points in the middle of the talk that I think you will find useful in your own work, and I hope that the talk as a whole will be helpful to you in providing a way to explain C++&#8217;s value proposition and give (or link to) an answer when someone asks <em>you</em> FAQ #2.
</p>
<p>I think it will be recorded, and will post a link here when the recording is available.
</p>
<p>I look forward to seeing many of you there tomorrow afternoon.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/04/02/build-talk-tomorrow-modern-c-what-you-need-to-know/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>CppCon 2014 Call for Submissions</title>
		<link>https://herbsutter.com/2014/03/25/cppcon-2014-call-for-submissions/</link>
				<pubDate>Tue, 25 Mar 2014 14:05:40 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2460</guid>
				<description><![CDATA[More news about the first annual CppCon that was announced last week: CppCon 2014 Call for Submissions CppCon is the annual, week-long face-to-face gathering for the entire C++ community. The conference is organized by the C++ community for the community and so we invite you to present. Have you learned something interesting about C++, maybe a new technique [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><img align="right" src="https://herbsutter.files.wordpress.com/2014/03/032514_1406_cppcon2014c11.png?w=500" alt="" />More news about the first annual CppCon that was announced last week:
</p>
<blockquote>
<p><a href="http://cppcon.org/call-for-submissions-2014/"><span style="color:#00a0cc;font-size:16pt;text-decoration:underline;">CppCon 2014 Call for Submissions</span></a><span style="font-size:16pt;"><br />
			</span></p>
</blockquote>
<blockquote>
<p><span style="font-size:12pt;">CppCon is the annual, week-long face-to-face gathering for the <em>entire</em> C++ community. The conference is organized by the C++ community for the community and so we invite you to present.<br />
</span></p>
</blockquote>
<blockquote>
<p><span style="font-size:12pt;">Have you learned something interesting about C++, maybe a new technique possible in C++11? Or perhaps you have implemented something cool related to C++, maybe a new C++ library? If so, consider sharing it with other C++ enthusiasts by giving a talk at CppCon 2014. Submissions deadline is May 15 with decisions sent by June 13. For topic ideas, possible formats, and submission instructions, see the <a href="http://cppcon.org/submissions/" title="Submissions"><span style="color:#00a0cc;text-decoration:underline;">Submissions</span></a> page.<br />
</span></p>
</blockquote>
<p>Note that speakers get free registration to attend the whole conference.
</p>
<p>I strongly encourage you to present – not &#8220;even if&#8221; you&#8217;ve never presented before, but &#8220;especially if&#8221; you haven&#8217;t. At 5 days x ~5 tracks x ~6 full-length talks per day, this is a big conference with a lot of room for half-length (30 min), full-length (60 min) and multi-hour formal talks (this is in addition to Lightning Talks, which will be arranged later).
</p>
<p>For an idea of talks, from the Submissions page:
</p>
<blockquote>
<p>We are open to any topic that will be of interest to a mainstream C++ audience. Below are some ideas.
</p>
<blockquote>
<ul>
<li>C++11
</li>
<li>C++ libraries and frameworks of general interest
</li>
<li>C++14 and new standardization proposals
</li>
<li>Parallelism/multi-processing
</li>
<li>Concepts and generic programming
</li>
<li>Functional programming
</li>
<li>High performance computing
</li>
<li>Software development tools, techniques, and processes for C++
</li>
<li>Practical experiences using C++ in real-world applications
</li>
<li>Industry-specific perspectives: mobile and embedded systems, game development, high performance trading, scientific programming, robotics, etc.
</li>
</ul>
</blockquote>
</blockquote>
<p>I know a number of people who are already planning to submit talks, and I am certain we will get talks on all these topics, and likely more.
</p>
<p>As for me, I&#8217;m going to go propose a talk on lock-free programming now… everyone should have fun with lock-free mail slots and linked lists, and know when to worry about the ABA problem (and know how to solve it in portable C++11 code).
</p>
<h3>What should you do next?<br />
</h3>
<p>If you have a talk idea, <a href="http://cppcon.org/submissions/">run don&#8217;t walk to submit a talk</a> – but <em>don&#8217;t register</em> for the conference yet as you will get free registration for the conference if your talk is accepted.
</p>
<p>Otherwise, <a href="http://cppcon2014.eventbrite.com/">register today</a>! The first 100 to register get the Super Early Bird rate of $695 for the whole conference, and registration got off to a strong start since it opened last week – a good number of first-100 places are still available. This is the coolest and most informative event for C++ in nearly 20 years, and whether you&#8217;re a C++ novice or an expert you are going to have a great time and learn a lot of practical information and skills you can use on your project today.</p>
]]></content:encoded>
									
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/03/032514_1406_cppcon2014c11.png" medium="image" />
	</item>
		<item>
		<title>We have CppCon…</title>
		<link>https://herbsutter.com/2014/03/18/we-have-cppcon/</link>
				<comments>https://herbsutter.com/2014/03/18/we-have-cppcon/#comments</comments>
				<pubDate>Tue, 18 Mar 2014 16:21:28 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2445</guid>
				<description><![CDATA[I&#8217;m really excited about this event! Note that the first 100 registrations get a big discount – pasting from the &#8220;registration&#8221; page: Regular registration fee is $995 but the first 100 attendees can take advantage of Super Early Bird registration and pay only $695. After that, the Early Bird registration fee is $845 and is [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><a href="cppcon.org"><img align="right" src="https://herbsutter.files.wordpress.com/2014/03/031814_1624_wehavecppco1.png?w=500" alt="" border="0" /></a>I&#8217;m really excited about this event!
</p>
<p>Note that the first 100 registrations get a big discount – pasting from the <a href="http://cppcon.org/registration/">&#8220;registration&#8221;</a> page:
</p>
<blockquote>
<p>Regular registration fee is $995 but the first 100 attendees can take advantage of Super Early Bird registration and pay only $695. After that, the Early Bird registration fee is $845 and is valid until the 1st of June. …
</p>
</blockquote>
<p>The announcement went live four hours ago, and the first registrations have already started to come in.
</p>
<p>The full text of today&#8217;s announcement follows:
</p>
<p>
 </p>
<p><a href="http://cppcon.org/registration-open-2014/"><span style="color:#00a0cc;font-size:24pt;text-decoration:underline;"><strong>CppCon 2014 Registration Open</strong></span></a><span style="color:#00171d;font-size:24pt;"><strong><br />
			</strong></span></p>
<p><span style="color:#3366ff;font-size:16pt;"><strong>Opening Keynote by Bjarne Stroustrup<br />September 7–12, 2014<br />Bellevue, Washington, USA<span style="color:#00171d;"><br />
				</span></strong></span></p>
<p style="text-align:justify;"><a href="http://cppcon.wpengine.com/registration/" title="Registration"><span style="color:#00a0cc;font-size:12pt;text-decoration:underline;">Registration is now open</span></a><span style="color:#00171d;font-size:12pt;"> for CppCon 2014 to be held September 7–12, 2014 at the Meydenbauer Center in Bellevue, Washington, USA. The conference will start with the keynote by Bjarne Stroustrup titled &#8220;<a href="http://cppcon.org/keynotes/" title="Keynotes"><span style="color:#00a0cc;text-decoration:underline;">Make Simple Tasks Simple!</span></a>&#8221;<br />
</span></p>
<p style="text-align:justify;"><span style="color:#00171d;font-size:12pt;">CppCon is the annual, week-long face-to-face gathering for the <em>entire</em> C++ community. The conference is organized by the C++ community for the community. You will enjoy inspirational talks and a friendly atmosphere designed to help attendees learn from each other, meet interesting people, and generally have a stimulating experience. Taking place this year in the beautiful Seattle neighborhood and including multiple diverse tracks, the conference will appeal to anyone from C++ novices to experts.<br />
</span></p>
<p style="text-align:center;"><img src="https://herbsutter.files.wordpress.com/2014/03/031814_1624_wehavecppco2.jpg?w=500" alt="" /><span style="color:#00171d;font-size:12pt;"><br />
		</span></p>
<p><span style="color:#00171d;font-size:16pt;"><strong>What you can expect at CppCon:<br />
</strong></span></p>
<ul>
<li>
<div style="text-align:justify;"><span style="color:#00171d;font-size:12pt;"><strong>Invited talks and panels</strong>: the CppCon keynote by Bjarne Stroustrup will start off a week full of insight from some of the world&#8217;s leading experts in C++. Still have questions? Ask them at one of CppCon&#8217;s panels featuring those at the cutting edge of the language.<br />
</span></div>
</li>
<li>
<div style="text-align:justify;"><span style="color:#00171d;font-size:12pt;"><strong>Presentations by the C++ community</strong>: What do embedded systems, game development, high frequency trading, and particle accelerators have in common? C++, of course! Expect talks from a broad range of domains experts focused on practical C++ techniques, libraries, and tools.<br />
</span></div>
</li>
<li>
<div style="text-align:justify;"><span style="color:#00171d;font-size:12pt;"><strong>Lightning talks</strong>: Get informed at a fast pace during special sessions of short, less formal talks. Never presented at a conference before? This is your chance to share your thoughts on a C++-related topic in an informal setting.<br />
</span></div>
</li>
<li><span style="color:#00171d;font-size:12pt;"><strong>Evening events and &#8220;unconference&#8221; time</strong>: Relax, socialize, or start an impromptu coding session.<br />
</span></li>
</ul>
<p style="text-align:justify;"><span style="color:#00171d;font-size:12pt;">CppCon&#8217;s goal is to encourage the best use of C++ while preserving the diversity of viewpoints and experiences, but other than that it is non-partisan and has no agenda. The conference is a project of the <a href="http://isocpp.org/about"><span style="color:#00a0cc;text-decoration:underline;">Standard C++ Foundation</span></a>, a not-for-profit organization whose purpose is to support the C++ software developer community and promote the understanding and use of modern, standard C++ on all compilers and platforms.<br />
</span></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/03/18/we-have-cppcon/feed/</wfw:commentRss>
		<slash:comments>8</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/03/031814_1624_wehavecppco1.png" medium="image" />

		<media:content url="https://herbsutter.files.wordpress.com/2014/03/031814_1624_wehavecppco2.jpg" medium="image" />
	</item>
		<item>
		<title>S&#038;S Postscript</title>
		<link>https://herbsutter.com/2014/03/17/ss-postscript/</link>
				<comments>https://herbsutter.com/2014/03/17/ss-postscript/#comments</comments>
				<pubDate>Mon, 17 Mar 2014 16:31:18 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2441</guid>
				<description><![CDATA[PS on the previous post regarding Stroustrup &#38; Sutter: I had asked the organizers whether it would be possible to get a piano in the room. I just learned a few minutes ago that they will be able to arrange a baby grand. Sweet! This is going to be fun…]]></description>
								<content:encoded><![CDATA[<p><img align="right" src="https://herbsutter.files.wordpress.com/2014/03/031714_1631_sspostscrip1.jpg?w=500" alt="" />PS on the <a href="https://herbsutter.com/2014/03/17/stroustrup-sutter-on-c-mar-31-apr-1-san-jose-ca/">previous post</a> regarding Stroustrup &amp; Sutter:
</p>
<p>I had asked the organizers whether it would be possible to get a piano in the room.
</p>
<p>I just learned a few minutes ago that they will be able to arrange a baby grand. Sweet!
</p>
<p>This is going to be fun…</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/03/17/ss-postscript/feed/</wfw:commentRss>
		<slash:comments>4</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/03/031714_1631_sspostscrip1.jpg" medium="image" />
	</item>
		<item>
		<title>Stroustrup &#038; Sutter on C++: Mar 31 – Apr 1, San Jose, CA</title>
		<link>https://herbsutter.com/2014/03/17/stroustrup-sutter-on-c-mar-31-apr-1-san-jose-ca/</link>
				<comments>https://herbsutter.com/2014/03/17/stroustrup-sutter-on-c-mar-31-apr-1-san-jose-ca/#comments</comments>
				<pubDate>Mon, 17 Mar 2014 16:23:30 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2434</guid>
				<description><![CDATA[It has occurred to me that I never announced this event here… In two weeks, Bjarne and I will be doing a two-day Stroustrup &#38; Sutter on C++ seminar in the San Francisco Bay area. It has been several years since the last S&#38;S event, so Bjarne and I are really looking forward to this. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><img align="right" src="https://herbsutter.files.wordpress.com/2014/03/031714_1624_stroustrups1.png?w=500" alt="" />It has occurred to me that I never announced this event here…
</p>
<p>In two weeks, Bjarne and I will be doing a <a href="http://isocpp.org/blog/2014/03/stroustrup-sutter2">two-day <strong>Stroustrup &amp; Sutter on C++</strong> seminar in the San Francisco Bay area</a>. It has been several years since the last S&amp;S event, so Bjarne and I are really looking forward to this.
</p>
<blockquote>
<p><a href="http://www.eeliveshow.com/sanjose/conference/super-c-tutorial.php"><span style="font-size:14pt;"><strong>Super C++ Tutorial: Stroustrup &amp; Sutter on C++</strong></span></a><span style="font-size:14pt;"><strong><br /></strong></span><br />EE Live!<br />March 31 &#8211; April 1, 2014<br />McEnery Convention Center<br />San Jose, CA, USA</p>
<p><a href="http://www.eeliveshow.com/sanjose/registration/?_mc=EELHOMEPAGE">Registration</a>
		</p>
</blockquote>
<p>The organizers have kindly made sure they can expand the room, so <a href="http://isocpp.org/blog/2014/03/stroustrup-sutter2">seats are still available</a>. Sorry for the short notice here on this blog.
</p>
<h2>Using C++ atomics: Lock-Free Algorithms and Data Structures in C++<br />
</h2>
<p>Here&#8217;s one interesting content update: The sessions page lists our talks, including a talk by me with the title <strong>&#8220;Three Cool Things in C++ Concurrency,&#8221;</strong> which is pronounced &#8220;I hadn&#8217;t decided what exactly I wanted to talk about by the time I had to submit the session description.&#8221;
</p>
<p>I have now decided, and the talk will be entirely on <strong>how to design and write lock-free algorithms and data structures using C++ atomic&lt;&gt;</strong> – something that can look deceptively simple, but contains very deep topics. (Important note: This is <em>not</em> the same as my &#8220;atomic&lt;&gt; Weapons&#8221; talk; that talk was about the &#8220;what they are and why&#8221; of the C++ memory model and atomics, and did not cover how to actually use atomics to implement highly concurrent algorithms and data structures.)
</p>
<p>This talk is about the &#8220;how to use them successfully&#8221; part of atomics, including:
</p>
<ul>
<li>Best practices and style for using atomic&lt;&gt;s
</li>
<li>Three examples, including lock-free mail slots and iterations of a lock-free linked list, all in portable Standard C++
</li>
<li>Defining and applying the different levels of &#8220;lock-freedom&#8221; (wait-free, lock-free, obstruction-free) to develop highly concurrent algorithms and data structures
</li>
<li>Explaining and applying key concepts including especially: linearizability; trading off concurrency vs. promptness; and trading off concurrency vs. throughput/utilization
</li>
<li>Demonstrating and solving the ABA problem, with clean and simple code – that&#8217;s right, did you know that in C++11 you can solve this without relying on esoterica like double-wide CAS (which isn&#8217;t always available) or hazard pointers (which are deeply complex) or garbage collection (which isn&#8217;t in the C++ standard… yet)?
</li>
</ul>
<p>A few of you may have seen part of this material in the few times I&#8217;ve taught the extended four-day version of my Effective Concurrency course. This version of the material is <strong>significantly updated for C++11/14</strong> and also contains <strong>new material never before seen</strong> even if you did take in the four-day EC course – including that instead of leaving the slist example as a cliffhanger, I present an actual complete solution for the slist example that is (a) correct and (b) can be entirely written using portable Standard C++11. It&#8217;s always nice to end with a solution you can actually use, instead of just an open problem cliffhanger…
</p>
<p>I&#8217;m looking forward to seeing many of you in San Jose in two weeks!</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/03/17/stroustrup-sutter-on-c-mar-31-apr-1-san-jose-ca/feed/</wfw:commentRss>
		<slash:comments>6</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/03/031714_1624_stroustrups1.png" medium="image" />
	</item>
		<item>
		<title>Reader Q&#038;A: Is std::atomic_compare_exchange_* implementable?</title>
		<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/</link>
				<comments>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comments</comments>
				<pubDate>Wed, 19 Feb 2014 18:31:51 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2429</guid>
				<description><![CDATA[Updated 8/26: Duncan&#8217;s question is actually correct and compare_exchange should have the semantics he asks for. However, the answer to &#8216;is it implementable&#8217; is I think still Yes. Quick answer: Yes. I see there was also a thread about this on StackOverflow, so I&#8217;ll echo this Q&#38;A publicly for others&#8217; benefit and hopefully to dispel [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><em><strong>Updated 8/26:</strong> Duncan&#8217;s question is actually correct and compare_exchange should have the semantics he asks for. However, the answer to &#8216;is it implementable&#8217; is I think still Yes.</em></p>
<p>Quick answer: Yes.</p>
<p>I see there was also a thread about this on StackOverflow, so I&#8217;ll echo this Q&amp;A publicly for others&#8217; benefit and hopefully to dispel confusion.</p>
<p>Duncan Forster asked:</p>
<blockquote><p>I&#8217;m quite alarmed the C++ committee chose such a bad interface for std::atomic compare_exchange, i.e.:</p>
<p><span style="font-family:Courier New;font-size:10pt;">    bool compare_exchange_???(T&amp; expected, T desired, &#8230;);<br />
</span><br />
I notice you have mentioned (here <a href="https://herbsutter.com/2012/08/31/reader-qa-how-to-write-a-cas-loop-using-stdatomics/">reader-qa-how-to-write-a-cas-loop-using-stdatomics</a>) that the committee had doubts whether it was a good idea.<br />
Your quote below:</p>
<blockquote>
<ul>
<li><em>Usage note: In the code at top we save an explicit reload from &#8216;a&#8217; in the loop because compare_exchange helpfully (or &#8220;helpfully&#8221; – this took me a while to discover and remember) stores the actual value in the &#8216;expected&#8217; value slot on failure. This actually makes loops simpler, though some of us are still have different feelings on different days about whether this subtlety was a good idea… anyway, it&#8217;s in the standard.<br />
</em></li>
</ul>
</blockquote>
</blockquote>
<blockquote><p>The reason I think it&#8217;s not only bad but also dangerous is that we now have a race condition baked into the standard. Race condition you say? All hardware CAS implementations that I know of only return 1 value (the old value). Yet the C++ version has 2 returns (success/failure as a boolean return and the old value by reference). So how can an atomic class which is suppose to implement atomic methods do this? Answer is it can&#8217;t, the boolean result is calculated after the atomic exchange has occurred. That leaves us with a method which is only partially atomic and with the bonus of a built-in race condition!</p>
<p>Perhaps I haven&#8217;t convinced you, so here&#8217;s some code to help. I have simulated the hardware CAS with simple C++ code to help demonstrate the problem. The crux of the problem is this statement: <span style="font-family:Courier New;font-size:10pt;">while(!atomic_bool_compare_and_swap(&amp;head, new_node-&gt;next, new_node))</span><br />
By creating a 1-line while loop and passing <span style="font-family:Courier New;font-size:10pt;">new_node-&gt;next</span> as the expected value, if someone is also consuming data the new_node will temporarily be visible by 2 threads. The other thread may process and delete the node before <span style="font-family:Courier New;font-size:10pt;">atomic_bool_compare_and_swap</span> has calculated success/failure. This would result in a spurious failure and the new_node actually being pushed twice onto the queue. As you can image this should lead to double delete and possibly the process aborting.</p></blockquote>
<blockquote><p>template&lt;typename _T&gt;<br />
bool atomic_bool_compare_and_swap(_T *value, _T&amp; expected, _T new_value)<br />
{<br />
_T old_value;</p>
<p>// Here be atomic<br />
{<br />
old_value = *value;<br />
if(old_value == expected)<br />
*value = new_value;<br />
}</p>
<p>// Here be race conditions<br />
return (old_value == expected);<br />
}</p>
<p>[&#8230; more code that exercises this function &#8230;]</p></blockquote>
<p>I don&#8217;t believe there is an implementability bug in the standard. <em><del>Rather, your code is incorrect.</del></em></p>
<p><em>[Update: &#8230;off-point stuff omitted&#8230;]</em></p>
<p>Let&#8217;s say you have a CAS that returns only the old value, but doesn&#8217;t set &#8220;expected,&#8221; as you describe below. Then you should just be able to implement the standard one in terms of that – quick sketch (untested code):</p>
<pre><code>    template&lt;typename _T&gt;
    bool atomic_compare_exchange(_T *value, _T&amp; expected, _T new_value)
    {
        _T old_value;
        <strong>_T old_expected = expected;</strong>

        // If all you have is a CAS that returns the old value, use that:
        old_value = CAS(value, expected, new_value);

        bool result = old_value == <strong>old_</strong>expected;
        expected = old_value;
        return result;
    }
</code></pre>
<p>Now that there&#8217;s no use of &#8220;expected&#8221; after the CAS and so no timing window.</p>
<p>If I&#8217;m misunderstanding the question, or have a bug in my thinking, please let me know in the comments. <em>[Update: Thanks to Duncan in particular for pointing out my original answer did have a bug in my thinking.]</em></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/feed/</wfw:commentRss>
		<slash:comments>23</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Trip report: Winter ISO C++ meeting</title>
		<link>https://herbsutter.com/2014/02/17/trip-report-winter-iso-c-meeting/</link>
				<comments>https://herbsutter.com/2014/02/17/trip-report-winter-iso-c-meeting/#comments</comments>
				<pubDate>Tue, 18 Feb 2014 00:52:43 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2425</guid>
				<description><![CDATA[I just posted my trip report from last week&#8217;s ISO C++ meeting over on isocpp.org. The meeting just wrapped up about 48 hours ago, on Saturday afternoon. This is a real milestone for C++. Not only did we finish C++14 (we think, assuming this coming ballot comes back clean so that we can skip the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I just <a href="http://isocpp.org/blog/2014/02/trip-report">posted my trip report</a> from last week&#8217;s ISO C++ meeting over on <em>isocpp.org</em>. The meeting just wrapped up about 48 hours ago, on Saturday afternoon.
</p>
<p>This is a real milestone for C++. Not only did we finish C++14 (we think, assuming this coming ballot comes back clean so that we can skip the final extra ballot step), but we made strong progress on all seven (7) of the Technical Specifications in flight… and approved starting an eighth (8<sup>th</sup>)!
</p>
<p>Good times.
</p>
<p>Thanks, everyone who worked so hard to make this happen.
</p>
<p style="text-align:center;"><a href="http://isocpp.org/blog/2014/02/trip-report"><img src="https://herbsutter.files.wordpress.com/2014/02/021814_0053_tripreportw1.png?w=500" alt="" border="0" /></a></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/02/17/trip-report-winter-iso-c-meeting/feed/</wfw:commentRss>
		<slash:comments>2</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>

		<media:content url="https://herbsutter.files.wordpress.com/2014/02/021814_0053_tripreportw1.png" medium="image" />
	</item>
		<item>
		<title>GotW #96: Oversharing</title>
		<link>https://herbsutter.com/2014/01/14/gotw-96-oversharing/</link>
				<comments>https://herbsutter.com/2014/01/14/gotw-96-oversharing/#comments</comments>
				<pubDate>Tue, 14 Jan 2014 16:55:10 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2414</guid>
				<description><![CDATA[Following on from #95, let&#8217;s consider reasons and methods to avoid mutable sharing in the first place…   Problem Consider the following code from GotW #95&#8217;s solution, where some_obj is a shared variable visible to multiple threads which then synchronize access to it. // thread 1{ lock_guard hold(mut_some_obj); // acquire lock code_that_reads_from( some_obj ); // [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Following on from #95, let&#8217;s consider reasons and methods to avoid mutable sharing in the first place…<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<p>Consider the following code from GotW #95&#8217;s solution, where <span style="color:#2e74b5;">some_obj</span> is a shared variable visible to multiple threads which then synchronize access to it.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br />}<br /><br />// thread 2<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_modifies( some_obj );    // passes some_obj by non-const &amp;<br />}
</code></pre>
</p>
<p>
 </p>
<h2>JG Questions<br />
</h2>
<p>1. Why do mutable shared variables like <span style="color:#2e74b5;">some_obj</span> make your code:
</p>
<p style="margin-left:36pt;">(a) more complex?
</p>
<p style="margin-left:36pt;">(b) more brittle?
</p>
<p style="margin-left:36pt;">(c) less scalable?
</p>
<p>
 </p>
<h2>Guru Questions<br />
</h2>
<p>2. Give an example of how the code that uses a mutable shared variable like <span style="color:#2e74b5;">some_obj</span> can be changed so that the variable is:
</p>
<p style="margin-left:36pt;">(a) <em>not shared</em>.
</p>
<p style="margin-left:36pt;">(b) <em>not mutable</em>.
</p>
<p>3. Let&#8217;s say we&#8217;re in a situation where we can&#8217;t apply the techniques from the answers to #2, so that the variable itself must remain shared and apparently mutable. Is there any way that the <em>internal implementation</em> of the variable can make the variable be <em>physically </em>not shared and/or not mutable, so that the calling code can treat it as a logically shared-and-mutable object yet not need to perform external synchronization? If so, explain. If not, why not?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/14/gotw-96-oversharing/feed/</wfw:commentRss>
		<slash:comments>16</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #95 Solution: Thread Safety and Synchronization</title>
		<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/</link>
				<comments>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comments</comments>
				<pubDate>Mon, 13 Jan 2014 19:00:16 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2411</guid>
				<description><![CDATA[This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.   Problem JG Questions 1. What is a race condition, and how serious [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is a race condition, and how serious is it?
</p>
<p>2. What is a correctly synchronized program? How do you achieve it? Be specific.
</p>
<p>
 </p>
<h2>Guru Questions<br />
</h2>
<p>3. Consider the following code, where <span style="color:#2e74b5;">some_obj</span> is a shared variable visible to multiple threads.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1 (performs no additional synchronization)<br />code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br /><br />// thread 2 (performs no additional synchronization)<br />code_that_modifies( some_obj );    // passes some_obj by non-const &amp;
</code></pre>
</p>
<p>If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of <span style="color:#2e74b5;">some_obj</span> is:
</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">int</span>?
</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">string</span>?
</p>
<p style="margin-left:36pt;">(c) <span style="color:#2e74b5;">vector&lt;map&lt;int,string&gt;&gt;</span>?
</p>
<p style="margin-left:36pt;">(d) <span style="color:#2e74b5;">shared_ptr&lt;widget&gt;</span>?
</p>
<p style="margin-left:36pt;">(e) <span style="color:#2e74b5;">mutex</span>?
</p>
<p style="margin-left:36pt;">(f) <span style="color:#2e74b5;">condition_variable</span>?
</p>
<p style="margin-left:36pt;">(g) <span style="color:#2e74b5;">atomic&lt;unsigned&gt;</span>?<span style="color:#2e74b5;"><br />
		</span></p>
<p>Hint: This is actually a two-part question, not a seven-part question. There are only two unique answers, each of which covers a subset of the cases.
</p>
<p>4. <em>External synchronization</em> means that the code that uses/owns a given shared object is responsible for performing synchronization on that object. Answer the following questions related to external synchronization:
</p>
<p style="margin-left:36pt;">(a) What is the normal external synchronization responsibility of code that owns and uses a given shared variable?
</p>
<p style="margin-left:36pt;">(b) What is the &#8220;basic thread safety guarantee&#8221; that all types must obey to enable calling code to perform normal external synchronization?
</p>
<p style="margin-left:36pt;">(c) What partial internal synchronization can still be required within the shared variable&#8217;s implementation?
</p>
<p>5. <em>Full internal synchronization</em> (a.k.a. &#8220;synchronized types&#8221; or &#8220;thread-safe types&#8221;) means that a shared object performs all necessary synchronization internally within that object, so that calling code does not need to perform any external synchronization. What types should be fully internally synchronized, and why?
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>Preface<br />
</h2>
<p>The discussion in this GotW applies not only to C++ but also to any mainstream language, except mainly that certain races have defined behavior in C# and Java. But the definition of what variables need to be synchronized, the tools we use to synchronize them, and the distinction between external and internal synchronization and when you use each one, are the same in all mainstream languages. If you&#8217;re a C# or Java programmer, everything here applies equally to you, with some minor renaming such as to rename C++ <span style="color:#2e74b5;">atomic</span> to C#/Java <span style="color:#2e74b5;">volatile</span>, although some concepts are harder to express in C#/Java (such as identifying the read-only methods on an otherwise mutable shared object; there are <span style="color:#2e74b5;">readonly</span> fields and &#8220;read-only&#8221; properties that have <span style="color:#2e74b5;">get</span> but not <span style="color:#2e74b5;">set</span>, but they express a subset of what you can express using C++ <span style="color:#2e74b5;">const</span> on member functions).
</p>
<p>Note: C++ <span style="color:#2e74b5;">volatile</span> variables (which have no analog in languages like C# and Java) are always beyond the scope of this and any other article about the memory model and synchronization. That&#8217;s because C++ <span style="color:#2e74b5;">volatile</span> variables aren&#8217;t about threads or communication at all and don&#8217;t interact with those things. Rather, a C++ <span style="color:#2e74b5;">volatile</span> variable should be viewed as portal into a different universe beyond the language — a memory location that by definition does not obey the language&#8217;s memory model because that memory location is accessed by hardware (e.g., written to by a daughter card), have more than one address, or is otherwise &#8220;strange&#8221; and beyond the language. So C++ <span style="color:#2e74b5;">volatile</span> variables are universally an exception to every guideline about synchronization because are always inherently &#8220;racy&#8221; and unsynchronizable using the normal tools  (mutexes, atomics, etc.) and more generally exist outside all normal of the language and compiler including that they generally cannot be optimized by the compiler (because the compiler isn&#8217;t allowed to know their semantics; a <span style="color:#2e74b5;">volatile int vi;</span> may not behave anything like a normal <span style="color:#2e74b5;">int</span>, and you can&#8217;t even assume that code like <span style="color:#2e74b5;">vi = 5; int read_back = vi;</span> is guaranteed to result in <span style="color:#2e74b5;">read_back == 5</span>, or that code like <span style="color:#2e74b5;">int i = vi; int j = vi;</span> that reads <span style="color:#2e74b5;">vi</span> twice will result in <span style="color:#2e74b5;">i == j</span> which will not be true if <span style="color:#2e74b5;">vi</span> is a hardware counter for example). For more discussion, see my article <a href="http://www.drdobbs.com/parallel/volatile-vs-volatile/212701484">&#8220;volatile vs. volatile.&#8221;</a>
	</p>
<p>
 </p>
<h2>1. What is a race condition, and how serious is it?<br />
</h2>
<p>A <em>race condition</em> occurs when two threads access the same shared variable concurrently, and at least one is a non-<span style="color:#2e74b5;">const</span> operation (writer). Concurrent <span style="color:#2e74b5;">const</span> operations are valid, and do not race with each other.
</p>
<p>Consecutive nonzero-length bitfields count as a single variable for the purpose of defining what a race condition is.
</p>
<p>Terminology note: Some people use &#8220;race&#8221; in a different sense, where in a program with no actual race conditions (as defined above) still operations on different threads could interleave in different orders in different executions of a correctly-synchronized program depending on how fast threads happen to execute relative to each other. That&#8217;s not a race condition in the sense we mean here—a better term for that might be &#8220;timing-dependent code.&#8221;
</p>
<p>If a race condition occurs, your program has <em>undefined behavior</em>. C++ does not recognize any so-called &#8220;benign races&#8221;—and in languages that have recognized some races as &#8220;benign&#8221; the community has gradually learned over time that many of them actually, well, aren&#8217;t.
</p>
<blockquote>
<p><strong>Guideline:</strong> Reads (<strong>const</strong> operations) on a shared object are safe to run concurrently with each other without synchronization.
</p>
</blockquote>
<p>
 </p>
<h2>2. What is a correctly synchronized program? How do you achieve it? Be specific.<br />
</h2>
<p>A correctly synchronized program is one that contains no race conditions. You achieve it by making sure that, for every shared variable, every thread that performs a write (non-<span style="color:#2e74b5;">const</span> operation) on that variable is synchronized so that no other reads or writes of that variable on other threads can run concurrently with that write.
</p>
<p>The shared variable usually protected by:
</p>
<ul>
<li>(commonly) using a <span style="color:#2e74b5;">mutex</span> or equivalent;
</li>
<li>(very rarely) by making it <span style="color:#2e74b5;">atomic</span> if that&#8217;s appropriate, such as in low-lock code; or
</li>
<li>(very rarely) for certain types by performing the synchronization internally, as we will see below.
</li>
</ul>
<p>
 </p>
<h2>3. Consider the following code… If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of some_obj is: (a) int? (b) string? (c) vector&lt;map&lt;int,string&gt;&gt;? (d) shared_ptr&lt;widget&gt;?<br />
</h2>
<p>No. The code has one thread reading (via <span style="color:#2e74b5;">const</span> operations) from <span style="color:#2e74b5;">some_obj</span>, and a second thread writing to the same variable. If those threads can execute at the same time, that&#8217;s a race and a direct non-stop ticket to undefined behavior land.
</p>
<p>The answer is to synchronize access to the variable, for example using a <span style="color:#2e74b5;">mutex</span>:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br />}<br /><br />// thread 2<br />{<br />    lock_guard hold(mut_some_obj);     // acquire lock<br />    code_that_modifies( some_obj );    // passes some_obj by non-const &amp;<br />}
</code></pre>
</p>
<p>Virtually all types, including <span style="color:#2e74b5;">shared_ptr</span> and <span style="color:#2e74b5;">vector</span> and other types, are just as thread-safe as <span style="color:#2e74b5;">int</span>; they&#8217;re not special for concurrency purposes. It doesn&#8217;t matter whether <span style="color:#2e74b5;">some_obj</span> is an <span style="color:#2e74b5;">int</span>, a <span style="color:#2e74b5;">string</span>, a container, or a smart pointer… concurrent reads (<span style="color:#2e74b5;">const</span> operations) are safe without synchronization, but the shared object is writeable, then the code that owns the object has to synchronize access to it.
</p>
<p>But when I said this is true for &#8220;virtually all types,&#8221; I meant all types except for types that are not fully internally synchronized, which brings us to the types that, by design, <em>are</em> special for concurrency purposes…
</p>
<p>
 </p>
<h2>… If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of g+shared is: (e) mutex? (f) condition_variable? (g) atomic&lt;unsigned&gt;?<br />
</h2>
<p>Yes. For these types, the code is okay, because these types already perform full internal synchronization and so they are safe to access without external synchronization.
</p>
<p>In fact, these types had better be safe to use without external synchronization, because they&#8217;re synchronization primitives you need to use as tools to synchronize other variables! And its turns out that that&#8217;s no accident…
</p>
<blockquote>
<p><strong>Guideline:</strong> A type should only be fully internally synchronized if and only if its purpose is to provide  inter-thread communication (e.g., a message queue) or synchronization (e.g., a mutex).
</p>
</blockquote>
<p>
 </p>
<h2>4. <em>External synchronization</em> means that the code that uses/owns a given shared object is responsible for performing synchronization on that object. Answer the following questions related to external synchronization:<br />
</h2>
<h3>(a) What is the normal external synchronization responsibility of code that owns and uses a given shared variable?<br />
</h3>
<p>The normal synchronization duty of care is simply this: The code that knows about and owns a writeable shared variable has to synchronize access to it. It will typically do that using a <span style="color:#2e74b5;">mutex</span> or similar (~99.9% of the time), or by making it <span style="color:#2e74b5;">atomic</span> if that&#8217;s possible and appropriate (~0.1% of the time).
</p>
<blockquote>
<p><strong>Guideline:</strong> The code that knows about and owns a writeable shared variable is responsible for synchronizing access to it.
</p>
</blockquote>
<p>
 </p>
<h3>(b) What is the &#8220;basic thread safety guarantee&#8221; that all types must obey to enable calling code to perform normal external synchronization?<br />
</h3>
<p>To make it possible for the code that uses a shared variable to do the above, two basic things must be true.
</p>
<p>First, concurrent operations on different objects must be safe. For example, let&#8217;s say we have two <span style="color:#2e74b5;">X</span> objects <span style="color:#2e74b5;">x1</span> and <span style="color:#2e74b5;">x2</span>, each of which is only used by one thread. Then consider this situation:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case A: Using distinct objects<br /><br />// thread 1 (performs no additional synchronization)<br />x1.something();                   // do something with x1<br /><br />// thread 2 (performs no additional synchronization)<br />x2 = something_else;              // do something else with x2
</code></pre>
</p>
<p>This must always be considered correctly synchronized. Remember, we stated that <span style="color:#2e74b5;">x1</span> and <span style="color:#2e74b5;">x2</span> are distinct objects, and cannot be aliases for the same object or similar hijinks.
</p>
<p>Second, concurrent <span style="color:#2e74b5;">const</span> operations that are just reading from the same variable <span style="color:#2e74b5;">x</span> must be safe:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case B: const access to the same object<br /><br />// thread 1 (performs no additional synchronization)<br />x.something_const();              // read from x (const operation)<br /><br />// thread 2 (performs no additional synchronization)<br />x.something_else_const();         // read from x (const operation)
</code></pre>
</p>
<p>This code too must be considered correctly synchronized, and had better work without external synchronization. It&#8217;s not a race, because the two threads are both performing <span style="color:#2e74b5;">const</span> accesses and reading from the shared object.
</p>
<p>This brings us to the case where there might be a combination of internal and external synchronization required…
</p>
<p>
 </p>
<h3>(c) What partial internal synchronization can still be required within the shared variable&#8217;s implementation?<br />
</h3>
<p>In some classes, objects that from the outside appear to be distinct but still may share state under the covers, without the calling code being able to tell that two apparently distinct objects are connected under the covers. Note that this not an exception to the previous guideline—it&#8217;s the same guideline!
</p>
<blockquote>
<p><strong>Guideline:</strong> It is always true that the code that knows about and owns a writeable shared variable is responsible for synchronizing access to it. If the writeable shared state is hidden inside the implementation of some class, then it&#8217;s simply that class&#8217; internals that are the &#8216;owning code&#8217; that has to synchronize access to (just) the shared state that only it knows about.
</p>
</blockquote>
<p>A classic case of &#8220;under-the-covers shared state&#8221; is reference counting, and the two poster-child examples are <span style="color:#2e74b5;">std::shared_ptr</span> and copy-on-write. Let&#8217;s use <span style="color:#2e74b5;">shared_ptr</span> as our main example.
</p>
<p>A reference-counted smart pointer like <span style="color:#2e74b5;">shared_ptr</span> keeps a reference count under the covers. Let&#8217;s say we have two distinct <span style="color:#2e74b5;">shared_ptr</span> objects <span style="color:#2e74b5;">sp1</span> and <span style="color:#2e74b5;">sp2</span>, each of which is used by only one thread. Then consider this situation:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case A: Using distinct objects<br /><br />// thread 1 (performs no additional synchronization)<br />auto x = sp1;                      // read from sp1 (writes the count!) <br /><br />// thread 2 (performs no additional synchronization)<br />sp2 = something_else;              // write to sp2 (writes the count!)
</code></pre>
</p>
<p>This code must be considered correctly synchronized, and had better work as shown without any external synchronization. Okay, fine …
</p>
<p>… but what if <span style="color:#2e74b5;">sp1</span> and <span style="color:#2e74b5;">sp2</span> are pointing to the same object and so share a reference count? If so, <em>that reference count is a writeable shared object</em>, and so it must be synchronized to avoid a race—but it is in general impossible for the calling code to do the right synchronization, because it is not even aware of the sharing! The code we just saw above doesn&#8217;t see the count, doesn&#8217;t know the count variable&#8217;s name, and doesn&#8217;t in general know which pointers share counts.
</p>
<p>Similarly, consider two threads just reading from the same variable <span style="color:#2e74b5;">sp</span>:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case B: const access to the same object<br /><br />// thread 1 (performs no additional synchronization)<br />auto sp3 = sp;                     // read from sp (writes the count!)<br /><br />// thread 2 (performs no additional synchronization)<br />auto sp4 = sp;                     // read from sp (writes the count!)
</code></pre>
</p>
<p>This code too must be considered correctly synchronized, and had better work without external synchronization. It&#8217;s not a race, because the two threads are both performing <span style="color:#2e74b5;">const</span> accesses and reading from the shared object. But under the covers, reading from <span style="color:#2e74b5;">sp</span> to copy it increments the reference count, and so again <em>that reference count is a writeable shared object</em>, and so it must be synchronized to avoid a race—and again it is in general impossible for the calling code to do the right synchronization, because it is not even aware of the sharing.
</p>
<p>So to deal with these cases, the code that knows about the shared reference count, namely the <span style="color:#2e74b5;">shared_ptr</span> implementation, has to synchronize access to the reference count. For reference counting, this is typically done by making the reference count a <span style="color:#2e74b5;">mutable atomic</span> variable. (See also GotW #6a and #6b.)
</p>
<p>For completeness, yes, of course external synchronization is still required as usual if the calling code shared a given visible <span style="color:#2e74b5;">shared_ptr</span> object and makes that same shared<span style="color:#2e74b5;">_ptr</span> object writable across threads:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// Case C: External synchronization still required as usual<br />//         for non-const access to same visible shared object<br /><br />// thread 1<br />{<br />    lock_guard hold(mut_sp);           // acquire lock<br />    auto sp3 = sp;                     // read from sp<br />}<br /><br />// thread 2<br />{<br />    lock_guard hold(mut_sp);           // acquire lock<br />    sp = something_else;               // modify sp<br />}
</code></pre>
</p>
<p>So it&#8217;s not like <span style="color:#2e74b5;">shared_ptr</span> is a fully internally synchronized type; if the caller is sharing an object of that type, the caller must synchronize access to it like it would do for other types, as noted in Question 3(d).
</p>
<p>So what&#8217;s the purpose of the internal synchronization? It&#8217;s only to do necessary synchronization on the parts that the internals know are shared <em>and that the internals own</em>, but that the caller can&#8217;t synchronize because he doesn&#8217;t know about the sharing and shouldn&#8217;t need to because the caller doesn&#8217;t own them, the internals do. So in the internal implementation of the type we do just enough internal synchronization to get back to the level where the caller can assume his usual duty of care and in the usual ways correctly synchronize any objects that might actually be shared.
</p>
<p>The same applies to other uses of reference counting, such as copy-on-write strategies. It also applies generally to any other internal sharing going on under the covers between objects that appear distinct and independent to the calling code.
</p>
<blockquote>
<p><strong>Guideline:</strong> If you design a class where two objects may invisibly share state under the covers, it is your class&#8217; responsibility to internally synchronize access to that <strong>mutable</strong> shared state (only) that it owns and that only it can see, because the calling code can&#8217;t. If you opt for under-the-covers-sharing strategies like copy-on-write, be aware of the duty you&#8217;re taking on for yourself and code with care.
</p>
</blockquote>
<p>For why such internal shared state should be <strong>mutable</strong>, see GotW #6a and #6b.
</p>
<p>
 </p>
<h2>5. <em>… </em>What types should be fully internally synchronized, and why?<br />
</h2>
<p>There is exactly one category of types which should be fully internally synchronized, so that any object of that type is always safe to use concurrently without external synchronization: Inter-thread synchronization and communication primitives themselves. This includes standard types like mutexes and atomics, but also inter-thread communication and synchronization types you might write yourself such as a message queue (communicating messages from one thread to another), Producer/Consumer active objects (again passing data from one concurrent entity to another), or a thread-safe counter (communicating counter increments and decrements among multiple threads).
</p>
<p>If you&#8217;re wondering if there might be other kinds of types that should be internally synchronized,  consider: The only type for which it would make sense to always internally synchronize every operation is a type where you know <em>every object</em> is going to be both (a) writeable and (b) shared across threads… and that means that the type is by definition designed to be used for inter-thread communication and/or synchronization.
</p>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: Daniel Hardman, Casey, Alb, Marcel Wid, ixache.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/feed/</wfw:commentRss>
		<slash:comments>24</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #95: Thread Safety and Synchronization</title>
		<link>https://herbsutter.com/2014/01/06/gotw-95-thread-safety-and-synchronization/</link>
				<comments>https://herbsutter.com/2014/01/06/gotw-95-thread-safety-and-synchronization/#comments</comments>
				<pubDate>Mon, 06 Jan 2014 16:00:09 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2401</guid>
				<description><![CDATA[This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.   Problem JG Questions 1. What is a race condition, and how serious [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>This GotW was written to answer a set of related frequently asked questions. So here&#8217;s a mini-FAQ on &#8220;thread safety and synchronization in a nutshell,&#8221; and the points we&#8217;ll cover apply to thread safety and synchronization in pretty much any mainstream language.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What is a race condition, and how serious is it?
</p>
<p>2. What is a correctly synchronized program? How do you achieve it? Be specific.
</p>
<p>
 </p>
<h2>Guru Questions<br />
</h2>
<p>3. Consider the following code, where <span style="color:#2e74b5;">some_obj</span> is a shared variable visible to multiple threads.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// thread 1 (performs no additional synchronization)<br />code_that_reads_from( some_obj );  // passes some_obj by const &amp;<br /><br />// thread 2 (performs no additional synchronization)<br />code_that_modifies( some_obj );    // passes some_obj by non-const &amp;
</code></pre>
</p>
<p>If threads 1 and 2 can run concurrently, is this code correctly synchronized if the type of <span style="color:#2e74b5;">some_obj</span> is:
</p>
<p style="margin-left:36pt;">(a) <span style="color:#2e74b5;">int</span>?
</p>
<p style="margin-left:36pt;">(b) <span style="color:#2e74b5;">string</span>?
</p>
<p style="margin-left:36pt;">(c) <span style="color:#2e74b5;">vector&lt;map&lt;int,string&gt;&gt;</span>?
</p>
<p style="margin-left:36pt;">(d) <span style="color:#2e74b5;">shared_ptr&lt;widget&gt;</span>?
</p>
<p style="margin-left:36pt;">(e) <span style="color:#2e74b5;">mutex</span>?
</p>
<p style="margin-left:36pt;">(f) <span style="color:#2e74b5;">condition_variable</span>?
</p>
<p style="margin-left:36pt;">(g) <span style="color:#2e74b5;">atomic&lt;unsigned&gt;</span>?<span style="color:#2e74b5;"><br />
		</span></p>
<p>Hint: This is actually a two-part question, not a seven-part question. There are only two unique answers, each of which covers a subset of the cases.
</p>
<p>4. <em>External synchronization</em> means that the code that uses/owns a given shared object is responsible for performing synchronization on that object. Answer the following questions related to external synchronization:
</p>
<p style="margin-left:36pt;">(a) What is the normal external synchronization responsibility of code that owns and uses a given shared variable?
</p>
<p style="margin-left:36pt;">(b) What is the &#8220;basic thread safety guarantee&#8221; that all types must obey to enable calling code to perform normal external synchronization?
</p>
<p style="margin-left:36pt;">(c) What partial internal synchronization can still be required within the shared variable&#8217;s implementation?
</p>
<p>5. <em>Full internal synchronization</em> (a.k.a. &#8220;synchronized types&#8221; or &#8220;thread-safe types&#8221;) means that a shared object performs all necessary synchronization internally within that object, so that calling code does not need to perform any external synchronization. What types should be fully internally synchronized, and why?</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/06/gotw-95-thread-safety-and-synchronization/feed/</wfw:commentRss>
		<slash:comments>15</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7c Solution: Minimizing Compile-Time Dependencies, Part 3</title>
		<link>https://herbsutter.com/2014/01/06/gotw-7c-solution-minimizing-compile-time-dependencies-part-3/</link>
				<comments>https://herbsutter.com/2014/01/06/gotw-7c-solution-minimizing-compile-time-dependencies-part-3/#comments</comments>
				<pubDate>Mon, 06 Jan 2014 15:58:39 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2399</guid>
				<description><![CDATA[Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.   Problem JG Question 1. What is the tightest coupling you can express in C++? [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the tightest coupling you can express in C++? And what&#8217;s the second-tightest?
</p>
<h2>Guru Question<br />
</h2>
<p>2. The Incredible Shrinking Header has now been greatly trimmed, but there may still be ways to reduce the dependencies further. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made further changes to <span style="color:#2e74b5;">X</span>, and how?
</p>
<p>This time, you may make any changes at all to <span style="color:#2e74b5;">X</span> as long as they don&#8217;t change its public interface, so that existing code that uses <span style="color:#2e74b5;">X</span> is unaffected. Again, note that the comments are important.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after converting to use a Pimpl to hide implementation details<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />#include "b.h"  // class B (has no virtual functions)<br />class C;<br />class E;<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What is the tightest coupling you can express in C++? And what&#8217;s the second-tightest?<br />
</h2>
<p>Friendship and inheritance, respectively.
</p>
<p>A friend of a class has access to everything in that class, including all of its private data and functions, and so the code in a friend depends on every detail of the type. Now that&#8217;s a close friend!
</p>
<p>A class derived from a class <span style="color:#2e74b5;">Base</span> has access to public and protected members in <span style="color:#2e74b5;">Base</span>, and depends on the size and layout of <span style="color:#2e74b5;">Base</span> because it contains a <span style="color:#2e74b5;">Base</span> subobject. Further, the inheritance relationship means that a derived type is at least by default substitutable for its <span style="color:#2e74b5;">Base</span>; whether the inheritance is public or nonpublic only changes what other code can see and make use of the substitutability. That&#8217;s pretty tight coupling, second only to friendship.
</p>
<p>
 </p>
<h2>2. What further #includes could be removed if we made further changes to X, and how?<br />
</h2>
<p>Many programmers still seem to march to the &#8220;It isn&#8217;t OO unless you inherit!&#8221; battle hymn, by which I mean that they use inheritance more than necessary. I&#8217;ll save the whole lecture for another time, but my bottom line is simply that inheritance (including but not limited to IS-A) is a much stronger relationship than HAS-A or USES-A. When it comes to managing dependencies, therefore, you should always prefer composition/membership over inheritance wherever possible. To paraphrase Einstein: &#8216;Use as strong a relationship as necessary, but no stronger.&#8217;
</p>
<p>In this code, <span style="color:#2e74b5;">X</span> is derived publicly from <span style="color:#2e74b5;">A</span> and privately from <span style="color:#2e74b5;">B</span>. Recall that public inheritance should always model IS-A and satisfy the Liskov Substitutability Principle (LSP). In this case <span style="color:#2e74b5;">X</span> IS-A <span style="color:#2e74b5;">A</span> and there&#8217;s naught wrong with it, so we&#8217;ll leave that as it is.
</p>
<p>But did you notice the curious thing about <span style="color:#2e74b5;">B</span>&#8216;s virtual functions?
</p>
<p>&#8220;What?&#8221; you might say. &#8220;<span style="color:#2e74b5;">B</span> has no virtual functions.&#8221;
</p>
<p>Right. <a href="http://en.wikipedia.org/wiki/Silver_Blaze">That is the curious thing.</a>
	</p>
<p><span style="color:#2e74b5;">B</span> is a private base class of <span style="color:#2e74b5;">X</span>. Normally, the only reason you would choose private inheritance over composition/membership is to gain access to protected members—which most of the time means &#8220;to override a virtual function.&#8221; (There are a few other rare and obscure reasons to inherit, but they&#8217;re, well, rare and obscure.) Otherwise you wouldn&#8217;t choose inheritance, because it&#8217;s almost the tightest coupling you can express in C++, second only to <span style="color:#2e74b5;">friend</span>ship.
</p>
<p>We are given that <span style="color:#2e74b5;">B</span> has no virtual functions, so there&#8217;s probably no reason to prefer the stronger relationship of inheritance—unless <span style="color:#2e74b5;">X</span> needs access to some protected function or data in <span style="color:#2e74b5;">B</span>, of course, but for now I&#8217;ll assume that this is not the case. So, instead of having a base subobject of type <span style="color:#2e74b5;">B</span>, <span style="color:#2e74b5;">X</span> probably ought to have simply a member object of type <span style="color:#2e74b5;">B</span>. Therefore, the way to further simplify the header is:
</p>
<p>
 </p>
<h2>(a) Remove unnecessary inheritance from class <span style="color:#2e74b5;">B.<br />
</span></h2>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>#include "b.h"  // class B (has no virtual functions)
</code></pre>
</p>
<p>Because the <span style="color:#2e74b5;">B</span> member object should be private (it is, after all, an implementation detail), and in order to get rid of the <span style="color:#2e74b5;">b.h</span> header entirely, this member should live in <span style="color:#2e74b5;">X</span>&#8216;s hidden <span style="color:#2e74b5;">pimpl</span> portion.
</p>
<blockquote>
<p><strong>Guideline: </strong>Never inherit when composition is sufficient.
</p>
</blockquote>
<p>
 </p>
<p>This leaves us with header code that&#8217;s vastly simplified from where we started in GotW #7a:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after removing unnecessary inheritance<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />class B;<br />class C;<br />class E;<br /><br />class X : public A {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // this now quietly includes a B<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>
 </p>
<p>After three passes of progressively greater simplification, the final result is that <span style="color:#2e74b5;">x.h</span> is still using other class names all over the place, but clients of <span style="color:#2e74b5;">X</span> need only pay for three <span style="color:#2e74b5;">#include</span>s: <span style="color:#2e74b5;">a.h</span>, <span style="color:#2e74b5;">memory</span>, and <span style="color:#2e74b5;">iosfwd</span>. What an improvement over the original!
</p>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks in particular to the following for their feedback to improve this article: juanchopanza, anicolaescu, Bert Rodiers.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2014/01/06/gotw-7c-solution-minimizing-compile-time-dependencies-part-3/feed/</wfw:commentRss>
		<slash:comments>26</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7c: Minimizing Compile-Time Dependencies, Part 3</title>
		<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/</link>
				<comments>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comments</comments>
				<pubDate>Tue, 31 Dec 2013 20:32:15 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2387</guid>
				<description><![CDATA[Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.   Problem JG Question 1. What is the tightest coupling you can express in C++? [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now the unnecessary headers have been removed, and avoidable dependencies on the internals of the class have been eliminated. Is there any further decoupling that can be done? The answer takes us back to basic principles of solid class design.<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Question<br />
</h2>
<p>1. What is the tightest coupling you can express in C++? And what&#8217;s the second-tightest?
</p>
<h2>Guru Question<br />
</h2>
<p>2. The Incredible Shrinking Header has now been greatly trimmed, but there may still be ways to reduce the dependencies further. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made further changes to <span style="color:#2e74b5;">X</span>, and how?
</p>
<p>This time, you may make any changes at all to <span style="color:#2e74b5;">X</span> as long as they don&#8217;t change its public interface, so that existing code that uses <span style="color:#2e74b5;">X</span> is unaffected. Again, note that the comments are important.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after converting to use a Pimpl to hide implementation details<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />#include "b.h"  // class B (has no virtual functions)<br />class C;<br />class E;<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre></p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>GotW #7b Solution: Minimizing Compile-Time Dependencies, Part 2</title>
		<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/</link>
				<comments>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comments</comments>
				<pubDate>Tue, 31 Dec 2013 20:24:37 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[GotW]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2384</guid>
				<description><![CDATA[Now that the unnecessary headers have been removed, it&#8217;s time for Phase 2: How can you limit dependencies on the internals of a class?   Problem JG Questions 1. What does private mean for a class member in C++? 2. Why does changing the private members of a type cause a recompilation? Guru Question 3. [&#8230;]]]></description>
								<content:encoded><![CDATA[<p><span style="color:#5a5a5a;"><em>Now that the unnecessary headers have been removed, it&#8217;s time for Phase 2: How can you limit dependencies on the internals of a class?<br />
</em></span></p>
<p>
 </p>
<h1>Problem<br />
</h1>
<h2>JG Questions<br />
</h2>
<p>1. What does <span style="color:#2e74b5;">private</span> mean for a class member in C++?
</p>
<p>2. Why does changing the private members of a type cause a recompilation?
</p>
<h2>Guru Question<br />
</h2>
<p>3. Below is how the header from the previous Item looks after the initial cleanup pass. What further <span style="color:#2e74b5;">#include</span>s could be removed if we made some suitable changes, and how?
</p>
<p>This time, you may make changes to <span style="color:#2e74b5;">X</span> as long as <span style="color:#2e74b5;">X</span>&#8216;s base classes and its public interface remain unchanged; any current code that already uses <span style="color:#2e74b5;">X</span> should not be affected beyond requiring a simple recompilation.
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: sans gratuitous headers<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;list&gt;<br /><br />// None of A, B, C, or D are templates.<br />// Only A and C have virtual functions.<br />#include "a.h"  // class A<br />#include "b.h"  // class B<br />#include "c.h"  // class C<br />#include "d.h"  // class D<br />class E;<br /><br />class X : public A, private B {<br />public:<br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />  private:<br />    std::list&lt;C&gt; clist;<br />    D            d;<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>
 </p>
<h1>Solution<br />
</h1>
<h2>1. What does private mean for a class member in C++?<br />
</h2>
<p>It means that outside code cannot access that member. Specifically, it cannot name it or call it.
</p>
<p>For example, given this class:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>class widget {<br />public:<br />    void f() { }<br />private:<br />    void f(int) { }<br />    int i;<br />};
</code></pre>
</p>
<p>Outside code cannot use the name of the <span style="color:#2e74b5;">private</span> members:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code> int main() {<br />    auto w = widget{};<br />    w.f();               // ok<br />    w.f(42);             // error, cannot access name "f(int)"<br />    w.i = 42;            // error, cannot access name "i"<br />}
</code></pre>
</p>
<p>
 </p>
<h2>2. Why does changing the private members of a type cause a recompilation?<br />
</h2>
<p>Because private data members can change the size of the object, and private member functions participate in overload resolution.
</p>
<p>Note that accessibility is still safely enforced: <em>Calling code</em> still doesn&#8217;t get to use the private parts of the class. However, <em>the compiler</em> gets to know all about them at all times, including as it compiles the calling code. This does increase build coupling, but it&#8217;s for a deliberate reason: C++ has always been designed for efficiency, and a little-appreciated cornerstone of that is that C++ is designed to by default expose a type&#8217;s full implementation to the compiler in order to make aggressive optimization easier. It&#8217;s one of the fundamental reasons C++ is an efficient language.
</p>
<p>
 </p>
<h2>3. What further #includes could be removed if we made some suitable changes, and how? … any current code that already uses X should not be affected beyond requiring a simple recompilation.<br />
</h2>
<p>There are a few things we weren&#8217;t able to do in the previous problem:
</p>
<ul>
<li>We had to leave <span style="color:#2e74b5;">a.h</span> and <span style="color:#2e74b5;">b.h</span>. We couldn&#8217;t get rid of these because <span style="color:#2e74b5;">X</span> inherits from both <span style="color:#2e74b5;">A</span> and <span style="color:#2e74b5;">B</span>, and you always have to have full definitions for base classes so that the compiler can determine <span style="color:#2e74b5;">X</span>&#8216;s object size, virtual functions, and other fundamentals. (Can you anticipate how to remove one of these? Think about it: Which one can you remove, and why/how? The answer will come shortly.)
</li>
<li>We had to leave <span style="color:#2e74b5;">list</span>, <span style="color:#2e74b5;">c.h</span> and <span style="color:#2e74b5;">d.h</span>. We couldn&#8217;t get rid of these right away because a <span style="color:#2e74b5;">list&lt;C&gt;</span> and a <span style="color:#2e74b5;">D</span> appear as private data members of <span style="color:#2e74b5;">X</span>. Although <span style="color:#2e74b5;">C</span> appears as neither a base class nor a member, it is being used to instantiate the <span style="color:#2e74b5;">list</span> member, and some have compilers required that when you instantiate <span style="color:#2e74b5;">list&lt;C&gt;</span> you be able to see the definition of <span style="color:#2e74b5;">C</span>. (The standard doesn&#8217;t require a definition here, though, so even if the compiler you are currently using has this restriction, you can expect the restriction to go away over time.)
</li>
</ul>
<p>Now let&#8217;s talk about the beauty of Pimpls.
</p>
<p>
 </p>
<h3>The Pimpl Idiom<br />
</h3>
<p>C++ lets us easily encapsulate the private parts of a class from unauthorized access. Unfortunately, because of the header file approach inherited from C, it can take a little more work to encapsulate dependencies on a class&#8217; privates.
</p>
<p>&#8220;But,&#8221; you say, &#8220;the whole point of encapsulation is that the client code shouldn&#8217;t have to know or care about a class&#8217; private implementation details, right?&#8221; Right, and in C++ the client code doesn&#8217;t need to know or care about access to a class&#8217; privates (because unless it&#8217;s a friend it isn&#8217;t allowed any), but because the privates are visible in the header the client code does have to depend upon any types they mention. This coupling between the caller and the class&#8217;s internal details creates dependencies on both (re)compilation and binary layout.
</p>
<p>How can we better insulate clients from a class&#8217; private implementation details? One good way is to use a special form of the handle/body idiom, popularly called the Pimpl Idiom because of the intentionally pronounceable <span style="color:#2e74b5;">pimpl</span> pointer, as a compilation firewall.
</p>
<p>A Pimpl is just an opaque pointer (a pointer to a forward-declared, but undefined, helper class) used to hide the private members of a class. That is, instead of writing this:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// file widget.h<br />//<br />class widget {<br />    // public and protected members<br />private:<br />    // private members; whenever these change,<br />    // all client code must be recompiled<br />};
</code></pre>
</p>
<p>We write instead:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>// file widget.h<br />//<br />#include &lt;memory&gt;<br /><br />class widget {<br />public:<br />    widget();<br />    ~widget();<br />    // public and protected members<br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />// file widget.cpp<br />//<br />#include "widget.h"<br /><br />struct widget::impl {<br />    // private members; fully hidden, can be<br />    // changed at will without recompiling clients<br />};<br /><br />widget::widget() : pimpl{ make_unique&lt;widget::impl&gt;(/*...*/) } { }<br />widget::~widget() =default;
</code></pre>
</p>
<p>Every <span style="color:#2e74b5;">widget</span> object dynamically allocates its <span style="color:#2e74b5;">impl</span> object. If you think of an object as a physical block, we&#8217;ve essentially lopped off a large chunk of the block and in its place left only &#8220;a little bump on the side&#8221;—the opaque pointer, or Pimpl. If copy and move are appropriate for your type, write those four operations to perform a deep copy that clones the <span style="color:#2e74b5;">impl</span> state.
</p>
<p>The major advantages of this idiom come from the fact that it breaks the caller&#8217;s dependency on the private details, including breaking both compile-time dependencies and binary dependencies:
</p>
<ul>
<li>Types mentioned only in a class&#8217; implementation need no longer be defined for client code, which can eliminate extra <span style="color:#2e74b5;">#include</span>s and improve compile speeds.
</li>
<li>A class&#8217; implementation can be changed—that is, private members can be freely added or removed—without recompiling client code. This is a useful technique for providing ABI-safety or binary compatibility, so that the client code is not dependent on the exact layout of the object.
</li>
</ul>
<p>The major costs of this idiom are in performance:
</p>
<ul>
<li>Each construction/destruction must allocate/deallocate memory.
</li>
<li>Each access of a hidden member can require at least one extra indirection. (If the hidden member being accessed itself uses a back pointer to call a function in the visible class, there will be multiple indirections, but is usually easy to avoid needing a back pointer.)
</li>
</ul>
<p>And of course we&#8217;re replacing any removed headers with the <span style="color:#2e74b5;">&lt;memory&gt;</span> header.
</p>
<p>We&#8217;ll come back to these and other Pimpl issues in GotW #24. For now, in our example, there were three headers whose definitions were needed simply because they appeared as private members of <span style="color:#2e74b5;">X</span>. If we instead restructure <span style="color:#2e74b5;">X</span> to use a Pimpl, we can immediately make several further simplifications:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>#include &lt;list&gt;<br />#include "c.h"  // class C<br />#include "d.h"  // class D
</code></pre>
</p>
<p>One of these headers (<span style="color:#2e74b5;">c.h</span>) can be replaced with a forward declaration because <span style="color:#2e74b5;">C</span> is still being mentioned elsewhere as a parameter or return type, and the other two (<span style="color:#2e74b5;">list</span> and <span style="color:#2e74b5;">d.h</span>) can disappear completely.
</p>
<blockquote>
<p><strong>Guideline:</strong> For widely-included classes whose implementations may change, or to provide ABI-safety or binary compatibility, consider using the compiler-firewall idiom (Pimpl Idiom) to hide implementation details. Use an opaque pointer (a pointer to a declared but undefined class) declared as <strong>struct impl; std::unique_ptr&lt;impl&gt; pimpl;</strong> to store private nonvirtual members.
</p>
</blockquote>
<p>
 </p>
<p>Note: We can&#8217;t tell from the original code by itself whether or not <span style="color:#2e74b5;">X</span> had (default) copy or move operations. If it did, then to preserve that we would need to write them again ourselves since the move-only <span style="color:#2e74b5;">unique_ptr</span> member suppresses the implicit generation of copy construction and copy assignment, and the user-declared destructor suppresses the implicit generation of move construction and move assignment. If we do need to write them by hand, the move constructor and move assignment can be <span style="color:#2e74b5;">=default</span>ed, and the copy constructor and copy assignment will need to copy the Pimpl object.
</p>
<p>After making that additional change, the header looks like this:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  x.h: after converting to use a Pimpl<br />//<br />#include &lt;iosfwd&gt;<br />#include &lt;memory&gt;<br />#include "a.h"  // class A (has virtual functions)<br />#include "b.h"  // class B (has no virtual functions)<br />class C;<br />class E;<br /><br />class X : public A, private B {<br />public:<br />    ~X();                          // defined out of line<br />    // and copy/move operations if X had them before<br /><br />       X( const C&amp; );<br />    B  f( int, char* );<br />    C  f( int, C );<br />    C&amp; g( B );<br />    E  h( E );<br />    virtual std::ostream&amp; print( std::ostream&amp; ) const;<br /><br />private:<br />    struct impl;<br />    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class<br />};<br /><br />std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />    return x.print(os);<br />}
</code></pre>
</p>
<p>Without more extensive changes, we still need the definitions for <span style="color:#2e74b5;">A</span> and <span style="color:#2e74b5;">B</span> because they are base classes, and we have to know at least their sizes in order to define the derived class <span style="color:#2e74b5;">X</span>.
</p>
<p>The private details go into <span style="color:#2e74b5;">X</span>&#8216;s implementation file where client code never sees them and therefore never depends upon them:
</p>
<p style="background:#ffffcc;margin-left:14pt;">
<pre><code>//  Implementation file x.cpp<br />//<br />#include &lt;list&gt;<br />#include "c.h"  // class C<br />#include "d.h"  // class D<br />using namespace std;<br /><br />struct X::impl {<br />    list&lt;C&gt; clist;<br />    D       d;<br />};<br /><br />X::X() : pimpl{ make_unique&lt;X::impl&gt;(/*...*/) } { }<br />X::~X() =default;
</code></pre>
</p>
<p>That brings us down to including only four headers, which is a great improvement—but it turns out that there is still a little more we could do, if only we were allowed to change the structure of <span style="color:#2e74b5;">X</span> more extensively. This leads us nicely into Part 3…
</p>
<p>
 </p>
<h2>Acknowledgments<br />
</h2>
<p>Thanks to the following for their feedback to improve this article: John Humphrey, thokra, Motti Lanzkron, Marcelo Pinto.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/feed/</wfw:commentRss>
		<slash:comments>14</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Visual C++ Compiler November 2013 CTP</title>
		<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/</link>
				<comments>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comments</comments>
				<pubDate>Mon, 18 Nov 2013 23:25:42 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Microsoft]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2361</guid>
				<description><![CDATA[We just shipped Visual C++2013 last month, but I announced at GoingNative in September that there would be more soon: another CTP (compiler preview) containing another batch of C++11/14 features, sometime in the fourth quarter. I&#8217;m happy to report that today we shipped the promised CTP. Compared to the &#8220;high probability in CTP&#8221; feature set I mentioned [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>We just shipped Visual C++2013 last month, but I announced at GoingNative in September that there would be more soon: another CTP (compiler preview) containing another batch of C++11/14 features, sometime in the fourth quarter.</p>
<p>I&#8217;m happy to report that <a href="http://blogs.msdn.com/b/vcblog/archive/2013/11/18/announcing-the-visual-c-compiler-november-2013-ctp.aspx">today we shipped the promised CTP</a>. Compared to the &#8220;high probability in CTP&#8221; feature set I mentioned in my GoingNative talk, one of those features I mentioned didn&#8217;t quite make it (C++14 generalized lambda capture, a.k.a. move capture and more), but to compensate, both medium-probability features made it (C++14 generic lambdas and C++11 inheriting constructors) plus, as a bonus, also alignof and alignas which we didn&#8217;t think would make it for the CTP but did. Here&#8217;s the full set of new features, pasting from the announcement:</p>
<ul>
<li>Implicit move special member function generation (thus also completing <em>=default</em>)</li>
<li>Reference qualifiers on member functions (a.k.a. &#8220;<em>&amp;</em> and <em>&amp;&amp;</em> for <em>*this</em>&#8220;)</li>
<li>Thread-safe function local static initialization (a.k.a. &#8220;magic statics&#8221;)</li>
<li>Inheriting constructors</li>
<li><em>alignof</em>/<em>alignas</em></li>
<li><em>__func__</em></li>
<li>Extended <em>sizeof</em></li>
<li><em>constexpr</em> (except for member functions)</li>
<li><em>noexcept</em> (unconditional)</li>
<li>C++14 <em>decltype(auto)</em></li>
<li>C++14 <em>auto</em> function return type deduction</li>
<li>C++14 generic lambdas (with explicit lambda capture list)</li>
<li>(Proposed for C++17) Resumable functions and <em>await</em></li>
</ul>
<p>The most-requested feature of C++14, and the one I&#8217;ve personally been anticipating the most, is generic lambdas &#8212; it is sweet to see it working right within Visual Studio 2013, as the CTP installs as a selectable toolset you can use within the shipping product to edit and build (no Intellisense or red squiggles though). Note that for this CTP, your lambda can be either generic (have an auto parameter type) or have a default capture list (e.g., [=] or [&amp;]), but not both &#8212; of course we&#8217;ll support both together in the future as the feature makes a future release.</p>
<p>As far as I know, this Visual C++ CTP is the first shipping (albeit CTP quality) C++ compiler to offer generic lambdas, though I expect Clang and gcc to also make them available soon &#8212; joy for C++ developers everywhere!</p>
<p>Once again, thank you very much again to the great Visual C++ team for producing this CTP; even as we speak, they&#8217;re hard at work on more. Thanks again also to the other members of the ISO C++ committee for producing a great and high-quality C++11 and soon-to-be-not-draft C++14.</p>
<p>I hope you enjoy trying out this CTP.</p>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/feed/</wfw:commentRss>
		<slash:comments>41</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>(V)C++ recorded talks at VS 2013 Launch</title>
		<link>https://herbsutter.com/2013/11/13/vc-recorded-talks-at-vs-2013-launch/</link>
				<comments>https://herbsutter.com/2013/11/13/vc-recorded-talks-at-vs-2013-launch/#comments</comments>
				<pubDate>Wed, 13 Nov 2013 22:18:04 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Microsoft]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2357</guid>
				<description><![CDATA[As part of today&#8217;s VS 2013 launch, in addition to the live talks and Q&#38;A we also have some recently recorded talks that are now also live. My talk is a quick 20-minute tour of the new ISO C++ conformance features in VC++ 2013 &#8212; nothing I haven&#8217;t said before, so if you&#8217;ve seen my [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>As part of today&#8217;s VS 2013 launch, in addition to the live talks and Q&amp;A we also have some recently recorded talks that are now also live. My talk is a quick 20-minute tour of the new ISO C++ conformance features in VC++ 2013 &#8212; nothing I haven&#8217;t said before, so if you&#8217;ve seen my last two Build talks you&#8217;ve seen this material, only here I&#8217;ve condensed it to a distilled two-minute overview of each feature using examples.</p>
<p>Here they are, each between 4 and 20 minutes long. Note that these are just the (V)C++-specific topics &#8212; be sure to look at the Related Videos of each to see other new features that light up for C++ as well as for other languages.</p>
<h3><a href="http://events.visualstudio.com/eng/sessions/details?SessionProfile=1876&amp;TrackProfile=1864">ISO C++ Additions in Visual C++ 2013</a> (Herb Sutter)</h3>
<blockquote><p>ISO C++ received a major upgrade with the latest standard, adding many features that make the language both simpler and more powerful. Visual C++ 2010 and 2012 have already implemented a number of these features, from auto to range-for to lambdas.  In this video, Herb Sutter reviews the additional ISO C++ standards conformance improvements in Visual C++ 2013, and how each of them contributes to making modern C++ code clean, safe, and faster than ever.</p></blockquote>
<h3><a href="http://events.visualstudio.com/eng/sessions/details?SessionProfile=1873&amp;TrackProfile=1864">​What&#8217;s New for C++ Developers in Visual Studio 2013 IDE​</a> (Jennifer Leaf)</h3>
<blockquote><p>Visual Studio 2013 includes several compelling new features for C++ developers.  In this video, you’ll learn about IntelliSense improvements, the new code formatting feature, and other changes that help you navigate through and write your code.</p></blockquote>
<h3><a href="http://events.visualstudio.com/eng/sessions/details?SessionProfile=1891&amp;TrackProfile=1864">New Compiler Optimizations for C++ Applications</a> (Jim Hogg &amp; Ankit Asthana)</h3>
<blockquote><p>C++ developers will find many improvements in Visual Studio 2013 &#8212; including new versions of the compiler, linker and tools &#8212; that make code run faster.  In this video we&#8217;ll cover C++ performance improvements, including better vectorization; permutation in the order of loop nests; better Profile-Guided Optimization (that now applies to Windows Store apps); a new vector calling convention; and more support for C++ Accelerated Massive Parallelism (AMP).</p></blockquote>
<h3><a href="http://events.visualstudio.com/eng/sessions/details?SessionProfile=1890&amp;TrackProfile=1864">Debugging Improvements for C++ Developers</a> (Brad Sullivan)</h3>
<blockquote><p>Visual Studio 2013 includes numerous improvements for debugging C++ applications.  In this video we&#8217;ll demo two of these features: Just My Code and JavaScript/Native Interop Debugging.</p></blockquote>
<h3><a href="http://events.visualstudio.com/eng/sessions/details?SessionProfile=1836&amp;TrackProfile=1833">Introducing Visual Studio 2013 for Windows Developers Building C++ Apps</a> (Raman Sharma)</h3>
<blockquote><p>Visual C++ in Visual Studio 2013 includes improvements for Windows App developers in the core language and libraries, as well in tooling, debugging and designers.  This video will provide an overview of these new features in Visual Studio 2013 for C++ developers building Windows Store apps.</p></blockquote>
]]></content:encoded>
							<wfw:commentRss>https://herbsutter.com/2013/11/13/vc-recorded-talks-at-vs-2013-launch/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
						
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
		<item>
		<title>Live Visual C++ Q&#038;A today</title>
		<link>https://herbsutter.com/2013/11/13/live-visual-c-qa-today/</link>
				<pubDate>Wed, 13 Nov 2013 16:37:23 +0000</pubDate>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
				<category><![CDATA[C++]]></category>
		<category><![CDATA[Microsoft]]></category>

		<guid isPermaLink="false">http://herbsutter.com/?p=2355</guid>
				<description><![CDATA[As part of the VS 2013 launch today, in a few hours I will be joining Tarek Madkour and Ale Contenti on camera for about half an hour to answer questions about VC++2013. Tarek and Ale are two of the three-manager triad who run our VC++ team. Visual C++ in 2013 and Beyond with Charles [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>As part of the VS 2013 launch today, in a few hours I will be joining Tarek Madkour and Ale Contenti on camera for about half an hour to answer questions about VC++2013. Tarek and Ale are two of the three-manager triad who run our VC++ team.</p>
<h2 style="padding-left:30px;"><a href="http://channel9.msdn.com/Events/Visual-Studio/Launch-2013/Visual-C-in-2013-and-Beyond">Visual C++ in 2013 and Beyond</a></h2>
<p style="padding-left:30px;">with Charles Torre, Ale Contenti, Tarek Madkour, and Herb Sutter</p>
<p style="padding-left:30px;">Date: November 13, 2013<br />
Time: 12:45pm PST (approx.)</p>
<p>I believe the session will be recorded and available on demand in a couple of days.</p>
]]></content:encoded>
									
		<media:content url="https://0.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=96&#38;d=identicon&#38;r=G" medium="image">
			<media:title type="html">Herb Sutter</media:title>
		</media:content>
	</item>
	</channel>
</rss>
