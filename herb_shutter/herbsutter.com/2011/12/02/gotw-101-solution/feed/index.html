<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #101: Solution	</title>
	<atom:link href="https://herbsutter.com/2011/12/02/gotw-101-solution/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2011/12/02/gotw-101-solution/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Alex Ivanoff				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4641</link>
		<dc:creator><![CDATA[Alex Ivanoff]]></dc:creator>
		<pubDate>Sun, 01 Jan 2012 18:56:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4641</guid>
					<description><![CDATA[Should operator-&#062; and operator* actually be const?

T* operator-&#062;() const;
T &#038; operator*() const]]></description>
		<content:encoded><![CDATA[<p>Should operator-&gt; and operator* actually be const?</p>
<p>T* operator-&gt;() const;<br />
T &amp; operator*() const</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MSN				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4611</link>
		<dc:creator><![CDATA[MSN]]></dc:creator>
		<pubDate>Wed, 21 Dec 2011 22:50:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4611</guid>
					<description><![CDATA[I believe pimpl needs to be explicitly instantiated as well. I tried using the code in GotW #101 in VC 2010, and it did not link without expliclty instantiating pimpl where I implemented widget::impl.

MSN]]></description>
		<content:encoded><![CDATA[<p>I believe pimpl needs to be explicitly instantiated as well. I tried using the code in GotW #101 in VC 2010, and it did not link without expliclty instantiating pimpl where I implemented widget::impl.</p>
<p>MSN</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4582</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 13 Dec 2011 22:52:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4582</guid>
					<description><![CDATA[@Simon: I should have been clearer in the text about benefits of the helper. Using the helper, the code is simpler because if you write it yourself you also have to write out-of-line ctor, and have to remember to write the out-of-line dtor. The code is also more robust, because for example you can&#039;t forget to write the out-of-line dtor.]]></description>
		<content:encoded><![CDATA[<p>@Simon: I should have been clearer in the text about benefits of the helper. Using the helper, the code is simpler because if you write it yourself you also have to write out-of-line ctor, and have to remember to write the out-of-line dtor. The code is also more robust, because for example you can&#8217;t forget to write the out-of-line dtor.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4581</link>
		<dc:creator><![CDATA[Robert]]></dc:creator>
		<pubDate>Tue, 13 Dec 2011 20:47:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4581</guid>
					<description><![CDATA[@Andrzerj: I agree that you need to do it &quot;somehow&quot;. The question is what does this helper offer that is better than simply using std::unique_ptr? And yes, I would need to include  anyway, but in this case I could end up &quot;having&quot; to include &quot;pimpl.h&quot; AND . For me this is a case of is the extra hassle/complexity (however small) worth it?

I think this boils down to the case (which you describe) where you want a deep copy and would prefer automatic generation of c-const and c-assign. In any other case I cannot see any advantage for this approach over using std::unique_ptr directly.

&lt;q&gt;
One other reason to use such pimpl helper is that by only using something with name “pimpl” makes your intentions more clear. Anyone will easily see that you wanted to implement this idiom (even if you have made some error that prevents code analysis). But again, this is just an aesthetic matter.
&lt;/q&gt;

Indeed it is an aesthetic matter, though in my personal opinion &quot;struct implementation&quot; is a pretty big giveaway. You migth as well do a typedef on std::unique_ptr anc call it pimpl.]]></description>
		<content:encoded><![CDATA[<p>@Andrzerj: I agree that you need to do it &#8220;somehow&#8221;. The question is what does this helper offer that is better than simply using std::unique_ptr? And yes, I would need to include  anyway, but in this case I could end up &#8220;having&#8221; to include &#8220;pimpl.h&#8221; AND . For me this is a case of is the extra hassle/complexity (however small) worth it?</p>
<p>I think this boils down to the case (which you describe) where you want a deep copy and would prefer automatic generation of c-const and c-assign. In any other case I cannot see any advantage for this approach over using std::unique_ptr directly.</p>
<p><q><br />
One other reason to use such pimpl helper is that by only using something with name “pimpl” makes your intentions more clear. Anyone will easily see that you wanted to implement this idiom (even if you have made some error that prevents code analysis). But again, this is just an aesthetic matter.<br />
</q></p>
<p>Indeed it is an aesthetic matter, though in my personal opinion &#8220;struct implementation&#8221; is a pretty big giveaway. You migth as well do a typedef on std::unique_ptr anc call it pimpl.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrzej Krzemieński				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4580</link>
		<dc:creator><![CDATA[Andrzej Krzemieński]]></dc:creator>
		<pubDate>Tue, 13 Dec 2011 20:26:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4580</guid>
					<description><![CDATA[@Robert: You definitely need to implement a pimpl idiom *somehow*. If you choose to do it with a raw pointer you are risking lots of memory-management-related problems. If you choose to use *some* smart pointer you need to include an extra header file anyway. 

Now, which of the hundred possible smart pointers will you choose? The one that fits your task best. What does std::unique_ptr have to offer? (1). It will release memory in the destructor, (2). It will prevent the automatic generation of invalid copy constructor and copy assignment. 

Can other smart pointers offer something else? Something better? I think yes: they can offer simpler construction syntax, and automatic generation of the correct copy constructor and copy assignment (with deep copy semantics). If you want your class to be copyable it saves you a certain amount of &quot;boiler-plate&quot; code. How is such pointer called? It is not called yet (at least I haven&#039;t heard of such pointer), but you could call it pimpl. 

I guess the answer to question &quot;is it worth it?&quot; pretty much depends on your programming style, your taste, your environment&#039;s constraints, etc. If you do not want your class to be copyable -- such smart pointer is not any better for you than a std::unique_ptr. If you cannot afford including a header file, this solution is not for you (I can afford it, and put it into a pre-compiled header, to decrease compile-times).

One other reason to use such pimpl helper is that by only using something with name &quot;pimpl&quot; makes your intentions more clear. Anyone will easily see that you wanted to implement this idiom (even if you have made some error that prevents code analysis). But again, this is just an aesthetic matter.]]></description>
		<content:encoded><![CDATA[<p>@Robert: You definitely need to implement a pimpl idiom *somehow*. If you choose to do it with a raw pointer you are risking lots of memory-management-related problems. If you choose to use *some* smart pointer you need to include an extra header file anyway. </p>
<p>Now, which of the hundred possible smart pointers will you choose? The one that fits your task best. What does std::unique_ptr have to offer? (1). It will release memory in the destructor, (2). It will prevent the automatic generation of invalid copy constructor and copy assignment. </p>
<p>Can other smart pointers offer something else? Something better? I think yes: they can offer simpler construction syntax, and automatic generation of the correct copy constructor and copy assignment (with deep copy semantics). If you want your class to be copyable it saves you a certain amount of &#8220;boiler-plate&#8221; code. How is such pointer called? It is not called yet (at least I haven&#8217;t heard of such pointer), but you could call it pimpl. </p>
<p>I guess the answer to question &#8220;is it worth it?&#8221; pretty much depends on your programming style, your taste, your environment&#8217;s constraints, etc. If you do not want your class to be copyable &#8212; such smart pointer is not any better for you than a std::unique_ptr. If you cannot afford including a header file, this solution is not for you (I can afford it, and put it into a pre-compiled header, to decrease compile-times).</p>
<p>One other reason to use such pimpl helper is that by only using something with name &#8220;pimpl&#8221; makes your intentions more clear. Anyone will easily see that you wanted to implement this idiom (even if you have made some error that prevents code analysis). But again, this is just an aesthetic matter.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4579</link>
		<dc:creator><![CDATA[Robert]]></dc:creator>
		<pubDate>Tue, 13 Dec 2011 18:06:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4579</guid>
					<description><![CDATA[I don&#039;t quite see how this makes the pimpl any simpler? 

+ include extras files
- instead of pimpl_(new impl(params)), we now write pimpl(params)

Doesn&#039;t it actually make it more complex than using the pimpl idioms without any &quot;helper&quot;?]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t quite see how this makes the pimpl any simpler? </p>
<p>+ include extras files<br />
&#8211; instead of pimpl_(new impl(params)), we now write pimpl(params)</p>
<p>Doesn&#8217;t it actually make it more complex than using the pimpl idioms without any &#8220;helper&#8221;?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John Farrier				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4572</link>
		<dc:creator><![CDATA[John Farrier]]></dc:creator>
		<pubDate>Mon, 12 Dec 2011 21:43:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4572</guid>
					<description><![CDATA[I was reading this post and the previous GotW #100, and I was wondering:  Is there a benefit to using this idiom to help with C++/CLI Native/Managed interoperability?  

It would be nice to have custom controls and objects be more purely managed code, but I have to do a great deal of interaction with native libraries.  This can lead to Visual Studio designer instability, Visual Studio locking of DLL&#039;s, and difficult debugging with so many managed to native transitions.  Putting all of the managed/native interop code in an &quot;Impl&quot; managed class (and into a .cpp file and out of the header) may ease this type of development.]]></description>
		<content:encoded><![CDATA[<p>I was reading this post and the previous GotW #100, and I was wondering:  Is there a benefit to using this idiom to help with C++/CLI Native/Managed interoperability?  </p>
<p>It would be nice to have custom controls and objects be more purely managed code, but I have to do a great deal of interaction with native libraries.  This can lead to Visual Studio designer instability, Visual Studio locking of DLL&#8217;s, and difficult debugging with so many managed to native transitions.  Putting all of the managed/native interop code in an &#8220;Impl&#8221; managed class (and into a .cpp file and out of the header) may ease this type of development.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrzej Krzemieński				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4563</link>
		<dc:creator><![CDATA[Andrzej Krzemieński]]></dc:creator>
		<pubDate>Fri, 09 Dec 2011 14:39:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4563</guid>
					<description><![CDATA[@Simon: In Herb&#039;s pimpl the difference seems to be in the variadic constructor. But you could also use different pimpl that provides value semantics: deep copy and deep assignment (unique_ptr provides shallow copy and assignment). Then your class gets copy and assignment for free (generated by compiler).]]></description>
		<content:encoded><![CDATA[<p>@Simon: In Herb&#8217;s pimpl the difference seems to be in the variadic constructor. But you could also use different pimpl that provides value semantics: deep copy and deep assignment (unique_ptr provides shallow copy and assignment). Then your class gets copy and assignment for free (generated by compiler).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4561</link>
		<dc:creator><![CDATA[Simon]]></dc:creator>
		<pubDate>Fri, 09 Dec 2011 11:19:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4561</guid>
					<description><![CDATA[Herb, I notice you&#039;ve changed your original solution to a simpler one, but as far as I can tell, your new solution basically amounts to writing the solution to #100 in a very round-about way when #100 is good enough as it is. At least the original inherited solution to #101 saved you writing the pimpl management code time and time again. This new solution doesn&#039;t even do that.

Now, instead of writing:

[code]
class widget {
  class impl;
  std::unique_ptr&#060;impl&#062; d;
};
[/code]

you write:

[code]
class widget {
  class impl;
  pimpl&#060;impl&#062; d;
};
[/code]

Seems to me like its the same result and doesn&#039;t save us writing any code.

I&#039;m sure I must be missing something.]]></description>
		<content:encoded><![CDATA[<p>Herb, I notice you&#8217;ve changed your original solution to a simpler one, but as far as I can tell, your new solution basically amounts to writing the solution to #100 in a very round-about way when #100 is good enough as it is. At least the original inherited solution to #101 saved you writing the pimpl management code time and time again. This new solution doesn&#8217;t even do that.</p>
<p>Now, instead of writing:</p>
<pre class="brush: plain; title: ; notranslate">
class widget {
  class impl;
  std::unique_ptr&lt;impl&gt; d;
};
</pre>
<p>you write:</p>
<pre class="brush: plain; title: ; notranslate">
class widget {
  class impl;
  pimpl&lt;impl&gt; d;
};
</pre>
<p>Seems to me like its the same result and doesn&#8217;t save us writing any code.</p>
<p>I&#8217;m sure I must be missing something.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrzej Krzemieński				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4559</link>
		<dc:creator><![CDATA[Andrzej Krzemieński]]></dc:creator>
		<pubDate>Thu, 08 Dec 2011 11:02:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4559</guid>
					<description><![CDATA[Herb, I encountered a tiny problem when using pimpls like the one you describe. Perhaps you know how to solve it better. Or perhaps you could mention it your GOTW item.

I try to apply the rule &quot;treat warnings as errors&quot;, and my problem is in fact about an annoying warning. (Annoying because it is a &quot;template&quot; which spreads across many, many lines)

I am using VS compilers. I am exposing my class, lets call it Flight, as part of the interface of my DLL, so it is declared as:

[code]
class EXPORT_MODE LFlight
{
  // ...
}; 
[/code]

where EXPORT_MODE is either __declspec(dllexport) or __declspec(dllimport), based on who is including the header. I think this is a standard and recommended practice? 

I do not want to expose the guts of Flight to the users of my DLL, so I use pimpl, but in fact I end up exposing the pimpl template to anyone. In the end I get warning C4251: &quot;[class template] needs to have dll-interface to be used by clients of class LFlight&quot;. This is a general issue of exposing template members as part of dll interface. But pimpl, on the other hand, should be just the right tool for such &quot;dll firewall&quot;.

I fix this problem by adding additional declarations which introduce explicit external EXPORT_MODE specializations for pimpl:

  extern template class __declspec(dllimport) pimpl;
or
  template class __declspec(dllexport) pimpl;

based on who is including the header. Is this the only way?

Regards,
&#038;rzej]]></description>
		<content:encoded><![CDATA[<p>Herb, I encountered a tiny problem when using pimpls like the one you describe. Perhaps you know how to solve it better. Or perhaps you could mention it your GOTW item.</p>
<p>I try to apply the rule &#8220;treat warnings as errors&#8221;, and my problem is in fact about an annoying warning. (Annoying because it is a &#8220;template&#8221; which spreads across many, many lines)</p>
<p>I am using VS compilers. I am exposing my class, lets call it Flight, as part of the interface of my DLL, so it is declared as:</p>
<pre class="brush: plain; title: ; notranslate">
class EXPORT_MODE LFlight
{
  // ...
}; 
</pre>
<p>where EXPORT_MODE is either __declspec(dllexport) or __declspec(dllimport), based on who is including the header. I think this is a standard and recommended practice? </p>
<p>I do not want to expose the guts of Flight to the users of my DLL, so I use pimpl, but in fact I end up exposing the pimpl template to anyone. In the end I get warning C4251: &#8220;[class template] needs to have dll-interface to be used by clients of class LFlight&#8221;. This is a general issue of exposing template members as part of dll interface. But pimpl, on the other hand, should be just the right tool for such &#8220;dll firewall&#8221;.</p>
<p>I fix this problem by adding additional declarations which introduce explicit external EXPORT_MODE specializations for pimpl:</p>
<p>  extern template class __declspec(dllimport) pimpl;<br />
or<br />
  template class __declspec(dllexport) pimpl;</p>
<p>based on who is including the header. Is this the only way?</p>
<p>Regards,<br />
&amp;rzej</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4537</link>
		<dc:creator><![CDATA[Robert]]></dc:creator>
		<pubDate>Sat, 03 Dec 2011 18:11:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4537</guid>
					<description><![CDATA[Shouldn&#039;t you also include copy/move constructors?

&lt;code&gt;
pimpl(std::unique_ptr&#038;&#038; other);
pimpl(const std::unique_ptr&#038; other);

template
pimpl::pimpl(std::unique_ptr&#060;typename pimpl::impl&#062;&#038;&#038; other) : m(std::move(other)){}
	
template
pimpl::pimpl(const typename std::unique_ptr&#060;typename pimpl::impl&#062;&#038; other) : m(new pimpl::impl(*other)){}
&lt;/code&gt;

or maybe even?

&lt;code&gt;
pimpl(T&#038;&#038; other);
pimpl(const T&#038; other);

template
pimpl::pimpl(T&#038;&#038; other) : m(std::move(other.m)){}
	
template
pimpl::pimpl(const T&#038; other) : impl_(new pimpl::m(*other.impl_)){}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>Shouldn&#8217;t you also include copy/move constructors?</p>
<p><code><br />
pimpl(std::unique_ptr&amp;&amp; other);<br />
pimpl(const std::unique_ptr&amp; other);</p>
<p>template<br />
pimpl::pimpl(std::unique_ptr&lt;typename pimpl::impl&gt;&amp;&amp; other) : m(std::move(other)){}</p>
<p>template<br />
pimpl::pimpl(const typename std::unique_ptr&lt;typename pimpl::impl&gt;&amp; other) : m(new pimpl::impl(*other)){}<br />
</code></p>
<p>or maybe even?</p>
<p><code><br />
pimpl(T&amp;&amp; other);<br />
pimpl(const T&amp; other);</p>
<p>template<br />
pimpl::pimpl(T&amp;&amp; other) : m(std::move(other.m)){}</p>
<p>template<br />
pimpl::pimpl(const T&amp; other) : impl_(new pimpl::m(*other.impl_)){}<br />
</code></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michal Mocny				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4535</link>
		<dc:creator><![CDATA[Michal Mocny]]></dc:creator>
		<pubDate>Sat, 03 Dec 2011 16:24:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4535</guid>
					<description><![CDATA[I have tried to write a similar helper class before, but had not thought to use a perfect forwarding constructor for initialization. Cool.
 
However, I really dislike the naming of pimpl.cpp, because I dislike seeing cpp files in include statements, and especially since this one is merely a template implementation file, which often have a special file extension (tpp?). Personally, I just leave them as .h files but would name them something like pimpl_fwd.h and pimpl_impl.h]]></description>
		<content:encoded><![CDATA[<p>I have tried to write a similar helper class before, but had not thought to use a perfect forwarding constructor for initialization. Cool.</p>
<p>However, I really dislike the naming of pimpl.cpp, because I dislike seeing cpp files in include statements, and especially since this one is merely a template implementation file, which often have a special file extension (tpp?). Personally, I just leave them as .h files but would name them something like pimpl_fwd.h and pimpl_impl.h</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4533</link>
		<dc:creator><![CDATA[Robert]]></dc:creator>
		<pubDate>Sat, 03 Dec 2011 16:08:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4533</guid>
					<description><![CDATA[Would it be possible to extend the pimpl class and provide default implementation for some common methods? e.g. swap?
 
class pimpl {
protected:
class impl;
std::unique_ptr m;
 
public:
void swap(pimpl&#038; other)
{
m.swap(other.m);
}
 
};]]></description>
		<content:encoded><![CDATA[<p>Would it be possible to extend the pimpl class and provide default implementation for some common methods? e.g. swap?</p>
<p>class pimpl {<br />
protected:<br />
class impl;<br />
std::unique_ptr m;</p>
<p>public:<br />
void swap(pimpl&amp; other)<br />
{<br />
m.swap(other.m);<br />
}</p>
<p>};</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert				</title>
				<link>https://herbsutter.com/2011/12/02/gotw-101-solution/#comment-4532</link>
		<dc:creator><![CDATA[Robert]]></dc:creator>
		<pubDate>Sat, 03 Dec 2011 16:08:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1107#comment-4532</guid>
					<description><![CDATA[I see 2 potential problems with this:
 
First of, template class pimpl::impl will need to be in the namespace as “pimpl”.
 
So if widget is in its own namespace, then the implementation will need to be in a different one?
 
.h
 
namespace foo {
 
class widget : public pimpl {…}
 
}
 
.cpp
 
using namespace foo;
 
template class pimpl::impl
 
namespace foo {
 
widget::widget() : pimpl(){}
 
}
 
Second, what about inheritance? Will that not cause ambiguity?
 
class widget : public pimpl {…}
class clock : public widget, public pimpl{…} // what pimpl to use?]]></description>
		<content:encoded><![CDATA[<p>I see 2 potential problems with this:</p>
<p>First of, template class pimpl::impl will need to be in the namespace as “pimpl”.</p>
<p>So if widget is in its own namespace, then the implementation will need to be in a different one?</p>
<p>.h</p>
<p>namespace foo {</p>
<p>class widget : public pimpl {…}</p>
<p>}</p>
<p>.cpp</p>
<p>using namespace foo;</p>
<p>template class pimpl::impl</p>
<p>namespace foo {</p>
<p>widget::widget() : pimpl(){}</p>
<p>}</p>
<p>Second, what about inheritance? Will that not cause ambiguity?</p>
<p>class widget : public pimpl {…}<br />
class clock : public widget, public pimpl{…} // what pimpl to use?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
