<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: C++ AMP keynote is online	</title>
	<atom:link href="https://herbsutter.com/2011/06/16/c-amp-keynote/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2011/06/16/c-amp-keynote/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: GPU: Pricing and Risk &#8211; C++ AMP &#171; Tales from a Trading Desk				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3586</link>
		<dc:creator><![CDATA[GPU: Pricing and Risk &#8211; C++ AMP &#171; Tales from a Trading Desk]]></dc:creator>
		<pubDate>Thu, 29 Sep 2011 19:16:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3586</guid>
					<description><![CDATA[[...] recall from Herb&#8217;s keynote that Microsoft is pushing C++ AMP as &#8220;open&#8221;. How long before NVIDIA offer C++ AMP [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] recall from Herb&#8217;s keynote that Microsoft is pushing C++ AMP as &#8220;open&#8221;. How long before NVIDIA offer C++ AMP [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brandi				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3293</link>
		<dc:creator><![CDATA[Brandi]]></dc:creator>
		<pubDate>Tue, 09 Aug 2011 11:30:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3293</guid>
					<description><![CDATA[Slam dunkin like Shaquille O&#039;Neal, if he wrote ifnomartive articles.]]></description>
		<content:encoded><![CDATA[<p>Slam dunkin like Shaquille O&#8217;Neal, if he wrote ifnomartive articles.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Neues Projekt unter .Net: c# oder Prism - Seite 4 - Delphi-PRAXiS				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3271</link>
		<dc:creator><![CDATA[Neues Projekt unter .Net: c# oder Prism - Seite 4 - Delphi-PRAXiS]]></dc:creator>
		<pubDate>Fri, 22 Jul 2011 07:54:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3271</guid>
					<description><![CDATA[[...]  [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;]  [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3266</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 19 Jul 2011 14:38:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3266</guid>
					<description><![CDATA[@JSawyer: Those are good questions. We&#039;ve considered those things and intend to do some of them. Briefly:

Tag/version: &quot;direct3d&quot; is a placeholder and we agree it implies the wrong thing because nothing about the model is DX-specific, so we&#039;ll probably rename this tag. Versions are accounted for in the design with a :## syntax (e.g., restrict(direct3d:11.1) but are not needed in the initial release. Yes, you can use macros for these.

The &quot;restrict&quot; name: Several people internally and externally have suggested renaming &#039;restrict&#039; to &#039;target&#039; because they have a view that this is about target platforms/cores. That&#039;s too narrow a view; this is a general-purpose facility for language _restrictions_ that is integrated into the language and can handle more than just targets (just as lambdas are a general-purpose facility that can handle more than just parallel algorithms).

Timeframe: We haven&#039;t announced a specific schedule yet, but have said that C++ AMP bits will be available later this year.

Thanks,

Herb]]></description>
		<content:encoded><![CDATA[<p>@JSawyer: Those are good questions. We&#8217;ve considered those things and intend to do some of them. Briefly:</p>
<p>Tag/version: &#8220;direct3d&#8221; is a placeholder and we agree it implies the wrong thing because nothing about the model is DX-specific, so we&#8217;ll probably rename this tag. Versions are accounted for in the design with a :## syntax (e.g., restrict(direct3d:11.1) but are not needed in the initial release. Yes, you can use macros for these.</p>
<p>The &#8220;restrict&#8221; name: Several people internally and externally have suggested renaming &#8216;restrict&#8217; to &#8216;target&#8217; because they have a view that this is about target platforms/cores. That&#8217;s too narrow a view; this is a general-purpose facility for language _restrictions_ that is integrated into the language and can handle more than just targets (just as lambdas are a general-purpose facility that can handle more than just parallel algorithms).</p>
<p>Timeframe: We haven&#8217;t announced a specific schedule yet, but have said that C++ AMP bits will be available later this year.</p>
<p>Thanks,</p>
<p>Herb</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JSawyer				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3264</link>
		<dc:creator><![CDATA[JSawyer]]></dc:creator>
		<pubDate>Sun, 17 Jul 2011 10:50:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3264</guid>
					<description><![CDATA[Hello! I&#039;ve never done GPGPU, but our financial applications are increasingly computation intensive and AMP seems like a nice way to go. I&#039;ve watched your presentation, but I have I few concerns though.

- the &quot;restrict&quot; keyword. I know it is a C99 keyword, but is it the most descriptive one? The &quot;restrict&quot; keyword could actually be used not to &quot;restrict&quot; the language features within {} block, but to &quot;expand&quot; them. Maybe as suggested by others, &quot;target&quot; and &quot;platform&quot; are more suitable keywords. I&#039;m against keyword inflation, but for the sake a clarity, maybe a new keyword should be considered?

restrict(direct3d):
 - should the target parameter be used with or without quotes?
 - should it have another (optional) parameter, such as version?
 - is direct3d the most suitable description for DirectCompute or DirectX 11?

I would much rather see it like this:
restrict(&quot;OpenCL&quot;, 1.1)
restrict(&quot;DirectCompute&quot;, 11)
restrict(&quot;pure&quot;)
Or with restrict keyword changed to platform / target.

This way the programmer could define _targetname and _targetversion constants (within ifdef etc.) and use:
restrict(_targetname, _targetversion)

_targetname would have to be a string, while _targetversion should be a float (to cover point versions, such as 1.1). If &quot;pure&quot;, the _targetversion could be ignored.

But then again, what about multi-targeting? If I&#039;d like my code to run both on OpenCL 1.1 and DirectCompute 11?
maybe restrict (OpenCL11; DirectCompute11) for a common set of features?
Maybe really a preprocessor should define _mytargets, that contain both OpenCL 1.1 and DirectCompute 11 targets?

All in all, the approach seems quite interesting. But when could we start using AMP? What is the time frame for shipping CTP or release versions of AMP?]]></description>
		<content:encoded><![CDATA[<p>Hello! I&#8217;ve never done GPGPU, but our financial applications are increasingly computation intensive and AMP seems like a nice way to go. I&#8217;ve watched your presentation, but I have I few concerns though.</p>
<p>&#8211; the &#8220;restrict&#8221; keyword. I know it is a C99 keyword, but is it the most descriptive one? The &#8220;restrict&#8221; keyword could actually be used not to &#8220;restrict&#8221; the language features within {} block, but to &#8220;expand&#8221; them. Maybe as suggested by others, &#8220;target&#8221; and &#8220;platform&#8221; are more suitable keywords. I&#8217;m against keyword inflation, but for the sake a clarity, maybe a new keyword should be considered?</p>
<p>restrict(direct3d):<br />
 &#8211; should the target parameter be used with or without quotes?<br />
 &#8211; should it have another (optional) parameter, such as version?<br />
 &#8211; is direct3d the most suitable description for DirectCompute or DirectX 11?</p>
<p>I would much rather see it like this:<br />
restrict(&#8220;OpenCL&#8221;, 1.1)<br />
restrict(&#8220;DirectCompute&#8221;, 11)<br />
restrict(&#8220;pure&#8221;)<br />
Or with restrict keyword changed to platform / target.</p>
<p>This way the programmer could define _targetname and _targetversion constants (within ifdef etc.) and use:<br />
restrict(_targetname, _targetversion)</p>
<p>_targetname would have to be a string, while _targetversion should be a float (to cover point versions, such as 1.1). If &#8220;pure&#8221;, the _targetversion could be ignored.</p>
<p>But then again, what about multi-targeting? If I&#8217;d like my code to run both on OpenCL 1.1 and DirectCompute 11?<br />
maybe restrict (OpenCL11; DirectCompute11) for a common set of features?<br />
Maybe really a preprocessor should define _mytargets, that contain both OpenCL 1.1 and DirectCompute 11 targets?</p>
<p>All in all, the approach seems quite interesting. But when could we start using AMP? What is the time frame for shipping CTP or release versions of AMP?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Enterprise Headlines and Summaries, June 2011				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3235</link>
		<dc:creator><![CDATA[Enterprise Headlines and Summaries, June 2011]]></dc:creator>
		<pubDate>Fri, 01 Jul 2011 23:13:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3235</guid>
					<description><![CDATA[[...] #Microsoft C++ AMP keynote is online The main reasons we decided to build a new model is that we believe there needs to be a single model that has all of the following attributes:&#160; [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] #Microsoft C++ AMP keynote is online The main reasons we decided to build a new model is that we believe there needs to be a single model that has all of the following attributes:&nbsp; [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thierry Seegers				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3234</link>
		<dc:creator><![CDATA[Thierry Seegers]]></dc:creator>
		<pubDate>Fri, 01 Jul 2011 20:47:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3234</guid>
					<description><![CDATA[I have some questions about the MatrixMult example presented. That function has, in its body, a lambda that is restrict(direct3d). The function itself, though, defaults to restrict(cpu). What does that mean? Given that it is implemented in terms of a restrict(direct3d) piece of code, doesn&#039;t that make the whole function restrict(direct3d)? And what happens when I run this code in a box with no GPU?]]></description>
		<content:encoded><![CDATA[<p>I have some questions about the MatrixMult example presented. That function has, in its body, a lambda that is restrict(direct3d). The function itself, though, defaults to restrict(cpu). What does that mean? Given that it is implemented in terms of a restrict(direct3d) piece of code, doesn&#8217;t that make the whole function restrict(direct3d)? And what happens when I run this code in a box with no GPU?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3211</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 27 Jun 2011 17:13:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3211</guid>
					<description><![CDATA[All questions of that form involve a scheduler that is responsible for mapping app workload to hardware and. Traditionally, app threads are mapped to cores by the OS scheduler, and this includes performing preemption to share a core when there are fewer cores than ready threads.  PPL tasks are mapped to cores by the ConcRT scheduler. C++ AMP tasks are mapped to specialized cores by the underlying scheduler, which initially is DirectCompute and can be other schedulers tomorrow.

The key thing is to have one scheduler for a given piece of hardware, and avoid having multiple different schedulers both think they own the same hardware and oversubscribing it. For a multicore example, it would be bad if Microsoft PPL&#039;s ConcRT scheduler and Intel&#039;s OpenMP scheduler both thought they owned the whole machine; it was that way at first, but the latter has now been implemented on top of the former so that they will share more nicely. The industry will continue to engineer under the covers to improve scheduling in this kind of way.]]></description>
		<content:encoded><![CDATA[<p>All questions of that form involve a scheduler that is responsible for mapping app workload to hardware and. Traditionally, app threads are mapped to cores by the OS scheduler, and this includes performing preemption to share a core when there are fewer cores than ready threads.  PPL tasks are mapped to cores by the ConcRT scheduler. C++ AMP tasks are mapped to specialized cores by the underlying scheduler, which initially is DirectCompute and can be other schedulers tomorrow.</p>
<p>The key thing is to have one scheduler for a given piece of hardware, and avoid having multiple different schedulers both think they own the same hardware and oversubscribing it. For a multicore example, it would be bad if Microsoft PPL&#8217;s ConcRT scheduler and Intel&#8217;s OpenMP scheduler both thought they owned the whole machine; it was that way at first, but the latter has now been implemented on top of the former so that they will share more nicely. The industry will continue to engineer under the covers to improve scheduling in this kind of way.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kaz Dragon				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3202</link>
		<dc:creator><![CDATA[Kaz Dragon]]></dc:creator>
		<pubDate>Mon, 27 Jun 2011 10:26:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3202</guid>
					<description><![CDATA[First off, I really like this concept, the syntax that goes with it, and pretty much everything about it.

I do have a couple of points of curiosity, though, although this may be my naïveté about GPUs: presuming this becomes a mainstream programming paradigm, what&#039;s going to happen when multiple applications try and offload data processing to the GPU at the same time?  For example, you&#039;re playing a game of &quot;Generic FPS 2015&quot;, running &quot;Cloud Project @Home&quot; in the background, and your virus scanner kicks in.  All of these compete for the resources on the GPU.  Will it play nicely?

From a more local perspective, what happens if, within one program, one thread kicks off some GPU parallel processing in one thread, then some other thread does the same, with a different algorithm on a different dataset.  Will one computation have to wait for the other to complete entirely before starting, or will it be able to run on parts of the GPU that are &quot;finished&quot; or otherwise unallocated?  Or option c): other?]]></description>
		<content:encoded><![CDATA[<p>First off, I really like this concept, the syntax that goes with it, and pretty much everything about it.</p>
<p>I do have a couple of points of curiosity, though, although this may be my naïveté about GPUs: presuming this becomes a mainstream programming paradigm, what&#8217;s going to happen when multiple applications try and offload data processing to the GPU at the same time?  For example, you&#8217;re playing a game of &#8220;Generic FPS 2015&#8221;, running &#8220;Cloud Project @Home&#8221; in the background, and your virus scanner kicks in.  All of these compete for the resources on the GPU.  Will it play nicely?</p>
<p>From a more local perspective, what happens if, within one program, one thread kicks off some GPU parallel processing in one thread, then some other thread does the same, with a different algorithm on a different dataset.  Will one computation have to wait for the other to complete entirely before starting, or will it be able to run on parts of the GPU that are &#8220;finished&#8221; or otherwise unallocated?  Or option c): other?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: thomas				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3172</link>
		<dc:creator><![CDATA[thomas]]></dc:creator>
		<pubDate>Tue, 21 Jun 2011 14:46:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3172</guid>
					<description><![CDATA[sooo could this mean a whole new level for pc gaming &#038; graphics?

or easier to program direct to metal?]]></description>
		<content:encoded><![CDATA[<p>sooo could this mean a whole new level for pc gaming &amp; graphics?</p>
<p>or easier to program direct to metal?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3171</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 23:05:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3171</guid>
					<description><![CDATA[@Herb Sutter:  Thanks for the explanation.  I didn&#039;t realize how weak &lt;code&gt;extern &quot;C&quot; { ... }&lt;/code&gt; actually is as a language linkage.  From the current draft standard ( http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf ), N3291 § 7.5 does a pretty good job of explaining what &lt;code&gt;extern &quot;langage name&quot; { ... }&lt;/code&gt; __cannot__ do.

ASIDE: It would be nice if the draft standard detailed what &lt;code&gt;extern &quot;langage name&quot; { ... }&lt;/code&gt; could do ... especially, how &lt;code&gt;extern &quot;langage name&quot; { ... }&lt;/code&gt; compared to the seemingly more restrictive &lt;code&gt;extern &quot;C&quot; { ... }&lt;/code&gt;.

While &lt;code&gt;restrict( direct3d ) { ... }&lt;/code&gt; implies restricting the compiler to a proper subset of C++ that is useful for the current version of the HLSL Compute Shader in the current version of Direct3D, there is no guarantee that this subset will remain proper over future versions of HLSL ... it very well could become a set with some features of C++ and some features not in C++ ... or blossom into an improper subset or a superset of C++ ... who knows ... so we might just be &lt;code&gt;restrict-ing in the short term and find ourselves with an odd keyword in the future.

Moreover, while it&#039;s convenient that C99 has &lt;code&gt;restrict&lt;/code&gt; as a reserved word, &lt;code&gt;restrict&lt;/code&gt; doesn&#039;t really get to the heart of the matter.  We are asking the compiler&#039;s backend to do something other than the default ... instead of producing x86/x64 instructions, we want the compiler to produce HLSL Compute Shader bytecode or Azure library calls or whatever.  Words/phrases that immediately come to mind are: target, emit, compile to, produce, build ... or even: language, specification, platform, architecture, ... but not &quot;restrict&quot;.  I think that something like &lt;code&gt;target( HLSL 5.0, OpenCL 1.0, Azure 1.0, MPI 2.2 ) { ... }&lt;/code&gt; ... or &lt;code&gt;emit( HLSL, OpenCL, Azure, MPI ) { ... }&lt;/code&gt; with compiler switches for version 5.0 of HLSL language, version 1.0 of the OpenCL spec, version 1.0 of the Azure library, and version 2.2 of the MPI spec/library ... or &lt;code&gt;platform( gpu, cloud )  { ... }&lt;/code&gt; with compiler switches for HLSL 5.0 language &#038; OpenCL 1.0 spec for gpu and Azure 1.0 library &#038; MPI 2.2 spec/library for cloud (but defaulting to normal C++0x if I forget to add those compiler switches) ... or some combination of these would get more to the point ... and be a little more future-proof.

Very Respectfully,
Joshua Burkholder

P.S. - Alternatively, you could just lift the restrictions from &lt;code&gt;extern &quot;language name&quot; { ... }&lt;/code&gt; that the current draft standard imposes and make any necessary additions ... esp., since you are going to be embracing and extending the C++0x language anyway.  Since  &lt;code&gt;extern &quot;language name&quot; { ... }&lt;/code&gt; was intended for language linkage ... and that seems to be what you are doing here, then you could just add the ability to place &lt;code&gt;extern &quot;language name&quot; { ... }&lt;/code&gt; in any scope, to place it on any lambda or member function, and to restrict the C++ language based on the &lt;code&gt;&quot;language name&quot;&lt;/code&gt; string within the scope of &lt;code&gt;extern &quot;language name&quot; { ... }&lt;/code&gt;.  In other words, a lambda could be written as: &lt;code&gt;[=] ( index&#060;2&#062;(1, 2) ) extern &quot;HLSL 5.0&quot; { ... /* restrict C++ to features that produce compiler-backend intermediate forms that are compatible with HLSL 5.0 compiler-backend intermediate forms */ ... }&lt;/code&gt; ... or something like that.]]></description>
		<content:encoded><![CDATA[<p>@Herb Sutter:  Thanks for the explanation.  I didn&#8217;t realize how weak <code>extern "C" { ... }</code> actually is as a language linkage.  From the current draft standard ( <a href="http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n3291.pdf</a> ), N3291 § 7.5 does a pretty good job of explaining what <code>extern "langage name" { ... }</code> __cannot__ do.</p>
<p>ASIDE: It would be nice if the draft standard detailed what <code>extern "langage name" { ... }</code> could do &#8230; especially, how <code>extern "langage name" { ... }</code> compared to the seemingly more restrictive <code>extern "C" { ... }</code>.</p>
<p>While <code>restrict( direct3d ) { ... }</code> implies restricting the compiler to a proper subset of C++ that is useful for the current version of the HLSL Compute Shader in the current version of Direct3D, there is no guarantee that this subset will remain proper over future versions of HLSL &#8230; it very well could become a set with some features of C++ and some features not in C++ &#8230; or blossom into an improper subset or a superset of C++ &#8230; who knows &#8230; so we might just be <code>restrict-ing in the short term and find ourselves with an odd keyword in the future.</p>
<p>Moreover, while it's convenient that C99 has </code><code>restrict</code> as a reserved word, <code>restrict</code> doesn't really get to the heart of the matter.  We are asking the compiler's backend to do something other than the default ... instead of producing x86/x64 instructions, we want the compiler to produce HLSL Compute Shader bytecode or Azure library calls or whatever.  Words/phrases that immediately come to mind are: target, emit, compile to, produce, build ... or even: language, specification, platform, architecture, ... but not "restrict".  I think that something like <code>target( HLSL 5.0, OpenCL 1.0, Azure 1.0, MPI 2.2 ) { ... }</code> ... or <code>emit( HLSL, OpenCL, Azure, MPI ) { ... }</code> with compiler switches for version 5.0 of HLSL language, version 1.0 of the OpenCL spec, version 1.0 of the Azure library, and version 2.2 of the MPI spec/library ... or <code>platform( gpu, cloud )  { ... }</code> with compiler switches for HLSL 5.0 language &amp; OpenCL 1.0 spec for gpu and Azure 1.0 library &amp; MPI 2.2 spec/library for cloud (but defaulting to normal C++0x if I forget to add those compiler switches) ... or some combination of these would get more to the point ... and be a little more future-proof.</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
<p>P.S. - Alternatively, you could just lift the restrictions from <code>extern "language name" { ... }</code> that the current draft standard imposes and make any necessary additions ... esp., since you are going to be embracing and extending the C++0x language anyway.  Since  <code>extern "language name" { ... }</code> was intended for language linkage ... and that seems to be what you are doing here, then you could just add the ability to place <code>extern "language name" { ... }</code> in any scope, to place it on any lambda or member function, and to restrict the C++ language based on the <code>"language name"</code> string within the scope of <code>extern "language name" { ... }</code>.  In other words, a lambda could be written as: <code>[=] ( index&lt;2&gt;(1, 2) ) extern "HLSL 5.0" { ... /* restrict C++ to features that produce compiler-backend intermediate forms that are compatible with HLSL 5.0 compiler-backend intermediate forms */ ... }</code> ... or something like that.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3169</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:25:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3169</guid>
					<description><![CDATA[The trouble with extern is that it&#039;s not fully integrated into the language. Here are a few examples: 1. It&#039;s important to be able to overload on these qualifiers even when only the qualifier is different. 2. You want to be able to express restrictions on all functions, including member functions and lambdas, not just namespace-scope functions. 3. You also have to be able to put restriction qualifiers on pointers to functions and other associated language features. There are more examples, but those are the kinds of things that are necessary to get to a fully integrated design, where this new feature is an orthogonal feature that works with everything else that&#039;s already there in the language, so that it just works with other language features as expected without surprises/limitations.]]></description>
		<content:encoded><![CDATA[<p>The trouble with extern is that it&#8217;s not fully integrated into the language. Here are a few examples: 1. It&#8217;s important to be able to overload on these qualifiers even when only the qualifier is different. 2. You want to be able to express restrictions on all functions, including member functions and lambdas, not just namespace-scope functions. 3. You also have to be able to put restriction qualifiers on pointers to functions and other associated language features. There are more examples, but those are the kinds of things that are necessary to get to a fully integrated design, where this new feature is an orthogonal feature that works with everything else that&#8217;s already there in the language, so that it just works with other language features as expected without surprises/limitations.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3168</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:24:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3168</guid>
					<description><![CDATA[Here is another (potentially naive) way to allow the coordinate and matrix perspectives to coexist (…again limited to an index&#060;2&#062; example, but using unions instead of references…):
&lt;code&gt;//===================================================================
#include&#160;&#060;iostream&#062;
&#160;
using&#160;namespace&#160;std;
&#160;
template&#160;&#060;&#160;size_t&#160;N&#160;&#062;
struct&#160;index;
&#160;
template&#160;&#060;&#062;
struct&#160;index&#060;&#160;2&#160;&#062;&#160;{
&#160;&#160;&#160;&#160;union&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;x;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;column;
&#160;&#160;&#160;&#160;};
&#160;&#160;&#160;&#160;union&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;y;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;row;
&#160;&#160;&#160;&#160;};
&#160;&#160;&#160;&#160;index&#160;(&#160;int&#160;x,&#160;int&#160;y&#160;)&#160;:&#160;x(&#160;x&#160;),&#160;y(&#160;y&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
};

template&#160;&#060;&#160;size_t&#160;N&#160;&#062;
struct&#160;matrix_index;

template&#160;&#060;&#062;
struct&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;:&#160;public&#160;index&#060;&#160;2&#160;&#062;&#160;{
&#160;&#160;&#160;&#160;matrix_index&#160;(&#160;int&#160;row,&#160;int&#160;column&#160;)&#160;:&#160;index&#060;&#160;2&#160;&#062;(&#160;column,&#160;row&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;matrix_index&#160;(&#160;index&#060;&#160;2&#160;&#062;&#160;const&#160;&#038;&#160;i&#160;)&#160;:&#160;index&#060;&#160;2&#160;&#062;(&#160;i&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
};
&#160;
std::ostream&#160;&#038;&#160;operator&#160;&#060;&#060;&#160;(&#160;std::ostream&#160;&#038;&#160;os,&#160;index&#060;&#160;2&#160;&#062;&#160;const&#160;&#038;&#160;i&#160;)&#160;{
&#160;&#160;&#160;&#160;os&#160;&#060;&#060;&#160;&quot;(&#160;&#160;&#160;x:&#160;&quot;&#160;&#060;&#060;&#160;i.x&#160;&#160;&#160;&#060;&#060;&#160;&quot;,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;&quot;&#160;&#060;&#060;&#160;i.y&#160;&#160;&#160;&#160;&#160;&#160;&#060;&#060;&#160;&quot;&#160;)&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;os&#160;&#060;&#060;&#160;&quot;[&#160;row:&#160;&quot;&#160;&#060;&#060;&#160;i.row&#160;&#060;&#060;&#160;&quot;,&#160;column:&#160;&quot;&#160;&#060;&#060;&#160;i.column&#160;&#060;&#060;&#160;&quot;&#160;)&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;return&#160;os;
}
&#160;
int&#160;main&#160;()&#160;{
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;sizeof(&#160;index&#060;&#160;2&#160;&#062;&#160;):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;&#160;&#060;&#060;&#160;sizeof(&#160;index&#060;&#160;2&#160;&#062;&#160;)&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;sizeof(&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;):&#160;&quot;&#160;&#060;&#060;&#160;sizeof(&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;)&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;index&#060;&#160;2&#160;&#062;&#160;i(&#160;2,&#160;3&#160;);
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;index&#060;&#160;2&#160;&#062;&#160;i(&#160;2,&#160;3&#160;);&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;i:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;i&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;i.x&#160;=&#160;5;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;i.x&#160;=&#160;5;&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;i:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;i&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;mi(&#160;3,&#160;2&#160;);
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;matrix_index&#060;&#160;2&#160;&#062;&#160;mi(&#160;3,&#160;2&#160;);&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;mi:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;mi&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;mi.column&#160;=&#160;5;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;mi.column&#160;=&#160;5;&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;mi:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;mi&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;//&#160;compilation&#160;checks:
&#160;&#160;&#160;&#160;index&#060;&#160;2&#160;&#062;&#160;i2(&#160;i&#160;);
&#160;&#160;&#160;&#160;index&#060;&#160;2&#160;&#062;&#160;i3(&#160;mi&#160;);
&#160;&#160;&#160;&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;mi2(&#160;i&#160;);
&#160;&#160;&#160;&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;mi3(&#160;mi&#160;);
&#160;&#160;&#160;&#160;i2&#160;=&#160;mi;
&#160;&#160;&#160;&#160;i3&#160;=&#160;i;
&#160;&#160;&#160;&#160;mi2&#160;=&#160;mi;
&#160;&#160;&#160;&#160;mi3&#160;=&#160;i;
&#160;&#160;&#160;&#160;return&#160;0;
}
//===================================================================
&lt;/code&gt;
At run-time, the code above produces the following:

&lt;code&gt;sizeof(&#160;index&#060;&#160;2&#160;&#062;&#160;):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;8
sizeof(&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;):&#160;8

index&#060;&#160;2&#160;&#062;&#160;i(&#160;2,&#160;3&#160;);
i:
(&#160;&#160;&#160;x:&#160;2,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;2&#160;)

i.x&#160;=&#160;5;
i:
(&#160;&#160;&#160;x:&#160;5,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;5&#160;)

matrix_index&#060;&#160;2&#160;&#062;&#160;mi(&#160;3,&#160;2&#160;);
mi:
(&#160;&#160;&#160;x:&#160;2,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;2&#160;)

mi.column&#160;=&#160;5;
mi:
(&#160;&#160;&#160;x:&#160;5,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;5&#160;)

&lt;/code&gt;

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>Here is another (potentially naive) way to allow the coordinate and matrix perspectives to coexist (…again limited to an index&lt;2&gt; example, but using unions instead of references…):<br />
<code>//===================================================================<br />
#include&nbsp;&lt;iostream&gt;<br />
&nbsp;<br />
using&nbsp;namespace&nbsp;std;<br />
&nbsp;<br />
template&nbsp;&lt;&nbsp;size_t&nbsp;N&nbsp;&gt;<br />
struct&nbsp;index;<br />
&nbsp;<br />
template&nbsp;&lt;&gt;<br />
struct&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;column;<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
&nbsp;&nbsp;&nbsp;&nbsp;union&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;y;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;row;<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;(&nbsp;int&nbsp;x,&nbsp;int&nbsp;y&nbsp;)&nbsp;:&nbsp;x(&nbsp;x&nbsp;),&nbsp;y(&nbsp;y&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
};</p>
<p>template&nbsp;&lt;&nbsp;size_t&nbsp;N&nbsp;&gt;<br />
struct&nbsp;matrix_index;</p>
<p>template&nbsp;&lt;&gt;<br />
struct&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;:&nbsp;public&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;(&nbsp;int&nbsp;row,&nbsp;int&nbsp;column&nbsp;)&nbsp;:&nbsp;index&lt;&nbsp;2&nbsp;&gt;(&nbsp;column,&nbsp;row&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;:&nbsp;index&lt;&nbsp;2&nbsp;&gt;(&nbsp;i&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
};<br />
&nbsp;<br />
std::ostream&nbsp;&amp;&nbsp;operator&nbsp;&lt;&lt;&nbsp;(&nbsp;std::ostream&nbsp;&amp;&nbsp;os,&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;"(&nbsp;&nbsp;&nbsp;x:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.x&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;"&nbsp;)"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;"[&nbsp;row:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.row&nbsp;&lt;&lt;&nbsp;",&nbsp;column:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.column&nbsp;&lt;&lt;&nbsp;"&nbsp;)"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />
}<br />
&nbsp;<br />
int&nbsp;main&nbsp;()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"sizeof(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;sizeof(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"sizeof(&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;"&nbsp;&lt;&lt;&nbsp;sizeof(&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;i(&nbsp;2,&nbsp;3&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"index&lt;&nbsp;2&nbsp;&gt;&nbsp;i(&nbsp;2,&nbsp;3&nbsp;);"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"i:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;i.x&nbsp;=&nbsp;5;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"i.x&nbsp;=&nbsp;5;"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"i:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi(&nbsp;3,&nbsp;2&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi(&nbsp;3,&nbsp;2&nbsp;);"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"mi:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;mi&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;mi.column&nbsp;=&nbsp;5;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"mi.column&nbsp;=&nbsp;5;"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"mi:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;mi&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;compilation&nbsp;checks:<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;i2(&nbsp;i&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;i3(&nbsp;mi&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi2(&nbsp;i&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi3(&nbsp;mi&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;i2&nbsp;=&nbsp;mi;<br />
&nbsp;&nbsp;&nbsp;&nbsp;i3&nbsp;=&nbsp;i;<br />
&nbsp;&nbsp;&nbsp;&nbsp;mi2&nbsp;=&nbsp;mi;<br />
&nbsp;&nbsp;&nbsp;&nbsp;mi3&nbsp;=&nbsp;i;<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />
}<br />
//===================================================================<br />
</code><br />
At run-time, the code above produces the following:</p>
<p><code>sizeof(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8<br />
sizeof(&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;8</p>
<p>index&lt;&nbsp;2&nbsp;&gt;&nbsp;i(&nbsp;2,&nbsp;3&nbsp;);<br />
i:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;2&nbsp;)</p>
<p>i.x&nbsp;=&nbsp;5;<br />
i:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;5&nbsp;)</p>
<p>matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi(&nbsp;3,&nbsp;2&nbsp;);<br />
mi:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;2&nbsp;)</p>
<p>mi.column&nbsp;=&nbsp;5;<br />
mi:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;5&nbsp;)</p>
<p></code></p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3167</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:21:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3167</guid>
					<description><![CDATA[The &quot;multiple schedulers&quot; problem is real and needs to be solved independently. For example, C++ PPL uses the ConcRT runtime scheduler. If OpenMP uses a different scheduler, then unless there are extra knobs to tell them not to use the whole machine, both will think they own the whole machine. One way to solve this is to use a common scheduler -- for example, IIRC Intel has updated their OpenMP implementation to use the ConcRT scheduler, which solves the problem. So the solution is to reduce the number of independent schedulers.

The good news is that the ConcRT and OpenMP and threadpool schedulers only deal with CPU cores today. C++ AMP deals only with GPU cores today. So there&#039;s no conflict at the moment, and as we integrate C++ PPL and C++ AMP we will definitely be sure to make the schedulers play nice (minimum bar) or be fully unified (ideal, and long-term necessity).]]></description>
		<content:encoded><![CDATA[<p>The &#8220;multiple schedulers&#8221; problem is real and needs to be solved independently. For example, C++ PPL uses the ConcRT runtime scheduler. If OpenMP uses a different scheduler, then unless there are extra knobs to tell them not to use the whole machine, both will think they own the whole machine. One way to solve this is to use a common scheduler &#8212; for example, IIRC Intel has updated their OpenMP implementation to use the ConcRT scheduler, which solves the problem. So the solution is to reduce the number of independent schedulers.</p>
<p>The good news is that the ConcRT and OpenMP and threadpool schedulers only deal with CPU cores today. C++ AMP deals only with GPU cores today. So there&#8217;s no conflict at the moment, and as we integrate C++ PPL and C++ AMP we will definitely be sure to make the schedulers play nice (minimum bar) or be fully unified (ideal, and long-term necessity).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3166</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:18:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3166</guid>
					<description><![CDATA[They must be built into the compiler. Allowing user-defined restriction qualifiers would be a much bigger language extension because you&#039;d need to be able to have a whole new set of language syntax to let you talk about specific language features in the language, to specify what language features are and aren&#039;t available. It&#039;s possible and nothing closes the door to that as a future path, but it&#039;s best to start with the basics and see how they work out.]]></description>
		<content:encoded><![CDATA[<p>They must be built into the compiler. Allowing user-defined restriction qualifiers would be a much bigger language extension because you&#8217;d need to be able to have a whole new set of language syntax to let you talk about specific language features in the language, to specify what language features are and aren&#8217;t available. It&#8217;s possible and nothing closes the door to that as a future path, but it&#8217;s best to start with the basics and see how they work out.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3165</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:16:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3165</guid>
					<description><![CDATA[@Mike: While we designed this, I did explore unifying this with const- and volatile-qualifiers on member functions. It turns out that they&#039;re not quite the same thing -- you could shoehorn mem-fun cv-qualifiers into restriction qualifiers, but fundamentally they&#039;re no different than just plain cv-qualifiers on ordinary parameters, and the only reason they&#039;re tacked on so awkwardly at the end is because you can&#039;t write them on the &quot;this&quot; parameter where they belong. IMO the right way in the future to unify mem-fun cv-qualifiers is by allowing explicit &quot;this&quot; parameters... it&#039;s really a different problem.]]></description>
		<content:encoded><![CDATA[<p>@Mike: While we designed this, I did explore unifying this with const- and volatile-qualifiers on member functions. It turns out that they&#8217;re not quite the same thing &#8212; you could shoehorn mem-fun cv-qualifiers into restriction qualifiers, but fundamentally they&#8217;re no different than just plain cv-qualifiers on ordinary parameters, and the only reason they&#8217;re tacked on so awkwardly at the end is because you can&#8217;t write them on the &#8220;this&#8221; parameter where they belong. IMO the right way in the future to unify mem-fun cv-qualifiers is by allowing explicit &#8220;this&#8221; parameters&#8230; it&#8217;s really a different problem.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3164</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:14:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3164</guid>
					<description><![CDATA[@Jesse: Alas, attributes aren&#039;t the answer because they&#039;re not part of the language. For example, you can&#039;t overload on them.]]></description>
		<content:encoded><![CDATA[<p>@Jesse: Alas, attributes aren&#8217;t the answer because they&#8217;re not part of the language. For example, you can&#8217;t overload on them.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3163</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jun 2011 00:13:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3163</guid>
					<description><![CDATA[@Lothar: I understand, and a lot of people felt the same about GUIs and OO.

The short answer is that we have to deal with it if we care about taking advantage of the compute throughput available on mainstream hardware from now on, because this is the way new performance will be delivered in mainstream hardware. Applications that aren&#039;t compute-intensive can ignore it; applications that are will need to cope with heterogeneous computing -- even if just locally, but more and more with cloud acceleration when connected (I believe this is the inevitable future in a handful of years).

I completely understand your feeling like you don&#039;t want to have to learn to deal with this stuff. The dirty little secret is that nobody wanted multicore in the past five years, and nobody really wants heterogeneous computing now... the chip vendors and the software developers, all of us together, would just love old-free-lunch improvements to single-core throughput to go on forever. But just as starting in the mid-2000s we needed to go parallel to get full compute throughput out of mainstream hardware, we will now need to go heterogeneous to get full performance. And although we&#039;d like to have not had to do the work of bringing parallelism into the mainstream, now that we are doing it there are strong other advantages, notably Performance/W and scalability.

I also get that you don&#039;t want something Windows-only. That&#039;s typical of C++ developers (including me), and it&#039;s why we&#039;ve decided to take the path of making this an open spec from the get-go. As of launch day both AMD and NVidia have announced support. More to come...

But it has to be easier to use than current tools if it&#039;s going to make sense for millions of developers; a priesthood can happily continue to use what&#039;s there now if they want, but we as an industry need to greatly broaden the audience of developers who can do this stuff successfully, as well as make all of us more productive. One aspect of this is minimizing differences from the proven programming models we already know: For C++ in particular, my personal belief is that both parallel computing and heterogeneous computing will fail unless we can make them just about as simple to use as STL algorithms. Fortunately, we now have a proof point that it can be done for parallel algorithms (see C++ PPL), and a proof of concept that the model can be taken to heterogeneous computing with an additional decoration (C++ AMP). I was concerned a few years ago, but now I&#039;m confident that we&#039;re going to get there.]]></description>
		<content:encoded><![CDATA[<p>@Lothar: I understand, and a lot of people felt the same about GUIs and OO.</p>
<p>The short answer is that we have to deal with it if we care about taking advantage of the compute throughput available on mainstream hardware from now on, because this is the way new performance will be delivered in mainstream hardware. Applications that aren&#8217;t compute-intensive can ignore it; applications that are will need to cope with heterogeneous computing &#8212; even if just locally, but more and more with cloud acceleration when connected (I believe this is the inevitable future in a handful of years).</p>
<p>I completely understand your feeling like you don&#8217;t want to have to learn to deal with this stuff. The dirty little secret is that nobody wanted multicore in the past five years, and nobody really wants heterogeneous computing now&#8230; the chip vendors and the software developers, all of us together, would just love old-free-lunch improvements to single-core throughput to go on forever. But just as starting in the mid-2000s we needed to go parallel to get full compute throughput out of mainstream hardware, we will now need to go heterogeneous to get full performance. And although we&#8217;d like to have not had to do the work of bringing parallelism into the mainstream, now that we are doing it there are strong other advantages, notably Performance/W and scalability.</p>
<p>I also get that you don&#8217;t want something Windows-only. That&#8217;s typical of C++ developers (including me), and it&#8217;s why we&#8217;ve decided to take the path of making this an open spec from the get-go. As of launch day both AMD and NVidia have announced support. More to come&#8230;</p>
<p>But it has to be easier to use than current tools if it&#8217;s going to make sense for millions of developers; a priesthood can happily continue to use what&#8217;s there now if they want, but we as an industry need to greatly broaden the audience of developers who can do this stuff successfully, as well as make all of us more productive. One aspect of this is minimizing differences from the proven programming models we already know: For C++ in particular, my personal belief is that both parallel computing and heterogeneous computing will fail unless we can make them just about as simple to use as STL algorithms. Fortunately, we now have a proof point that it can be done for parallel algorithms (see C++ PPL), and a proof of concept that the model can be taken to heterogeneous computing with an additional decoration (C++ AMP). I was concerned a few years ago, but now I&#8217;m confident that we&#8217;re going to get there.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3162</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Sun, 19 Jun 2011 23:15:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3162</guid>
					<description><![CDATA[The formating for the above code sample is fine; however, I forgot to modify the &quot;At run-time, this produces the following&quot; example, so here it is ... with proper formating:
&lt;code&gt;sizeof(&#160;index&#060;&#160;2&#160;&#062;&#160;):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16
sizeof(&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;):&#160;16

index&#060;&#160;2&#160;&#062;&#160;i(&#160;2,&#160;3&#160;);
i:
(&#160;&#160;&#160;x:&#160;2,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;2&#160;)

i.x&#160;=&#160;5;
i:
(&#160;&#160;&#160;x:&#160;5,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;5&#160;)

matrix_index&#060;&#160;2&#160;&#062;&#160;mi(&#160;3,&#160;2&#160;);
mi:
(&#160;&#160;&#160;x:&#160;2,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;2&#160;)

mi.column&#160;=&#160;5;
mi:
(&#160;&#160;&#160;x:&#160;5,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;3&#160;)
[&#160;row:&#160;3,&#160;column:&#160;5&#160;)
&lt;/code&gt;

Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>The formating for the above code sample is fine; however, I forgot to modify the &#8220;At run-time, this produces the following&#8221; example, so here it is &#8230; with proper formating:<br />
<code>sizeof(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16<br />
sizeof(&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;16</p>
<p>index&lt;&nbsp;2&nbsp;&gt;&nbsp;i(&nbsp;2,&nbsp;3&nbsp;);<br />
i:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;2&nbsp;)</p>
<p>i.x&nbsp;=&nbsp;5;<br />
i:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;5&nbsp;)</p>
<p>matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi(&nbsp;3,&nbsp;2&nbsp;);<br />
mi:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;2&nbsp;)</p>
<p>mi.column&nbsp;=&nbsp;5;<br />
mi:<br />
(&nbsp;&nbsp;&nbsp;x:&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;3&nbsp;)<br />
[&nbsp;row:&nbsp;3,&nbsp;column:&nbsp;5&nbsp;)<br />
</code></p>
<p>Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3161</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Sun, 19 Jun 2011 23:02:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3161</guid>
					<description><![CDATA[@Herb Sutter:

Why &lt;code&gt;restrict( direct3d ) { ... }&lt;/code&gt;, vice &lt;code&gt;extern &quot;direct3d&quot; { ... }&lt;/code&gt;?

&lt;code&gt;extern &quot;C&quot; { ... }&lt;/code&gt; seems to have worked pretty well.  What would &lt;code&gt;extern &quot;direct3d&quot; { ... }&lt;/code&gt; not do that you need it to?

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>@Herb Sutter:</p>
<p>Why <code>restrict( direct3d ) { ... }</code>, vice <code>extern "direct3d" { ... }</code>?</p>
<p><code>extern "C" { ... }</code> seems to have worked pretty well.  What would <code>extern "direct3d" { ... }</code> not do that you need it to?</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3160</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Sun, 19 Jun 2011 22:50:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3160</guid>
					<description><![CDATA[@Mike Gibson:  Gleened from just videos, my understanding of &quot;restrict&quot; is that it tells the compiler to consider language rules for a set of the C++ language (in this case, just a proper subset of C++ ... but a superset would also be possible for things like C++ 202x language feature testing).  Since function pointers and recursion are not allowed under &quot;restrict( direct3d )&quot;, then &quot;restrict( direct3d )&quot; tells the compiler to consider a proper subset of C++0x where a pointer to a function or a recursive function should produce a compile-time error inside the context that follows (i.e. a compile-time error for just the code in between the &quot;{&quot; and &quot;}&quot; that follows the &quot;restrict( direct3d )&quot;).  This restriction allows the front end of the compiler to create an intermediate representation out of the proper subset of C++0x code that the backend can optimize and emit to anything it wants ... like HLSL bytecode, or IA64 instructions, or a combination of both.  Of course, an additional run-time that handles the interaction between the CPU and the GPU (for HLSL) will also be added during compilation besides just the usual run-time that sets up the stack and calls &quot;main&quot;.

@Herb Sutter:  If the above is the case, then I think names like &quot;direct3d&quot; and &quot;cpu&quot; are __bad__ ... they are much too hardware-target specific.  Hardware targets work well as compiler switches (say for x86, x64, ...), vice being put directly in code.  I would think that language specifications ... and maybe versions ... should go in between the parens of &quot;restrict(  )&quot;.  For instance, &quot;restrict( OpenCL 1.0 )&quot;, &quot;restrict( C++ 2003 )&quot;, &quot;restrict( HLSL 5.0 )&quot;, &quot;restrict( C++ 202x )&quot;, &quot;restrict( ECMAScript 5.0 )&quot; ... or whatever.  Additionally, I would imagine that the HLSL will add features in the future (i.e. leading to additional bytecode instructions) in Direct3D 12 (or Direct3D 13, or Direct3D 14, or ...), so which HLSL version does &quot;restrict( direct3d )&quot; target?  Will this be a compiler switch, pragma, or something I can stick in between the parens of &quot;restrict(  )&quot;?  This seems like the DLL-Hell versioning problem that .NET assemblies tried to solve, but at a language/compiler level.

Lastly, I am __REALLY__ dissatisfied with the order of the indices in the index&#060;2&#062;, extent&#060;2&#062;, and similar templates ... i.e. y, x ... instead of the usual x, y.  Hint:  If you want me to think in terms of rows and columns, then provide an interface (say a &quot;matrix_index&quot; class for a &quot;matrix_view&quot; class) that allows me to think in terms of rows (y&#039;s) and columns (x&#039;s) ... but do __not__ force me to use &quot;y&quot; for row and &quot;x&quot; for column ... and do __not__ change the generally accepted order of things ... i.e. (x, y) ... because you are trying to fit multiple perspectives into one view ... i.e. (y, x) that also means (row, column).  I should be able to have and declare indices using the coordinate perspective ... i.e. (x, y) ... or using the matrix perspective ... i.e. (row, column).  The API should support both perspectives ... without me having to type a whole bunch.  Maybe more template meta-programming should be done?  Or maybe just some API changes?

NOTE: Of course, the (z, y, x) ordering for index and extent needs to be changed as well.

Very Respectfully,
Joshua Burkholder

P.S. - Here is one (potentially naive) way to allow the coordinate and matrix perspectives to coexist (...limited to an index&#060;2&#062; example...):
&lt;code&gt;//===================================================================
#include&#160;&#060;iostream&#062;

using&#160;namespace&#160;std;

template&#160;&#060;&#160;size_t&#160;N&#160;&#062;
struct&#160;index;

template&#160;&#060;&#062;
struct&#160;index&#060;&#160;2&#160;&#062;&#160;{
&#160;&#160;&#160;&#160;int&#160;x;
&#160;&#160;&#160;&#160;int&#160;y;
&#160;&#160;&#160;&#160;int&#038;&#160;row;
&#160;&#160;&#160;&#160;int&#038;&#160;column;
&#160;&#160;&#160;&#160;index&#160;(&#160;int&#160;_x,&#160;int&#160;_y&#160;)&#160;:&#160;x(&#160;_x&#160;),&#160;y(&#160;_y&#160;),&#160;row(&#160;y&#160;),&#160;column(&#160;x&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;index&#160;(&#160;index&#160;const&#160;&#038;&#160;i&#160;)&#160;:&#160;x(&#160;i.x&#160;),&#160;y(&#160;i.y&#160;),&#160;row(&#160;y&#160;),&#160;column(&#160;x&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;index&#160;&#038;&#160;operator&#160;=&#160;(&#160;index&#160;const&#160;&#038;&#160;i&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;(&#160;&#038;i&#160;!=&#160;this&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x&#160;=&#160;i.x;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;y&#160;=&#160;i.y;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;*this;
&#160;&#160;&#160;&#160;}
};

template&#160;&#060;&#160;size_t&#160;N&#160;&#062;
struct&#160;matrix_index&#160;:&#160;public&#160;index&#060;&#160;N&#160;&#062;&#160;{
&#160;&#160;&#160;&#160;matrix_index&#160;(&#160;int&#160;row,&#160;int&#160;column&#160;)&#160;:&#160;index&#060;&#160;N&#160;&#062;(&#160;column,&#160;row&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;matrix_index&#160;(&#160;matrix_index&#160;const&#160;&#038;&#160;mi&#160;)&#160;:&#160;index&#060;&#160;N&#160;&#062;(&#160;mi&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;matrix_index&#160;(&#160;index&#060;&#160;N&#160;&#062;&#160;const&#160;&#038;&#160;i&#160;)&#160;:&#160;index&#060;&#160;N&#160;&#062;(&#160;i&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;matrix_index&#160;&#038;&#160;operator&#160;=&#160;(&#160;matrix_index&#160;const&#160;&#038;&#160;mi&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;(&#160;&#038;mi&#160;!=&#160;this&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;index&#060;&#160;N&#160;&#062;::operator&#160;=(&#160;mi&#160;);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;*this;
&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;matrix_index&#160;&#038;&#160;operator&#160;=&#160;(&#160;index&#060;&#160;N&#160;&#062;&#160;const&#160;&#038;&#160;i&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if&#160;(&#160;&#038;i&#160;!=&#160;this&#160;)&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;index&#060;&#160;N&#160;&#062;::operator&#160;=(&#160;i&#160;);
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;*this;
&#160;&#160;&#160;&#160;}
};

std::ostream&#160;&#038;&#160;operator&#160;&#060;&#060;&#160;(&#160;std::ostream&#160;&#038;&#160;os,&#160;index&#060;&#160;2&#160;&#062;&#160;const&#160;&#038;&#160;i&#160;)&#160;{
&#160;&#160;&#160;&#160;os&#160;&#060;&#060;&#160;&quot;(&#160;&#160;&#160;x:&#160;&quot;&#160;&#060;&#060;&#160;i.x&#160;&#160;&#160;&#060;&#060;&#160;&quot;,&#160;&#160;&#160;&#160;&#160;&#160;y:&#160;&quot;&#160;&#060;&#060;&#160;i.y&#160;&#160;&#160;&#160;&#160;&#160;&#060;&#060;&#160;&quot;&#160;)&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;os&#160;&#060;&#060;&#160;&quot;[&#160;row:&#160;&quot;&#160;&#060;&#060;&#160;i.row&#160;&#060;&#060;&#160;&quot;,&#160;column:&#160;&quot;&#160;&#060;&#060;&#160;i.column&#160;&#060;&#060;&#160;&quot;&#160;)&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;return&#160;os;
}

int&#160;main&#160;()&#160;{
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;sizeof(&#160;index&#060;&#160;2&#160;&#062;&#160;):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&quot;&#160;&#060;&#060;&#160;sizeof(&#160;index&#060;&#160;2&#160;&#062;&#160;)&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;sizeof(&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;):&#160;&quot;&#160;&#060;&#060;&#160;sizeof(&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;)&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;index&#060;&#160;2&#160;&#062;&#160;i(&#160;2,&#160;3&#160;);
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;index&#060;&#160;2&#160;&#062;&#160;i(&#160;2,&#160;3&#160;);&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;i:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;i&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;i.x&#160;=&#160;5;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;i.x&#160;=&#160;5;&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;i:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;i&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;mi(&#160;3,&#160;2&#160;);
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;matrix_index&#060;&#160;2&#160;&#062;&#160;mi(&#160;3,&#160;2&#160;);&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;mi:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;mi&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;mi.column&#160;=&#160;5;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;mi.column&#160;=&#160;5;&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;mi:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;mi&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------------------------------------
&#160;&#160;&#160;&#160;//&#160;compilation&#160;checks:
&#160;&#160;&#160;&#160;index&#060;&#160;2&#160;&#062;&#160;i2(&#160;i&#160;);
&#160;&#160;&#160;&#160;index&#060;&#160;2&#160;&#062;&#160;i3(&#160;mi&#160;);
&#160;&#160;&#160;&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;mi2(&#160;i&#160;);
&#160;&#160;&#160;&#160;matrix_index&#060;&#160;2&#160;&#062;&#160;mi3(&#160;mi&#160;);
&#160;&#160;&#160;&#160;i2&#160;=&#160;mi;
&#160;&#160;&#160;&#160;i3&#160;=&#160;i;
&#160;&#160;&#160;&#160;mi2&#160;=&#160;mi;
&#160;&#160;&#160;&#160;mi3&#160;=&#160;i;
&#160;&#160;&#160;&#160;return&#160;0;
}
//===================================================================
&lt;/code&gt;
At run-time this produces the following:
&lt;code&gt;sizeof( index ):        16
sizeof( matrix_index ): 16

index i( 2, 3 );
i:
(   x: 2,      y: 3 )
[ row: 3, column: 2 )

i.x = 5;
i:
(   x: 5,      y: 3 )
[ row: 3, column: 5 )

matrix_index mi( 3, 2 );
mi:
(   x: 2,      y: 3 )
[ row: 3, column: 2 )

mi.column = 5;
mi:
(   x: 5,      y: 3 )
[ row: 3, column: 5 )
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>@Mike Gibson:  Gleened from just videos, my understanding of &#8220;restrict&#8221; is that it tells the compiler to consider language rules for a set of the C++ language (in this case, just a proper subset of C++ &#8230; but a superset would also be possible for things like C++ 202x language feature testing).  Since function pointers and recursion are not allowed under &#8220;restrict( direct3d )&#8221;, then &#8220;restrict( direct3d )&#8221; tells the compiler to consider a proper subset of C++0x where a pointer to a function or a recursive function should produce a compile-time error inside the context that follows (i.e. a compile-time error for just the code in between the &#8220;{&#8221; and &#8220;}&#8221; that follows the &#8220;restrict( direct3d )&#8221;).  This restriction allows the front end of the compiler to create an intermediate representation out of the proper subset of C++0x code that the backend can optimize and emit to anything it wants &#8230; like HLSL bytecode, or IA64 instructions, or a combination of both.  Of course, an additional run-time that handles the interaction between the CPU and the GPU (for HLSL) will also be added during compilation besides just the usual run-time that sets up the stack and calls &#8220;main&#8221;.</p>
<p>@Herb Sutter:  If the above is the case, then I think names like &#8220;direct3d&#8221; and &#8220;cpu&#8221; are __bad__ &#8230; they are much too hardware-target specific.  Hardware targets work well as compiler switches (say for x86, x64, &#8230;), vice being put directly in code.  I would think that language specifications &#8230; and maybe versions &#8230; should go in between the parens of &#8220;restrict(  )&#8221;.  For instance, &#8220;restrict( OpenCL 1.0 )&#8221;, &#8220;restrict( C++ 2003 )&#8221;, &#8220;restrict( HLSL 5.0 )&#8221;, &#8220;restrict( C++ 202x )&#8221;, &#8220;restrict( ECMAScript 5.0 )&#8221; &#8230; or whatever.  Additionally, I would imagine that the HLSL will add features in the future (i.e. leading to additional bytecode instructions) in Direct3D 12 (or Direct3D 13, or Direct3D 14, or &#8230;), so which HLSL version does &#8220;restrict( direct3d )&#8221; target?  Will this be a compiler switch, pragma, or something I can stick in between the parens of &#8220;restrict(  )&#8221;?  This seems like the DLL-Hell versioning problem that .NET assemblies tried to solve, but at a language/compiler level.</p>
<p>Lastly, I am __REALLY__ dissatisfied with the order of the indices in the index&lt;2&gt;, extent&lt;2&gt;, and similar templates &#8230; i.e. y, x &#8230; instead of the usual x, y.  Hint:  If you want me to think in terms of rows and columns, then provide an interface (say a &#8220;matrix_index&#8221; class for a &#8220;matrix_view&#8221; class) that allows me to think in terms of rows (y&#8217;s) and columns (x&#8217;s) &#8230; but do __not__ force me to use &#8220;y&#8221; for row and &#8220;x&#8221; for column &#8230; and do __not__ change the generally accepted order of things &#8230; i.e. (x, y) &#8230; because you are trying to fit multiple perspectives into one view &#8230; i.e. (y, x) that also means (row, column).  I should be able to have and declare indices using the coordinate perspective &#8230; i.e. (x, y) &#8230; or using the matrix perspective &#8230; i.e. (row, column).  The API should support both perspectives &#8230; without me having to type a whole bunch.  Maybe more template meta-programming should be done?  Or maybe just some API changes?</p>
<p>NOTE: Of course, the (z, y, x) ordering for index and extent needs to be changed as well.</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
<p>P.S. &#8211; Here is one (potentially naive) way to allow the coordinate and matrix perspectives to coexist (&#8230;limited to an index&lt;2&gt; example&#8230;):<br />
<code>//===================================================================<br />
#include&nbsp;&lt;iostream&gt;</p>
<p>using&nbsp;namespace&nbsp;std;</p>
<p>template&nbsp;&lt;&nbsp;size_t&nbsp;N&nbsp;&gt;<br />
struct&nbsp;index;</p>
<p>template&nbsp;&lt;&gt;<br />
struct&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x;<br />
&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;y;<br />
&nbsp;&nbsp;&nbsp;&nbsp;int&amp;&nbsp;row;<br />
&nbsp;&nbsp;&nbsp;&nbsp;int&amp;&nbsp;column;<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;(&nbsp;int&nbsp;_x,&nbsp;int&nbsp;_y&nbsp;)&nbsp;:&nbsp;x(&nbsp;_x&nbsp;),&nbsp;y(&nbsp;_y&nbsp;),&nbsp;row(&nbsp;y&nbsp;),&nbsp;column(&nbsp;x&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;(&nbsp;index&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;:&nbsp;x(&nbsp;i.x&nbsp;),&nbsp;y(&nbsp;i.y&nbsp;),&nbsp;row(&nbsp;y&nbsp;),&nbsp;column(&nbsp;x&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&nbsp;&amp;&nbsp;operator&nbsp;=&nbsp;(&nbsp;index&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;&amp;i&nbsp;!=&nbsp;this&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;i.x;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;i.y;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
};</p>
<p>template&nbsp;&lt;&nbsp;size_t&nbsp;N&nbsp;&gt;<br />
struct&nbsp;matrix_index&nbsp;:&nbsp;public&nbsp;index&lt;&nbsp;N&nbsp;&gt;&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;(&nbsp;int&nbsp;row,&nbsp;int&nbsp;column&nbsp;)&nbsp;:&nbsp;index&lt;&nbsp;N&nbsp;&gt;(&nbsp;column,&nbsp;row&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;(&nbsp;matrix_index&nbsp;const&nbsp;&amp;&nbsp;mi&nbsp;)&nbsp;:&nbsp;index&lt;&nbsp;N&nbsp;&gt;(&nbsp;mi&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;(&nbsp;index&lt;&nbsp;N&nbsp;&gt;&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;:&nbsp;index&lt;&nbsp;N&nbsp;&gt;(&nbsp;i&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;&amp;&nbsp;operator&nbsp;=&nbsp;(&nbsp;matrix_index&nbsp;const&nbsp;&amp;&nbsp;mi&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;&amp;mi&nbsp;!=&nbsp;this&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;N&nbsp;&gt;::operator&nbsp;=(&nbsp;mi&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&nbsp;&amp;&nbsp;operator&nbsp;=&nbsp;(&nbsp;index&lt;&nbsp;N&nbsp;&gt;&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(&nbsp;&amp;i&nbsp;!=&nbsp;this&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;N&nbsp;&gt;::operator&nbsp;=(&nbsp;i&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;*this;<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
};</p>
<p>std::ostream&nbsp;&amp;&nbsp;operator&nbsp;&lt;&lt;&nbsp;(&nbsp;std::ostream&nbsp;&amp;&nbsp;os,&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;const&nbsp;&amp;&nbsp;i&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;"(&nbsp;&nbsp;&nbsp;x:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.x&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&lt;&nbsp;"&nbsp;)"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;os&nbsp;&lt;&lt;&nbsp;"[&nbsp;row:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.row&nbsp;&lt;&lt;&nbsp;",&nbsp;column:&nbsp;"&nbsp;&lt;&lt;&nbsp;i.column&nbsp;&lt;&lt;&nbsp;"&nbsp;)"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;os;<br />
}</p>
<p>int&nbsp;main&nbsp;()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"sizeof(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;sizeof(&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"sizeof(&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;):&nbsp;"&nbsp;&lt;&lt;&nbsp;sizeof(&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;)&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;i(&nbsp;2,&nbsp;3&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"index&lt;&nbsp;2&nbsp;&gt;&nbsp;i(&nbsp;2,&nbsp;3&nbsp;);"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"i:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;i.x&nbsp;=&nbsp;5;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"i.x&nbsp;=&nbsp;5;"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"i:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;i&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi(&nbsp;3,&nbsp;2&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi(&nbsp;3,&nbsp;2&nbsp;);"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"mi:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;mi&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;mi.column&nbsp;=&nbsp;5;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"mi.column&nbsp;=&nbsp;5;"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"mi:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;mi&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------------------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;compilation&nbsp;checks:<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;i2(&nbsp;i&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;index&lt;&nbsp;2&nbsp;&gt;&nbsp;i3(&nbsp;mi&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi2(&nbsp;i&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;matrix_index&lt;&nbsp;2&nbsp;&gt;&nbsp;mi3(&nbsp;mi&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;i2&nbsp;=&nbsp;mi;<br />
&nbsp;&nbsp;&nbsp;&nbsp;i3&nbsp;=&nbsp;i;<br />
&nbsp;&nbsp;&nbsp;&nbsp;mi2&nbsp;=&nbsp;mi;<br />
&nbsp;&nbsp;&nbsp;&nbsp;mi3&nbsp;=&nbsp;i;<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />
}<br />
//===================================================================<br />
</code><br />
At run-time this produces the following:<br />
<code>sizeof( index ):        16<br />
sizeof( matrix_index ): 16</p>
<p>index i( 2, 3 );<br />
i:<br />
(   x: 2,      y: 3 )<br />
[ row: 3, column: 2 )</p>
<p>i.x = 5;<br />
i:<br />
(   x: 5,      y: 3 )<br />
[ row: 3, column: 5 )</p>
<p>matrix_index mi( 3, 2 );<br />
mi:<br />
(   x: 2,      y: 3 )<br />
[ row: 3, column: 2 )</p>
<p>mi.column = 5;<br />
mi:<br />
(   x: 5,      y: 3 )<br />
[ row: 3, column: 5 )<br />
</code></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lothar Scholz				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3158</link>
		<dc:creator><![CDATA[Lothar Scholz]]></dc:creator>
		<pubDate>Sat, 18 Jun 2011 18:21:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3158</guid>
					<description><![CDATA[Well being a normal application programmer i can&#039;t think of heterogenous computing as any useful for my and the most non multi-media/gaming applications. The shared memory requirement are what kills it all for me, shared memory and large virtual memory sets among all threads/tasks - otherwise i could multiprocessing giving me even more stability in my application. And with this usecase a GCD with the system wide thread pool (no it is not like Cilk, it&#039;s much more powerful)  looks more productive and performant. 

If you want to convince me take a compiler or database or excel spreadsheet or a word document or ... as an example for AMP not a simple particle system. Promoting heterogenous computing is Marketing, just Marketing.

And it is not true that Apples lamda functions/C blocks are Objective-C features. They and GCD are pure C level. 

And again - i and my company will never use pure Windows API&#039;s anymore. We make as much money from our MacOSX port as we make from our Windows App. So please stop the API wars.]]></description>
		<content:encoded><![CDATA[<p>Well being a normal application programmer i can&#8217;t think of heterogenous computing as any useful for my and the most non multi-media/gaming applications. The shared memory requirement are what kills it all for me, shared memory and large virtual memory sets among all threads/tasks &#8211; otherwise i could multiprocessing giving me even more stability in my application. And with this usecase a GCD with the system wide thread pool (no it is not like Cilk, it&#8217;s much more powerful)  looks more productive and performant. </p>
<p>If you want to convince me take a compiler or database or excel spreadsheet or a word document or &#8230; as an example for AMP not a simple particle system. Promoting heterogenous computing is Marketing, just Marketing.</p>
<p>And it is not true that Apples lamda functions/C blocks are Objective-C features. They and GCD are pure C level. </p>
<p>And again &#8211; i and my company will never use pure Windows API&#8217;s anymore. We make as much money from our MacOSX port as we make from our Windows App. So please stop the API wars.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dan Golick				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3157</link>
		<dc:creator><![CDATA[Dan Golick]]></dc:creator>
		<pubDate>Sat, 18 Jun 2011 17:07:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3157</guid>
					<description><![CDATA[Its wonderful that Microsoft has made it easier to write multi-core, hetrogeneous code but...

If multiple applications are running trying to use all the cores and all the gpus things start to run slower.  We need an OS level task scheduler that can be the traffic cop at run-time.

Now my c# app is trying to use all cores and my c++ app is trying to use all cores and everything runs slower!!]]></description>
		<content:encoded><![CDATA[<p>Its wonderful that Microsoft has made it easier to write multi-core, hetrogeneous code but&#8230;</p>
<p>If multiple applications are running trying to use all the cores and all the gpus things start to run slower.  We need an OS level task scheduler that can be the traffic cop at run-time.</p>
<p>Now my c# app is trying to use all cores and my c++ app is trying to use all cores and everything runs slower!!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jesse Towner				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3156</link>
		<dc:creator><![CDATA[Jesse Towner]]></dc:creator>
		<pubDate>Sat, 18 Jun 2011 05:56:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3156</guid>
					<description><![CDATA[Yeah, you very well may be right.]]></description>
		<content:encoded><![CDATA[<p>Yeah, you very well may be right.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike Gibson				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3155</link>
		<dc:creator><![CDATA[Mike Gibson]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 19:44:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3155</guid>
					<description><![CDATA[I think much of what was done with concepts would be applicable to restrict.  A generalized way of specifying restrictions on the code you write.  Then, instead of requiring a new keyword for code you want to use in with direct3d, the compiler just checks individual restrictions as it goes and doesn&#039;t allow direct3d when the code doesn&#039;t comply.  Then, the restrict keyword just uses concepts to make the error messages nicer.  This would have the side benefit of allowing old code to take advantage of new processing models without having to be updated to include some new keyword.

Perhaps it&#039;s a good thing that concepts didn&#039;t make it this time around.  Perhaps the idea is far more powerful than previously thought.]]></description>
		<content:encoded><![CDATA[<p>I think much of what was done with concepts would be applicable to restrict.  A generalized way of specifying restrictions on the code you write.  Then, instead of requiring a new keyword for code you want to use in with direct3d, the compiler just checks individual restrictions as it goes and doesn&#8217;t allow direct3d when the code doesn&#8217;t comply.  Then, the restrict keyword just uses concepts to make the error messages nicer.  This would have the side benefit of allowing old code to take advantage of new processing models without having to be updated to include some new keyword.</p>
<p>Perhaps it&#8217;s a good thing that concepts didn&#8217;t make it this time around.  Perhaps the idea is far more powerful than previously thought.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: contextfree				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3154</link>
		<dc:creator><![CDATA[contextfree]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 19:34:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3154</guid>
					<description><![CDATA[Must &quot;restrict&quot; targets be built into the compiler, or is there some way to write them as libraries?]]></description>
		<content:encoded><![CDATA[<p>Must &#8220;restrict&#8221; targets be built into the compiler, or is there some way to write them as libraries?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jesse Towner				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3153</link>
		<dc:creator><![CDATA[Jesse Towner]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 19:12:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3153</guid>
					<description><![CDATA[Yeah, I was thinking about that stuff too. Perhaps something that utilizes C++0x&#039;s new attribute syntax, which would provide better context sensitivity, is the way to go?]]></description>
		<content:encoded><![CDATA[<p>Yeah, I was thinking about that stuff too. Perhaps something that utilizes C++0x&#8217;s new attribute syntax, which would provide better context sensitivity, is the way to go?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jesse Towner				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3152</link>
		<dc:creator><![CDATA[Jesse Towner]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 18:46:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3152</guid>
					<description><![CDATA[It would appear you are caught in some sort of Reality Distortion Field. Here, let me target you with my tractor beam, perhaps I can free you from that treacherous trap.

Firstly, GCD has absolutely nothing to do with heterogeneous computing. What GCD provides is a hierarchical work-stealing task scheduler and some interesting lock-free/wait-free data structures underneath the hood to facilitate message passing between worker threads. That&#039;s all it is. It&#039;s modeled after technologies from Cilk and other early concurrency projects, which have been around since the 90s or earlier--and it doesn&#039;t even do a good job of providing all of the features from Cilk, only the bare necessities. Microsoft&#039;s PPL and Intel&#039;s TBB initiatives, also somewhat based off of Cilk, go further than GCD in providing concurrent algorithmic skeletons and other high level abstractions which can be composed together to solve various concurrency problems. GCD just gives you a bare bones task scheduler. But in the end, GCD, PPL, TBB, et. al. don&#039;t really attempt to tackle heterogeneous computing.

In fact, Apple came up with a completely different technology for heterogeneous massively parallel computing that I&#039;m sure you&#039;ve heard of--OpenCL. OpenCL takes C99, makes some changes and provides some abstractions for working with vector data-types and image memory buffers on GPUs, but it can also be used for running code on CPUs and perhaps other hardware like FPGAs. And that&#039;s really what heterogeneous computing is about, about writing code that can run on different types of devices in a uniform way. OpenCL implements something of a client-server model similar to OpenGL, where the host application written in regular C (or C++/Obj-C) running on the CPU can delegate work to OpenCL compute kernels, written in the OpenCL C99 dialect and compiled separately that are instantiated and run on various compute devices such as the GPU, or as new threads on the same CPU if you so choose.

So why not just use OpenCL? Well, OpenCL is modeled after C, which is all fine and good, but for C++ programmers, may leave something to be desired. C++ AMP, from what I&#039;ve gleaned, provides you with all of those higher level abstractions if you so chose to use them, such as templates, exceptions, class types with RAII, rvalue-references and so on. Hopefully I&#039;m not wrong about this, but C++ AMP also appears to do away with the client-server model of OpenCL and DirectCompute: it unifies the programming environment in a natural way. You write your application code in C++ AMP, which is just a superset of C++0x (hopefully C++11 really soon), and when you want to delegate computation to heterogeneous devices, you instruct a concurrent algorithmic skeleton, which is simply a template library abstraction, to invoke a function or functor object that has been restricted to run on such devices, also written in C++ AMP and within the same source file. You don&#039;t have to write compute kernel code in a different language or compile the kernel source files separately, it&#039;s all handled by the C++ AMP compiler and runtime libraries automatically. It&#039;s really the next logical step to take within the domain of heterogeneous computing. I really hope C++1x adopts what ever emerges and stabilizes out of the C++ AMP effort. I&#039;m really pumped about it and I&#039;m glad to see it&#039;ll be an open standard as I primarily work on non-Microsoft platforms.

As for Apple&#039;s blocks, they are an Objective-C language extension that doesn&#039;t fit nicely into the C++ programming model. C++0x lambda functions are much more expressive. They provide standard C++ object semantics such as constructors, assignment operators, etc. and facilitate fine-grained variable capture capabilities where you can precisely decide what you want to capture within the closure, either by value or by reference, if you so choose. Additionally, C++0x lambda functions have been in the works for a long time, long before Apple released Obj-C blocks with OS X 10.6.]]></description>
		<content:encoded><![CDATA[<p>It would appear you are caught in some sort of Reality Distortion Field. Here, let me target you with my tractor beam, perhaps I can free you from that treacherous trap.</p>
<p>Firstly, GCD has absolutely nothing to do with heterogeneous computing. What GCD provides is a hierarchical work-stealing task scheduler and some interesting lock-free/wait-free data structures underneath the hood to facilitate message passing between worker threads. That&#8217;s all it is. It&#8217;s modeled after technologies from Cilk and other early concurrency projects, which have been around since the 90s or earlier&#8211;and it doesn&#8217;t even do a good job of providing all of the features from Cilk, only the bare necessities. Microsoft&#8217;s PPL and Intel&#8217;s TBB initiatives, also somewhat based off of Cilk, go further than GCD in providing concurrent algorithmic skeletons and other high level abstractions which can be composed together to solve various concurrency problems. GCD just gives you a bare bones task scheduler. But in the end, GCD, PPL, TBB, et. al. don&#8217;t really attempt to tackle heterogeneous computing.</p>
<p>In fact, Apple came up with a completely different technology for heterogeneous massively parallel computing that I&#8217;m sure you&#8217;ve heard of&#8211;OpenCL. OpenCL takes C99, makes some changes and provides some abstractions for working with vector data-types and image memory buffers on GPUs, but it can also be used for running code on CPUs and perhaps other hardware like FPGAs. And that&#8217;s really what heterogeneous computing is about, about writing code that can run on different types of devices in a uniform way. OpenCL implements something of a client-server model similar to OpenGL, where the host application written in regular C (or C++/Obj-C) running on the CPU can delegate work to OpenCL compute kernels, written in the OpenCL C99 dialect and compiled separately that are instantiated and run on various compute devices such as the GPU, or as new threads on the same CPU if you so choose.</p>
<p>So why not just use OpenCL? Well, OpenCL is modeled after C, which is all fine and good, but for C++ programmers, may leave something to be desired. C++ AMP, from what I&#8217;ve gleaned, provides you with all of those higher level abstractions if you so chose to use them, such as templates, exceptions, class types with RAII, rvalue-references and so on. Hopefully I&#8217;m not wrong about this, but C++ AMP also appears to do away with the client-server model of OpenCL and DirectCompute: it unifies the programming environment in a natural way. You write your application code in C++ AMP, which is just a superset of C++0x (hopefully C++11 really soon), and when you want to delegate computation to heterogeneous devices, you instruct a concurrent algorithmic skeleton, which is simply a template library abstraction, to invoke a function or functor object that has been restricted to run on such devices, also written in C++ AMP and within the same source file. You don&#8217;t have to write compute kernel code in a different language or compile the kernel source files separately, it&#8217;s all handled by the C++ AMP compiler and runtime libraries automatically. It&#8217;s really the next logical step to take within the domain of heterogeneous computing. I really hope C++1x adopts what ever emerges and stabilizes out of the C++ AMP effort. I&#8217;m really pumped about it and I&#8217;m glad to see it&#8217;ll be an open standard as I primarily work on non-Microsoft platforms.</p>
<p>As for Apple&#8217;s blocks, they are an Objective-C language extension that doesn&#8217;t fit nicely into the C++ programming model. C++0x lambda functions are much more expressive. They provide standard C++ object semantics such as constructors, assignment operators, etc. and facilitate fine-grained variable capture capabilities where you can precisely decide what you want to capture within the closure, either by value or by reference, if you so choose. Additionally, C++0x lambda functions have been in the works for a long time, long before Apple released Obj-C blocks with OS X 10.6.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike Gibson				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3151</link>
		<dc:creator><![CDATA[Mike Gibson]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 16:00:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3151</guid>
					<description><![CDATA[This is awesome.  Given that the restrict keyword and writeonly additions are totally new, how willing are you to allow the legendary C++ language community to figure out how to &quot;do it better&quot;?.  I can foresee that many folks won&#039;t like how MS has done this stuff.

I think that the writeonly idea is even more broadly applicable than the restrict stuff.

What you&#039;re doing with restrict is just adding a way to add more qualifiers, like const and volatile.  I see the need to qualify functions/lambdas/etc. in a number ways, but just adding more and more keywords isn&#039;t the way to go.  Perhaps you extend restrict to not just this parallel stuff, but to include *all* the restrictive qualifiers that one can use, like const and volatile.  Then the writeonly stuff can just be included directly along with the rest of the restrictions.

I can envision a system whereby you can create new restriction types based on other restriction types, all built up from a core set of restrictions like const, volatile, writeonly, pure, direct3d, etc.]]></description>
		<content:encoded><![CDATA[<p>This is awesome.  Given that the restrict keyword and writeonly additions are totally new, how willing are you to allow the legendary C++ language community to figure out how to &#8220;do it better&#8221;?.  I can foresee that many folks won&#8217;t like how MS has done this stuff.</p>
<p>I think that the writeonly idea is even more broadly applicable than the restrict stuff.</p>
<p>What you&#8217;re doing with restrict is just adding a way to add more qualifiers, like const and volatile.  I see the need to qualify functions/lambdas/etc. in a number ways, but just adding more and more keywords isn&#8217;t the way to go.  Perhaps you extend restrict to not just this parallel stuff, but to include *all* the restrictive qualifiers that one can use, like const and volatile.  Then the writeonly stuff can just be included directly along with the rest of the restrictions.</p>
<p>I can envision a system whereby you can create new restriction types based on other restriction types, all built up from a core set of restrictions like const, volatile, writeonly, pure, direct3d, etc.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GPU in the cloud &#187; Blog Archive &#187; C++ AMP keynote is online « Sutter&#039;s Mill				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3149</link>
		<dc:creator><![CDATA[GPU in the cloud &#187; Blog Archive &#187; C++ AMP keynote is online « Sutter&#039;s Mill]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 12:15:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3149</guid>
					<description><![CDATA[[...] Read More: C++ AMP keynote is online « Sutter&#039;s Mill [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Read More: C++ AMP keynote is online « Sutter&#039;s Mill [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lothar Scholz				</title>
				<link>https://herbsutter.com/2011/06/16/c-amp-keynote/#comment-3148</link>
		<dc:creator><![CDATA[Lothar Scholz]]></dc:creator>
		<pubDate>Fri, 17 Jun 2011 12:00:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=593#comment-3148</guid>
					<description><![CDATA[I&#039;m not impressed - i would have been 5 years ago.

For general purpose multithreading i believe that Apples GCD is much more helpful in reality. And why couldn&#039;t you use Apples lamba function C extension? Maintaining platform independent business logic was already hard without using MT, this is going to be a pain in the butt. Please stop this API wars.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not impressed &#8211; i would have been 5 years ago.</p>
<p>For general purpose multithreading i believe that Apples GCD is much more helpful in reality. And why couldn&#8217;t you use Apples lamba function C extension? Maintaining platform independent business logic was already hard without using MT, this is going to be a pain in the butt. Please stop this API wars.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
