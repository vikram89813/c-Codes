<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Garbage Collection Synopsis, and C++	</title>
	<atom:link href="https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: David Bradley				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4449</link>
		<dc:creator><![CDATA[David Bradley]]></dc:creator>
		<pubDate>Wed, 23 Nov 2011 14:19:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4449</guid>
					<description><![CDATA[I remain unconvinced that GC is a great sole solution for memory management. I&#039;ve rarely needed it except in certain complex object graphs. It only addresses one leak point, references can still be leaked. Also having all objects with a non-deterministic lifetime is often inconvenient. From the systems I&#039;ve worked on there are often unsavvory side effects that occur under certain conditions.

I do want to be able to use it, but I want to dictate when and to what extent I want to use it. C# to some degree allows that with &quot;using&quot;. But that&#039;s still a bit clumbsy. Maybe approached from the opposite direction would be better, where rather than default to GC you have an allocator/pointer that would allow you to indicate objects to be managed by GC.  But from my experience with JavaScript and XPCOM&#039;s reference counting mechanism that might prove difficult.]]></description>
		<content:encoded><![CDATA[<p>I remain unconvinced that GC is a great sole solution for memory management. I&#8217;ve rarely needed it except in certain complex object graphs. It only addresses one leak point, references can still be leaked. Also having all objects with a non-deterministic lifetime is often inconvenient. From the systems I&#8217;ve worked on there are often unsavvory side effects that occur under certain conditions.</p>
<p>I do want to be able to use it, but I want to dictate when and to what extent I want to use it. C# to some degree allows that with &#8220;using&#8221;. But that&#8217;s still a bit clumbsy. Maybe approached from the opposite direction would be better, where rather than default to GC you have an allocator/pointer that would allow you to indicate objects to be managed by GC.  But from my experience with JavaScript and XPCOM&#8217;s reference counting mechanism that might prove difficult.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4426</link>
		<dc:creator><![CDATA[John]]></dc:creator>
		<pubDate>Fri, 18 Nov 2011 14:34:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4426</guid>
					<description><![CDATA[GC is for lazy programmers. C++ programmers dont need it.]]></description>
		<content:encoded><![CDATA[<p>GC is for lazy programmers. C++ programmers dont need it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4350</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Tue, 08 Nov 2011 19:37:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4350</guid>
					<description><![CDATA[It seems to me that you&#039;d want to be able to classify certain types as only managing memory, so they can be used in GC&#039;d or non-GC&#039;d code (with dtors skipped).  Of course we&#039;d need to be able to propagate that information through the type system à la &lt;code&gt;noexcept&lt;/code&gt;.  Probably that sort of propagation mechanism needs to be generalized.]]></description>
		<content:encoded><![CDATA[<p>It seems to me that you&#8217;d want to be able to classify certain types as only managing memory, so they can be used in GC&#8217;d or non-GC&#8217;d code (with dtors skipped).  Of course we&#8217;d need to be able to propagate that information through the type system à la <code>noexcept</code>.  Probably that sort of propagation mechanism needs to be generalized.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gene Bushuyev				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4349</link>
		<dc:creator><![CDATA[Gene Bushuyev]]></dc:creator>
		<pubDate>Tue, 08 Nov 2011 19:10:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4349</guid>
					<description><![CDATA[If GC is ever added to the standard I strongly believe it should be limited only to the types with trivial destructors. There should be no change in the current syntax or new keywords or new type of pointers. That limits the useability but it also keeps programs from unholy interraction of GC with destructors. Trivial destructors will be consistent with infinite life time implied by GC, so the program will not be able to detect the difference. Compiler vendors can implement this behavior within the current standard, though adding it as a requirement will make code portable.

On the positive side, I forsee new books coming about GC gotchas in C++, which makes life even more interesting -- You did what? Added a destructor? Now your program leaks! Isn&#039;t that sweet :-)]]></description>
		<content:encoded><![CDATA[<p>If GC is ever added to the standard I strongly believe it should be limited only to the types with trivial destructors. There should be no change in the current syntax or new keywords or new type of pointers. That limits the useability but it also keeps programs from unholy interraction of GC with destructors. Trivial destructors will be consistent with infinite life time implied by GC, so the program will not be able to detect the difference. Compiler vendors can implement this behavior within the current standard, though adding it as a requirement will make code portable.</p>
<p>On the positive side, I forsee new books coming about GC gotchas in C++, which makes life even more interesting &#8212; You did what? Added a destructor? Now your program leaks! Isn&#8217;t that sweet :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bob				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4249</link>
		<dc:creator><![CDATA[Bob]]></dc:creator>
		<pubDate>Mon, 31 Oct 2011 18:35:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4249</guid>
					<description><![CDATA[I designed a GC library for C++.  It&#039;s not quite automatic, but it has a simple command for quickly going through and picking up unused memory references.  The command could be timed, put into some algorithm, or manually inputted at certain points in the code sequence that is natural for a GC sweep.  Overall it&#039;s extremely efficient, though I can&#039;t guarantee that is commercial grade since I got bored of it after design.]]></description>
		<content:encoded><![CDATA[<p>I designed a GC library for C++.  It&#8217;s not quite automatic, but it has a simple command for quickly going through and picking up unused memory references.  The command could be timed, put into some algorithm, or manually inputted at certain points in the code sequence that is natural for a GC sweep.  Overall it&#8217;s extremely efficient, though I can&#8217;t guarantee that is commercial grade since I got bored of it after design.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4161</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Fri, 28 Oct 2011 21:17:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4161</guid>
					<description><![CDATA[If these questions are “just details” then you and I are having different discussions.  I&#039;m trying to address the biggest challenge in achieving your goals (with which I don&#039;t take issue): coming up with a coherent programming model that accomodates both GC and destructors.  To get there, you need to determine if/which things that used to be implementation details would subsequently have to be documented in interfaces, and these questions you&#039;re calling “details” make a huge difference in the answers.

Your goals to clean up shared_ptr cycles and support lock-free programming are great; my skepticism about achieving it with a GC language feature comes from the lack of good answers to questions about the programming model.  In my opinion there&#039;s nothing interesting to say about GC in C++ until those questions are addressed.]]></description>
		<content:encoded><![CDATA[<p>If these questions are “just details” then you and I are having different discussions.  I&#8217;m trying to address the biggest challenge in achieving your goals (with which I don&#8217;t take issue): coming up with a coherent programming model that accomodates both GC and destructors.  To get there, you need to determine if/which things that used to be implementation details would subsequently have to be documented in interfaces, and these questions you&#8217;re calling “details” make a huge difference in the answers.</p>
<p>Your goals to clean up shared_ptr cycles and support lock-free programming are great; my skepticism about achieving it with a GC language feature comes from the lack of good answers to questions about the programming model.  In my opinion there&#8217;s nothing interesting to say about GC in C++ until those questions are addressed.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4159</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 Oct 2011 19:06:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4159</guid>
					<description><![CDATA[Whatever gc_new or make_gc etc. returns would be GC&#039;d. It&#039;s a separate design decision whether it would be better to call that thing a * or some other pointer type like gc_ptr or something (just as shared_ptr and unique_ptr and weak_ptr and * are all different standard pointer types). I can see benefits and drawbacks both ways, reusing */&#038; or not reusing */&#038;.

These are interesting design questions that any specific proposal has to answer concretely and that have several promising potential design answers. But for the purposes of this discussion they are really just details that shouldn&#039;t obscure the main goal, which is to not remove/replace any existing uses (e.g., uses of std:: smart pointers or *&#039;s or change the programming model to want to gcnew everything, etc.), only to additionally solve those problems std:: smart pointers cannot (specifically shared_ptr cycles and ABA).]]></description>
		<content:encoded><![CDATA[<p>Whatever gc_new or make_gc etc. returns would be GC&#8217;d. It&#8217;s a separate design decision whether it would be better to call that thing a * or some other pointer type like gc_ptr or something (just as shared_ptr and unique_ptr and weak_ptr and * are all different standard pointer types). I can see benefits and drawbacks both ways, reusing */&amp; or not reusing */&amp;.</p>
<p>These are interesting design questions that any specific proposal has to answer concretely and that have several promising potential design answers. But for the purposes of this discussion they are really just details that shouldn&#8217;t obscure the main goal, which is to not remove/replace any existing uses (e.g., uses of std:: smart pointers or *&#8217;s or change the programming model to want to gcnew everything, etc.), only to additionally solve those problems std:: smart pointers cannot (specifically shared_ptr cycles and ABA).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4156</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Fri, 28 Oct 2011 17:57:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4156</guid>
					<description><![CDATA[Sorry, but that doesn&#039;t answer the question.  Let me rephrase.  If I take a raw pointer or reference to an object allocated with gc_new, is the existence of that pointer enough to keep the object alive, or not?]]></description>
		<content:encoded><![CDATA[<p>Sorry, but that doesn&#8217;t answer the question.  Let me rephrase.  If I take a raw pointer or reference to an object allocated with gc_new, is the existence of that pointer enough to keep the object alive, or not?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4155</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 Oct 2011 15:20:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4155</guid>
					<description><![CDATA[&lt;blockquote&gt;You still haven’t said whether all pointers or only special pointers participate in refcounting.&lt;/blockquote&gt;

My interest is in cleaning up cycles of shared_ptrs, and objects allocated with an explicit opt-in GC heap allocator (e.g., gc_new T or gc_allocator or some such). Only the cases std::*_ptr can&#039;t deal with today.]]></description>
		<content:encoded><![CDATA[<blockquote><p>You still haven’t said whether all pointers or only special pointers participate in refcounting.</p></blockquote>
<p>My interest is in cleaning up cycles of shared_ptrs, and objects allocated with an explicit opt-in GC heap allocator (e.g., gc_new T or gc_allocator or some such). Only the cases std::*_ptr can&#8217;t deal with today.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4154</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 Oct 2011 15:15:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4154</guid>
					<description><![CDATA[&lt;p&gt;Here are my answers to your main questions. I think Bjarne would give similar answers; he’s long been a proponent of optional GC (#2) for ISO C++.&lt;/p&gt;

&lt;p&gt;Briefly:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Adding a new feature to a language should be based on good reasoning, such as:&lt;/p&gt;

  &lt;p&gt;a) How likely will the feature be abused more than used well?
    &lt;br /&gt;b) How often is the feature needed at all?

    &lt;br /&gt;c) What cost or how viral is the feature? (does it force itself on those who might not want it)&lt;/p&gt;

  &lt;p&gt;@Herb, what are your answers to these a/b/c questions? Can I see your answers? &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fundamental point is that something is worth standardizing iff it’s important to support in portable code, and pulls its weight including being worth whatever cost there might be. To evaluate that, the committee members consider issues like those above as input.&lt;/p&gt;

&lt;p&gt;The answers to the above could be different for different GC proposals, but for the one I have in mind (GC for shared_ptr cycles + memory allocated with an explicitly GC-requested allocator such as a gc_new T or gc_allocator&#060;T&#062;), I think the answers are:&lt;/p&gt;

&lt;p&gt;a) I think it would be used well and rarely, because we’d teach to never use it by default (shared_ptr et al. are and should continue to be the recommended default);&lt;/p&gt;

&lt;p&gt;b) The feature should be needed rarely, but is required for interesting and important cases that simply can’t be handled in portable C++ code today. It’s kind of like what Booch said about multiple inheritance: You rarely need it, but when you need it you really need it and nothing else will do.&lt;/p&gt;

&lt;p&gt;c) I would hope it would be contained and not viral at all. I don’t see why it couldn’t be done in a very targeted way.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Secondly, are you sure your motivation is not more driven by the desire to make C++ play better with languages that already have pervasive GC, rather than by the value that GC brings to C++ itself?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That’s a natural question, because I’m heavily involved in C++/CLI and C++/CX.&lt;/p&gt;

&lt;p&gt;Yes, I’m sure. My motivation here is not related to those, though I’ve learned a lot from doing them. C++/CLI and C++CX are a different topic because they are bindings to &lt;strong&gt;foreign &lt;/strong&gt;object models and runtime systems. C++/CLI binds to .NET, which supports GC (#3 above). C++/CX binds to Windows 8 WinRT, which uses pure reference counting only (#1 above), cycle leaking and all, and here ^ and ref new can basically be thought of as a flavor of shared_ptr and make_shared baked into the compiler, plus COM details that shared_ptr and make_shared can&#039;t handle which is why we couldn&#039;t just use shared_ptr itself.&lt;/p&gt;

&lt;p&gt;In this post’s topic, I am only interested in what makes sense for &lt;strong&gt;native &lt;/strong&gt;(and possibly standard) C++, and the value GC (specifically #2) brings there. My motivation is to be able to write portable C++ code that can deal with shared_ptr cycles, and portable code to express those relatively rare, but genuinely interesting and important, algorithms that actually do require GC, which include important high-performance lock-free algorithms.&lt;/p&gt;

&lt;p&gt;Note that for several years now I’ve been writing and teaching about Effective Concurrency in all the major languages -- C++, Java, C#, and C+pthreads – and in the lock-free code section I keep having to add comments about how certain examples are easy/easier in Java and C#, and hand-wave about what it would take to do them in C++. I hate that.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I mean, if the discussion continues as is, which seems to be roughly trying to answer the isolated question of:&lt;/p&gt;

  &lt;p&gt;“what is the value of GC to C++?”&lt;/p&gt;

  &lt;p&gt;then I suspsect the majority of C++ people will just conclude the answer is “GC offers insufficient value to warrant making it pervasive in the language”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I was with you until the last sentence, which shifted to “pervasive.” I don’t know of anyone (including me) who is arguing for making it pervasive in the language; as I argued in my &lt;a href=&quot;http://channel9.msdn.com/Events/BUILD/BUILD2011/TOOL-835T&quot; rel=&quot;nofollow&quot;&gt;&lt;em&gt;Writing Modern C++ Code &lt;/em&gt;talk at Build&lt;/a&gt;, C++ is doing very well with ref counting as its primary memory and resource management tool.&lt;/p&gt;

&lt;p&gt;The answer to “what is the value of GC to C++?” is “to handle the remaining important cases ref counting can’t, such as shared_ptr cycles and ABA problems in high-performance lock-free code,” not to replace any existing use of ref counting. GC should be purely additive.&lt;/p&gt;]]></description>
		<content:encoded><![CDATA[<p>Here are my answers to your main questions. I think Bjarne would give similar answers; he’s long been a proponent of optional GC (#2) for ISO C++.</p>
<p>Briefly:</p>
<blockquote>
<p>Adding a new feature to a language should be based on good reasoning, such as:</p>
<p>a) How likely will the feature be abused more than used well?<br />
    <br />b) How often is the feature needed at all?</p>
<p>c) What cost or how viral is the feature? (does it force itself on those who might not want it)</p>
<p>@Herb, what are your answers to these a/b/c questions? Can I see your answers? </p>
</blockquote>
<p>The fundamental point is that something is worth standardizing iff it’s important to support in portable code, and pulls its weight including being worth whatever cost there might be. To evaluate that, the committee members consider issues like those above as input.</p>
<p>The answers to the above could be different for different GC proposals, but for the one I have in mind (GC for shared_ptr cycles + memory allocated with an explicitly GC-requested allocator such as a gc_new T or gc_allocator&lt;T&gt;), I think the answers are:</p>
<p>a) I think it would be used well and rarely, because we’d teach to never use it by default (shared_ptr et al. are and should continue to be the recommended default);</p>
<p>b) The feature should be needed rarely, but is required for interesting and important cases that simply can’t be handled in portable C++ code today. It’s kind of like what Booch said about multiple inheritance: You rarely need it, but when you need it you really need it and nothing else will do.</p>
<p>c) I would hope it would be contained and not viral at all. I don’t see why it couldn’t be done in a very targeted way.</p>
<blockquote>
<p>Secondly, are you sure your motivation is not more driven by the desire to make C++ play better with languages that already have pervasive GC, rather than by the value that GC brings to C++ itself?</p>
</blockquote>
<p>That’s a natural question, because I’m heavily involved in C++/CLI and C++/CX.</p>
<p>Yes, I’m sure. My motivation here is not related to those, though I’ve learned a lot from doing them. C++/CLI and C++CX are a different topic because they are bindings to <strong>foreign </strong>object models and runtime systems. C++/CLI binds to .NET, which supports GC (#3 above). C++/CX binds to Windows 8 WinRT, which uses pure reference counting only (#1 above), cycle leaking and all, and here ^ and ref new can basically be thought of as a flavor of shared_ptr and make_shared baked into the compiler, plus COM details that shared_ptr and make_shared can&#8217;t handle which is why we couldn&#8217;t just use shared_ptr itself.</p>
<p>In this post’s topic, I am only interested in what makes sense for <strong>native </strong>(and possibly standard) C++, and the value GC (specifically #2) brings there. My motivation is to be able to write portable C++ code that can deal with shared_ptr cycles, and portable code to express those relatively rare, but genuinely interesting and important, algorithms that actually do require GC, which include important high-performance lock-free algorithms.</p>
<p>Note that for several years now I’ve been writing and teaching about Effective Concurrency in all the major languages &#8212; C++, Java, C#, and C+pthreads – and in the lock-free code section I keep having to add comments about how certain examples are easy/easier in Java and C#, and hand-wave about what it would take to do them in C++. I hate that.</p>
<blockquote>
<p>I mean, if the discussion continues as is, which seems to be roughly trying to answer the isolated question of:</p>
<p>“what is the value of GC to C++?”</p>
<p>then I suspsect the majority of C++ people will just conclude the answer is “GC offers insufficient value to warrant making it pervasive in the language”</p>
</blockquote>
<p>I was with you until the last sentence, which shifted to “pervasive.” I don’t know of anyone (including me) who is arguing for making it pervasive in the language; as I argued in my <a href="http://channel9.msdn.com/Events/BUILD/BUILD2011/TOOL-835T" rel="nofollow"><em>Writing Modern C++ Code </em>talk at Build</a>, C++ is doing very well with ref counting as its primary memory and resource management tool.</p>
<p>The answer to “what is the value of GC to C++?” is “to handle the remaining important cases ref counting can’t, such as shared_ptr cycles and ABA problems in high-performance lock-free code,” not to replace any existing use of ref counting. GC should be purely additive.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Garbage collection/reference counting in C++11 - Devalot				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4147</link>
		<dc:creator><![CDATA[Garbage collection/reference counting in C++11 - Devalot]]></dc:creator>
		<pubDate>Thu, 27 Oct 2011 17:40:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4147</guid>
					<description><![CDATA[[...] are plenty of people who criticize C++ for not having a standard garbage collector. Herb Sutter explains why C++ doesn&#039;t support automatic mark-compact garbage collection but does have a formal ABI for [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] are plenty of people who criticize C++ for not having a standard garbage collector. Herb Sutter explains why C++ doesn&#039;t support automatic mark-compact garbage collection but does have a formal ABI for [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Glen				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4136</link>
		<dc:creator><![CDATA[Glen]]></dc:creator>
		<pubDate>Thu, 27 Oct 2011 03:46:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4136</guid>
					<description><![CDATA[Adding a new feature to a language should be based on good reasoning, such as:

a) How likely will the feature be abused more than used well?
b) How often is the feature needed at all?
c) What cost or how viral is the feature? (does it force itself on those who might not want it)

If a feature fails these tests, then the feature should most likely not be included, or be included in a mitigated way.

In the case of adding the GC feature to C++, if these tests could be considered in isolation, I thoroughly (so far) fail to see enough value in adding GC to C++; because when I apply these tests to GC, I get these results:

on point a), I think GC will be considered the &quot;easy&quot; option so will be used to excess as a magic bullet when it is not.
on point b), I rarely, if ever, find myself writing much code where I think &quot;wow, if only I had GC right now...&quot;
on point c), if point a) turns out to be true, I will find my application becoming the undesired &quot;beneficiary&quot; of a lot of garbage I didn&#039;t create and can&#039;t control.

So given these are my answers, thus far (and I am open to being convinced), I strongly agree with @Frank Davis that adding GC to C++ will make GC virus like for C++, and quite likely to the detriment of C++&#039;s own superior way of doing things.

@Herb, what are your answers to these a/b/c questions? Can I see your answers? Secondly, are you sure your motivation is not more driven by the desire to make C++ play better with languages that already have pervasive GC, rather than by the value that GC brings to C++ itself?

If that&#039;s the real motivation, then @everybody, perhaps we should just deal to that question instead? If we try to justify (or not) GC and C++ on their own terms as the discussion seems to be framed thus far, I suspect we will get the wrong or limited answers. I think to get better answers we need to ask a broader question:

I mean, if the discussion continues as is, which seems to be roughly trying to answer the isolated question of:

&quot;what is the value of GC to C++?&quot;

then I suspsect the majority of C++ people will just conclude the answer is &quot;GC offers insufficient value to warrant making it pervasive in the language&quot; and that will be that, for reasons very much like the ones I have given above.

However, if the right question is really this:

&quot;Given that many other languages (possibly wrongly) have chosen to make GC pervasive, how can (or even should) C++ interoperate with those languages, and can it be done without destructing/debasing C++ itself? If we don&#039;t allow such easy interoperability, are we doing more damage to C++ by marginalising C++ than by providing the choice?&quot;

If we ask that question, I think we&#039;ll get different and possibly more useful answers?

What says @others?

I think what we are really talking about here is &quot;should we, and how do we integrate c++ with C#, Java, and javascript etc and other languages.&quot;

Isn&#039;t Herb&#039;s answer to this (in the context of MS at least) already known, it&#039;s C++/CX and C++/CLI?

@others: Regardless of whether Herb convinces others of the value of GC, the question of if/how to integrate better with languages that have it still needs to be answered. Does it not? If one says simply C++ does not need GC (which I currently feel) are we not also saying C++ can&#039;t easily integrate with those that already have GC? That part I&#039;m not sure how I feel. I do feel both questions go together though.

I think minds against GC should be aware of that when answering about saying no to it.

Is C++/CLI or C++/CX the answer? Can we improve on it or mitigate it? and can/should it be part of ISO C++?

@Dave, I&#039;m keen to hear your thoughts on all this point of view and these questions. Thanks. :)]]></description>
		<content:encoded><![CDATA[<p>Adding a new feature to a language should be based on good reasoning, such as:</p>
<p>a) How likely will the feature be abused more than used well?<br />
b) How often is the feature needed at all?<br />
c) What cost or how viral is the feature? (does it force itself on those who might not want it)</p>
<p>If a feature fails these tests, then the feature should most likely not be included, or be included in a mitigated way.</p>
<p>In the case of adding the GC feature to C++, if these tests could be considered in isolation, I thoroughly (so far) fail to see enough value in adding GC to C++; because when I apply these tests to GC, I get these results:</p>
<p>on point a), I think GC will be considered the &#8220;easy&#8221; option so will be used to excess as a magic bullet when it is not.<br />
on point b), I rarely, if ever, find myself writing much code where I think &#8220;wow, if only I had GC right now&#8230;&#8221;<br />
on point c), if point a) turns out to be true, I will find my application becoming the undesired &#8220;beneficiary&#8221; of a lot of garbage I didn&#8217;t create and can&#8217;t control.</p>
<p>So given these are my answers, thus far (and I am open to being convinced), I strongly agree with @Frank Davis that adding GC to C++ will make GC virus like for C++, and quite likely to the detriment of C++&#8217;s own superior way of doing things.</p>
<p>@Herb, what are your answers to these a/b/c questions? Can I see your answers? Secondly, are you sure your motivation is not more driven by the desire to make C++ play better with languages that already have pervasive GC, rather than by the value that GC brings to C++ itself?</p>
<p>If that&#8217;s the real motivation, then @everybody, perhaps we should just deal to that question instead? If we try to justify (or not) GC and C++ on their own terms as the discussion seems to be framed thus far, I suspect we will get the wrong or limited answers. I think to get better answers we need to ask a broader question:</p>
<p>I mean, if the discussion continues as is, which seems to be roughly trying to answer the isolated question of:</p>
<p>&#8220;what is the value of GC to C++?&#8221;</p>
<p>then I suspsect the majority of C++ people will just conclude the answer is &#8220;GC offers insufficient value to warrant making it pervasive in the language&#8221; and that will be that, for reasons very much like the ones I have given above.</p>
<p>However, if the right question is really this:</p>
<p>&#8220;Given that many other languages (possibly wrongly) have chosen to make GC pervasive, how can (or even should) C++ interoperate with those languages, and can it be done without destructing/debasing C++ itself? If we don&#8217;t allow such easy interoperability, are we doing more damage to C++ by marginalising C++ than by providing the choice?&#8221;</p>
<p>If we ask that question, I think we&#8217;ll get different and possibly more useful answers?</p>
<p>What says @others?</p>
<p>I think what we are really talking about here is &#8220;should we, and how do we integrate c++ with C#, Java, and javascript etc and other languages.&#8221;</p>
<p>Isn&#8217;t Herb&#8217;s answer to this (in the context of MS at least) already known, it&#8217;s C++/CX and C++/CLI?</p>
<p>@others: Regardless of whether Herb convinces others of the value of GC, the question of if/how to integrate better with languages that have it still needs to be answered. Does it not? If one says simply C++ does not need GC (which I currently feel) are we not also saying C++ can&#8217;t easily integrate with those that already have GC? That part I&#8217;m not sure how I feel. I do feel both questions go together though.</p>
<p>I think minds against GC should be aware of that when answering about saying no to it.</p>
<p>Is C++/CLI or C++/CX the answer? Can we improve on it or mitigate it? and can/should it be part of ISO C++?</p>
<p>@Dave, I&#8217;m keen to hear your thoughts on all this point of view and these questions. Thanks. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kometes (@K0metes)				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4133</link>
		<dc:creator><![CDATA[Kometes (@K0metes)]]></dc:creator>
		<pubDate>Thu, 27 Oct 2011 03:17:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4133</guid>
					<description><![CDATA[I&#039;ve written a 
&lt;a href=&quot;https://github.com/Kometes/Honeycomb/blob/master/Honeycomb/Src/Common/Inc/Thread/Concur/List.h&quot; rel=&quot;nofollow&quot;&gt;lock-free doubly linked list&lt;/a&gt; using portable C++11 style threads/atomics. The limitations of hazard pointers that I think you&#039;re talking about can be patched up with &lt;a href=&quot;https://github.com/Kometes/Honeycomb/blob/master/Honeycomb/Src/Common/Inc/Thread/Concur/Mem.h&quot; rel=&quot;nofollow&quot;&gt;what basically amounts to GC&lt;/a&gt;, but it&#039;s a GC optimized for the problem domain and turns out to be quite trivial, deterministic and lock-free.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve written a<br />
<a href="https://github.com/Kometes/Honeycomb/blob/master/Honeycomb/Src/Common/Inc/Thread/Concur/List.h" rel="nofollow">lock-free doubly linked list</a> using portable C++11 style threads/atomics. The limitations of hazard pointers that I think you&#8217;re talking about can be patched up with <a href="https://github.com/Kometes/Honeycomb/blob/master/Honeycomb/Src/Common/Inc/Thread/Concur/Mem.h" rel="nofollow">what basically amounts to GC</a>, but it&#8217;s a GC optimized for the problem domain and turns out to be quite trivial, deterministic and lock-free.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4126</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Thu, 27 Oct 2011 00:03:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4126</guid>
					<description><![CDATA[Final judgement reserved of course, but I&#039;ve spent a lot of time thinking about this problem and haven&#039;t seen or found anything that solves it yet, so forgive me if I&#039;m skeptical.

&lt;blockquote&gt;
If the calling code that owns the object wants it to be destroyed deterministically, and the object may participate in a cycle, then the code has to break the cycle. The object itself doesn’t and shouldn’t care so its code is unaffected.
&lt;/blockquote&gt;

Great; you insulate the object from the knowledge that it might be leaked.  But you don&#039;t insulate client code from the knowledge that the object participates in a cycle or that its destructor (possibly indirectly) handles non-memory resources.  Now every class that might participate in a reference cycle or manage non-memory resources needs to advertise that fact; it can never be an implementation detail.

You still haven&#039;t said whether all pointers or only special pointers participate in refcounting.

With regard to &quot;relying on accurate GC,&quot; I can&#039;t imagine what visible effects would allow a program to determine that it has an accurate GC, and I can&#039;t imagine what standard language you could write that would force an implementation to provide an accurate GC... or any GC for that matter.  For what it&#039;s worth, I don&#039;t have a position on accurate-vs-conservative GC; everything I&#039;ve said about the programming model applies equally to both.

Hazard pointers seem reasonably straighforward to me, and it doesn&#039;t seem to me that merely having a GC is going to make the shark-infested waters of lockfree programming seem easy and safe to anyone.]]></description>
		<content:encoded><![CDATA[<p>Final judgement reserved of course, but I&#8217;ve spent a lot of time thinking about this problem and haven&#8217;t seen or found anything that solves it yet, so forgive me if I&#8217;m skeptical.</p>
<blockquote><p>
If the calling code that owns the object wants it to be destroyed deterministically, and the object may participate in a cycle, then the code has to break the cycle. The object itself doesn’t and shouldn’t care so its code is unaffected.
</p></blockquote>
<p>Great; you insulate the object from the knowledge that it might be leaked.  But you don&#8217;t insulate client code from the knowledge that the object participates in a cycle or that its destructor (possibly indirectly) handles non-memory resources.  Now every class that might participate in a reference cycle or manage non-memory resources needs to advertise that fact; it can never be an implementation detail.</p>
<p>You still haven&#8217;t said whether all pointers or only special pointers participate in refcounting.</p>
<p>With regard to &#8220;relying on accurate GC,&#8221; I can&#8217;t imagine what visible effects would allow a program to determine that it has an accurate GC, and I can&#8217;t imagine what standard language you could write that would force an implementation to provide an accurate GC&#8230; or any GC for that matter.  For what it&#8217;s worth, I don&#8217;t have a position on accurate-vs-conservative GC; everything I&#8217;ve said about the programming model applies equally to both.</p>
<p>Hazard pointers seem reasonably straighforward to me, and it doesn&#8217;t seem to me that merely having a GC is going to make the shark-infested waters of lockfree programming seem easy and safe to anyone.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4120</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 21:09:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4120</guid>
					<description><![CDATA[All I ask is that you reserve your judgment until hearing out a complete proposal. :)

Briefly answering your questions:

Ordered destructors must always get called deterministically (only), as today. They cannot be called while automatically/lazily cleaning up cycles because cycle cleanup is unordered. The natural tool for unordered cleanup is the unordered finalizer, if unordered cleanup is to be supported at all of course.

It&#039;s up to the calling code that owns a particular object to manage its lifetime. If the calling code that owns the object wants it to be destroyed deterministically, and the object may participate in a cycle, then the code has to break the cycle. The object itself doesn&#039;t and shouldn&#039;t care so its code is unaffected.

All existing C++ garbage collectors, notably the Boehm collector, aren&#039;t enough for many interesting uses for several reasons, the main one being that they&#039;re conservative, not accurate. See Hans Boehm&#039;s page &lt;a href=&quot;http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html&quot; rel=&quot;nofollow&quot;&gt;Advantages and Disadvantages of Conservative Garbage Collection&lt;/a&gt; for more discussion of tradeoffs.

As usual, there&#039;s something to standardize iff we want to enable portability. So in this case the question is whether it&#039;s interesting to enable portable programs that rely on GC -- and note that typically if they rely on GC, they rely specifically on accurate GC, not conservative &quot;maybe-GC.&quot; For example, C++11 atomics enable writing many kinds of portable lock-free code, but not all; we need a standard for #2 [*] if we want to enable people to write portable lock-free singly-linked lists, where the only known practical algorithms require automatic (non-refcount) GC and so they cannot be implemented in portable C++ today without some nonportable platform-specific code underneath. [**]


[*] Or #3, but that&#039;s more invasive in the language. Normal pointers can handle #2, but not #3.

[**] Again, appeals to hazard pointers fail because the obscure convolutions and limitations of hazard pointers only expose the limits of even the most heroic efforts to work around the lack of true automatic GC. The main contribution of hazard pointers, unfortunately, is that they thoroughly motivate why direct support for automatic GC is needed. It&#039;s similar to how Boost.Lambda is wonderful for a few basic cases if: (a) you can live within the limitations (e.g., on member functions) and remember them every time and don&#039;t accidentally reach for something they can&#039;t do; and (b) spell everything correctly the first time so you avoid the undebuggable template error cascades. Both (a) and (b) are routinely violated even by developers familiar with the library, and so Boost.Lambda mostly serves as thorough motivation for why language support for lambdas is needed, and are cited as such in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf&quot; rel=&quot;nofollow&quot;&gt;the original C++0x lambda proposal&lt;/a&gt; (see section 1.1).]]></description>
		<content:encoded><![CDATA[<p>All I ask is that you reserve your judgment until hearing out a complete proposal. :)</p>
<p>Briefly answering your questions:</p>
<p>Ordered destructors must always get called deterministically (only), as today. They cannot be called while automatically/lazily cleaning up cycles because cycle cleanup is unordered. The natural tool for unordered cleanup is the unordered finalizer, if unordered cleanup is to be supported at all of course.</p>
<p>It&#8217;s up to the calling code that owns a particular object to manage its lifetime. If the calling code that owns the object wants it to be destroyed deterministically, and the object may participate in a cycle, then the code has to break the cycle. The object itself doesn&#8217;t and shouldn&#8217;t care so its code is unaffected.</p>
<p>All existing C++ garbage collectors, notably the Boehm collector, aren&#8217;t enough for many interesting uses for several reasons, the main one being that they&#8217;re conservative, not accurate. See Hans Boehm&#8217;s page <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html" rel="nofollow">Advantages and Disadvantages of Conservative Garbage Collection</a> for more discussion of tradeoffs.</p>
<p>As usual, there&#8217;s something to standardize iff we want to enable portability. So in this case the question is whether it&#8217;s interesting to enable portable programs that rely on GC &#8212; and note that typically if they rely on GC, they rely specifically on accurate GC, not conservative &#8220;maybe-GC.&#8221; For example, C++11 atomics enable writing many kinds of portable lock-free code, but not all; we need a standard for #2 [*] if we want to enable people to write portable lock-free singly-linked lists, where the only known practical algorithms require automatic (non-refcount) GC and so they cannot be implemented in portable C++ today without some nonportable platform-specific code underneath. [**]</p>
<p>[*] Or #3, but that&#8217;s more invasive in the language. Normal pointers can handle #2, but not #3.</p>
<p>[**] Again, appeals to hazard pointers fail because the obscure convolutions and limitations of hazard pointers only expose the limits of even the most heroic efforts to work around the lack of true automatic GC. The main contribution of hazard pointers, unfortunately, is that they thoroughly motivate why direct support for automatic GC is needed. It&#8217;s similar to how Boost.Lambda is wonderful for a few basic cases if: (a) you can live within the limitations (e.g., on member functions) and remember them every time and don&#8217;t accidentally reach for something they can&#8217;t do; and (b) spell everything correctly the first time so you avoid the undebuggable template error cascades. Both (a) and (b) are routinely violated even by developers familiar with the library, and so Boost.Lambda mostly serves as thorough motivation for why language support for lambdas is needed, and are cited as such in <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf" rel="nofollow">the original C++0x lambda proposal</a> (see section 1.1).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Harold Ancell				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4119</link>
		<dc:creator><![CDATA[Harold Ancell]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 21:04:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4119</guid>
					<description><![CDATA[Jones and Lins is indeed great but it&#039;s a decade and a half old.  Jones just published an updated version with two different co-authors, Hosking and Moss, The Garbage Collection Handbook, &lt;a href=&quot;http://www.amazon.com/gp/product/1420082795/&quot; rel=&quot;nofollow&quot;&gt;available here&lt;/a&gt;.  I haven&#039;t had time to really look at this new edition, although it comments that many foundational explanations are more concise in the new book and if they&#039;re problematic you might want to look at the older one.

Speaking of books, Mr. Cutter, when are you going to publish your&#039;s on the fun of low level concurrency?  At the end, your superb column was the only reason I was still reading the paper magazine....]]></description>
		<content:encoded><![CDATA[<p>Jones and Lins is indeed great but it&#8217;s a decade and a half old.  Jones just published an updated version with two different co-authors, Hosking and Moss, The Garbage Collection Handbook, <a href="http://www.amazon.com/gp/product/1420082795/" rel="nofollow">available here</a>.  I haven&#8217;t had time to really look at this new edition, although it comments that many foundational explanations are more concise in the new book and if they&#8217;re problematic you might want to look at the older one.</p>
<p>Speaking of books, Mr. Cutter, when are you going to publish your&#8217;s on the fun of low level concurrency?  At the end, your superb column was the only reason I was still reading the paper magazine&#8230;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: chilabot				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4116</link>
		<dc:creator><![CDATA[chilabot]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 19:41:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4116</guid>
					<description><![CDATA[GC type 2 and 3 would be a bad addition to the language. If those are needed for a *particular* type of application, then they sould be provided as libraries. Most kind of applications only need the first type.]]></description>
		<content:encoded><![CDATA[<p>GC type 2 and 3 would be a bad addition to the language. If those are needed for a *particular* type of application, then they sould be provided as libraries. Most kind of applications only need the first type.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4115</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 19:30:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4115</guid>
					<description><![CDATA[Some important details missing here: do regular C++ pointers refcount, or just some special GC/smart pointer (I presume the latter)?  Do you plan to call destructors during cycle reclamation (I presume not)?. 

Regardless of the answers, I think this approach is problematic.  It doesn&#039;t matter what small fraction of objects get reclaimed by GC; as long as GC is in the system and a GC&#039;d object can contain an object whose destructor matters, we&#039;re breaking the implicit contract with class authors that destructors will be called, (or that they&#039;ll work as designed if you &lt;em&gt;do&lt;/em&gt; intend to call them).

The basic programming model remains the same: if you leak stuff, it won&#039;t (necessarily) get destroyed and its memory &lt;em&gt;might&lt;/em&gt; eventually be reclaimed.  These are exactly the guarantees that the C++ standard gives you today.  Personally, I wouldn&#039;t waste the cycles on refcounting if that&#039;s all you&#039;re getting.  To leak objects and get their destructors called, you need to know they don&#039;t participate in any cycles, which is very difficult in general, even if you have a special GC pointer (because people will use it liberally).

Any vendor who wants to support the programming model where leaking memory is (sometimes) harmless can ship the Boehm collector as part of their runtime.  I seriously don&#039;t think there&#039;s anything to standardize here.]]></description>
		<content:encoded><![CDATA[<p>Some important details missing here: do regular C++ pointers refcount, or just some special GC/smart pointer (I presume the latter)?  Do you plan to call destructors during cycle reclamation (I presume not)?. </p>
<p>Regardless of the answers, I think this approach is problematic.  It doesn&#8217;t matter what small fraction of objects get reclaimed by GC; as long as GC is in the system and a GC&#8217;d object can contain an object whose destructor matters, we&#8217;re breaking the implicit contract with class authors that destructors will be called, (or that they&#8217;ll work as designed if you <em>do</em> intend to call them).</p>
<p>The basic programming model remains the same: if you leak stuff, it won&#8217;t (necessarily) get destroyed and its memory <em>might</em> eventually be reclaimed.  These are exactly the guarantees that the C++ standard gives you today.  Personally, I wouldn&#8217;t waste the cycles on refcounting if that&#8217;s all you&#8217;re getting.  To leak objects and get their destructors called, you need to know they don&#8217;t participate in any cycles, which is very difficult in general, even if you have a special GC pointer (because people will use it liberally).</p>
<p>Any vendor who wants to support the programming model where leaking memory is (sometimes) harmless can ship the Boehm collector as part of their runtime.  I seriously don&#8217;t think there&#8217;s anything to standardize here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: henrik				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4114</link>
		<dc:creator><![CDATA[henrik]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 19:23:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4114</guid>
					<description><![CDATA[and Apple added and promoted GC to Objective-C only to kind of back down. now not so promoted and iOS does not support it. besides ref counting is not very hard to do and works just fine. atleast in ObjC :)

http://arstechnica.com/apple/reviews/2011/07/mac-os-x-10-7.ars/10#arc]]></description>
		<content:encoded><![CDATA[<p>and Apple added and promoted GC to Objective-C only to kind of back down. now not so promoted and iOS does not support it. besides ref counting is not very hard to do and works just fine. atleast in ObjC :)</p>
<p><a href="http://arstechnica.com/apple/reviews/2011/07/mac-os-x-10-7.ars/10#arc" rel="nofollow">http://arstechnica.com/apple/reviews/2011/07/mac-os-x-10-7.ars/10#arc</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4112</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 18:37:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4112</guid>
					<description><![CDATA[See other comments, but briefly: cleaning up cycles of shared_ptrs, which you can often design away but sometimes naturally arise; and lock-free coding to solve the ABA problem and other issues, where it really makes the code way simpler, and you really don&#039;t want to dip into the murky waters of hazard pointers which are mainly useful to show the extent of the heroic efforts to deal with this problem without automatic non-RC GC.]]></description>
		<content:encoded><![CDATA[<p>See other comments, but briefly: cleaning up cycles of shared_ptrs, which you can often design away but sometimes naturally arise; and lock-free coding to solve the ABA problem and other issues, where it really makes the code way simpler, and you really don&#8217;t want to dip into the murky waters of hazard pointers which are mainly useful to show the extent of the heroic efforts to deal with this problem without automatic non-RC GC.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4111</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 18:35:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4111</guid>
					<description><![CDATA[That&#039;s not the only alternative. Destructors and finalizers are different and complementary (and you virtually always want the former, as mentioned in other comments below).

Reference counting (#1) is often the best and it&#039;s C++&#039;s default form of GC. But there are reasons to also (not instead) want lazy mark-sweep (#2) garbage collection in C++ to deal with things ref counting can&#039;t deal with, including when potential cycles are unavoidable (in some cases some objects may naturally be shared, but then might refer to each other) and lock-free ABA issues.

My impression is that the best memory management model for future C++ will be reference counting nearly always (#1) plus mark-sweep GC (#2) to reclaim ref count cycles and enable important lock-free code styles that smart pointers alone can&#039;t support.

Using #2 as a backup for #1 in this way has been well explored in the past in other languages and systems. It is known to work well, it makes #2 faster because you have less memory to inspect (e.g., Bacon&#039;s observation that you can&#039;t get a cycle unless a ref count decrement results in a nonzero count, so you only add those to a root list), and you only need unordered finalizers (if at all) for the objects cleaned up by #2 (e.g., if there&#039;s a cycle you have to pick a loser and break it somewhere, and for the non-cycle cases you typically can arrange for those objects to not own resources so no finalizer is necessary).

So my current position is to support: (a) adding mark-sweep GC to a future C++ standard, but to use it only for cleaning up shared_ptr cycles and objects allocated with a separate &quot;gcnew&quot; or similar opt-in GC allocation to cover the lock-free uses; and (b) not support finalizers at all, which I think we can get away with -- they&#039;re strongly discouraged even in the systems like Java and .NET that have way more potential need for them because they lack any kind of standard reference counting to have a stronger deterministic destruction story.]]></description>
		<content:encoded><![CDATA[<p>That&#8217;s not the only alternative. Destructors and finalizers are different and complementary (and you virtually always want the former, as mentioned in other comments below).</p>
<p>Reference counting (#1) is often the best and it&#8217;s C++&#8217;s default form of GC. But there are reasons to also (not instead) want lazy mark-sweep (#2) garbage collection in C++ to deal with things ref counting can&#8217;t deal with, including when potential cycles are unavoidable (in some cases some objects may naturally be shared, but then might refer to each other) and lock-free ABA issues.</p>
<p>My impression is that the best memory management model for future C++ will be reference counting nearly always (#1) plus mark-sweep GC (#2) to reclaim ref count cycles and enable important lock-free code styles that smart pointers alone can&#8217;t support.</p>
<p>Using #2 as a backup for #1 in this way has been well explored in the past in other languages and systems. It is known to work well, it makes #2 faster because you have less memory to inspect (e.g., Bacon&#8217;s observation that you can&#8217;t get a cycle unless a ref count decrement results in a nonzero count, so you only add those to a root list), and you only need unordered finalizers (if at all) for the objects cleaned up by #2 (e.g., if there&#8217;s a cycle you have to pick a loser and break it somewhere, and for the non-cycle cases you typically can arrange for those objects to not own resources so no finalizer is necessary).</p>
<p>So my current position is to support: (a) adding mark-sweep GC to a future C++ standard, but to use it only for cleaning up shared_ptr cycles and objects allocated with a separate &#8220;gcnew&#8221; or similar opt-in GC allocation to cover the lock-free uses; and (b) not support finalizers at all, which I think we can get away with &#8212; they&#8217;re strongly discouraged even in the systems like Java and .NET that have way more potential need for them because they lack any kind of standard reference counting to have a stronger deterministic destruction story.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4110</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 18:20:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4110</guid>
					<description><![CDATA[For example, see &lt;a href=&quot;http://www.bluebytesoftware.com/blog/PermaLink.aspx?guid=88e62cdf-5919-4ac7-bc33-20c06ae539ae&quot; rel=&quot;nofollow&quot;&gt;this 2005 chapter from the .NET Design Guidelines&lt;/a&gt;, especially the annotations I provided.

C++/CLI has prior art showing an elegant way to expose finalizers in C++. It uses the T::!T() syntax. But yes, you should not rely on unordered finalizers, deterministic ordered destructors are much preferable in all languages including C# and Java, and C++ does them best including when using smart pointers.]]></description>
		<content:encoded><![CDATA[<p>For example, see <a href="http://www.bluebytesoftware.com/blog/PermaLink.aspx?guid=88e62cdf-5919-4ac7-bc33-20c06ae539ae" rel="nofollow">this 2005 chapter from the .NET Design Guidelines</a>, especially the annotations I provided.</p>
<p>C++/CLI has prior art showing an elegant way to expose finalizers in C++. It uses the T::!T() syntax. But yes, you should not rely on unordered finalizers, deterministic ordered destructors are much preferable in all languages including C# and Java, and C++ does them best including when using smart pointers.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4103</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 14:51:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4103</guid>
					<description><![CDATA[Ask any GC expert and they&#039;ll tell you that confusing finalizers with destructors is a fatal error.  They&#039;re really distinct beasts, in so many ways: finalizers have no ordering constraints, no guarantee they will ever get called, etc….  Read what the Josh Bloch has to say about finalizers in Java: his guideline is basically, &quot;don&#039;t use finalizers for anything that matters.&quot;]]></description>
		<content:encoded><![CDATA[<p>Ask any GC expert and they&#8217;ll tell you that confusing finalizers with destructors is a fatal error.  They&#8217;re really distinct beasts, in so many ways: finalizers have no ordering constraints, no guarantee they will ever get called, etc….  Read what the Josh Bloch has to say about finalizers in Java: his guideline is basically, &#8220;don&#8217;t use finalizers for anything that matters.&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4102</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 14:46:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4102</guid>
					<description><![CDATA[@Martin Vejnár: That is one argument that&#039;s been made.  Last I heard, it helps in lock-free programming because nobody knows how to do deallocation efficiently without stopping the world.]]></description>
		<content:encoded><![CDATA[<p>@Martin Vejnár: That is one argument that&#8217;s been made.  Last I heard, it helps in lock-free programming because nobody knows how to do deallocation efficiently without stopping the world.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4101</link>
		<dc:creator><![CDATA[Paul]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 14:35:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4101</guid>
					<description><![CDATA[Or you could have special destructors for releasing memory, and then you would know if its a GC type or non-GC type by checking if it has a non trivial destructor. If GC is disabled(I assume if it was built-in to C++ it would be optional), it would make the memory destructor part of the main destructor. So ultimately it would have a non trivial destructor with the GC disabled and a trivial destructor when the GC is enabled.

Especially on multi-core machine, the GC generally has better performance than reference counting, because the collection can be done in separate thread.]]></description>
		<content:encoded><![CDATA[<p>Or you could have special destructors for releasing memory, and then you would know if its a GC type or non-GC type by checking if it has a non trivial destructor. If GC is disabled(I assume if it was built-in to C++ it would be optional), it would make the memory destructor part of the main destructor. So ultimately it would have a non trivial destructor with the GC disabled and a trivial destructor when the GC is enabled.</p>
<p>Especially on multi-core machine, the GC generally has better performance than reference counting, because the collection can be done in separate thread.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Momchil Velikov				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4100</link>
		<dc:creator><![CDATA[Momchil Velikov]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 13:53:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4100</guid>
					<description><![CDATA[Garbage collected object can still have a sort of destructors, traditionally called &quot;finalizer&quot;s, which could close files, etc, i.e. release non-memory resources. Finalizers have their own set of problems, though. For example, since the garbage collectors conservatively approximate object lifetime with object reachability, it&#039;s not clear what do to when a finalizer is run on an unreachable object, but that finalizer makes the object reachable again (i.e. the reachability approximation of lifetime no longer holds. Oh well, one can always take the &quot;undefined behavior&quot; escape route :).  Another issue is triggering of collection - one can reasonably assume that a shortage of memory would cause unreachable, but not yet collected object to be collected, in effect releasing memory, whereas shortage of non-memory resources ... well it will need to be integrated with the garbage collector somehow ...]]></description>
		<content:encoded><![CDATA[<p>Garbage collected object can still have a sort of destructors, traditionally called &#8220;finalizer&#8221;s, which could close files, etc, i.e. release non-memory resources. Finalizers have their own set of problems, though. For example, since the garbage collectors conservatively approximate object lifetime with object reachability, it&#8217;s not clear what do to when a finalizer is run on an unreachable object, but that finalizer makes the object reachable again (i.e. the reachability approximation of lifetime no longer holds. Oh well, one can always take the &#8220;undefined behavior&#8221; escape route :).  Another issue is triggering of collection &#8211; one can reasonably assume that a shortage of memory would cause unreachable, but not yet collected object to be collected, in effect releasing memory, whereas shortage of non-memory resources &#8230; well it will need to be integrated with the garbage collector somehow &#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Frank Davis				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4099</link>
		<dc:creator><![CDATA[Frank Davis]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 12:39:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4099</guid>
					<description><![CDATA[I don&#039;t want to come across as stubborn or stuck in my ways, but I really do not want to see a built in GC as a part of the C++ standard.

I think memory can be managed easily if you are willing to learn the simple smart pointer abstractions. Shared pointer is basically a rudimentary GC which maintains constant execution time.

Furthermore I know that if it was to be introduced, libraries would quickly introduce it and it would become be hard to build a non GC (therefore known execution time) out of component libraries. Look at Objective C and D as examples of to the metal languages with a GC, almost all of the code written for them usually the GC by default. They have a place but it isn&#039;t the same as C++.]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t want to come across as stubborn or stuck in my ways, but I really do not want to see a built in GC as a part of the C++ standard.</p>
<p>I think memory can be managed easily if you are willing to learn the simple smart pointer abstractions. Shared pointer is basically a rudimentary GC which maintains constant execution time.</p>
<p>Furthermore I know that if it was to be introduced, libraries would quickly introduce it and it would become be hard to build a non GC (therefore known execution time) out of component libraries. Look at Objective C and D as examples of to the metal languages with a GC, almost all of the code written for them usually the GC by default. They have a place but it isn&#8217;t the same as C++.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Achilleas Margaritis				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4098</link>
		<dc:creator><![CDATA[Achilleas Margaritis]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 11:29:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4098</guid>
					<description><![CDATA[Reference counting covers a lot,, if not most of cases. It requires careful planning not to introduce cycles via subclasses, but it is quite ubiquitous in the C++ world nowadays, and therefore GC is not really required.

In case someone is interested, I have a new idea regarding collection: instead of tracing objects from roots, let the roots be traced from objects. I&#039;ve made an implementation here: https://github.com/axilmar/a5gc]]></description>
		<content:encoded><![CDATA[<p>Reference counting covers a lot,, if not most of cases. It requires careful planning not to introduce cycles via subclasses, but it is quite ubiquitous in the C++ world nowadays, and therefore GC is not really required.</p>
<p>In case someone is interested, I have a new idea regarding collection: instead of tracing objects from roots, let the roots be traced from objects. I&#8217;ve made an implementation here: <a href="https://github.com/axilmar/a5gc" rel="nofollow">https://github.com/axilmar/a5gc</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: sim82 (@sim82)				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4096</link>
		<dc:creator><![CDATA[sim82 (@sim82)]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 09:30:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4096</guid>
					<description><![CDATA[&quot;what anyone would use GC for&quot;
I&#039;ve come across one case where GC actually makes things easier: a data-structure for storing un-rooted trees, where the inner nodes are represented by circular linked lists (this kind of structure is common in computational phylogenetics). The circular links don&#039;t work with ref-counting and the trees can be freely split/merged, so it&#039;s kind of cumbersome to keep track of the separate trees for manual de-allocation. A manual mark/sweep GC was the most convenient solution. Apart from that, I&#039;ve been quite happy without mandatory GC. Have not seen a memory-leak for a while...]]></description>
		<content:encoded><![CDATA[<p>&#8220;what anyone would use GC for&#8221;<br />
I&#8217;ve come across one case where GC actually makes things easier: a data-structure for storing un-rooted trees, where the inner nodes are represented by circular linked lists (this kind of structure is common in computational phylogenetics). The circular links don&#8217;t work with ref-counting and the trees can be freely split/merged, so it&#8217;s kind of cumbersome to keep track of the separate trees for manual de-allocation. A manual mark/sweep GC was the most convenient solution. Apart from that, I&#8217;ve been quite happy without mandatory GC. Have not seen a memory-leak for a while&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin Vejnár				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4094</link>
		<dc:creator><![CDATA[Martin Vejnár]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 09:07:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4094</guid>
					<description><![CDATA[I was wandering the same thing. Is there perhaps a performance benefit in delaying memory releases so that multiple of them can be processed in batch?]]></description>
		<content:encoded><![CDATA[<p>I was wandering the same thing. Is there perhaps a performance benefit in delaying memory releases so that multiple of them can be processed in batch?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: 조영일의 자리 매김 &#183; [번역] shared_ptr				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4092</link>
		<dc:creator><![CDATA[조영일의 자리 매김 &#183; [번역] shared_ptr]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 09:02:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4092</guid>
					<description><![CDATA[[...] Sutter가 GC에 대한 견해를 밝혔는데, 레퍼런스 카운팅은 표준을 통해 지원하고, Mark&#038;Sweep 방식은 [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter가 GC에 대한 견해를 밝혔는데, 레퍼런스 카운팅은 표준을 통해 지원하고, Mark&amp;Sweep 방식은 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrzej Krzemieński				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4091</link>
		<dc:creator><![CDATA[Andrzej Krzemieński]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 07:33:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4091</guid>
					<description><![CDATA[Hi,
This is perhaps a good place to ask what anyone would use GC for. I understand that it is indispensable in Java because you cannot allocate objects on &quot;the stack&quot;. In contrast, C++ offers automatic life-time and memory management. 

What are the practical uses of GC in C++? What are the practical uses of shared_ptr?

Regards,
&#038;rzej]]></description>
		<content:encoded><![CDATA[<p>Hi,<br />
This is perhaps a good place to ask what anyone would use GC for. I understand that it is indispensable in Java because you cannot allocate objects on &#8220;the stack&#8221;. In contrast, C++ offers automatic life-time and memory management. </p>
<p>What are the practical uses of GC in C++? What are the practical uses of shared_ptr?</p>
<p>Regards,<br />
&amp;rzej</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cory Nelson (@scalablecory)				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4087</link>
		<dc:creator><![CDATA[Cory Nelson (@scalablecory)]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 00:17:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4087</guid>
					<description><![CDATA[&quot;OK, GC was invented half a century ago. When it is going to land in the C++ world?&quot;

Honest question: what uses have you seen for GC?

Getting rid of the ABA tag in some lock-free algorithms is one, but there are other solutions with similar efficiency and flexibility.

.NET has a lot of small heap allocations so compaction is pretty nice for maintaining low fragmentation (and possibly locality). The heap is touched far less often in C++, so I see compaction as less important here.

Resource management in C++ has been easy for some time now. Easier than in C#, even. I can&#039;t remember the last time I had a memory leak.]]></description>
		<content:encoded><![CDATA[<p>&#8220;OK, GC was invented half a century ago. When it is going to land in the C++ world?&#8221;</p>
<p>Honest question: what uses have you seen for GC?</p>
<p>Getting rid of the ABA tag in some lock-free algorithms is one, but there are other solutions with similar efficiency and flexibility.</p>
<p>.NET has a lot of small heap allocations so compaction is pretty nice for maintaining low fragmentation (and possibly locality). The heap is touched far less often in C++, so I see compaction as less important here.</p>
<p>Resource management in C++ has been easy for some time now. Easier than in C#, even. I can&#8217;t remember the last time I had a memory leak.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4086</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Wed, 26 Oct 2011 00:03:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/10/25/garbage-collection-synopsis-and-c/#comment-4086</guid>
					<description><![CDATA[The greatest obstacle to integrating GC with C++ is the lack of a programming model for mixing GC with destructors.  Today, when I write a class with a destructor, I can, &lt;em&gt;as an implementation detail&lt;/em&gt;, make it hold a file open, claim mutexes, or handle any other non-memory resource I want it to, so long as I clean those resources up in the destructor.  I can be assured that—so long as the user of my class plays by the rules—the destructor will always get called and those resources will be released.

Now, in a world with GC, it&#039;s &lt;em&gt;de-rigeur&lt;/em&gt; to place objects into data structures and simply leak them, secure in the knowledge that they will be cleaned up as necessary.  The problem, if we start doing that, is that the destructors of objects managing non-memory resources are no longer called.  So what&#039;s the programming model for using GC in C++?  If we still have to write code to destroy/delete objects, then the programming model isn&#039;t changed, and there&#039;s no benefit to users in standardizing GC.  Any vendor who wants to can add a GC for cleaning up leaked memory as a conforming extension.

The alternative is to declare some classes as GC&#039;d-only and some as non-GC&#039;d, and disallow non-GC&#039;d classes inside GC&#039;d classes.  But that&#039;s awful :-)]]></description>
		<content:encoded><![CDATA[<p>The greatest obstacle to integrating GC with C++ is the lack of a programming model for mixing GC with destructors.  Today, when I write a class with a destructor, I can, <em>as an implementation detail</em>, make it hold a file open, claim mutexes, or handle any other non-memory resource I want it to, so long as I clean those resources up in the destructor.  I can be assured that—so long as the user of my class plays by the rules—the destructor will always get called and those resources will be released.</p>
<p>Now, in a world with GC, it&#8217;s <em>de-rigeur</em> to place objects into data structures and simply leak them, secure in the knowledge that they will be cleaned up as necessary.  The problem, if we start doing that, is that the destructors of objects managing non-memory resources are no longer called.  So what&#8217;s the programming model for using GC in C++?  If we still have to write code to destroy/delete objects, then the programming model isn&#8217;t changed, and there&#8217;s no benefit to users in standardizing GC.  Any vendor who wants to can add a GC for cleaning up leaked memory as a conforming extension.</p>
<p>The alternative is to declare some classes as GC&#8217;d-only and some as non-GC&#8217;d, and disallow non-GC&#8217;d classes inside GC&#8217;d classes.  But that&#8217;s awful :-)</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
