<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Why no container-based algorithms?	</title>
	<atom:link href="https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-4278</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 02 Nov 2011 15:48:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-4278</guid>
					<description><![CDATA[@Gevorg: Duh. Fixed. That&#039;s what I get for throwing in edits on the fly without compiling -- gcc would have merrily reported &quot;error: need &#039;typename&#039; before &#039;std::enableif&#060; ...&#034; etc.]]></description>
		<content:encoded><![CDATA[<p>@Gevorg: Duh. Fixed. That&#8217;s what I get for throwing in edits on the fly without compiling &#8212; gcc would have merrily reported &#8220;error: need &#8216;typename&#8217; before &#8216;std::enableif&lt; &#8230;&quot; etc.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gevorg				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-4271</link>
		<dc:creator><![CDATA[Gevorg]]></dc:creator>
		<pubDate>Wed, 02 Nov 2011 09:33:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-4271</guid>
					<description><![CDATA[Herb, now the &#039;typename&#039; keywords aren&#039;t where they should be.
Instead of    enable_if&#060; typename CallableWithBeginAndEnd&#060;Container&#062;::value, void &#062;::type
it should&#039;ve been    typename enable_if&#060; CallableWithBeginAndEnd&#060;Container&#062;::value, void &#062;::type
Similarly for disable_if. Well we don&#039;t have disable_if in std so I guess it is assumed the user has written one himself. Alternatively, boost::disable_if_c, or better, boost::disable_if and omitting ::value part.]]></description>
		<content:encoded><![CDATA[<p>Herb, now the &#8216;typename&#8217; keywords aren&#8217;t where they should be.<br />
Instead of    enable_if&lt; typename CallableWithBeginAndEnd&lt;Container&gt;::value, void &gt;::type<br />
it should&#8217;ve been    typename enable_if&lt; CallableWithBeginAndEnd&lt;Container&gt;::value, void &gt;::type<br />
Similarly for disable_if. Well we don&#8217;t have disable_if in std so I guess it is assumed the user has written one himself. Alternatively, boost::disable_if_c, or better, boost::disable_if and omitting ::value part.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-4252</link>
		<dc:creator><![CDATA[Paul]]></dc:creator>
		<pubDate>Mon, 31 Oct 2011 23:17:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-4252</guid>
					<description><![CDATA[Jon said: Why not change the name of the functions that take a collection? Eg sort_col()

Herb said: You could, but then you lose the ability to overload which can be desirable.

My question: why would you want to be able to overload in this particular instance?  Sort with two iterators - you want to maybe sort only half of the collection.  Sort a container - sort them all.   Different intents, different names.

A better function name would be sort_all().
Then the meaning of that line of code becomes clearer with even less code to read.  And if you accidentally pass it two iterators then it can tell you.]]></description>
		<content:encoded><![CDATA[<p>Jon said: Why not change the name of the functions that take a collection? Eg sort_col()</p>
<p>Herb said: You could, but then you lose the ability to overload which can be desirable.</p>
<p>My question: why would you want to be able to overload in this particular instance?  Sort with two iterators &#8211; you want to maybe sort only half of the collection.  Sort a container &#8211; sort them all.   Different intents, different names.</p>
<p>A better function name would be sort_all().<br />
Then the meaning of that line of code becomes clearer with even less code to read.  And if you accidentally pass it two iterators then it can tell you.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris Vine				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3812</link>
		<dc:creator><![CDATA[Chris Vine]]></dc:creator>
		<pubDate>Mon, 17 Oct 2011 12:40:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3812</guid>
					<description><![CDATA[Isn&#039;t the new C++11 range-based for supposed to cover this use case?  The only significant difference between this proposal and range-based for is that what would be the function block of the lambda statement in this proposal becomes the range-based for&#039;s statement block.]]></description>
		<content:encoded><![CDATA[<p>Isn&#8217;t the new C++11 range-based for supposed to cover this use case?  The only significant difference between this proposal and range-based for is that what would be the function block of the lambda statement in this proposal becomes the range-based for&#8217;s statement block.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marshall Clow				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3757</link>
		<dc:creator><![CDATA[Marshall Clow]]></dc:creator>
		<pubDate>Fri, 14 Oct 2011 21:50:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3757</guid>
					<description><![CDATA[&quot;Iterators must go&quot; was the (deliberately) provocative title for Andrei&#039;s 2009 Boostcon keynote address.

The video from the keynote&lt;a href=&quot;http://blip.tv/boostcon/boostcon-2009-keynote-2452140&quot; rel=&quot;nofollow&quot;&gt; is available here&lt;/a&gt;]]></description>
		<content:encoded><![CDATA[<p>&#8220;Iterators must go&#8221; was the (deliberately) provocative title for Andrei&#8217;s 2009 Boostcon keynote address.</p>
<p>The video from the keynote<a href="http://blip.tv/boostcon/boostcon-2009-keynote-2452140" rel="nofollow"> is available here</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: hp				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3755</link>
		<dc:creator><![CDATA[hp]]></dc:creator>
		<pubDate>Fri, 14 Oct 2011 19:45:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3755</guid>
					<description><![CDATA[Compared to what it costs to sort a container, it&#039;s not a lot you have to code. So it does hinder you to sort at every corner. code length correlates with costs. a good thing, isn&#039;t it?]]></description>
		<content:encoded><![CDATA[<p>Compared to what it costs to sort a container, it&#8217;s not a lot you have to code. So it does hinder you to sort at every corner. code length correlates with costs. a good thing, isn&#8217;t it?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marshall Clow				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3719</link>
		<dc:creator><![CDATA[Marshall Clow]]></dc:creator>
		<pubDate>Thu, 13 Oct 2011 22:51:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3719</guid>
					<description><![CDATA[&lt;a href=&quot;http://www.boost.org/doc/libs/1_47_0/libs/range/doc/html/range/reference/algorithms/non_mutating/for_each.html&quot; rel=&quot;nofollow&quot;&gt;Boost.Range&lt;/a&gt; is your friend for this.]]></description>
		<content:encoded><![CDATA[<p><a href="http://www.boost.org/doc/libs/1_47_0/libs/range/doc/html/range/reference/algorithms/non_mutating/for_each.html" rel="nofollow">Boost.Range</a> is your friend for this.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3694</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Thu, 13 Oct 2011 17:10:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3694</guid>
					<description><![CDATA[Is iterators must go replacement(aka STL with ranges) avaliable from boost? I tried reading documentation for boost::range but it is a bit inconclusive :)]]></description>
		<content:encoded><![CDATA[<p>Is iterators must go replacement(aka STL with ranges) avaliable from boost? I tried reading documentation for boost::range but it is a bit inconclusive :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3688</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Thu, 13 Oct 2011 12:25:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3688</guid>
					<description><![CDATA[Cool, Ill check it out, but I will probably never use it in production because I have phobia of nonboost or nonstd libraries. :)]]></description>
		<content:encoded><![CDATA[<p>Cool, Ill check it out, but I will probably never use it in production because I have phobia of nonboost or nonstd libraries. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3684</link>
		<dc:creator><![CDATA[Martin]]></dc:creator>
		<pubDate>Thu, 13 Oct 2011 08:09:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3684</guid>
					<description><![CDATA[There&#039;s a recent discussion on the clcm newsgroup: 
Should (and can) the  functions be extended by convenience helpers that take generic containers as parameters?
-&#062;
http://groups.google.com/group/comp.lang.c++.moderated/browse_frm/thread/2a6ddce953dd8365/64b60bf5da5fbc5c?tvc=1#64b60bf5da5fbc5c]]></description>
		<content:encoded><![CDATA[<p>There&#8217;s a recent discussion on the clcm newsgroup:<br />
Should (and can) the  functions be extended by convenience helpers that take generic containers as parameters?<br />
-&gt;<br />
<a href="http://groups.google.com/group/comp.lang.c++.moderated/browse_frm/thread/2a6ddce953dd8365/64b60bf5da5fbc5c?tvc=1#64b60bf5da5fbc5c" rel="nofollow">http://groups.google.com/group/comp.lang.c++.moderated/browse_frm/thread/2a6ddce953dd8365/64b60bf5da5fbc5c?tvc=1#64b60bf5da5fbc5c</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marshall Clow				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3681</link>
		<dc:creator><![CDATA[Marshall Clow]]></dc:creator>
		<pubDate>Wed, 12 Oct 2011 23:49:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3681</guid>
					<description><![CDATA[As Tomas says, enable_if is your friend here.

template&#060;typename Container, typename Pred&#062; 
disable_if&#060; is_same&#060;Container, Pred&#062;::value, void&#062;::type 
sort( Container&#038;, Pred );]]></description>
		<content:encoded><![CDATA[<p>As Tomas says, enable_if is your friend here.</p>
<p>template&lt;typename Container, typename Pred&gt;<br />
disable_if&lt; is_same&lt;Container, Pred&gt;::value, void&gt;::type<br />
sort( Container&amp;, Pred );</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John Golding				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3655</link>
		<dc:creator><![CDATA[John Golding]]></dc:creator>
		<pubDate>Tue, 11 Oct 2011 08:24:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3655</guid>
					<description><![CDATA[I did this at my last company - I wrote templates called things like for_all etc that took in the collection as a parameter rather than a couple of parameters which specified iterators.
John]]></description>
		<content:encoded><![CDATA[<p>I did this at my last company &#8211; I wrote templates called things like for_all etc that took in the collection as a parameter rather than a couple of parameters which specified iterators.<br />
John</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ZenJu				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3640</link>
		<dc:creator><![CDATA[ZenJu]]></dc:creator>
		<pubDate>Mon, 10 Oct 2011 20:08:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3640</guid>
					<description><![CDATA[You may want to checkout zenXml on sourceforge. It&#039;s intent is to provide smallest implementations for both UTF8 and XML conversions possible. But two caveats: It&#039;s C++11 only (needs gcc &#062;= 4.5.2, VS2010). Similarity to my name are *not* accidental! :)]]></description>
		<content:encoded><![CDATA[<p>You may want to checkout zenXml on sourceforge. It&#8217;s intent is to provide smallest implementations for both UTF8 and XML conversions possible. But two caveats: It&#8217;s C++11 only (needs gcc &gt;= 4.5.2, VS2010). Similarity to my name are *not* accidental! :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3639</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Mon, 10 Oct 2011 09:55:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3639</guid>
					<description><![CDATA[Tnx, Just to be clear my question here was why it isnt in the standard, on SO was how to work around it not being in the standard.]]></description>
		<content:encoded><![CDATA[<p>Tnx, Just to be clear my question here was why it isnt in the standard, on SO was how to work around it not being in the standard.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3638</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Mon, 10 Oct 2011 09:54:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3638</guid>
					<description><![CDATA[Well I presume Unicode in not as glorious as core language features or fancy libs like atomic, mutex and thread that depend on those so people didnt care.  :(   I wish that there was some &quot;wishfund&quot; for boost where people could donate some small amount of cash for libs that they want implemented. I&#039;m not rich, but I would gladly donate some small amount(25$) for a decent Unicode boost lib. And 5k people donating should be a decent incentive for basic functionality... Also I presume people would like better XML support... I know that this probably wont happen because I get the feeling that most of the open source people feel that money is evil. :)]]></description>
		<content:encoded><![CDATA[<p>Well I presume Unicode in not as glorious as core language features or fancy libs like atomic, mutex and thread that depend on those so people didnt care.  :(   I wish that there was some &#8220;wishfund&#8221; for boost where people could donate some small amount of cash for libs that they want implemented. I&#8217;m not rich, but I would gladly donate some small amount(25$) for a decent Unicode boost lib. And 5k people donating should be a decent incentive for basic functionality&#8230; Also I presume people would like better XML support&#8230; I know that this probably wont happen because I get the feeling that most of the open source people feel that money is evil. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tomas				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3637</link>
		<dc:creator><![CDATA[Tomas]]></dc:creator>
		<pubDate>Mon, 10 Oct 2011 08:15:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3637</guid>
					<description><![CDATA[Given that enable_if is now part of the standard what exactly speaks against using this construct in standard library? Are we waiting for new version of concepts?]]></description>
		<content:encoded><![CDATA[<p>Given that enable_if is now part of the standard what exactly speaks against using this construct in standard library? Are we waiting for new version of concepts?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: chila				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3631</link>
		<dc:creator><![CDATA[chila]]></dc:creator>
		<pubDate>Sun, 09 Oct 2011 16:03:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3631</guid>
					<description><![CDATA[boost::range]]></description>
		<content:encoded><![CDATA[<p>boost::range</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Abrahams				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3630</link>
		<dc:creator><![CDATA[David Abrahams]]></dc:creator>
		<pubDate>Sun, 09 Oct 2011 14:04:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3630</guid>
					<description><![CDATA[Andrei Alexandrescu gave a compelling keynote at Boostcon 2009 about ranged-based algorithm interfaces: https://github.com/boostcon/2009_presentations/raw/master/wed/iterators-must-go.pdf]]></description>
		<content:encoded><![CDATA[<p>Andrei Alexandrescu gave a compelling keynote at Boostcon 2009 about ranged-based algorithm interfaces: <a href="https://github.com/boostcon/2009_presentations/raw/master/wed/iterators-must-go.pdf" rel="nofollow">https://github.com/boostcon/2009_presentations/raw/master/wed/iterators-must-go.pdf</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Price				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3629</link>
		<dc:creator><![CDATA[Michael Price]]></dc:creator>
		<pubDate>Sun, 09 Oct 2011 12:07:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3629</guid>
					<description><![CDATA[And if it weren&#039;t for backwards compatibility, I&#039;d say rename the iterator-based ones.  It seems that using begin and end iterators is by far the most common usage.

Too bad that decision wasn&#039;t made way back when.]]></description>
		<content:encoded><![CDATA[<p>And if it weren&#8217;t for backwards compatibility, I&#8217;d say rename the iterator-based ones.  It seems that using begin and end iterators is by far the most common usage.</p>
<p>Too bad that decision wasn&#8217;t made way back when.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Maxim Yegorushkin				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3628</link>
		<dc:creator><![CDATA[Maxim Yegorushkin]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 23:13:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3628</guid>
					<description><![CDATA[There are two simple and robust solutions to the issue which don&#039;t involve meta-programming here: a) put the range versions in another namespace, like boost does; b) name them differently, since code that deals with iterators and ranges has to treat them differently anyway. Using meta-programming to solve it is mentally satisfying, but it is not obvious how it makes the user code shorter or cleaner (again, since code that deals with iterators and ranges has to treat them differently anyway).]]></description>
		<content:encoded><![CDATA[<p>There are two simple and robust solutions to the issue which don&#8217;t involve meta-programming here: a) put the range versions in another namespace, like boost does; b) name them differently, since code that deals with iterators and ranges has to treat them differently anyway. Using meta-programming to solve it is mentally satisfying, but it is not obvious how it makes the user code shorter or cleaner (again, since code that deals with iterators and ranges has to treat them differently anyway).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ZenJu				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3627</link>
		<dc:creator><![CDATA[ZenJu]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 22:31:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3627</guid>
					<description><![CDATA[Actually not hard. Implementing utf8/utf16/utf32 conversions as templates took myself only 190 lines of code. 
I don&#039;t know if these fundamental algorithms are part of C++11, but it would be quite a shame if not. Were in 2011 and Unicode is everwhere...]]></description>
		<content:encoded><![CDATA[<p>Actually not hard. Implementing utf8/utf16/utf32 conversions as templates took myself only 190 lines of code.<br />
I don&#8217;t know if these fundamental algorithms are part of C++11, but it would be quite a shame if not. Were in 2011 and Unicode is everwhere&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3626</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 22:16:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3626</guid>
					<description><![CDATA[Well Im not an expert but how hard is to make utf8/16/32 strings that are &quot;easily&quot;(number of code lines, not easy in fast ) convertable to eachother and that are easily fprintable(aka you can specify how you want file to be encoded,)]]></description>
		<content:encoded><![CDATA[<p>Well Im not an expert but how hard is to make utf8/16/32 strings that are &#8220;easily&#8221;(number of code lines, not easy in fast ) convertable to eachother and that are easily fprintable(aka you can specify how you want file to be encoded,)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ZenJu				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3624</link>
		<dc:creator><![CDATA[ZenJu]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 10:17:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3624</guid>
					<description><![CDATA[&#062; And 4 is indistinguishable from 1 today
Why not throw some template metaprogramming at it? It&#039;s not hard to come up with a solution that distinguishes both cases at compile time:
Simply put, a container could be identified by having &quot;begin(), end()&quot; members, while an iterator via iterator_traits.
I&#039;ve done something similar with an XML serialization library, that detects all STL and non-STL types and &quot;does the right thing&quot;.

I&#039;ll acknowledge, there are other considerations, style maybe, but feasibility? Hey I&#039;d be glad to implement it! :) And while at it, I&#039;d implement a member remove_if(Predicate p) for all container types, not just std::list).]]></description>
		<content:encoded><![CDATA[<p>&gt; And 4 is indistinguishable from 1 today<br />
Why not throw some template metaprogramming at it? It&#8217;s not hard to come up with a solution that distinguishes both cases at compile time:<br />
Simply put, a container could be identified by having &#8220;begin(), end()&#8221; members, while an iterator via iterator_traits.<br />
I&#8217;ve done something similar with an XML serialization library, that detects all STL and non-STL types and &#8220;does the right thing&#8221;.</p>
<p>I&#8217;ll acknowledge, there are other considerations, style maybe, but feasibility? Hey I&#8217;d be glad to implement it! :) And while at it, I&#8217;d implement a member remove_if(Predicate p) for all container types, not just std::list).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tamas				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3623</link>
		<dc:creator><![CDATA[Tamas]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 09:58:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3623</guid>
					<description><![CDATA[Of course all the angle brackets were eaten, the first func had templates class A, class B, and the second one had class A. And obviously an stdio.h was included.]]></description>
		<content:encoded><![CDATA[<p>Of course all the angle brackets were eaten, the first func had templates class A, class B, and the second one had class A. And obviously an stdio.h was included.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tamas				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3622</link>
		<dc:creator><![CDATA[Tamas]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 09:56:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3622</guid>
					<description><![CDATA[It&#039;s not exactly clear for me why 1) and 4) are indistinguisable. 1) has the same argument types while 4) has different argument types, so the only way ambiguity would arise if the container and the predicate had the same type, which doesn&#039;t seem realistic. Perhaps there&#039;s some technical issue with template instantiation and function overloading I don&#039;t realize that would cause issues in some cases, but this seems to work:

#include 
template 
void func(A a, B b) {
  printf(&quot;Heterogeneous\n&quot;);
}

template 
void func(A a, A a2) {
  printf(&quot;Homogeneous\n&quot;);
}

int main()
{
  func(1, &#039;a&#039;);
  func(1, 2);
}]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s not exactly clear for me why 1) and 4) are indistinguisable. 1) has the same argument types while 4) has different argument types, so the only way ambiguity would arise if the container and the predicate had the same type, which doesn&#8217;t seem realistic. Perhaps there&#8217;s some technical issue with template instantiation and function overloading I don&#8217;t realize that would cause issues in some cases, but this seems to work:</p>
<p>#include<br />
template<br />
void func(A a, B b) {<br />
  printf(&#8220;Heterogeneous\n&#8221;);<br />
}</p>
<p>template<br />
void func(A a, A a2) {<br />
  printf(&#8220;Homogeneous\n&#8221;);<br />
}</p>
<p>int main()<br />
{<br />
  func(1, &#8216;a&#8217;);<br />
  func(1, 2);<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gevorg				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3618</link>
		<dc:creator><![CDATA[Gevorg]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 06:16:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3618</guid>
					<description><![CDATA[Thanks Herb, this looks much better. One last catch if I may; it&#039;s missing typename before enable_ifs. Thanks for the article by the way, now I can link people to it next time they ask me why no container overloads for std:: algorithms :)]]></description>
		<content:encoded><![CDATA[<p>Thanks Herb, this looks much better. One last catch if I may; it&#8217;s missing typename before enable_ifs. Thanks for the article by the way, now I can link people to it next time they ask me why no container overloads for std:: algorithms :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3615</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 05:30:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3615</guid>
					<description><![CDATA[Good catches, thanks. As for the !, I was writing down the idea quickly and couldn&#039;t remember offhand if boolean logic would work, but I think you&#039;re right that it should. Updated.]]></description>
		<content:encoded><![CDATA[<p>Good catches, thanks. As for the !, I was writing down the idea quickly and couldn&#8217;t remember offhand if boolean logic would work, but I think you&#8217;re right that it should. Updated.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gevorg				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3614</link>
		<dc:creator><![CDATA[Gevorg]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 05:02:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3614</guid>
					<description><![CDATA[Herb, don&#039;t you need (1) enable_if&#039;d instead of (2) ?
(2) takes three parameters so already doesn&#039;t conflict with other overloads.
Also, don&#039;t you need to pass Iter to NotCallableWithNonmemberBeginAndEnd instead of Container (no type named Container there) ?
Somehow we don&#039;t have std::disable_if like we do in boost, but why not use !CallableWithNonmemberBeginAndEnd::value for (1) to avoid the need of writing another traits class?
Thank you.]]></description>
		<content:encoded><![CDATA[<p>Herb, don&#8217;t you need (1) enable_if&#8217;d instead of (2) ?<br />
(2) takes three parameters so already doesn&#8217;t conflict with other overloads.<br />
Also, don&#8217;t you need to pass Iter to NotCallableWithNonmemberBeginAndEnd instead of Container (no type named Container there) ?<br />
Somehow we don&#8217;t have std::disable_if like we do in boost, but why not use !CallableWithNonmemberBeginAndEnd::value for (1) to avoid the need of writing another traits class?<br />
Thank you.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Price				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3613</link>
		<dc:creator><![CDATA[Michael Price]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 04:56:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3613</guid>
					<description><![CDATA[+1 for Howard Hinnant&#039;s answer.  Of course I went ahead and posted my variadic template solution.]]></description>
		<content:encoded><![CDATA[<p>+1 for Howard Hinnant&#8217;s answer.  Of course I went ahead and posted my variadic template solution.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3612</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 02:58:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3612</guid>
					<description><![CDATA[There are many, *many* different things that could be called &quot;unicode support.&quot; What exactly are you looking for?

The fullest version of Unicode support means being able to classify codepoints (asking if codepoint X is a combining character, or whatever), combine codepoints into graphemes, unicode normalization, and many, many other things. These are not simple things to do.

Do note that the vast majority of things that were added to C++11&#039;s standard library were either existing practice (ie: Boost) or slight modifications thereof. Virtually nothing was brought into the standard library that was not already implemented, or something that was not associated with C++11-specific language features (emplace, etc).

It&#039;s one thing to come up with a language feature out of whole cloth. It&#039;s quite a bigger challenge to do that for a library. Especially for something that is as big and complex as &quot;Unicode support.&quot;

Currently, the closest thing to existing practice for full-on Unicode support in C++ land is ICU. And that&#039;s not a very standard C++-friendly library. It has its own locales, it has its own strings (not templated), it has its own way of doing everything. It&#039;s a Java library that is implemented in C++.

In short, a C++ standard Unicode library would have to be written and tested *before* being incorporated into the standard. As nice as Unicode support would be, the last thing you want in the standard is *bad* Unicode support.]]></description>
		<content:encoded><![CDATA[<p>There are many, *many* different things that could be called &#8220;unicode support.&#8221; What exactly are you looking for?</p>
<p>The fullest version of Unicode support means being able to classify codepoints (asking if codepoint X is a combining character, or whatever), combine codepoints into graphemes, unicode normalization, and many, many other things. These are not simple things to do.</p>
<p>Do note that the vast majority of things that were added to C++11&#8217;s standard library were either existing practice (ie: Boost) or slight modifications thereof. Virtually nothing was brought into the standard library that was not already implemented, or something that was not associated with C++11-specific language features (emplace, etc).</p>
<p>It&#8217;s one thing to come up with a language feature out of whole cloth. It&#8217;s quite a bigger challenge to do that for a library. Especially for something that is as big and complex as &#8220;Unicode support.&#8221;</p>
<p>Currently, the closest thing to existing practice for full-on Unicode support in C++ land is ICU. And that&#8217;s not a very standard C++-friendly library. It has its own locales, it has its own strings (not templated), it has its own way of doing everything. It&#8217;s a Java library that is implemented in C++.</p>
<p>In short, a C++ standard Unicode library would have to be written and tested *before* being incorporated into the standard. As nice as Unicode support would be, the last thing you want in the standard is *bad* Unicode support.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ryan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3611</link>
		<dc:creator><![CDATA[Ryan]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 02:28:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3611</guid>
					<description><![CDATA[I&#039;d like to point out that Boost provides this kind of functionality in its Range library. It defines algorithms with the same name as the ones in the standard library, but of course they&#039;re all in the boost namespace. I&#039;ve found it really useful! http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/algorithms/introduction.html]]></description>
		<content:encoded><![CDATA[<p>I&#8217;d like to point out that Boost provides this kind of functionality in its Range library. It defines algorithms with the same name as the ones in the standard library, but of course they&#8217;re all in the boost namespace. I&#8217;ve found it really useful! <a href="http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/algorithms/introduction.html" rel="nofollow">http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/algorithms/introduction.html</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3610</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 01:46:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3610</guid>
					<description><![CDATA[argh bracket eating WP, regarding array question you can see the code here:
http://stackoverflow.com/questions/7689288/less-verbose-way-to-declare-multidimensional-stdarray]]></description>
		<content:encoded><![CDATA[<p>argh bracket eating WP, regarding array question you can see the code here:<br />
<a href="http://stackoverflow.com/questions/7689288/less-verbose-way-to-declare-multidimensional-stdarray" rel="nofollow">http://stackoverflow.com/questions/7689288/less-verbose-way-to-declare-multidimensional-stdarray</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3609</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 01:44:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3609</guid>
					<description><![CDATA[Herb, why there isnt a better unicode support in c++11. I might be misinformed, but from I see support is almost nonexistant except u16/32strings  and matching char types.
 Also sorry to bother you again but I think you might have missed my original question...
 this really bugs me: Why you dont make include guards obsolete and repetitive inclusion explicit. 
Another small iritating thing. :why cant i write array my3Darray;

BTW nice article, I knew before that concepts would enable this, but never know the &quot;deep&quot; reason]]></description>
		<content:encoded><![CDATA[<p>Herb, why there isnt a better unicode support in c++11. I might be misinformed, but from I see support is almost nonexistant except u16/32strings  and matching char types.<br />
 Also sorry to bother you again but I think you might have missed my original question&#8230;<br />
 this really bugs me: Why you dont make include guards obsolete and repetitive inclusion explicit.<br />
Another small iritating thing. :why cant i write array my3Darray;</p>
<p>BTW nice article, I knew before that concepts would enable this, but never know the &#8220;deep&#8221; reason</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3608</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 01:18:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3608</guid>
					<description><![CDATA[You could, but then you lose the ability to overload which can be desirable. For one thing, we&#039;d then have to teach multiple function names -- that&#039;s admittedly not the end of the world, but it does make things uglier with for_each vs. for_each_coll or something like that. It just looks like a workaround.]]></description>
		<content:encoded><![CDATA[<p>You could, but then you lose the ability to overload which can be desirable. For one thing, we&#8217;d then have to teach multiple function names &#8212; that&#8217;s admittedly not the end of the world, but it does make things uglier with for_each vs. for_each_coll or something like that. It just looks like a workaround.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2011/10/07/why-no-container-based-algorithms/#comment-3607</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Sat, 08 Oct 2011 01:07:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=662#comment-3607</guid>
					<description><![CDATA[Why not change the name of the functions that take a collection? Eg sort_col()]]></description>
		<content:encoded><![CDATA[<p>Why not change the name of the functions that take a collection? Eg sort_col()</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
