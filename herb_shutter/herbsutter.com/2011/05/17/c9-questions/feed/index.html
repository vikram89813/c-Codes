<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Post your questions for a followup C9 interview	</title>
	<atom:link href="https://herbsutter.com/2011/05/17/c9-questions/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2011/05/17/c9-questions/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Christopher				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3283</link>
		<dc:creator><![CDATA[Christopher]]></dc:creator>
		<pubDate>Tue, 02 Aug 2011 19:43:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3283</guid>
					<description><![CDATA[#pragma once does not work if you #include a copy of the header.]]></description>
		<content:encoded><![CDATA[<p>#pragma once does not work if you #include a copy of the header.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Christopher				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3282</link>
		<dc:creator><![CDATA[Christopher]]></dc:creator>
		<pubDate>Tue, 02 Aug 2011 19:41:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3282</guid>
					<description><![CDATA[#import uses GUIDs assigned to modules, which is the same mechanism as #include guards, only more automatic.]]></description>
		<content:encoded><![CDATA[<p>#import uses GUIDs assigned to modules, which is the same mechanism as #include guards, only more automatic.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike Dimmick				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3136</link>
		<dc:creator><![CDATA[Mike Dimmick]]></dc:creator>
		<pubDate>Mon, 13 Jun 2011 12:06:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3136</guid>
					<description><![CDATA[You&#039;re confusing Windows CE with desktop Windows. The existing hacks are there to handle the fact that Windows CE doesn&#039;t have as wide an API as desktop Windows does, and in a few cases has behavioural differences. 

Windows 8 on ARM will (I expect) be the traditional Windows desktop and server code ported to the ARM processor, and MFC is portable across processors. The existing source code will Just Work as there is very little code in there that is processor-specific. The little that is is limited to ATL window thunks and the implementations of IDispatch. If Microsoft don&#039;t do it, you could probably do the tiny bit of porting work necessary and compile the library yourself (makefiles are supplied!).]]></description>
		<content:encoded><![CDATA[<p>You&#8217;re confusing Windows CE with desktop Windows. The existing hacks are there to handle the fact that Windows CE doesn&#8217;t have as wide an API as desktop Windows does, and in a few cases has behavioural differences. </p>
<p>Windows 8 on ARM will (I expect) be the traditional Windows desktop and server code ported to the ARM processor, and MFC is portable across processors. The existing source code will Just Work as there is very little code in there that is processor-specific. The little that is is limited to ATL window thunks and the implementations of IDispatch. If Microsoft don&#8217;t do it, you could probably do the tiny bit of porting work necessary and compile the library yourself (makefiles are supplied!).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rick Leir				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3125</link>
		<dc:creator><![CDATA[Rick Leir]]></dc:creator>
		<pubDate>Wed, 08 Jun 2011 12:08:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3125</guid>
					<description><![CDATA[I read and enjoyed the 2005 books:
C++ coding standards : 101 rules, guidelines, and best practices, Exceptional C++ style : 40 new engineering puzzles
Herb: will you be updating them or writing new books?]]></description>
		<content:encoded><![CDATA[<p>I read and enjoyed the 2005 books:<br />
C++ coding standards : 101 rules, guidelines, and best practices, Exceptional C++ style : 40 new engineering puzzles<br />
Herb: will you be updating them or writing new books?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: &#8220;Ask Me Anything&#8221; interview is now live on Channel 9 &#171; Sutter&#8217;s Mill				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3119</link>
		<dc:creator><![CDATA[&#8220;Ask Me Anything&#8221; interview is now live on Channel 9 &#171; Sutter&#8217;s Mill]]></dc:creator>
		<pubDate>Tue, 07 Jun 2011 16:00:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3119</guid>
					<description><![CDATA[[...] again for all your questions; we took as many of the most popular ones as we could. I hope you enjoy [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] again for all your questions; we took as many of the most popular ones as we could. I hope you enjoy [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Moritz Leutenecker				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3111</link>
		<dc:creator><![CDATA[Moritz Leutenecker]]></dc:creator>
		<pubDate>Fri, 03 Jun 2011 23:06:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3111</guid>
					<description><![CDATA[I wanted to know if there is any effort to enable the MFC in future versions of Visual Studio to be able to support the new Windows 8 ARM processor architecture. I am a bit concerned, because MFC are old but still very vital for many of the native developers, that it will not be extended to support the new ARM architecture of Windows 8. I remember having ARM based Embedded VC++ Version 3 in 2003 / 2004 which has already a major part of the MFC ported to ARM architecture. 

I just wanted to help to point out that already a large part of the MFC is ARM compatible and it would maybe need only a few more parts to be converted to give the whole MFC full support for the ARM platform.

A concerned customer, Greetings!]]></description>
		<content:encoded><![CDATA[<p>I wanted to know if there is any effort to enable the MFC in future versions of Visual Studio to be able to support the new Windows 8 ARM processor architecture. I am a bit concerned, because MFC are old but still very vital for many of the native developers, that it will not be extended to support the new ARM architecture of Windows 8. I remember having ARM based Embedded VC++ Version 3 in 2003 / 2004 which has already a major part of the MFC ported to ARM architecture. </p>
<p>I just wanted to help to point out that already a large part of the MFC is ARM compatible and it would maybe need only a few more parts to be converted to give the whole MFC full support for the ARM platform.</p>
<p>A concerned customer, Greetings!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Granville Barnett				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3109</link>
		<dc:creator><![CDATA[Granville Barnett]]></dc:creator>
		<pubDate>Thu, 02 Jun 2011 23:22:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3109</guid>
					<description><![CDATA[What&#039;s the status on the adoption of the C++11 memory model?

The language features in C++11 are nice but this is *the* big one.]]></description>
		<content:encoded><![CDATA[<p>What&#8217;s the status on the adoption of the C++11 memory model?</p>
<p>The language features in C++11 are nice but this is *the* big one.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: freefly				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3108</link>
		<dc:creator><![CDATA[freefly]]></dc:creator>
		<pubDate>Thu, 02 Jun 2011 16:00:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3108</guid>
					<description><![CDATA[Extending my GUI question early on... 
Why isn&#039;t microsoft thinking in terms of 

1. A good customizable GUI (xaml/xml based RAD) tooling support for C++. With DirectX support.

2. A good C++ OOP libraries to support other technologies of the OS parts. ( some good app model around web, OPTIONAL )

3. C++0x full standard.

This will serve portable applications on all platforms phone/Tablet/PC. A developer can concentrate on one programming language (C++). Why we are being pushed to the limits with a non portable runtimes/plugins and misfitting frameworks ? 

I am sure, if something like xaml/xml based GUI tooling is enabled for C++, then it will change everything for good.]]></description>
		<content:encoded><![CDATA[<p>Extending my GUI question early on&#8230;<br />
Why isn&#8217;t microsoft thinking in terms of </p>
<p>1. A good customizable GUI (xaml/xml based RAD) tooling support for C++. With DirectX support.</p>
<p>2. A good C++ OOP libraries to support other technologies of the OS parts. ( some good app model around web, OPTIONAL )</p>
<p>3. C++0x full standard.</p>
<p>This will serve portable applications on all platforms phone/Tablet/PC. A developer can concentrate on one programming language (C++). Why we are being pushed to the limits with a non portable runtimes/plugins and misfitting frameworks ? </p>
<p>I am sure, if something like xaml/xml based GUI tooling is enabled for C++, then it will change everything for good.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3106</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Thu, 02 Jun 2011 00:17:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3106</guid>
					<description><![CDATA[Plausibility is overrated.  ;-)

I started by manually following the first part of the Mr. Sutter&#039;s second recommendation bullet (at the top):

&quot;Return often to vote your and others’ questions up or down.&quot;

... but then I remembered that I was a programmer ... so I let my laptop take over clearing the browser cache, reloading the page, and doing the click-ity clicks.

I expect a few more people will join in on the fun ... and express their excitement about C++0x in code.

Obviously, all ... but maybe 5 ... of the thumbs-up votes on the top three &quot;Joshua Burkholder&quot; posts are from me.

Energetically,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>Plausibility is overrated.  ;-)</p>
<p>I started by manually following the first part of the Mr. Sutter&#8217;s second recommendation bullet (at the top):</p>
<p>&#8220;Return often to vote your and others’ questions up or down.&#8221;</p>
<p>&#8230; but then I remembered that I was a programmer &#8230; so I let my laptop take over clearing the browser cache, reloading the page, and doing the click-ity clicks.</p>
<p>I expect a few more people will join in on the fun &#8230; and express their excitement about C++0x in code.</p>
<p>Obviously, all &#8230; but maybe 5 &#8230; of the thumbs-up votes on the top three &#8220;Joshua Burkholder&#8221; posts are from me.</p>
<p>Energetically,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Zura				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3105</link>
		<dc:creator><![CDATA[Zura]]></dc:creator>
		<pubDate>Wed, 01 Jun 2011 05:42:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3105</guid>
					<description><![CDATA[Actually, Cory writes about &quot;polymorphic lambdas&quot; and not about runtime polymorphism. So, please ignore first sentence from my reply above.]]></description>
		<content:encoded><![CDATA[<p>Actually, Cory writes about &#8220;polymorphic lambdas&#8221; and not about runtime polymorphism. So, please ignore first sentence from my reply above.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Zura				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3104</link>
		<dc:creator><![CDATA[Zura]]></dc:creator>
		<pubDate>Wed, 01 Jun 2011 05:24:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3104</guid>
					<description><![CDATA[Also, not necessary polymorphic.
Why there is no type inference for this?

While not as beautiful as e.g. C#&#039;s variant, it still would be useful to have:

[](auto x) { return x * 2; }]]></description>
		<content:encoded><![CDATA[<p>Also, not necessary polymorphic.<br />
Why there is no type inference for this?</p>
<p>While not as beautiful as e.g. C#&#8217;s variant, it still would be useful to have:</p>
<p>[](auto x) { return x * 2; }</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cory Nelson				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3103</link>
		<dc:creator><![CDATA[Cory Nelson]]></dc:creator>
		<pubDate>Wed, 01 Jun 2011 02:30:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3103</guid>
					<description><![CDATA[I don’t bring up language changes lightly either!  as I said, boost::asio is a really nice library, but it’s still very verbose and difficult to learn.  It’s about as good as you can pull off with a library.  To improve any more, language integration is necessary.

C#’s new async features are like the holy grail of async – anyone who’s been doing it long enough in C++ will have wished for exactly what C# does.]]></description>
		<content:encoded><![CDATA[<p>I don’t bring up language changes lightly either!  as I said, boost::asio is a really nice library, but it’s still very verbose and difficult to learn.  It’s about as good as you can pull off with a library.  To improve any more, language integration is necessary.</p>
<p>C#’s new async features are like the holy grail of async – anyone who’s been doing it long enough in C++ will have wished for exactly what C# does.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: martin wirth				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3102</link>
		<dc:creator><![CDATA[martin wirth]]></dc:creator>
		<pubDate>Tue, 31 May 2011 19:55:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3102</guid>
					<description><![CDATA[counter argument: in C++ making changes to the language happens much more rarely than e.g. in c# - fortunately. things like this can be done in a library. dont integrate everything there is into the language itself, its complex enough. 
wouldnt want the language to change its shape each year or two like in c#. c++ needs more stability.]]></description>
		<content:encoded><![CDATA[<p>counter argument: in C++ making changes to the language happens much more rarely than e.g. in c# &#8211; fortunately. things like this can be done in a library. dont integrate everything there is into the language itself, its complex enough.<br />
wouldnt want the language to change its shape each year or two like in c#. c++ needs more stability.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gevorg				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3101</link>
		<dc:creator><![CDATA[Gevorg]]></dc:creator>
		<pubDate>Tue, 31 May 2011 16:08:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3101</guid>
					<description><![CDATA[Clang/LLVM comes to the rescue here.]]></description>
		<content:encoded><![CDATA[<p>Clang/LLVM comes to the rescue here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Reminder: Vote on AMA questions by tomorrow night &#171; Sutter&#8217;s Mill				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3100</link>
		<dc:creator><![CDATA[Reminder: Vote on AMA questions by tomorrow night &#171; Sutter&#8217;s Mill]]></dc:creator>
		<pubDate>Tue, 31 May 2011 16:00:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3100</guid>
					<description><![CDATA[[...] promised, reminder: The followup interview on Channel 9 has been scheduled, and will be shot on Thursday, June 2. You have until midnight June [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] promised, reminder: The followup interview on Channel 9 has been scheduled, and will be shot on Thursday, June 2. You have until midnight June [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3098</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 31 May 2011 15:36:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3098</guid>
					<description><![CDATA[We&#039;ll be looking for the truly most popular questions that aren&#039;t of interest to just a few people, so obvious hacking is counterproductive. But we&#039;re also looking for questions that can be answered well in a video interview, and questions about code examples that are more than a line or two long make that harder.]]></description>
		<content:encoded><![CDATA[<p>We&#8217;ll be looking for the truly most popular questions that aren&#8217;t of interest to just a few people, so obvious hacking is counterproductive. But we&#8217;re also looking for questions that can be answered well in a video interview, and questions about code examples that are more than a line or two long make that harder.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ML				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3097</link>
		<dc:creator><![CDATA[ML]]></dc:creator>
		<pubDate>Tue, 31 May 2011 14:20:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3097</guid>
					<description><![CDATA[Agreed. I&#039;ve been tinkering with Boost.Enum, which is not part of the official Boost release but is in the Vault. It supports type-safety (mitigated by C++0x), string names, etc. See here: http://stackoverflow.com/questions/217549/which-typesafe-enum-in-c-are-you-using]]></description>
		<content:encoded><![CDATA[<p>Agreed. I&#8217;ve been tinkering with Boost.Enum, which is not part of the official Boost release but is in the Vault. It supports type-safety (mitigated by C++0x), string names, etc. See here: <a href="http://stackoverflow.com/questions/217549/which-typesafe-enum-in-c-are-you-using" rel="nofollow">http://stackoverflow.com/questions/217549/which-typesafe-enum-in-c-are-you-using</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ML				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3096</link>
		<dc:creator><![CDATA[ML]]></dc:creator>
		<pubDate>Tue, 31 May 2011 14:18:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3096</guid>
					<description><![CDATA[Thumb up: 2361, Thumbs down: 3

If you&#039;re going to hack the vote, at least make it seem plausible.]]></description>
		<content:encoded><![CDATA[<p>Thumb up: 2361, Thumbs down: 3</p>
<p>If you&#8217;re going to hack the vote, at least make it seem plausible.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ML				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3095</link>
		<dc:creator><![CDATA[ML]]></dc:creator>
		<pubDate>Tue, 31 May 2011 14:12:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3095</guid>
					<description><![CDATA[&quot;&#039;C++ is expert friendly. But, it’s also novice hostile&#039;, this is a direct quote from Bjarne Stroustrup. I can’t believe you’re doubting this.&quot;

I am not and did not doubt this, but there are certainly better and worse ways of approaching C++ pedagogy. My point was that Koenig teaches C++ in a way that makes the language *less* hostile to novices, IMHO, but there&#039;s always going to be a learning curve.]]></description>
		<content:encoded><![CDATA[<p>&#8220;&#8216;C++ is expert friendly. But, it’s also novice hostile&#8217;, this is a direct quote from Bjarne Stroustrup. I can’t believe you’re doubting this.&#8221;</p>
<p>I am not and did not doubt this, but there are certainly better and worse ways of approaching C++ pedagogy. My point was that Koenig teaches C++ in a way that makes the language *less* hostile to novices, IMHO, but there&#8217;s always going to be a learning curve.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3092</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Sat, 28 May 2011 16:38:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3092</guid>
					<description><![CDATA[Is there a chance that we will get to_string() for enums. Would make it much easier to write and display certain stuff.]]></description>
		<content:encoded><![CDATA[<p>Is there a chance that we will get to_string() for enums. Would make it much easier to write and display certain stuff.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3091</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Sat, 28 May 2011 08:06:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3091</guid>
					<description><![CDATA[It&#039;s merely an example of a function that takes a (ptr, size_t) pair. Most such functions don&#039;t have an overload that takes a std::string&#038; and std::string&#038; isn&#039;t the only &#039;container&#039; that could be passed via such a pair.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s merely an example of a function that takes a (ptr, size_t) pair. Most such functions don&#8217;t have an overload that takes a std::string&amp; and std::string&amp; isn&#8217;t the only &#8216;container&#8217; that could be passed via such a pair.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3090</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Sat, 28 May 2011 04:32:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3090</guid>
					<description><![CDATA[@Olaf: IOStreams allows input/output of formatted and unformatted data (std::string, char*, int, double, user-defined structs/classes, etc.) ... which is one reason why there are so many options to place your data in the stream; however, &lt;code&gt;operator&#060;&#060;&lt;/code&gt; is the overloaded operator to use and program against for output and &lt;code&gt;operator&#062;&#062;&lt;/code&gt; is the operator to use and program against for input.  Here is an example of using these operators when dealing with standard out, standard in, file streams, and string streams:

&lt;code&gt;//========================================
#include&#160;&#060;string&#062;
#include&#160;&#060;iostream&#062;
#include&#160;&#060;fstream&#062;
#include&#160;&#060;sstream&#062;

using&#160;namespace&#160;std;

int&#160;main&#160;()&#160;{
&#160;&#160;&#160;&#160;string&#160;const&#160;filename&#160;=&#160;&quot;fstream.txt&quot;;
&#160;&#160;&#160;&#160;string&#160;s1&#160;=&#160;&quot;s1&quot;;
&#160;&#160;&#160;&#160;string&#160;s2&#160;=&#160;&quot;s2&quot;;
&#160;&#160;&#160;&#160;string&#160;s3;
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;//&#160;ostream
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;ostream:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s1:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s1&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s2:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s2&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s3:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s3&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;//&#160;istream
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;istream:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;Enter&#160;s1&#160;string:&#160;&quot;;
&#160;&#160;&#160;&#160;cin&#160;&#062;&#062;&#160;s1;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;Enter&#160;s2&#160;string:&#160;&quot;;
&#160;&#160;&#160;&#160;cin&#160;&#062;&#062;&#160;s2;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;ostream:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s1:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s1&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s2:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s2&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s3:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s3&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;//&#160;fstream
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;fstream:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;fstream&#160;f(&#160;filename&#160;);
&#160;&#160;&#160;&#160;f&#160;&#060;&#060;&#160;s1&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;f&#160;&#060;&#060;&#160;s2&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;f.close();
&#160;&#160;&#160;&#160;f.open(&#160;filename&#160;);
&#160;&#160;&#160;&#160;f&#160;&#062;&#062;&#160;s2;
&#160;&#160;&#160;&#160;f&#160;&#062;&#062;&#160;s1;
&#160;&#160;&#160;&#160;f.close();
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s1:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s1&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s2:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s2&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s3:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s3&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;//&#160;stringstream
&#160;&#160;&#160;&#160;//----------------------------
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;stringstream:&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;stringstream&#160;ss;
&#160;&#160;&#160;&#160;ss&#160;&#060;&#060;&#160;s1&#160;&#060;&#060;&#160;s2;
&#160;&#160;&#160;&#160;ss&#160;&#062;&#062;&#160;s3;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s1:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s1&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s2:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s2&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;s3:&#160;&#160;&quot;&#160;&#060;&#060;&#160;s3&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;return&#160;0;
}
//========================================
&lt;/code&gt;
This code produces the following output (assuming you typed &quot;abc&quot; for s1 and &quot;wxyz&quot; for s2):
&lt;code&gt;ostream:
s1:  s1
s2:  s2
s3:

istream:
Enter s1 string: abc
Enter s2 string: wxyz

ostream:
s1:  abc
s2:  wxyz
s3:

fstream:
s1:  wxyz
s2:  abc
s3:

stringstream:
s1:  wxyz
s2:  abc
s3:  wxyzabc
&lt;/code&gt;
The book Standard C++ IOStreams and Locales by Langer and Kreft describes how C++ IOStreams are to be used ... and (most importantly) how they can be extended.

Hope This Helps,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>@Olaf: IOStreams allows input/output of formatted and unformatted data (std::string, char*, int, double, user-defined structs/classes, etc.) &#8230; which is one reason why there are so many options to place your data in the stream; however, <code>operator&lt;&lt;</code> is the overloaded operator to use and program against for output and <code>operator&gt;&gt;</code> is the operator to use and program against for input.  Here is an example of using these operators when dealing with standard out, standard in, file streams, and string streams:</p>
<p><code>//========================================<br />
#include&nbsp;&lt;string&gt;<br />
#include&nbsp;&lt;iostream&gt;<br />
#include&nbsp;&lt;fstream&gt;<br />
#include&nbsp;&lt;sstream&gt;</p>
<p>using&nbsp;namespace&nbsp;std;</p>
<p>int&nbsp;main&nbsp;()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;const&nbsp;filename&nbsp;=&nbsp;"fstream.txt";<br />
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;s1&nbsp;=&nbsp;"s1";<br />
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;s2&nbsp;=&nbsp;"s2";<br />
&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;s3;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ostream<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"ostream:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s1:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s1&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s2:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s2&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s3:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s3&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;istream<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"istream:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"Enter&nbsp;s1&nbsp;string:&nbsp;";<br />
&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;s1;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"Enter&nbsp;s2&nbsp;string:&nbsp;";<br />
&nbsp;&nbsp;&nbsp;&nbsp;cin&nbsp;&gt;&gt;&nbsp;s2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"ostream:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s1:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s1&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s2:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s2&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s3:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s3&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;fstream<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"fstream:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;fstream&nbsp;f(&nbsp;filename&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;&lt;&lt;&nbsp;s1&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;&lt;&lt;&nbsp;s2&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f.close();<br />
&nbsp;&nbsp;&nbsp;&nbsp;f.open(&nbsp;filename&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;&gt;&gt;&nbsp;s2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;&gt;&gt;&nbsp;s1;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f.close();<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s1:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s1&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s2:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s2&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s3:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s3&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;stringstream<br />
&nbsp;&nbsp;&nbsp;&nbsp;//----------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"stringstream:"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;stringstream&nbsp;ss;<br />
&nbsp;&nbsp;&nbsp;&nbsp;ss&nbsp;&lt;&lt;&nbsp;s1&nbsp;&lt;&lt;&nbsp;s2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;ss&nbsp;&gt;&gt;&nbsp;s3;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s1:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s1&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s2:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s2&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"s3:&nbsp;&nbsp;"&nbsp;&lt;&lt;&nbsp;s3&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />
}<br />
//========================================<br />
</code><br />
This code produces the following output (assuming you typed &#8220;abc&#8221; for s1 and &#8220;wxyz&#8221; for s2):<br />
<code>ostream:<br />
s1:  s1<br />
s2:  s2<br />
s3:</p>
<p>istream:<br />
Enter s1 string: abc<br />
Enter s2 string: wxyz</p>
<p>ostream:<br />
s1:  abc<br />
s2:  wxyz<br />
s3:</p>
<p>fstream:<br />
s1:  wxyz<br />
s2:  abc<br />
s3:</p>
<p>stringstream:<br />
s1:  wxyz<br />
s2:  abc<br />
s3:  wxyzabc<br />
</code><br />
The book Standard C++ IOStreams and Locales by Langer and Kreft describes how C++ IOStreams are to be used &#8230; and (most importantly) how they can be extended.</p>
<p>Hope This Helps,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cory Nelson				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3089</link>
		<dc:creator><![CDATA[Cory Nelson]]></dc:creator>
		<pubDate>Sat, 28 May 2011 03:21:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3089</guid>
					<description><![CDATA[VC++ implements an old version of lambdas that makes a lot of sensible things not work.  vNext is supposed to implement N2927 (New wording for C++0x Lambdas), so I suspect many of these issues will be solved.]]></description>
		<content:encoded><![CDATA[<p>VC++ implements an old version of lambdas that makes a lot of sensible things not work.  vNext is supposed to implement N2927 (New wording for C++0x Lambdas), so I suspect many of these issues will be solved.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mawirth				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3088</link>
		<dc:creator><![CDATA[mawirth]]></dc:creator>
		<pubDate>Sat, 28 May 2011 01:21:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3088</guid>
					<description><![CDATA[i noticed that in the current version of vc++ using lambdas sometimes can disable ADL / König lookup to work as expected - for instance, i have to qualify for_each by prefixing it with std even though the iterator range is also of types within the std namespace (vector iterators for example). 
how do ADL and lambdas interact in general (which would be my main question)? 
do lambdas introduce something like temporary types that make ADL fail? what about ADL in lambda bodies?

looking forward to the next channel9 episode from c++ world !]]></description>
		<content:encoded><![CDATA[<p>i noticed that in the current version of vc++ using lambdas sometimes can disable ADL / König lookup to work as expected &#8211; for instance, i have to qualify for_each by prefixing it with std even though the iterator range is also of types within the std namespace (vector iterators for example).<br />
how do ADL and lambdas interact in general (which would be my main question)?<br />
do lambdas introduce something like temporary types that make ADL fail? what about ADL in lambda bodies?</p>
<p>looking forward to the next channel9 episode from c++ world !</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3087</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Sat, 28 May 2011 00:24:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3087</guid>
					<description><![CDATA[Olaf, how would cout.write(s) differ from cout &#060;&#060; s?]]></description>
		<content:encoded><![CDATA[<p>Olaf, how would cout.write(s) differ from cout &lt;&lt; s?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3086</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Fri, 27 May 2011 23:31:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3086</guid>
					<description><![CDATA[Examples are istream::read and ostream::write.
Instead of string s; cout.write(s.data(), s.size()); you could use cout.write(s);]]></description>
		<content:encoded><![CDATA[<p>Examples are istream::read and ostream::write.<br />
Instead of string s; cout.write(s.data(), s.size()); you could use cout.write(s);</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3085</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Fri, 27 May 2011 23:19:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3085</guid>
					<description><![CDATA[I understand your distress.  I had to learn C++ twice.

The first time, C++ was taught to me as C with minor changes: cout (instead of printf), class (instead of struct), new (instead of malloc), and delete/delete[] (instead of free).  The pointers, arrays, and functions were all the same ... OOP has emphasized, but templates and the STL were never mentioned ... and I didn&#039;t know they existed until years later.  Everything was slanted towards a C-way of looking at things ... even though the textbook I was studying from at the time kept stating that we needed to break free of the C mindset and concentrate on C++&#039;s OOP way of thinking.  It all seemed very cosmetic ... all very C.

After using other languages at work for a number of years (and not using C++), I had to re-learn C++ again for a few projects.  I decided to take a class again.  The approach that the instructor used to teach C++ this second time around made all the difference.  First, we started off learning the easy parts of the STL (like std::vector, std::back_inserter, std::for_each, ...) and then we started on easy/useful function templates (like creating templates for operator&#060;&#060; to print out each element in a std::vector&#060;T&#062; ... so we could just cout a vector).  We went through iterators, vice pointers, and other containers, vice arrays.  Then we went over classes and some OOP ... and how they worked with generic programming.  At the end, we covered the bit-twiddling, #define-ing, and pointer-obsessed nature that characterizes C.

This second approach worked for me.  The first did not.  My impression is that the presentation of C++ makes all the difference.  There is no need to start with the C parts of C++ (like pointers, arrays, new, or delete/delete[]).  There is also no need to present C++ as an OOP language that emphasizes C-like features (like pointers, arrays, new, and delete/delete[]).  However, introducing C++ through the Standard Library using simple generic programming and simple OOP seems to work well ... and C++1998/2003 fits that bill.

With C++0x&#039;s auto and alternative tokens (like &quot;and&quot; for &#038;&#038;, &quot;or&quot; for &#124;&#124;, ...), the next version of C++ will be easier to read for novices ... and potentially easier to program.  With C++0x&#039;s std::make_shared, we can get rid of most (if not all) of the calls to new and delete ... and deal solely with std::shared_ptr. With C++0x&#039;s range-based for loop, iterating over collections will be easier for everyone (including novices).  With lambdas and decltype in C++0x, STL functions like std::for_each and std::transform will be dramatically easier to use.  With C++0x&#039;s uniform initialization, it will be easier for everyone (including novices) to work through ideas in C++ code because we&#039;ll be able to initialize vectors, constructors, etc. in the same way we have been able to initialize arrays of ints (making C++ more scriptable without compromising performance).

C++0x may be vastly easier for novices to learn ... but their C++0x instructor can always make it difficult ... and the book they use for C++0x can always be written from a perspective that was relevant 30 years ago.


Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>I understand your distress.  I had to learn C++ twice.</p>
<p>The first time, C++ was taught to me as C with minor changes: cout (instead of printf), class (instead of struct), new (instead of malloc), and delete/delete[] (instead of free).  The pointers, arrays, and functions were all the same &#8230; OOP has emphasized, but templates and the STL were never mentioned &#8230; and I didn&#8217;t know they existed until years later.  Everything was slanted towards a C-way of looking at things &#8230; even though the textbook I was studying from at the time kept stating that we needed to break free of the C mindset and concentrate on C++&#8217;s OOP way of thinking.  It all seemed very cosmetic &#8230; all very C.</p>
<p>After using other languages at work for a number of years (and not using C++), I had to re-learn C++ again for a few projects.  I decided to take a class again.  The approach that the instructor used to teach C++ this second time around made all the difference.  First, we started off learning the easy parts of the STL (like std::vector, std::back_inserter, std::for_each, &#8230;) and then we started on easy/useful function templates (like creating templates for operator&lt;&lt; to print out each element in a std::vector&lt;T&gt; &#8230; so we could just cout a vector).  We went through iterators, vice pointers, and other containers, vice arrays.  Then we went over classes and some OOP &#8230; and how they worked with generic programming.  At the end, we covered the bit-twiddling, #define-ing, and pointer-obsessed nature that characterizes C.</p>
<p>This second approach worked for me.  The first did not.  My impression is that the presentation of C++ makes all the difference.  There is no need to start with the C parts of C++ (like pointers, arrays, new, or delete/delete[]).  There is also no need to present C++ as an OOP language that emphasizes C-like features (like pointers, arrays, new, and delete/delete[]).  However, introducing C++ through the Standard Library using simple generic programming and simple OOP seems to work well &#8230; and C++1998/2003 fits that bill.</p>
<p>With C++0x&#8217;s auto and alternative tokens (like &#8220;and&#8221; for &amp;&amp;, &#8220;or&#8221; for ||, &#8230;), the next version of C++ will be easier to read for novices &#8230; and potentially easier to program.  With C++0x&#8217;s std::make_shared, we can get rid of most (if not all) of the calls to new and delete &#8230; and deal solely with std::shared_ptr. With C++0x&#8217;s range-based for loop, iterating over collections will be easier for everyone (including novices).  With lambdas and decltype in C++0x, STL functions like std::for_each and std::transform will be dramatically easier to use.  With C++0x&#8217;s uniform initialization, it will be easier for everyone (including novices) to work through ideas in C++ code because we&#8217;ll be able to initialize vectors, constructors, etc. in the same way we have been able to initialize arrays of ints (making C++ more scriptable without compromising performance).</p>
<p>C++0x may be vastly easier for novices to learn &#8230; but their C++0x instructor can always make it difficult &#8230; and the book they use for C++0x can always be written from a perspective that was relevant 30 years ago.</p>
<p>Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3084</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Fri, 27 May 2011 20:47:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3084</guid>
					<description><![CDATA[What &quot;ptr pair&quot; and const std::string&#038; functions from the C++ Standard Library are you referring to?

Please, provide a small code sample that demonstrates how you are using these functions.

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>What &#8220;ptr pair&#8221; and const std::string&amp; functions from the C++ Standard Library are you referring to?</p>
<p>Please, provide a small code sample that demonstrates how you are using these functions.</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3083</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Fri, 27 May 2011 13:12:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3083</guid>
					<description><![CDATA[#pragma once // supported by GCC and VS, not sure what compilers do not support it]]></description>
		<content:encoded><![CDATA[<p>#pragma once // supported by GCC and VS, not sure what compilers do not support it</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3082</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Fri, 27 May 2011 12:54:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3082</guid>
					<description><![CDATA[Data/String Ref (ptr pair) class/wrapper
A lot of functions have a (ptr, size_t) pair or a const std::string&#038; parameter. The latter requires you to construct a std::string which isn&#039;t necessary while the former requires the use of two parameters which isn&#039;t handy.

Why does C++ not have a class/wrapper for this?]]></description>
		<content:encoded><![CDATA[<p>Data/String Ref (ptr pair) class/wrapper<br />
A lot of functions have a (ptr, size_t) pair or a const std::string&amp; parameter. The latter requires you to construct a std::string which isn&#8217;t necessary while the former requires the use of two parameters which isn&#8217;t handy.</p>
<p>Why does C++ not have a class/wrapper for this?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3081</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Fri, 27 May 2011 12:52:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3081</guid>
					<description><![CDATA[Class Properties
C# and Ruby have them (AFAIK) and they&#039;re very handy. What&#039;s your opinion and is there a chance to see them in C++ in the future?]]></description>
		<content:encoded><![CDATA[<p>Class Properties<br />
C# and Ruby have them (AFAIK) and they&#8217;re very handy. What&#8217;s your opinion and is there a chance to see them in C++ in the future?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rob Yull				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3074</link>
		<dc:creator><![CDATA[Rob Yull]]></dc:creator>
		<pubDate>Thu, 26 May 2011 11:51:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3074</guid>
					<description><![CDATA[Ignore the previous question, it finally hit me what is going on.]]></description>
		<content:encoded><![CDATA[<p>Ignore the previous question, it finally hit me what is going on.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rob Yull				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3072</link>
		<dc:creator><![CDATA[Rob Yull]]></dc:creator>
		<pubDate>Wed, 25 May 2011 21:19:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3072</guid>
					<description><![CDATA[I just watched the presentation, and was trying to convert some of my existing code to use lambdas and algorithms.

I tried the following in VS2010 Pro (snippet from actual code.  It exists in a static member function of a class that exists in the namespace KS::Math)

typedef vector storage_type;
typedef typename storage_type::value_type value_type;
std::string Input(&quot;12345&quot;);
storage_type Translate(5);

std::for_each(Input.rbegin(), Input.rend(), [&#038;Translate](std::string::value_type Value)
{
	std::fill(Translate.begin(), Translate.end(), 0);
	//  The next line produces the error - Error	1	error C2440: &#039;=&#039; : cannot convert from &#039;KS::Math::`anonymous-namespace&#039;::&#039; to &#039;unsigned int&#039;	e:\programming\ksframework\branches\sandbox\src\kslibrary\math\bigintegermath.hpp	2619

	Translate.front() = [&#038;Value]() -&#062; value_type
	{
		switch(Value)
		{
		case &#039;0&#039;:	return 0;
		case &#039;1&#039;:	return 1;
		case &#039;2&#039;:	return 2;
		case &#039;3&#039;:	return 3;
		case &#039;4&#039;:	return 4;
		case &#039;5&#039;:	return 5;
		case &#039;6&#039;:	return 6;
		case &#039;7&#039;:	return 7;
		case &#039;8&#039;:	return 8;
		case &#039;9&#039;:	return 9;
		default:	throw std::exception();
		}
	};
}

As mentioned in the comment above, VS spits out a C2440 error saying it can&#039;t convert from &#039;KS::Math::`anonymous-namespace&#039;::&#039; to &#039;unsigned int&#039;

I changed the code to 
	auto CharToInt = [&#038;Value]() -&#062; value_type
	{
		switch(Value)
		{
		case &#039;0&#039;:	return 0;
		case &#039;1&#039;:	return 1;
		case &#039;2&#039;:	return 2;
		case &#039;3&#039;:	return 3;
		case &#039;4&#039;:	return 4;
		case &#039;5&#039;:	return 5;
		case &#039;6&#039;:	return 6;
		case &#039;7&#039;:	return 7;
		case &#039;8&#039;:	return 8;
		case &#039;9&#039;:	return 9;
		default:	throw std::exception();
		}
	};
	Translate.front() = CharToInt();

This version compiles just fine.

Is there something I&#039;m doing wrong with the first version, or can it just not work without storing the lambdas in the variable first?]]></description>
		<content:encoded><![CDATA[<p>I just watched the presentation, and was trying to convert some of my existing code to use lambdas and algorithms.</p>
<p>I tried the following in VS2010 Pro (snippet from actual code.  It exists in a static member function of a class that exists in the namespace KS::Math)</p>
<p>typedef vector storage_type;<br />
typedef typename storage_type::value_type value_type;<br />
std::string Input(&#8220;12345&#8221;);<br />
storage_type Translate(5);</p>
<p>std::for_each(Input.rbegin(), Input.rend(), [&amp;Translate](std::string::value_type Value)<br />
{<br />
	std::fill(Translate.begin(), Translate.end(), 0);<br />
	//  The next line produces the error &#8211; Error	1	error C2440: &#8216;=&#8217; : cannot convert from &#8216;KS::Math::`anonymous-namespace&#8217;::&#8217; to &#8216;unsigned int&#8217;	e:\programming\ksframework\branches\sandbox\src\kslibrary\math\bigintegermath.hpp	2619</p>
<p>	Translate.front() = [&amp;Value]() -&gt; value_type<br />
	{<br />
		switch(Value)<br />
		{<br />
		case &#8216;0&#8217;:	return 0;<br />
		case &#8216;1&#8217;:	return 1;<br />
		case &#8216;2&#8217;:	return 2;<br />
		case &#8216;3&#8217;:	return 3;<br />
		case &#8216;4&#8217;:	return 4;<br />
		case &#8216;5&#8217;:	return 5;<br />
		case &#8216;6&#8217;:	return 6;<br />
		case &#8216;7&#8217;:	return 7;<br />
		case &#8216;8&#8217;:	return 8;<br />
		case &#8216;9&#8217;:	return 9;<br />
		default:	throw std::exception();<br />
		}<br />
	};<br />
}</p>
<p>As mentioned in the comment above, VS spits out a C2440 error saying it can&#8217;t convert from &#8216;KS::Math::`anonymous-namespace&#8217;::&#8217; to &#8216;unsigned int&#8217;</p>
<p>I changed the code to<br />
	auto CharToInt = [&amp;Value]() -&gt; value_type<br />
	{<br />
		switch(Value)<br />
		{<br />
		case &#8216;0&#8217;:	return 0;<br />
		case &#8216;1&#8217;:	return 1;<br />
		case &#8216;2&#8217;:	return 2;<br />
		case &#8216;3&#8217;:	return 3;<br />
		case &#8216;4&#8217;:	return 4;<br />
		case &#8216;5&#8217;:	return 5;<br />
		case &#8216;6&#8217;:	return 6;<br />
		case &#8216;7&#8217;:	return 7;<br />
		case &#8216;8&#8217;:	return 8;<br />
		case &#8216;9&#8217;:	return 9;<br />
		default:	throw std::exception();<br />
		}<br />
	};<br />
	Translate.front() = CharToInt();</p>
<p>This version compiles just fine.</p>
<p>Is there something I&#8217;m doing wrong with the first version, or can it just not work without storing the lambdas in the variable first?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3071</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Wed, 25 May 2011 16:35:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3071</guid>
					<description><![CDATA[Do you have an opinion on Intel TBB? Do you some similar library being integrated into the standard?]]></description>
		<content:encoded><![CDATA[<p>Do you have an opinion on Intel TBB? Do you some similar library being integrated into the standard?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: muler				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3070</link>
		<dc:creator><![CDATA[muler]]></dc:creator>
		<pubDate>Wed, 25 May 2011 08:17:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3070</guid>
					<description><![CDATA[25-50% is an overstatement. the C++ committee can&#039;t even vote out triagraphs !!!

C++ has been hijacked by experts and it&#039;s so novice hostile. that is a fact. the better way is to accept the fact and think of solutions.]]></description>
		<content:encoded><![CDATA[<p>25-50% is an overstatement. the C++ committee can&#8217;t even vote out triagraphs !!!</p>
<p>C++ has been hijacked by experts and it&#8217;s so novice hostile. that is a fact. the better way is to accept the fact and think of solutions.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: freefly				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3069</link>
		<dc:creator><![CDATA[freefly]]></dc:creator>
		<pubDate>Tue, 24 May 2011 12:44:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3069</guid>
					<description><![CDATA[@Cory Nelson :  I know WPF well and there are times when you really wish you want a C++ GUI. With WPF you are at the mercy of the framework. (i.e. you cannot go beyond the framework or .net framework ) There are many I can point  out... When you write custom applications, that are really different from regular apps, you end up writing lot of interop stuff and it just feels like you just made a salad. As a C++ dev, I just want to be in C++ and not studying and reading about the WPF and C#.]]></description>
		<content:encoded><![CDATA[<p>@Cory Nelson :  I know WPF well and there are times when you really wish you want a C++ GUI. With WPF you are at the mercy of the framework. (i.e. you cannot go beyond the framework or .net framework ) There are many I can point  out&#8230; When you write custom applications, that are really different from regular apps, you end up writing lot of interop stuff and it just feels like you just made a salad. As a C++ dev, I just want to be in C++ and not studying and reading about the WPF and C#.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Atle Iversen				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3068</link>
		<dc:creator><![CDATA[Atle Iversen]]></dc:creator>
		<pubDate>Tue, 24 May 2011 09:58:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3068</guid>
					<description><![CDATA[I&#039;m not sure how much you&#039;re allowed to tell us, but I would *love* to hear some details about MS Windows and/or MS Office; how much C vs. C++, which parts of C++ do they use etc (Google has released an &quot;official&quot; C++ coding standard, but I would love to see something similar from the MS Windows and MS Office teams...)]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not sure how much you&#8217;re allowed to tell us, but I would *love* to hear some details about MS Windows and/or MS Office; how much C vs. C++, which parts of C++ do they use etc (Google has released an &#8220;official&#8221; C++ coding standard, but I would love to see something similar from the MS Windows and MS Office teams&#8230;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cory Nelson				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3067</link>
		<dc:creator><![CDATA[Cory Nelson]]></dc:creator>
		<pubDate>Tue, 24 May 2011 05:36:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3067</guid>
					<description><![CDATA[WPF fulfills all those requirements.

I guess you meant one in C++, but… why do you need to write a GUI in C++?  Backend, sure, but GUI?]]></description>
		<content:encoded><![CDATA[<p>WPF fulfills all those requirements.</p>
<p>I guess you meant one in C++, but… why do you need to write a GUI in C++?  Backend, sure, but GUI?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3066</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Tue, 24 May 2011 04:49:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3066</guid>
					<description><![CDATA[Will Visual C++ allow lambda functions with no captures to be converted to their associated function pointers (per the C++0x Draft Standard)?  Or does Visual C++ interpret the C++0x Draft Standard differently on these type of lambda conversions?

Background:
In Section § 5.1.2 Paragraph 6 (on Page 94) of the 2011-04-05 C++0x Draft Standard (N3291=11-0061), a lambda function with no captures should be able to be converted to a function pointer having the same parameter and return types as the lambda.  Currently, g++ 4.5.2 seems to implement this; however, Visual C++ 2010 SP1 does not seem to implement this.  For instance, the following code compiles on g++ 4.5.2, but __not__ on Visual C++ 2010 SP1 ... Visual C++ issues a compile-time error at the &quot;f = lambda_1&quot; line:
&lt;code&gt;#include&#160;&#060;iostream&#062;

using&#160;namespace&#160;std;

void&#160;function_1&#160;(&#160;void&#160;)&#160;{
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;function_1&quot;&#160;&#060;&#060;&#160;endl;
}
void&#160;function_2&#160;(&#160;void&#160;)&#160;{
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;function_2&quot;&#160;&#060;&#060;&#160;endl;
}
auto&#160;lambda_1&#160;=&#160;[]&#160;(&#160;void&#160;)&#160;-&#062;&#160;void&#160;{
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;lambda_1&quot;&#160;&#060;&#060;&#160;endl;
};
int&#160;main&#160;()&#160;{&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;auto&#160;lambda_2&#160;=&#160;[]&#160;(&#160;void&#160;)&#160;-&#062;&#160;void&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;lambda_2&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;};
&#160;&#160;&#160;&#160;//-------------------------
&#160;&#160;&#160;&#160;typedef&#160;void&#160;(*F)&#160;(&#160;void&#160;);
&#160;&#160;&#160;&#160;F&#160;f;
&#160;&#160;&#160;&#160;f&#160;=&#160;function_1;
&#160;&#160;&#160;&#160;f();
&#160;&#160;&#160;&#160;f&#160;=&#160;function_2;
&#160;&#160;&#160;&#160;f();
&#160;&#160;&#160;&#160;f&#160;=&#160;lambda_1;
&#160;&#160;&#160;&#160;f();
&#160;&#160;&#160;&#160;f&#160;=&#160;lambda_2;
&#160;&#160;&#160;&#160;f();
&#160;&#160;&#160;&#160;f&#160;=&#160;[]&#160;(&#160;void&#160;)&#160;-&#062;&#160;void&#160;{
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;&quot;lambda_3&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;};
&#160;&#160;&#160;&#160;f();
&#160;&#160;&#160;&#160;//-------------------------
&#160;&#160;&#160;&#160;return&#160;0;
}&lt;/code&gt;
When this code is compiled using g++ 4.5.2 and run using the following command lines:
&lt;code&gt;g++ -o main.exe -std=c++0x -march=native -O3 -Wall -Wextra -Werror main.cpp
./main.exe&lt;/code&gt;
The following output is generated (as expected):
&lt;code&gt;function_1
function_2
lambda_1
lambda_2
lambda_3&lt;/code&gt;

When will this compile/work in Visual C++?

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>Will Visual C++ allow lambda functions with no captures to be converted to their associated function pointers (per the C++0x Draft Standard)?  Or does Visual C++ interpret the C++0x Draft Standard differently on these type of lambda conversions?</p>
<p>Background:<br />
In Section § 5.1.2 Paragraph 6 (on Page 94) of the 2011-04-05 C++0x Draft Standard (N3291=11-0061), a lambda function with no captures should be able to be converted to a function pointer having the same parameter and return types as the lambda.  Currently, g++ 4.5.2 seems to implement this; however, Visual C++ 2010 SP1 does not seem to implement this.  For instance, the following code compiles on g++ 4.5.2, but __not__ on Visual C++ 2010 SP1 &#8230; Visual C++ issues a compile-time error at the &#8220;f = lambda_1&#8221; line:<br />
<code>#include&nbsp;&lt;iostream&gt;</p>
<p>using&nbsp;namespace&nbsp;std;</p>
<p>void&nbsp;function_1&nbsp;(&nbsp;void&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"function_1"&nbsp;&lt;&lt;&nbsp;endl;<br />
}<br />
void&nbsp;function_2&nbsp;(&nbsp;void&nbsp;)&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"function_2"&nbsp;&lt;&lt;&nbsp;endl;<br />
}<br />
auto&nbsp;lambda_1&nbsp;=&nbsp;[]&nbsp;(&nbsp;void&nbsp;)&nbsp;-&gt;&nbsp;void&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"lambda_1"&nbsp;&lt;&lt;&nbsp;endl;<br />
};<br />
int&nbsp;main&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;auto&nbsp;lambda_2&nbsp;=&nbsp;[]&nbsp;(&nbsp;void&nbsp;)&nbsp;-&gt;&nbsp;void&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"lambda_2"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;typedef&nbsp;void&nbsp;(*F)&nbsp;(&nbsp;void&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;f;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;function_1;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f();<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;function_2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f();<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;lambda_1;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f();<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;lambda_2;<br />
&nbsp;&nbsp;&nbsp;&nbsp;f();<br />
&nbsp;&nbsp;&nbsp;&nbsp;f&nbsp;=&nbsp;[]&nbsp;(&nbsp;void&nbsp;)&nbsp;-&gt;&nbsp;void&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;"lambda_3"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
&nbsp;&nbsp;&nbsp;&nbsp;f();<br />
&nbsp;&nbsp;&nbsp;&nbsp;//-------------------------<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />
}</code><br />
When this code is compiled using g++ 4.5.2 and run using the following command lines:<br />
<code>g++ -o main.exe -std=c++0x -march=native -O3 -Wall -Wextra -Werror main.cpp<br />
./main.exe</code><br />
The following output is generated (as expected):<br />
<code>function_1<br />
function_2<br />
lambda_1<br />
lambda_2<br />
lambda_3</code></p>
<p>When will this compile/work in Visual C++?</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3065</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 24 May 2011 01:53:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3065</guid>
					<description><![CDATA[I see a lot of great questions here! I&#039;m looking forward to answering as many as we can.
I&#039;ve updated the blog post to note that the followup interview has been scheduled for next week, so you have until midnight June 1 (North American Pacific time) to post new questions and vote others&#039; questions up/down. I&#039;ll blog a reminder a day or two before the cutoff.]]></description>
		<content:encoded><![CDATA[<p>I see a lot of great questions here! I&#8217;m looking forward to answering as many as we can.<br />
I&#8217;ve updated the blog post to note that the followup interview has been scheduled for next week, so you have until midnight June 1 (North American Pacific time) to post new questions and vote others&#8217; questions up/down. I&#8217;ll blog a reminder a day or two before the cutoff.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3064</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Mon, 23 May 2011 21:56:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3064</guid>
					<description><![CDATA[So... what&#039;s the alternative? A language that effectively breaks 25-50% of all existing code every time a new version comes out?

If you tried to do that, then what you have is not a single evolving language. What you will have is multiple, *incompatibile* languages. Every new &quot;version&quot; will be a new language that will have new compilers. Users will pick a specific version and code to it rather than &quot;upgrading&quot; to something &quot;cleaner&quot;. Compiler developers will have to essentially support multiple compilers for the supposedly same language.

Really, if you&#039;re going to break most code with a new &quot;version&quot; of a language, just write a new language. It would be better than carrying on the pretense that we&#039;re talking about a &quot;version&quot; change.]]></description>
		<content:encoded><![CDATA[<p>So&#8230; what&#8217;s the alternative? A language that effectively breaks 25-50% of all existing code every time a new version comes out?</p>
<p>If you tried to do that, then what you have is not a single evolving language. What you will have is multiple, *incompatibile* languages. Every new &#8220;version&#8221; will be a new language that will have new compilers. Users will pick a specific version and code to it rather than &#8220;upgrading&#8221; to something &#8220;cleaner&#8221;. Compiler developers will have to essentially support multiple compilers for the supposedly same language.</p>
<p>Really, if you&#8217;re going to break most code with a new &#8220;version&#8221; of a language, just write a new language. It would be better than carrying on the pretense that we&#8217;re talking about a &#8220;version&#8221; change.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: freefly				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3061</link>
		<dc:creator><![CDATA[freefly]]></dc:creator>
		<pubDate>Mon, 23 May 2011 15:04:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3061</guid>
					<description><![CDATA[Hi Herb,
    Thanks for your efforts and time spend on this Q&#038;A.

Is it time for Microsoft to introduce a GUI framework for the 21st century ? what we have now is, things before the internet era. We are still dragging it along with us, aren&#039;t we ? When will be see an good GUI framework based on DirectX and supporting API libraries ?

thanks]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,<br />
    Thanks for your efforts and time spend on this Q&amp;A.</p>
<p>Is it time for Microsoft to introduce a GUI framework for the 21st century ? what we have now is, things before the internet era. We are still dragging it along with us, aren&#8217;t we ? When will be see an good GUI framework based on DirectX and supporting API libraries ?</p>
<p>thanks</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: muler				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3059</link>
		<dc:creator><![CDATA[muler]]></dc:creator>
		<pubDate>Mon, 23 May 2011 07:37:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3059</guid>
					<description><![CDATA[&quot;C++ is expert friendly. But, it&#039;s also novice hostile&quot;, this is a direct quote from Bjarne Stroustrup. I can&#039;t believe you&#039;re doubting this.

I think C++ has been taken hostage by it&#039;s success. You can&#039;t remove a bad feature because there is some code &quot;out there&quot; that depends on it -- i believe this is too much emphasis on backward compatibility.

I think C++ needs to wash itself and remove the dirt.]]></description>
		<content:encoded><![CDATA[<p>&#8220;C++ is expert friendly. But, it&#8217;s also novice hostile&#8221;, this is a direct quote from Bjarne Stroustrup. I can&#8217;t believe you&#8217;re doubting this.</p>
<p>I think C++ has been taken hostage by it&#8217;s success. You can&#8217;t remove a bad feature because there is some code &#8220;out there&#8221; that depends on it &#8212; i believe this is too much emphasis on backward compatibility.</p>
<p>I think C++ needs to wash itself and remove the dirt.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3058</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Mon, 23 May 2011 06:14:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3058</guid>
					<description><![CDATA[There is no unicode encoding conversion operation, if that&#039;s what you&#039;re asking for.]]></description>
		<content:encoded><![CDATA[<p>There is no unicode encoding conversion operation, if that&#8217;s what you&#8217;re asking for.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3057</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 23 May 2011 04:30:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3057</guid>
					<description><![CDATA[For #4 above, a raw string requires an &lt;code&gt;R&lt;/code&gt; in front of the &lt;code&gt;raw-string&lt;/code&gt;.  An example of using a raw string is the following ... assumed to be in main.cpp:
&lt;code&gt;#include&#160;&#060;iostream&#062;

using&#160;namespace&#160;std;

int&#160;main&#160;()&#160;{
&#160;&#160;&#160;&#160;cout&#160;&#060;&#060;&#160;R&quot;(&quot;C:\Program&#160;Files\&quot;)&quot;&#160;&#060;&#060;&#160;endl;
&#160;&#160;&#160;&#160;return&#160;0;
}&lt;/code&gt;
This code doesn&#039;t currently compile in Visual C++ 2010 (because C++0x raw strings aren&#039;t yet implemented); however, g++ 4.5.2 has no issues ... so if we execute the following on the command lines:
&lt;code&gt;g++ -o main.exe -std=c++0x -march=native -O3 -Wall -Wextra main.cpp
./main.exe&lt;/code&gt;
Then main.exe will compile and run ... producing the following output:
&lt;code&gt;&quot;C:\Program Files\&quot;&lt;/code&gt;

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>For #4 above, a raw string requires an <code>R</code> in front of the <code>raw-string</code>.  An example of using a raw string is the following &#8230; assumed to be in main.cpp:<br />
<code>#include&nbsp;&lt;iostream&gt;</p>
<p>using&nbsp;namespace&nbsp;std;</p>
<p>int&nbsp;main&nbsp;()&nbsp;{<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout&nbsp;&lt;&lt;&nbsp;R"("C:\Program&nbsp;Files\")"&nbsp;&lt;&lt;&nbsp;endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;<br />
}</code><br />
This code doesn&#8217;t currently compile in Visual C++ 2010 (because C++0x raw strings aren&#8217;t yet implemented); however, g++ 4.5.2 has no issues &#8230; so if we execute the following on the command lines:<br />
<code>g++ -o main.exe -std=c++0x -march=native -O3 -Wall -Wextra main.cpp<br />
./main.exe</code><br />
Then main.exe will compile and run &#8230; producing the following output:<br />
<code>"C:\Program Files\"</code></p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3056</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 23 May 2011 04:11:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3056</guid>
					<description><![CDATA[What C++0x features are being added to Visual C++ 2011?

Specifically, are the following being added to Visual C++ 2011?:
1) std::initializer_list
2) std::thread
3) range-based for statement (i.e. &lt;code&gt;for ( for-range-declaration : expression ) statement&lt;/code&gt;)
4) raw strings (i.e. &lt;code&gt;raw-string:&quot;optional-d-char-sequence(optional-r-char-sequence)optional-d-char-sequence&quot;&lt;/code&gt;)


Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>What C++0x features are being added to Visual C++ 2011?</p>
<p>Specifically, are the following being added to Visual C++ 2011?:<br />
1) std::initializer_list<br />
2) std::thread<br />
3) range-based for statement (i.e. <code>for ( for-range-declaration : expression ) statement</code>)<br />
4) raw strings (i.e. <code>raw-string:"optional-d-char-sequence(optional-r-char-sequence)optional-d-char-sequence"</code>)</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3055</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 23 May 2011 02:14:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3055</guid>
					<description><![CDATA[Please, disregard this post.  The angle brackets and tab spacing did not come through (esp. in the code).

Below is an identical post that has the angle brackets and better spacing.

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>Please, disregard this post.  The angle brackets and tab spacing did not come through (esp. in the code).</p>
<p>Below is an identical post that has the angle brackets and better spacing.</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3054</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 23 May 2011 01:57:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3054</guid>
					<description><![CDATA[Mr. Sutter,

My previous post did not take into account angle brackets and tab spacing; therefore, please delete/disregard my previous post.

Here is my question:

In C++0x, will decltype(std::vector&#060;std::string&#062;())::value_type become valid?  And will it be the same as std::string?
If not, why? And what chapter/section of the C++0x draft standard prevents this decltype(...)::some_type (i.e. the ::some_type as a nested type of the decltype(...) call)?

Background:
If we have the following code:
&#060;code&#062;
#include &#060;vector&#062;
#include &#060;string&#062;
#include &#060;algorithm&#062;
#include &#060;iostream&#062;

using namespace std;

int main () {
&#160;&#160;&#160;&#160;vector&#060;string&#062; strings;
&#160;&#160;&#160;&#160;strings.push_back( &quot;Hello&quot; );
&#160;&#160;&#160;&#160;strings.push_back( &quot;World&quot; );

&#160;&#160;&#160;&#160;for_each( strings.cbegin(), strings.cend(), []( decltype(strings.cbegin().operator*())&#038; str ) {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &#060;&#060; str &#060;&#060; endl;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;);

&#160;&#160;&#160;&#160;return 0;
}
&#060;/code&#062;
Then, str is a const std::string &#038; and the output is as follows:
Hello
World

However, in Visual C++ 2010 SP1 and g++ 4.5.2, the (arguably) more-readable code cannot compile:
&#060;code&#062;
#include &#060;vector&#062;
#include &#060;string&#062;
#include &#060;algorithm&#062;
#include &#060;iostream&#062;
#include &#060;type_traits&#062;

using namespace std;

int main () {
&#160;&#160;&#160;&#160;vector&#060;string&#062; strings;
&#160;&#160;&#160;&#160;strings.push_back( &quot;Hello&quot; );
&#160;&#160;&#160;&#160;strings.push_back( &quot;World&quot; );

&#160;&#160;&#160;&#160;cout &#060;&#060; &quot;Is decltype(strings) the same type as vector&#060;string&#062;?  &quot;;
&#160;&#160;&#160;&#160;cout &#060;&#060; ( is_same&#060;decltype(strings), vector&#060;string&#062;&#062;::value ? &quot;Yes.&quot; : &quot;No.&quot; ) &#060;&#060; endl;

&#160;&#160;&#160;&#160;for_each( strings.cbegin(), strings.cend(), []( decltype(strings)::value_type const &#038; str ) {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &#060;&#060; str &#060;&#060; endl;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;);
&#160;&#160;&#160;&#160;return 0;
}
&#060;/code&#062;
Both Visual C++ 2010 SP1 and g++ 4.5.2 do not accept decltype(strings)::value_type as a type, even though vector&#060;string&#062;::value_type is an acceptable type.

One workaround to this is to create a typedef of just decltype(strings) prior to writing out the lambda, but that isn&#039;t quite as satisfying as just using the decltype() immediately where it is needed.  In other words, this code does work:
&#060;code&#062;
#include &#060;vector&#062;
#include &#060;string&#062;
#include &#060;algorithm&#062;
#include &#060;iostream&#062;
#include &#060;type_traits&#062;

using namespace std;

int main () {
&#160;&#160;&#160;&#160;vector&#060;string&#062; strings;
&#160;&#160;&#160;&#160;strings.push_back( &quot;Hello&quot; );
&#160;&#160;&#160;&#160;strings.push_back( &quot;World&quot; );
&#160;&#160;&#160;&#160;
&#160;&#160;&#160;&#160;cout &#060;&#060; &quot;Is decltype(strings) the same type as vector&#060;string&#062;?  &quot;;
&#160;&#160;&#160;&#160;cout &#060;&#060; ( is_same&#060;decltype(strings), vector&#060;string&#062;&#062;::value ? &quot;Yes.&quot; : &quot;No.&quot; ) &#060;&#060; endl;

&#160;&#160;&#160;&#160;typedef decltype(strings) STRINGS_TYPE;
&#160;&#160;&#160;&#160;for_each( strings.cbegin(), strings.cend(), []( STRINGS_TYPE::value_type const &#038; str ) {
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;cout &#060;&#060; str &#060;&#060; endl;
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}
&#160;&#160;&#160;&#160;);
&#160;&#160;&#160;&#160;return 0;
}
&#060;/code&#062;

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>Mr. Sutter,</p>
<p>My previous post did not take into account angle brackets and tab spacing; therefore, please delete/disregard my previous post.</p>
<p>Here is my question:</p>
<p>In C++0x, will decltype(std::vector&lt;std::string&gt;())::value_type become valid?  And will it be the same as std::string?<br />
If not, why? And what chapter/section of the C++0x draft standard prevents this decltype(&#8230;)::some_type (i.e. the ::some_type as a nested type of the decltype(&#8230;) call)?</p>
<p>Background:<br />
If we have the following code:<br />
&lt;code&gt;<br />
#include &lt;vector&gt;<br />
#include &lt;string&gt;<br />
#include &lt;algorithm&gt;<br />
#include &lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>int main () {<br />
&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;string&gt; strings;<br />
&nbsp;&nbsp;&nbsp;&nbsp;strings.push_back( &#8220;Hello&#8221; );<br />
&nbsp;&nbsp;&nbsp;&nbsp;strings.push_back( &#8220;World&#8221; );</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;for_each( strings.cbegin(), strings.cend(), []( decltype(strings.cbegin().operator*())&amp; str ) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; str &lt;&lt; endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br />
}<br />
&lt;/code&gt;<br />
Then, str is a const std::string &amp; and the output is as follows:<br />
Hello<br />
World</p>
<p>However, in Visual C++ 2010 SP1 and g++ 4.5.2, the (arguably) more-readable code cannot compile:<br />
&lt;code&gt;<br />
#include &lt;vector&gt;<br />
#include &lt;string&gt;<br />
#include &lt;algorithm&gt;<br />
#include &lt;iostream&gt;<br />
#include &lt;type_traits&gt;</p>
<p>using namespace std;</p>
<p>int main () {<br />
&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;string&gt; strings;<br />
&nbsp;&nbsp;&nbsp;&nbsp;strings.push_back( &#8220;Hello&#8221; );<br />
&nbsp;&nbsp;&nbsp;&nbsp;strings.push_back( &#8220;World&#8221; );</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &#8220;Is decltype(strings) the same type as vector&lt;string&gt;?  &#8220;;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; ( is_same&lt;decltype(strings), vector&lt;string&gt;&gt;::value ? &#8220;Yes.&#8221; : &#8220;No.&#8221; ) &lt;&lt; endl;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;for_each( strings.cbegin(), strings.cend(), []( decltype(strings)::value_type const &amp; str ) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; str &lt;&lt; endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br />
}<br />
&lt;/code&gt;<br />
Both Visual C++ 2010 SP1 and g++ 4.5.2 do not accept decltype(strings)::value_type as a type, even though vector&lt;string&gt;::value_type is an acceptable type.</p>
<p>One workaround to this is to create a typedef of just decltype(strings) prior to writing out the lambda, but that isn&#8217;t quite as satisfying as just using the decltype() immediately where it is needed.  In other words, this code does work:<br />
&lt;code&gt;<br />
#include &lt;vector&gt;<br />
#include &lt;string&gt;<br />
#include &lt;algorithm&gt;<br />
#include &lt;iostream&gt;<br />
#include &lt;type_traits&gt;</p>
<p>using namespace std;</p>
<p>int main () {<br />
&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;string&gt; strings;<br />
&nbsp;&nbsp;&nbsp;&nbsp;strings.push_back( &#8220;Hello&#8221; );<br />
&nbsp;&nbsp;&nbsp;&nbsp;strings.push_back( &#8220;World&#8221; );<br />
&nbsp;&nbsp;&nbsp;&nbsp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; &#8220;Is decltype(strings) the same type as vector&lt;string&gt;?  &#8220;;<br />
&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; ( is_same&lt;decltype(strings), vector&lt;string&gt;&gt;::value ? &#8220;Yes.&#8221; : &#8220;No.&#8221; ) &lt;&lt; endl;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;typedef decltype(strings) STRINGS_TYPE;<br />
&nbsp;&nbsp;&nbsp;&nbsp;for_each( strings.cbegin(), strings.cend(), []( STRINGS_TYPE::value_type const &amp; str ) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cout &lt;&lt; str &lt;&lt; endl;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;&nbsp;&nbsp;);<br />
&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br />
}<br />
&lt;/code&gt;</p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joshua Burkholder				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3053</link>
		<dc:creator><![CDATA[Joshua Burkholder]]></dc:creator>
		<pubDate>Mon, 23 May 2011 01:49:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3053</guid>
					<description><![CDATA[In C++0x, will decltype(std::vector())::value_type become valid?  And will it be the same as std::string?
If not, why? And what chapter/section of the C++0x draft standard prevents this decltype(...)::some_type (i.e. the ::some_type as a nested type of the decltype(...) call)?

Background:
If we have the following code:
&lt;code&gt;
#include 
#include 
#include 
#include 

using namespace std;

int main () {
	vector strings;
	strings.push_back( &quot;Hello&quot; );
	strings.push_back( &quot;World&quot; );

	for_each( strings.cbegin(), strings.cend(), []( decltype(strings.cbegin().operator*())&#038; str ) {
			cout &#060;&#060; str &#060;&#060; endl;
		}
	);

	return 0;
}
&lt;/code&gt;
Then, str is a const std::string &#038; and the output is as follows:
Hello
World

However, in Visual C++ 2010 SP1 and g++ 4.5.2, the (arguably) more-readable code cannot compile:
&lt;code&gt;
#include 
#include 
#include 
#include 
#include 

using namespace std;

int main () {
	vector strings;
	strings.push_back( &quot;Hello&quot; );
	strings.push_back( &quot;World&quot; );

	cout &#060;&#060; &#034;Is decltype(strings) the same type as vector?  &quot;;
	cout &#060;&#060; ( is_same&#060;decltype(strings), vector&#062;::value ? &quot;Yes.&quot; : &quot;No.&quot; ) &#060;&#060; endl;

	for_each( strings.cbegin(), strings.cend(), []( decltype(strings)::value_type const &#038; str ) {
		cout &#060;&#060; str &#060;&#060; endl;
		}
	);
	return 0;
}
&lt;/code&gt;
Both Visual C++ 2010 SP1 and g++ 4.5.2 do not accept decltype(strings)::value_type as a type, even though vector::value_type is an acceptable type.

One workaround to this is to create a typedef of just decltype(strings) prior to writing out the lambda, but that isn&#039;t quite as satisfying as just using the decltype() immediately where it is needed.  In other words, this code does work:
&lt;code&gt;
#include 
#include 
#include 
#include 
#include 

using namespace std;

int main () {
	vector strings;
	strings.push_back( &quot;Hello&quot; );
	strings.push_back( &quot;World&quot; );

	cout &#060;&#060; &#034;Is decltype(strings) the same type as vector?  &quot;;
	cout &#060;&#060; ( is_same&#060;decltype(strings), vector&#062;::value ? &quot;Yes.&quot; : &quot;No.&quot; ) &#060;&#060; endl;

	typedef decltype(strings) STRINGS_TYPE;
	for_each( strings.cbegin(), strings.cend(), []( STRINGS_TYPE::value_type const &#038; str ) {
		cout &#060;&#060; str &#060;&#060; endl;
		}
	);
	return 0;
}
&lt;/code&gt;

Very Respectfully,
Joshua Burkholder]]></description>
		<content:encoded><![CDATA[<p>In C++0x, will decltype(std::vector())::value_type become valid?  And will it be the same as std::string?<br />
If not, why? And what chapter/section of the C++0x draft standard prevents this decltype(&#8230;)::some_type (i.e. the ::some_type as a nested type of the decltype(&#8230;) call)?</p>
<p>Background:<br />
If we have the following code:<br />
<code><br />
#include<br />
#include<br />
#include<br />
#include </p>
<p>using namespace std;</p>
<p>int main () {<br />
	vector strings;<br />
	strings.push_back( "Hello" );<br />
	strings.push_back( "World" );</p>
<p>	for_each( strings.cbegin(), strings.cend(), []( decltype(strings.cbegin().operator*())&amp; str ) {<br />
			cout &lt;&lt; str &lt;&lt; endl;<br />
		}<br />
	);</p>
<p>	return 0;<br />
}<br />
</code><br />
Then, str is a const std::string &amp; and the output is as follows:<br />
Hello<br />
World</p>
<p>However, in Visual C++ 2010 SP1 and g++ 4.5.2, the (arguably) more-readable code cannot compile:<br />
<code><br />
#include<br />
#include<br />
#include<br />
#include<br />
#include </p>
<p>using namespace std;</p>
<p>int main () {<br />
	vector strings;<br />
	strings.push_back( "Hello" );<br />
	strings.push_back( "World" );</p>
<p>	cout &lt;&lt; &quot;Is decltype(strings) the same type as vector?  ";<br />
	cout &lt;&lt; ( is_same&lt;decltype(strings), vector&gt;::value ? "Yes." : "No." ) &lt;&lt; endl;</p>
<p>	for_each( strings.cbegin(), strings.cend(), []( decltype(strings)::value_type const &amp; str ) {<br />
		cout &lt;&lt; str &lt;&lt; endl;<br />
		}<br />
	);<br />
	return 0;<br />
}<br />
</code><br />
Both Visual C++ 2010 SP1 and g++ 4.5.2 do not accept decltype(strings)::value_type as a type, even though vector::value_type is an acceptable type.</p>
<p>One workaround to this is to create a typedef of just decltype(strings) prior to writing out the lambda, but that isn&#8217;t quite as satisfying as just using the decltype() immediately where it is needed.  In other words, this code does work:<br />
<code><br />
#include<br />
#include<br />
#include<br />
#include<br />
#include </p>
<p>using namespace std;</p>
<p>int main () {<br />
	vector strings;<br />
	strings.push_back( "Hello" );<br />
	strings.push_back( "World" );</p>
<p>	cout &lt;&lt; &quot;Is decltype(strings) the same type as vector?  ";<br />
	cout &lt;&lt; ( is_same&lt;decltype(strings), vector&gt;::value ? "Yes." : "No." ) &lt;&lt; endl;</p>
<p>	typedef decltype(strings) STRINGS_TYPE;<br />
	for_each( strings.cbegin(), strings.cend(), []( STRINGS_TYPE::value_type const &amp; str ) {<br />
		cout &lt;&lt; str &lt;&lt; endl;<br />
		}<br />
	);<br />
	return 0;<br />
}<br />
</code></p>
<p>Very Respectfully,<br />
Joshua Burkholder</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2011/05/17/c9-questions/#comment-3052</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Sun, 22 May 2011 13:33:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=568#comment-3052</guid>
					<description><![CDATA[do you thing that there should be foreach like &quot;for_each_in_range&quot;  . something like for(auto element55:my_multimap.equal_range(55));]]></description>
		<content:encoded><![CDATA[<p>do you thing that there should be foreach like &#8220;for_each_in_range&#8221;  . something like for(auto element55:my_multimap.equal_range(55));</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
