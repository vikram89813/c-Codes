<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #100: Compilation Firewalls	</title>
	<atom:link href="https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Joe				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4400</link>
		<dc:creator><![CDATA[Joe]]></dc:creator>
		<pubDate>Tue, 15 Nov 2011 01:25:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4400</guid>
					<description><![CDATA[If memory allocations are a bottleneck, you can use a custom  allocator in the internal unique_ptr.]]></description>
		<content:encoded><![CDATA[<p>If memory allocations are a bottleneck, you can use a custom  allocator in the internal unique_ptr.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Henrik Vallgren				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4396</link>
		<dc:creator><![CDATA[Henrik Vallgren]]></dc:creator>
		<pubDate>Mon, 14 Nov 2011 14:36:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4396</guid>
					<description><![CDATA[How about performance? Memory allocations are often a bottleneck, and it seems that pimple would make the situation worse.]]></description>
		<content:encoded><![CDATA[<p>How about performance? Memory allocations are often a bottleneck, and it seems that pimple would make the situation worse.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthieu M.				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4371</link>
		<dc:creator><![CDATA[Matthieu M.]]></dc:creator>
		<pubDate>Thu, 10 Nov 2011 15:01:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4371</guid>
					<description><![CDATA[Simple comments (I am sorry, I don&#039;t have the time for a full-blown answer):

1) I would note that the compilation firewall goal is different than the ABI compatibility goal. We are ready to pay the cost of compilation when adding a virtual method in the former case, even if it would run the risk of breaking the ABI.

2) Implementation using a `unique_ptr`, with out of line definition of all the special members (= default is awesome)

3) Anything that is private, *apart from virtual functions* goes into the Impl. protected elements and virtual elements are logically part of the interface as far as derived classes are concerned, and &quot;lifting&quot; them does not solve anything. Of course, they should still delegate to the Impl class.

4) A back pointer (if necessary) should not be embedded, it cripples the automated move generation. It&#039;s simpler to have the main class pass a pointer to itself during forwarding when it&#039;s actually necessary.]]></description>
		<content:encoded><![CDATA[<p>Simple comments (I am sorry, I don&#8217;t have the time for a full-blown answer):</p>
<p>1) I would note that the compilation firewall goal is different than the ABI compatibility goal. We are ready to pay the cost of compilation when adding a virtual method in the former case, even if it would run the risk of breaking the ABI.</p>
<p>2) Implementation using a `unique_ptr`, with out of line definition of all the special members (= default is awesome)</p>
<p>3) Anything that is private, *apart from virtual functions* goes into the Impl. protected elements and virtual elements are logically part of the interface as far as derived classes are concerned, and &#8220;lifting&#8221; them does not solve anything. Of course, they should still delegate to the Impl class.</p>
<p>4) A back pointer (if necessary) should not be embedded, it cripples the automated move generation. It&#8217;s simpler to have the main class pass a pointer to itself during forwarding when it&#8217;s actually necessary.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ephi				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4370</link>
		<dc:creator><![CDATA[Ephi]]></dc:creator>
		<pubDate>Thu, 10 Nov 2011 14:34:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4370</guid>
					<description><![CDATA[Maybe you can cross-post to comp.programming.c++.,moderated
Bring back the 90s!]]></description>
		<content:encoded><![CDATA[<p>Maybe you can cross-post to comp.programming.c++.,moderated<br />
Bring back the 90s!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Redl				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4358</link>
		<dc:creator><![CDATA[Sebastian Redl]]></dc:creator>
		<pubDate>Wed, 09 Nov 2011 14:47:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4358</guid>
					<description><![CDATA[2) unique_ptr.
Interestingly enough, C++11 allows you to do this:

struct foo { ~foo(); };
foo::~foo() = default;

The interesting part is that this &quot;body&quot; is semantically equivalent and longer to type than just {}. (Yes, it really is fully semantically equivalent.)

3+4) Putting only the data in the impl has the advantage that you never need a back pointer, since all code runs with &#039;this&#039; being the outer object. The disadvantage is that adding private members to the outer class will force a recompile on clients (even though binary compatibility would be preserved).
Putting private functions in the impl has the advantage that you can add as many as you want without forcing a recompile; it has the disadvantage of needing a back pointer when I want to call some public function that expects the type (or a supertype) of the outer class, as well as when I want to call a public function or a virtual function on the outer class.
Putting all functions in the impl with the outer class only containing wrappers is strictly better (except for the repetitive code) than putting only the private functions there, since it means you can call other public functions without a back pointer.
This leaves back pointers necessary in two situations:
1) When passing &#039;this&#039; to somewhere else.
2) When calling virtual functions.
Note that putting virtual functions into the impl class is not an option. Overriding classes would have to override the impl class for this to work, and you really, really don&#039;t want to expose the impl class to overriders.]]></description>
		<content:encoded><![CDATA[<p>2) unique_ptr.<br />
Interestingly enough, C++11 allows you to do this:</p>
<p>struct foo { ~foo(); };<br />
foo::~foo() = default;</p>
<p>The interesting part is that this &#8220;body&#8221; is semantically equivalent and longer to type than just {}. (Yes, it really is fully semantically equivalent.)</p>
<p>3+4) Putting only the data in the impl has the advantage that you never need a back pointer, since all code runs with &#8216;this&#8217; being the outer object. The disadvantage is that adding private members to the outer class will force a recompile on clients (even though binary compatibility would be preserved).<br />
Putting private functions in the impl has the advantage that you can add as many as you want without forcing a recompile; it has the disadvantage of needing a back pointer when I want to call some public function that expects the type (or a supertype) of the outer class, as well as when I want to call a public function or a virtual function on the outer class.<br />
Putting all functions in the impl with the outer class only containing wrappers is strictly better (except for the repetitive code) than putting only the private functions there, since it means you can call other public functions without a back pointer.<br />
This leaves back pointers necessary in two situations:<br />
1) When passing &#8216;this&#8217; to somewhere else.<br />
2) When calling virtual functions.<br />
Note that putting virtual functions into the impl class is not an option. Overriding classes would have to override the impl class for this to work, and you really, really don&#8217;t want to expose the impl class to overriders.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Pseudonym				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4342</link>
		<dc:creator><![CDATA[Pseudonym]]></dc:creator>
		<pubDate>Mon, 07 Nov 2011 04:45:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4342</guid>
					<description><![CDATA[The question of how to handle protected members is an interesting one. Pimpl and inheritance are a mix that I&#039;ve never had to use.  I suspect that the &quot;right&quot; answer depends highly on context. Random thoughts:

1. If you find yourself wanting to do inheritance in the &quot;handle&quot; class, using an abstract base class could be a better solution.
2. If you find yourself wanting to do inheritance in the &quot;body&quot; class, consider that this might be an envelope/letter situation rather than handle/body.
3. If you find yourself wanting to do both, that this might be a bridge pattern.]]></description>
		<content:encoded><![CDATA[<p>The question of how to handle protected members is an interesting one. Pimpl and inheritance are a mix that I&#8217;ve never had to use.  I suspect that the &#8220;right&#8221; answer depends highly on context. Random thoughts:</p>
<p>1. If you find yourself wanting to do inheritance in the &#8220;handle&#8221; class, using an abstract base class could be a better solution.<br />
2. If you find yourself wanting to do inheritance in the &#8220;body&#8221; class, consider that this might be an envelope/letter situation rather than handle/body.<br />
3. If you find yourself wanting to do both, that this might be a bridge pattern.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul de Vrieze				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4339</link>
		<dc:creator><![CDATA[Paul de Vrieze]]></dc:creator>
		<pubDate>Sun, 06 Nov 2011 14:04:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4339</guid>
					<description><![CDATA[The answers to this question (and the whole pimpl idiom) is strongly related to runtime in-memory characteristics of objects (and vtables).

#1 )Let&#039;s actually answer #1 as the right answer helps with the other ones. The pimpl idiom is a workaround for the fact that usage of a class by value needs to know the object size. While this helps with recompilation the main purpose is to maintain stable ABI&#039;s for libraries.

#2 )Best way to express the idiom: &quot;unique_ptr pimpl;&quot;. PIMPLTYPE is forward declared in the header, but specified in the source file. 

#3 )What should go into the pimpl object:
 - First of all, private virtual functions make no sense (unless you have friend declarations).
 - Non-virtual functions are not called through the vtable (but through normal symbol resolution) so adding one anywhere in a class does not matter.
 - You may not want to expose private methods to usage outside the unit of compilation. As doing so through declaring them on the pimpl also avoids unneeded indirection (pimpl-&#062;member) that is a straightforward approach.
 - However, using non-member private functions with the pimpl as the first parameter in the anonymous namespace would also be a solution. (needs more &quot;friend&quot; delarations though, unless you declare the members of the pimpl as public (which should not be an issue))
 - Private implementation means private, not protected. While it may be possible (with pain) to make the private implementation protected that is a whole other can of worms and probably requires multiple header files, so protected members have no place in a pimpl (as the pimpl itself should be private, and no child could access the pimpl to get to the protected members).
 - As pimpls are private, they should not have virtual members.
 - For inheritance, each child that wanted to add members would have its own pimpl. The child would use the class through the public part only, and only call public or protected (virtual) methods on the public class. For public (or protected) methods, they are part of the API (and ABI) and their implementation never is. Therefore there is no need to forward their implementation to the pimpl (if optimizing make a local variable containing the pimpl, so you don&#039;t need this-&#062;pimpl-&#062;member, just lPimpl-&#062;member).
 - Forwarding (public / protected) methods to the pimpl is possible but induces errors in case of inheritance.

#4 ) Back pointers.
 - Back pointers are needed for classes with public/protected virtual methods. As any child can only implement them on the public class whenever their functionality is needed, they are called by the implementation in the public parent class (even if they just forward to the pimpl, that&#039;s why you don&#039;t want two methods to chose from, one in the pimpl and one in the public class).
 - Any method on the pimpl that needs to invoke a method on the public class (any virtual method) must do so through a pointer (or pointer wrapper) to the public class.
 - As said by others, there are two ways to get a pointer to the public class. The first one is as a member attribute of the pimpl (with corresponding possible issues regarding move semantics, stale pointers etc.). The second one is as a parameter to any method on the pimpl that needs to (indirectly) call such a virtual method on the public class.
 - If the pimpl does not contain methods, only attributes (which is completely acceptable from the point of view of what a pimpl does, as private nonvirtual methods do not change ABI) then obviously there is no need for back pointers (or related headaches) at all.]]></description>
		<content:encoded><![CDATA[<p>The answers to this question (and the whole pimpl idiom) is strongly related to runtime in-memory characteristics of objects (and vtables).</p>
<p>#1 )Let&#8217;s actually answer #1 as the right answer helps with the other ones. The pimpl idiom is a workaround for the fact that usage of a class by value needs to know the object size. While this helps with recompilation the main purpose is to maintain stable ABI&#8217;s for libraries.</p>
<p>#2 )Best way to express the idiom: &#8220;unique_ptr pimpl;&#8221;. PIMPLTYPE is forward declared in the header, but specified in the source file. </p>
<p>#3 )What should go into the pimpl object:<br />
 &#8211; First of all, private virtual functions make no sense (unless you have friend declarations).<br />
 &#8211; Non-virtual functions are not called through the vtable (but through normal symbol resolution) so adding one anywhere in a class does not matter.<br />
 &#8211; You may not want to expose private methods to usage outside the unit of compilation. As doing so through declaring them on the pimpl also avoids unneeded indirection (pimpl-&gt;member) that is a straightforward approach.<br />
 &#8211; However, using non-member private functions with the pimpl as the first parameter in the anonymous namespace would also be a solution. (needs more &#8220;friend&#8221; delarations though, unless you declare the members of the pimpl as public (which should not be an issue))<br />
 &#8211; Private implementation means private, not protected. While it may be possible (with pain) to make the private implementation protected that is a whole other can of worms and probably requires multiple header files, so protected members have no place in a pimpl (as the pimpl itself should be private, and no child could access the pimpl to get to the protected members).<br />
 &#8211; As pimpls are private, they should not have virtual members.<br />
 &#8211; For inheritance, each child that wanted to add members would have its own pimpl. The child would use the class through the public part only, and only call public or protected (virtual) methods on the public class. For public (or protected) methods, they are part of the API (and ABI) and their implementation never is. Therefore there is no need to forward their implementation to the pimpl (if optimizing make a local variable containing the pimpl, so you don&#8217;t need this-&gt;pimpl-&gt;member, just lPimpl-&gt;member).<br />
 &#8211; Forwarding (public / protected) methods to the pimpl is possible but induces errors in case of inheritance.</p>
<p>#4 ) Back pointers.<br />
 &#8211; Back pointers are needed for classes with public/protected virtual methods. As any child can only implement them on the public class whenever their functionality is needed, they are called by the implementation in the public parent class (even if they just forward to the pimpl, that&#8217;s why you don&#8217;t want two methods to chose from, one in the pimpl and one in the public class).<br />
 &#8211; Any method on the pimpl that needs to invoke a method on the public class (any virtual method) must do so through a pointer (or pointer wrapper) to the public class.<br />
 &#8211; As said by others, there are two ways to get a pointer to the public class. The first one is as a member attribute of the pimpl (with corresponding possible issues regarding move semantics, stale pointers etc.). The second one is as a parameter to any method on the pimpl that needs to (indirectly) call such a virtual method on the public class.<br />
 &#8211; If the pimpl does not contain methods, only attributes (which is completely acceptable from the point of view of what a pimpl does, as private nonvirtual methods do not change ABI) then obviously there is no need for back pointers (or related headaches) at all.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: James Taylor (@james_e_taylor)				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4338</link>
		<dc:creator><![CDATA[James Taylor (@james_e_taylor)]]></dc:creator>
		<pubDate>Sun, 06 Nov 2011 13:18:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4338</guid>
					<description><![CDATA[I haven&#039;t looked at the new language spec so may be talking out of turn here.

In good ol&#039; c++ use of smart pointers for pimpl ran the risk of emitting a &#039;delete p&#039; before the type of p had been defined which is either undefined or defined not to do anything (can&#039;t remember which).  This is often caught at compile time by methods such as boost&#039;s checked_delete().

Has this been fixed in the new C++?]]></description>
		<content:encoded><![CDATA[<p>I haven&#8217;t looked at the new language spec so may be talking out of turn here.</p>
<p>In good ol&#8217; c++ use of smart pointers for pimpl ran the risk of emitting a &#8216;delete p&#8217; before the type of p had been defined which is either undefined or defined not to do anything (can&#8217;t remember which).  This is often caught at compile time by methods such as boost&#8217;s checked_delete().</p>
<p>Has this been fixed in the new C++?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roman Kutlak				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4337</link>
		<dc:creator><![CDATA[Roman Kutlak]]></dc:creator>
		<pubDate>Sun, 06 Nov 2011 09:57:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4337</guid>
					<description><![CDATA[I see what you mean Ben. I was kinda assuming that whenever you involve pointers in your class, you pretty much have to supply your own copy/move constructor/assignment. Thanks for the explanation.]]></description>
		<content:encoded><![CDATA[<p>I see what you mean Ben. I was kinda assuming that whenever you involve pointers in your class, you pretty much have to supply your own copy/move constructor/assignment. Thanks for the explanation.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4333</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Sun, 06 Nov 2011 01:57:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4333</guid>
					<description><![CDATA[And now I go back and see that all of my template brackets have been eaten :(

Hopefully the intent is clear enough without them.]]></description>
		<content:encoded><![CDATA[<p>And now I go back and see that all of my template brackets have been eaten :(</p>
<p>Hopefully the intent is clear enough without them.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4332</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Sun, 06 Nov 2011 01:56:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4332</guid>
					<description><![CDATA[Re: Roman Kutlak
Say I have this setup:
class Outer {
std::unique_ptr pimpl_;
};
class Inner {
   std::weak_ptr backPtr_;
};

Then, I have some code like this:
Outer make_outer()
{
   Outer old_outer;
   return old_outer;
}
//...
current_outer = make_outer();

That code will use the move assignment operator.  When backPtr was initially created, it pointed at old_outer.  After the assignment to current_outer, the backPtr is now pointing at a &quot;dead&quot; object.  This can be fixed by writing your own move constructor and move assignment operator, and having those operations dig into the Inner implementation to &quot;patch up&quot; backPtr, but it is more effort.  You can&#039;t just use the defaults anymore.]]></description>
		<content:encoded><![CDATA[<p>Re: Roman Kutlak<br />
Say I have this setup:<br />
class Outer {<br />
std::unique_ptr pimpl_;<br />
};<br />
class Inner {<br />
   std::weak_ptr backPtr_;<br />
};</p>
<p>Then, I have some code like this:<br />
Outer make_outer()<br />
{<br />
   Outer old_outer;<br />
   return old_outer;<br />
}<br />
//&#8230;<br />
current_outer = make_outer();</p>
<p>That code will use the move assignment operator.  When backPtr was initially created, it pointed at old_outer.  After the assignment to current_outer, the backPtr is now pointing at a &#8220;dead&#8221; object.  This can be fixed by writing your own move constructor and move assignment operator, and having those operations dig into the Inner implementation to &#8220;patch up&#8221; backPtr, but it is more effort.  You can&#8217;t just use the defaults anymore.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roman Kutlak				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4329</link>
		<dc:creator><![CDATA[Roman Kutlak]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 22:03:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4329</guid>
					<description><![CDATA[Hello guys, I am a newbie so this answer is basically just testing my understanding of the concepts. Any comments highly appreciated!

1. My understanding of pimpl was that it&#039;s main purpose is to protect the client from recompilation of the code when you change some class&#039;s internal working. The indirection (pointer to implementation) shields the clients of the class from internal changes. It is not supposed to be a replacement for a pure virtual interface (not implying that it can&#039;t be). 

2. I would use std::unique_ptr.

3. This in turn suggests that private (and protected I guess) members should be in the pimpl and only the public interface can be in the actual class. I think that for the firewall to work as intended the class using the pimpl should provide forwarding functions (for the public part) that call the actual function implemented in the pimpl and the pimpl class should essentially be the intended class (i.e. implement all functions).

I am not sure how this would work with the inheritance. Is it why one would need the back pointer?

4. If you need pointer to the main class, use std::weak_ptr. (Not sure I understood Ben Craig&#039;s argument about &quot;dead&quot; wrapper object - the pimpl will get destroyed when the object dies so this should not happen, right?)]]></description>
		<content:encoded><![CDATA[<p>Hello guys, I am a newbie so this answer is basically just testing my understanding of the concepts. Any comments highly appreciated!</p>
<p>1. My understanding of pimpl was that it&#8217;s main purpose is to protect the client from recompilation of the code when you change some class&#8217;s internal working. The indirection (pointer to implementation) shields the clients of the class from internal changes. It is not supposed to be a replacement for a pure virtual interface (not implying that it can&#8217;t be). </p>
<p>2. I would use std::unique_ptr.</p>
<p>3. This in turn suggests that private (and protected I guess) members should be in the pimpl and only the public interface can be in the actual class. I think that for the firewall to work as intended the class using the pimpl should provide forwarding functions (for the public part) that call the actual function implemented in the pimpl and the pimpl class should essentially be the intended class (i.e. implement all functions).</p>
<p>I am not sure how this would work with the inheritance. Is it why one would need the back pointer?</p>
<p>4. If you need pointer to the main class, use std::weak_ptr. (Not sure I understood Ben Craig&#8217;s argument about &#8220;dead&#8221; wrapper object &#8211; the pimpl will get destroyed when the object dies so this should not happen, right?)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jøger Hansegård (@jogerh)				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4328</link>
		<dc:creator><![CDATA[Jøger Hansegård (@jogerh)]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 22:00:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4328</guid>
					<description><![CDATA[2. I prefer unique_ptr, but that does not compile cleanly on warning level 4 for classes exported from a dll. Quite annoying. 

3. 
a) put all private data (but not functions) into impl;
+ Functions are declared in a single class. You do not have to look in two different classes to find function implementation.
- Need to expose function parameter types in the header file. This may cause you to include more header files than necessary.
- Implementation details are exposed.

b) put all private members into impl;
+ Gives the cleanest class signature, hiding everything that can be hidden.
+ Gives the lowest number of header dependencies in the class header.
- Template function pattern can not be implemented.

c) put all private and protected members into impl;
- Protected members have to be exposed in the class declaration, or they are not accessible by derived types.
(+) Avoids use of protected members.

d) put all private nonvirtual members into impl;
+ See b)
+ Template function pattern can be implemented.

e) put everything into impl, and write the public class itself as only the public interface, each implemented as a simple forwarding function (a handle/body variant).
+ Can be nice if you want to isolate/highlight certain functionality of a class. Implementation of the monitor object can be done by putting the lock acquisition/release in the &quot;forwarding&quot; function, and forward everything else to the pimpl.
- Duplicates every function, produces a lot of code that does not give any value.
- Makes refactoring cumbersome.

As a side note, what made the difference for me was to call the impl object &quot;m&quot;, so that instead of accessing member variables by impl-&#062;foo, i just type m-&#062;foo. Then it looks very similar to how I usually spell member variables: m_foo.]]></description>
		<content:encoded><![CDATA[<p>2. I prefer unique_ptr, but that does not compile cleanly on warning level 4 for classes exported from a dll. Quite annoying. </p>
<p>3.<br />
a) put all private data (but not functions) into impl;<br />
+ Functions are declared in a single class. You do not have to look in two different classes to find function implementation.<br />
&#8211; Need to expose function parameter types in the header file. This may cause you to include more header files than necessary.<br />
&#8211; Implementation details are exposed.</p>
<p>b) put all private members into impl;<br />
+ Gives the cleanest class signature, hiding everything that can be hidden.<br />
+ Gives the lowest number of header dependencies in the class header.<br />
&#8211; Template function pattern can not be implemented.</p>
<p>c) put all private and protected members into impl;<br />
&#8211; Protected members have to be exposed in the class declaration, or they are not accessible by derived types.<br />
(+) Avoids use of protected members.</p>
<p>d) put all private nonvirtual members into impl;<br />
+ See b)<br />
+ Template function pattern can be implemented.</p>
<p>e) put everything into impl, and write the public class itself as only the public interface, each implemented as a simple forwarding function (a handle/body variant).<br />
+ Can be nice if you want to isolate/highlight certain functionality of a class. Implementation of the monitor object can be done by putting the lock acquisition/release in the &#8220;forwarding&#8221; function, and forward everything else to the pimpl.<br />
&#8211; Duplicates every function, produces a lot of code that does not give any value.<br />
&#8211; Makes refactoring cumbersome.</p>
<p>As a side note, what made the difference for me was to call the impl object &#8220;m&#8221;, so that instead of accessing member variables by impl-&gt;foo, i just type m-&gt;foo. Then it looks very similar to how I usually spell member variables: m_foo.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michal Mocny				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4325</link>
		<dc:creator><![CDATA[Michal Mocny]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 13:58:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4325</guid>
					<description><![CDATA[@Dave, @Paul: http://stackoverflow.com/questions/825018/pimpl-idiom-vs-pure-virtual-class-interface

Pure virtual class &quot;Interface&quot; and Pimpl idiom can be similar, but are not quite interchangeable.  For one thing, adapting an existing class to use Pimpl can be done without changing clients.  Also, classes using the Pimpl idiom are proper value_types and don&#039;t need factory methods, etc etc.

Both are useful.]]></description>
		<content:encoded><![CDATA[<p>@Dave, @Paul: <a href="http://stackoverflow.com/questions/825018/pimpl-idiom-vs-pure-virtual-class-interface" rel="nofollow">http://stackoverflow.com/questions/825018/pimpl-idiom-vs-pure-virtual-class-interface</a></p>
<p>Pure virtual class &#8220;Interface&#8221; and Pimpl idiom can be similar, but are not quite interchangeable.  For one thing, adapting an existing class to use Pimpl can be done without changing clients.  Also, classes using the Pimpl idiom are proper value_types and don&#8217;t need factory methods, etc etc.</p>
<p>Both are useful.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul Michalik				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4322</link>
		<dc:creator><![CDATA[Paul Michalik]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 10:42:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4322</guid>
					<description><![CDATA[I am with Dave here: One should decide whether an interface (pure abstract class) or a pimpl/forwarder combination suites better. As a rule of thumb I am using the first whenever binary safety and/or seamless interoperability with other platforms is required. Clearly, some sort of infrastructure (factories, kind of &#039;IUnknown&#039;, etc) is required then. I am using the latter, whenever I just want to hide implementation details inside of a library or inside of a statically linked program, where virtual function calls and factories would be unnecessary overhead.]]></description>
		<content:encoded><![CDATA[<p>I am with Dave here: One should decide whether an interface (pure abstract class) or a pimpl/forwarder combination suites better. As a rule of thumb I am using the first whenever binary safety and/or seamless interoperability with other platforms is required. Clearly, some sort of infrastructure (factories, kind of &#8216;IUnknown&#8217;, etc) is required then. I am using the latter, whenever I just want to hide implementation details inside of a library or inside of a statically linked program, where virtual function calls and factories would be unnecessary overhead.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dave				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4321</link>
		<dc:creator><![CDATA[Dave]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 09:07:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4321</guid>
					<description><![CDATA[Is the pimpl idiom something that should be encouraged? 
Why not use a pure virtual class, as an interface?

I&#039;ve never seen a good use of this idiom, when its needed, its probably a code smell.]]></description>
		<content:encoded><![CDATA[<p>Is the pimpl idiom something that should be encouraged?<br />
Why not use a pure virtual class, as an interface?</p>
<p>I&#8217;ve never seen a good use of this idiom, when its needed, its probably a code smell.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon Buchan				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4320</link>
		<dc:creator><![CDATA[Simon Buchan]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 06:10:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4320</guid>
					<description><![CDATA[I wait for C++11 TR1, which is rumoured(?) to include real modules: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf

Currently, I avoid explicit pimpl, I don&#039;t like the complication. I tend to take in order of feasibility the compile hit, duplicating private member typedefs, casting private members, or using C-style forward def and loose functions.]]></description>
		<content:encoded><![CDATA[<p>I wait for C++11 TR1, which is rumoured(?) to include real modules: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf</a></p>
<p>Currently, I avoid explicit pimpl, I don&#8217;t like the complication. I tend to take in order of feasibility the compile hit, duplicating private member typedefs, casting private members, or using C-style forward def and loose functions.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michal Mocny				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4317</link>
		<dc:creator><![CDATA[Michal Mocny]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 03:14:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4317</guid>
					<description><![CDATA[(2) TLDR; std::unique_ptr

(3) TLDR; I move private non-virtual methods+data.

I don&#039;t use protected members and try to minimize protected methods.
Private non-virtual methods can (should?) be detached and written in an anonymous namespace anyway (there are exceptions) so adding them to the Impl class is just for convenience (so you don&#039;t need to befriend or pass references around).
Any time I use public data, I&#039;m not using pimpl.
I wouldn&#039;t ever put everything into the pimpl -- and when I use handle/body idiom that way, I don&#039;t call it Pimpl since the body is not &quot;mine&quot;.  I would call that proxy or delegate.  (And I do think it would be interesting to have an easier way to implement proxy classes in c++..)

(4) TLDR; I pass back pointer as the first argument to those methods that need it (hopefully rarely).

First off, I don&#039;t waste space storing a back pointer.
Second, and more importantly, I don&#039;t need to write a custom move constructor for my &quot;Handle&quot; classes this way.  If you store back pointer, you have to manage when your Handle moves (yuk) (and if you are using shared_ptr (for whatever reason), this should help too)!
Either way, in my experience it is rare to need back pointers -- unless your classes have grown monolithic ;)]]></description>
		<content:encoded><![CDATA[<p>(2) TLDR; std::unique_ptr</p>
<p>(3) TLDR; I move private non-virtual methods+data.</p>
<p>I don&#8217;t use protected members and try to minimize protected methods.<br />
Private non-virtual methods can (should?) be detached and written in an anonymous namespace anyway (there are exceptions) so adding them to the Impl class is just for convenience (so you don&#8217;t need to befriend or pass references around).<br />
Any time I use public data, I&#8217;m not using pimpl.<br />
I wouldn&#8217;t ever put everything into the pimpl &#8212; and when I use handle/body idiom that way, I don&#8217;t call it Pimpl since the body is not &#8220;mine&#8221;.  I would call that proxy or delegate.  (And I do think it would be interesting to have an easier way to implement proxy classes in c++..)</p>
<p>(4) TLDR; I pass back pointer as the first argument to those methods that need it (hopefully rarely).</p>
<p>First off, I don&#8217;t waste space storing a back pointer.<br />
Second, and more importantly, I don&#8217;t need to write a custom move constructor for my &#8220;Handle&#8221; classes this way.  If you store back pointer, you have to manage when your Handle moves (yuk) (and if you are using shared_ptr (for whatever reason), this should help too)!<br />
Either way, in my experience it is rare to need back pointers &#8212; unless your classes have grown monolithic ;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4315</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 02:22:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4315</guid>
					<description><![CDATA[I am now realizing that back pointers with a std::unique_ptr have the same problem as those with a std::shared_ptr.  The back pointer could point to a moved from, and already destroyed object.  I think that a const std::unique_ptr would be the pointer of choice in situations where you want a back pointer.  I don&#039;t think the language allows a const std::unique_ptr to be moved from.]]></description>
		<content:encoded><![CDATA[<p>I am now realizing that back pointers with a std::unique_ptr have the same problem as those with a std::shared_ptr.  The back pointer could point to a moved from, and already destroyed object.  I think that a const std::unique_ptr would be the pointer of choice in situations where you want a back pointer.  I don&#8217;t think the language allows a const std::unique_ptr to be moved from.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4314</link>
		<dc:creator><![CDATA[Mike]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 00:53:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4314</guid>
					<description><![CDATA[On 3/4, I think there&#039;s a nice dovetailing of hardline pimpl (everything but forwarders in the impl) and what used to be called the &quot;non-virtual interface&quot; idiom. (I haven&#039;t seen it mentioned for years, so maybe it&#039;s called something else now.)

All virtual functions are non-public, and can thus be put into the impl, probably removing any need for a backreference. The public forwarder functions do argument/precondition/postcondition checking, tidily removing the risk of duplication or inconsistency across base and override implementations.

In practice I&#039;m not wild about pimpl, mostly because of the extra allocations involved. In an ideal world, better encapsulation wouldn&#039;t cost you performance.]]></description>
		<content:encoded><![CDATA[<p>On 3/4, I think there&#8217;s a nice dovetailing of hardline pimpl (everything but forwarders in the impl) and what used to be called the &#8220;non-virtual interface&#8221; idiom. (I haven&#8217;t seen it mentioned for years, so maybe it&#8217;s called something else now.)</p>
<p>All virtual functions are non-public, and can thus be put into the impl, probably removing any need for a backreference. The public forwarder functions do argument/precondition/postcondition checking, tidily removing the risk of duplication or inconsistency across base and override implementations.</p>
<p>In practice I&#8217;m not wild about pimpl, mostly because of the extra allocations involved. In an ideal world, better encapsulation wouldn&#8217;t cost you performance.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4313</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 00:17:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4313</guid>
					<description><![CDATA[On further reflection, I am pretty sure you can leave all of the &quot;automatic&quot; copy and move operations alone, and just write an out of line, trivial destructor, like so: 

PublicInterface::~PublicInterface() {}

You need the out of line destructor because the destructor eventually calls delete, and you don&#039;t want to do that on an incomplete type.  You don&#039;t need the move operations because those just twiddle pointers, and that is safe to do on an incomplete type.]]></description>
		<content:encoded><![CDATA[<p>On further reflection, I am pretty sure you can leave all of the &#8220;automatic&#8221; copy and move operations alone, and just write an out of line, trivial destructor, like so: </p>
<p>PublicInterface::~PublicInterface() {}</p>
<p>You need the out of line destructor because the destructor eventually calls delete, and you don&#8217;t want to do that on an incomplete type.  You don&#8217;t need the move operations because those just twiddle pointers, and that is safe to do on an incomplete type.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4312</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Sat, 05 Nov 2011 00:10:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4312</guid>
					<description><![CDATA[Skipping the JG question, Herb already has chapters on that :)

2. I&#039;m not sure how &quot;basic&quot; basic is.  I see two main options.
a) std::unique_ptr
b) std::shared_ptr
Most of my classes would use unique_ptr.  With shared_ptr, I had to &quot;out of line&quot; all of my automatic functions (copy ctor, assignment op).  I suspect I have to do the same thing for unique_ptr, except I would probably delete the copy variants and default the move variants.  So some basic code:

class PublicInterfaceImpl;

class PublicInterface {
public:
   PublicInterface();
   PublicInterface(const PublicInterface &#038;) = delete;
   PublicInterface &#038;operator =(const PublicInterface &#038;) = delete;
   PublicInterface(PublicInterface &#038;&#038;) = default; //maybe? I don&#039;t recall if you can do an =default on the definition in a cpp file.
   PublicInterface &#038;operator =(PublicInterface &#038;&#038;) = default; //same concern here
   ~PublicInterface() = default;
private:
   std::unique_ptr pimpl_;
};
//cpp
class PublicInterfaceImpl { /* ... */ };
PublicInterface::PublicInterface() : pimpl_(new PublicInterfaceImpl) {}


3.  I almost always put everything into the impl except for the public interface, and write a bunch of forwarding functions.  This gives maximum protection.  One downside is the amount of boilerplate.  It also doesn&#039;t play nice with protected members, but I&#039;m not a huge fan of protected members other than destructors.  You have one extra indirection with this scheme, but your compiler should still be able to inline a lot of it away within your cpp.

a) Putting private data into the pimpl is easy and straightforward, and you get &quot;size&quot; protection, but you can still cause recompiles because of new helper private methods.
b) Only putting private stuff in the impl often causes awkward splits in functionality, but you cause fewer recompiles this way.  Also, you can&#039;t get rid of the private virtual functions in the outer / wrapper class.
c) There isn&#039;t a good reason to put protected members in the pimpl
d) The &quot;template&quot; Gang of Four pattern likes having private virtual functions.  One way or another, virtual functions are part of the public interface, even if they aren&#039;t in &quot;public&quot; visibility.  So you can&#039;t get rid of the private virtual functions.  You still get some of the awkward splits that I mentioned in b) above though.
e) This is my preferred solution.

4. When implementing the GoF &quot;template&quot; pattern as a pimpl, you generally need a back pointer to actually call the virtual function.  If my pimpl pointer is a std::unique_ptr, I would use a non-owning raw pointer as my back pointer.  If my pimpl pointer is a std::shared_ptr, I would probably make a sad face.  I can&#039;t use a std::shared_ptr as that creates a cycle.  I don&#039;t want to use a std::weak_ptr or raw pointer, because it could point at a &quot;dead&quot; wrapper object, even when there are other &quot;live&quot; object wrappers..  So yeah, std::shared_ptr pimpls and back pointers probably don&#039;t mix.]]></description>
		<content:encoded><![CDATA[<p>Skipping the JG question, Herb already has chapters on that :)</p>
<p>2. I&#8217;m not sure how &#8220;basic&#8221; basic is.  I see two main options.<br />
a) std::unique_ptr<br />
b) std::shared_ptr<br />
Most of my classes would use unique_ptr.  With shared_ptr, I had to &#8220;out of line&#8221; all of my automatic functions (copy ctor, assignment op).  I suspect I have to do the same thing for unique_ptr, except I would probably delete the copy variants and default the move variants.  So some basic code:</p>
<p>class PublicInterfaceImpl;</p>
<p>class PublicInterface {<br />
public:<br />
   PublicInterface();<br />
   PublicInterface(const PublicInterface &amp;) = delete;<br />
   PublicInterface &amp;operator =(const PublicInterface &amp;) = delete;<br />
   PublicInterface(PublicInterface &amp;&amp;) = default; //maybe? I don&#8217;t recall if you can do an =default on the definition in a cpp file.<br />
   PublicInterface &amp;operator =(PublicInterface &amp;&amp;) = default; //same concern here<br />
   ~PublicInterface() = default;<br />
private:<br />
   std::unique_ptr pimpl_;<br />
};<br />
//cpp<br />
class PublicInterfaceImpl { /* &#8230; */ };<br />
PublicInterface::PublicInterface() : pimpl_(new PublicInterfaceImpl) {}</p>
<p>3.  I almost always put everything into the impl except for the public interface, and write a bunch of forwarding functions.  This gives maximum protection.  One downside is the amount of boilerplate.  It also doesn&#8217;t play nice with protected members, but I&#8217;m not a huge fan of protected members other than destructors.  You have one extra indirection with this scheme, but your compiler should still be able to inline a lot of it away within your cpp.</p>
<p>a) Putting private data into the pimpl is easy and straightforward, and you get &#8220;size&#8221; protection, but you can still cause recompiles because of new helper private methods.<br />
b) Only putting private stuff in the impl often causes awkward splits in functionality, but you cause fewer recompiles this way.  Also, you can&#8217;t get rid of the private virtual functions in the outer / wrapper class.<br />
c) There isn&#8217;t a good reason to put protected members in the pimpl<br />
d) The &#8220;template&#8221; Gang of Four pattern likes having private virtual functions.  One way or another, virtual functions are part of the public interface, even if they aren&#8217;t in &#8220;public&#8221; visibility.  So you can&#8217;t get rid of the private virtual functions.  You still get some of the awkward splits that I mentioned in b) above though.<br />
e) This is my preferred solution.</p>
<p>4. When implementing the GoF &#8220;template&#8221; pattern as a pimpl, you generally need a back pointer to actually call the virtual function.  If my pimpl pointer is a std::unique_ptr, I would use a non-owning raw pointer as my back pointer.  If my pimpl pointer is a std::shared_ptr, I would probably make a sad face.  I can&#8217;t use a std::shared_ptr as that creates a cycle.  I don&#8217;t want to use a std::weak_ptr or raw pointer, because it could point at a &#8220;dead&#8221; wrapper object, even when there are other &#8220;live&#8221; object wrappers..  So yeah, std::shared_ptr pimpls and back pointers probably don&#8217;t mix.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alf P. Steinbach				</title>
				<link>https://herbsutter.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4311</link>
		<dc:creator><![CDATA[Alf P. Steinbach]]></dc:creator>
		<pubDate>Fri, 04 Nov 2011 23:16:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2011/11/04/gotw-100-compilation-firewalls/#comment-4311</guid>
					<description><![CDATA[The name &quot;compilation firewall&quot; tells you that it has to do with tucking away some ugly things, such as the zillions of macros in Microsoft&#039;s , or say a C header that uses the name &quot;class&quot;. Thus what to put in the implementation, while often correlating with the public/private distinction, is fundamentally an independent issue. In the implementation class, put anything that depends on (for example) the ugly header, then add whatever&#039;s natural.

By the way, nice that you&#039;re doing GOTW&#039;s again, and in particular this one; there&#039;s less chance of recommending &quot;auto_ptr&quot; this time since it&#039;s now deprecated. :-)

Instead of a smart pointer I&#039;d just make the visible class non-copyable, and implement constructor and destructor.


Cheers &#038; hth.

- Alf]]></description>
		<content:encoded><![CDATA[<p>The name &#8220;compilation firewall&#8221; tells you that it has to do with tucking away some ugly things, such as the zillions of macros in Microsoft&#8217;s , or say a C header that uses the name &#8220;class&#8221;. Thus what to put in the implementation, while often correlating with the public/private distinction, is fundamentally an independent issue. In the implementation class, put anything that depends on (for example) the ugly header, then add whatever&#8217;s natural.</p>
<p>By the way, nice that you&#8217;re doing GOTW&#8217;s again, and in particular this one; there&#8217;s less chance of recommending &#8220;auto_ptr&#8221; this time since it&#8217;s now deprecated. :-)</p>
<p>Instead of a smart pointer I&#8217;d just make the visible class non-copyable, and implement constructor and destructor.</p>
<p>Cheers &amp; hth.</p>
<p>&#8211; Alf</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
