<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Trip report: Fall 2015 ISO C++ standards meeting	</title>
	<atom:link href="https://herbsutter.com/2015/10/25/2568/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2015/10/25/2568/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Trip report: Summer ISO C++ standards meeting (Oulu) &#124; Sutter’s Mill				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-39290</link>
		<dc:creator><![CDATA[Trip report: Summer ISO C++ standards meeting (Oulu) &#124; Sutter’s Mill]]></dc:creator>
		<pubDate>Thu, 30 Jun 2016 23:17:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-39290</guid>
					<description><![CDATA[[&#8230;] already added to C++17). The new std::variant is a type-safe union; for more background see also my fall meeting trip report. Here’s an example adapted from the paper that shows how you can use [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] already added to C++17). The new std::variant is a type-safe union; for more background see also my fall meeting trip report. Here’s an example adapted from the paper that shows how you can use [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-38548</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Tue, 29 Dec 2015 14:16:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-38548</guid>
					<description><![CDATA[I was looking at P0144, the structured bindings proposal. I was thinking that a great extension to this would be allowing the user to unbind a template parameter pack:

template
auto func(Args ...args)
{
   auto {x, y, z} = args...;
   auto {u, v, w} = modifier(args)...; //Can unpack over arbitrary expressions.
}

This would be exceptionally useful in template code. If there are more arguments in the binding than the parameter pack, you get a compile error. But if there are more arguments in the pack than the binding, their expressions are evaluated, but are simply discarded as if they were returned from a function without being used (so [[nodiscard]] will still complain).]]></description>
		<content:encoded><![CDATA[<p>I was looking at P0144, the structured bindings proposal. I was thinking that a great extension to this would be allowing the user to unbind a template parameter pack:</p>
<p>template<br />
auto func(Args &#8230;args)<br />
{<br />
   auto {x, y, z} = args&#8230;;<br />
   auto {u, v, w} = modifier(args)&#8230;; //Can unpack over arbitrary expressions.<br />
}</p>
<p>This would be exceptionally useful in template code. If there are more arguments in the binding than the parameter pack, you get a compile error. But if there are more arguments in the pack than the binding, their expressions are evaluated, but are simply discarded as if they were returned from a function without being used (so [[nodiscard]] will still complain).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ Annotated: Fall 2015 &#124; JetBrains CLion Blog				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-38016</link>
		<dc:creator><![CDATA[C++ Annotated: Fall 2015 &#124; JetBrains CLion Blog]]></dc:creator>
		<pubDate>Tue, 01 Dec 2015 15:53:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-38016</guid>
					<description><![CDATA[[&#8230;] Stroustrup and Herb Sutter published detailed reports about Fall 2015 ISO C++ standards [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Stroustrup and Herb Sutter published detailed reports about Fall 2015 ISO C++ standards [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ Annotated: Fall 2015 &#124; ReSharper C++ Blog				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-38015</link>
		<dc:creator><![CDATA[C++ Annotated: Fall 2015 &#124; ReSharper C++ Blog]]></dc:creator>
		<pubDate>Tue, 01 Dec 2015 15:52:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-38015</guid>
					<description><![CDATA[[&#8230;] Stroustrup and Herb Sutter published detailed reports about Fall 2015 ISO C++ standards [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Stroustrup and Herb Sutter published detailed reports about Fall 2015 ISO C++ standards [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tony Van Eerd				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-37893</link>
		<dc:creator><![CDATA[Tony Van Eerd]]></dc:creator>
		<pubDate>Wed, 28 Oct 2015 16:16:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-37893</guid>
					<description><![CDATA[For variant, eg [code]variant&#060;int, string&#062;[/code] note that functions like [code]get&#060;int&#062;[/code] already needed to check if the discriminant was an int.  And throw if it was a string.  Now it throws if it is a string or invalid. So no extra code.  And visitation needs to check the discriminant as well, so no real extra code there either.
As for &quot;separate tag value for invalid state internally&quot;, assume the variant has uses an int (or enum) as the discriminant of which type is currently set (ie 0 means int, 1 means string for the above variant). -1 can mean invalid.]]></description>
		<content:encoded><![CDATA[<p>For variant, eg </p>
<pre class="brush: plain; title: ; notranslate">variant&lt;int, string&gt;</pre>
<p> note that functions like </p>
<pre class="brush: plain; title: ; notranslate">get&lt;int&gt;</pre>
<p> already needed to check if the discriminant was an int.  And throw if it was a string.  Now it throws if it is a string or invalid. So no extra code.  And visitation needs to check the discriminant as well, so no real extra code there either.<br />
As for &#8220;separate tag value for invalid state internally&#8221;, assume the variant has uses an int (or enum) as the discriminant of which type is currently set (ie 0 means int, 1 means string for the above variant). -1 can mean invalid.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ilya Popov				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-37887</link>
		<dc:creator><![CDATA[Ilya Popov]]></dc:creator>
		<pubDate>Mon, 26 Oct 2015 09:38:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-37887</guid>
					<description><![CDATA[Does it mean there will be a separate tag value for &quot;invalid&quot; state internally?]]></description>
		<content:encoded><![CDATA[<p>Does it mean there will be a separate tag value for &#8220;invalid&#8221; state internally?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-37883</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 26 Oct 2015 02:36:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-37883</guid>
					<description><![CDATA[@jmckesson: &quot;Modules phase 1&quot; is essentially Gaby&#039;s approach, and &quot;phase 2&quot; is essentially adding support for exporting macros. As for variant, &quot;zero overhead&quot; means at run time -- no extra space consumed, and no extra code executed -- compared to writing it (correctly) by hand using a raw union and a discriminant tag.]]></description>
		<content:encoded><![CDATA[<p>@jmckesson: &#8220;Modules phase 1&#8221; is essentially Gaby&#8217;s approach, and &#8220;phase 2&#8221; is essentially adding support for exporting macros. As for variant, &#8220;zero overhead&#8221; means at run time &#8212; no extra space consumed, and no extra code executed &#8212; compared to writing it (correctly) by hand using a raw union and a discriminant tag.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ZaldronGG				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-37882</link>
		<dc:creator><![CDATA[ZaldronGG]]></dc:creator>
		<pubDate>Mon, 26 Oct 2015 01:57:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-37882</guid>
					<description><![CDATA[jmckesson, why check it? If the variant invariants&#039; are not met, chance&#039;s are your function doesn&#039;t know enough to  act accordingly, and should just let it throw.]]></description>
		<content:encoded><![CDATA[<p>jmckesson, why check it? If the variant invariants&#8217; are not met, chance&#8217;s are your function doesn&#8217;t know enough to  act accordingly, and should just let it throw.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2015/10/25/2568/#comment-37881</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Sun, 25 Oct 2015 23:50:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2568#comment-37881</guid>
					<description><![CDATA[&#062; Modules has reached a milestone: design agreement! This was done by separating “phase 1” and “phase 2” of modules

What are the two phases exactly? Is &quot;phase 1&quot; going to be what Gabriel Dos Reis presented at CppCon2015? Because if we get that, I&#039;m not sure what could happen in &quot;phase 2&quot;. And if &quot;phase 1&quot; doesn&#039;t include all of those elements, I don&#039;t know how useful that phase could be.

&#062; attempting to access the invalid variant causes defined behavior, such as throwing an exception, instead of undefined behavior.

Does this not mean that every function that uses the variant must check its validity? How exactly is that &quot;zero overhead&quot;?

Granted, I don&#039;t care all that much, as long as we have a never-empty variant that can get through the committee...]]></description>
		<content:encoded><![CDATA[<p>&gt; Modules has reached a milestone: design agreement! This was done by separating “phase 1” and “phase 2” of modules</p>
<p>What are the two phases exactly? Is &#8220;phase 1&#8221; going to be what Gabriel Dos Reis presented at CppCon2015? Because if we get that, I&#8217;m not sure what could happen in &#8220;phase 2&#8221;. And if &#8220;phase 1&#8221; doesn&#8217;t include all of those elements, I don&#8217;t know how useful that phase could be.</p>
<p>&gt; attempting to access the invalid variant causes defined behavior, such as throwing an exception, instead of undefined behavior.</p>
<p>Does this not mean that every function that uses the variant must check its validity? How exactly is that &#8220;zero overhead&#8221;?</p>
<p>Granted, I don&#8217;t care all that much, as long as we have a never-empty variant that can get through the committee&#8230;</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
