<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Reader Q&#038;A: auto and for loop index variables	</title>
	<atom:link href="https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Greg Marr				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-37949</link>
		<dc:creator><![CDATA[Greg Marr]]></dc:creator>
		<pubDate>Thu, 12 Nov 2015 16:46:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-37949</guid>
					<description><![CDATA[Adam, even better than both in that it doesn&#039;t introduce variables into the outer scope:

[code]
for (decltype(object.size()) i = 0, n = object.size(); i &#060; n; ++i)
[/code]

That is, unless the loop body does something that can change the size of object, in which case you do need your second form, and you have to live with any extra size() calls.]]></description>
		<content:encoded><![CDATA[<p>Adam, even better than both in that it doesn&#8217;t introduce variables into the outer scope:</p>
<pre class="brush: plain; title: ; notranslate">
for (decltype(object.size()) i = 0, n = object.size(); i &lt; n; ++i)
</pre>
<p>That is, unless the loop body does something that can change the size of object, in which case you do need your second form, and you have to live with any extra size() calls.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: adam915				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-37937</link>
		<dc:creator><![CDATA[adam915]]></dc:creator>
		<pubDate>Mon, 09 Nov 2015 13:10:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-37937</guid>
					<description><![CDATA[Hi all, I&#039;m not sure about insert object.size() (or any other function) in for statement is good solution, i think the

[code]auto object_size = object.size();
decltype(object_size) i = 0;
for (i = 0; i &#060; object_size; i++) { … }[/code]

it&#039;s better than

[code]for (decltype(object.size()) i = 0; i &#060; object.size(); i++) { … } [/code]

because we don&#039;t call object.size() function in every iteration (in second example, it&#039;s called twice)]]></description>
		<content:encoded><![CDATA[<p>Hi all, I&#8217;m not sure about insert object.size() (or any other function) in for statement is good solution, i think the</p>
<pre class="brush: plain; title: ; notranslate">auto object_size = object.size();
decltype(object_size) i = 0;
for (i = 0; i &lt; object_size; i++) { … }</pre>
<p>it&#8217;s better than</p>
<pre class="brush: plain; title: ; notranslate">for (decltype(object.size()) i = 0; i &lt; object.size(); i++) { … } </pre>
<p>because we don&#8217;t call object.size() function in every iteration (in second example, it&#8217;s called twice)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Satish				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36926</link>
		<dc:creator><![CDATA[Satish]]></dc:creator>
		<pubDate>Tue, 14 Apr 2015 05:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36926</guid>
					<description><![CDATA[Should be able to use an STL alogrithm if possible?.]]></description>
		<content:encoded><![CDATA[<p>Should be able to use an STL alogrithm if possible?.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: buttink				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36792</link>
		<dc:creator><![CDATA[buttink]]></dc:creator>
		<pubDate>Mon, 30 Mar 2015 21:17:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36792</guid>
					<description><![CDATA[I want the nifty way python does it
[code]
for (tie(i, elem) : enumerate(list)) {
   ...
}
[/code]
Just need to be able to define variables in tie.]]></description>
		<content:encoded><![CDATA[<p>I want the nifty way python does it</p>
<pre class="brush: plain; title: ; notranslate">
for (tie(i, elem) : enumerate(list)) {
   ...
}
</pre>
<p>Just need to be able to define variables in tie.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daniel Nyström				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36567</link>
		<dc:creator><![CDATA[Daniel Nyström]]></dc:creator>
		<pubDate>Sat, 07 Mar 2015 12:20:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36567</guid>
					<description><![CDATA[I would actually like to propose a breaking change; I think
[code]
auto i = 0;
[/code]
should not compile. The reason is, &lt;code&gt;0&lt;/code&gt; is a valid constant for all signed integral types, all unsigned integral types, all floating-point types and all pointer types. So the type really can&#039;t be deduced. This could lead to code like
[code]
auto i=0, sz=77u;
[/code]
working, since &lt;code&gt;i&lt;/code&gt; don&#039;t participate in deduction, and the rest agree]]></description>
		<content:encoded><![CDATA[<p>I would actually like to propose a breaking change; I think</p>
<pre class="brush: plain; title: ; notranslate">
auto i = 0;
</pre>
<p>should not compile. The reason is, <code>0</code> is a valid constant for all signed integral types, all unsigned integral types, all floating-point types and all pointer types. So the type really can&#8217;t be deduced. This could lead to code like</p>
<pre class="brush: plain; title: ; notranslate">
auto i=0, sz=77u;
</pre>
<p>working, since <code>i</code> don&#8217;t participate in deduction, and the rest agree</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jonas Minnberg				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36373</link>
		<dc:creator><![CDATA[Jonas Minnberg]]></dc:creator>
		<pubDate>Mon, 16 Feb 2015 15:15:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36373</guid>
					<description><![CDATA[I am going to go against the tide here and say that I *don&#039;t* want i to become size_t.

For a counting for loop, especially one that goes from 0, there is never any reason to use an unsigned value, and since I try to use signed integers in most other places, this can lead to having to cast the index back to signed inside the loop.

So a nice benefit of creating an iterator factory function to use in a for-each loop is that it can actually convert the argument to a signed 32 or 64 bit integer (and for correctness sake throw an exception if the argument is too large to fit).]]></description>
		<content:encoded><![CDATA[<p>I am going to go against the tide here and say that I *don&#8217;t* want i to become size_t.</p>
<p>For a counting for loop, especially one that goes from 0, there is never any reason to use an unsigned value, and since I try to use signed integers in most other places, this can lead to having to cast the index back to signed inside the loop.</p>
<p>So a nice benefit of creating an iterator factory function to use in a for-each loop is that it can actually convert the argument to a signed 32 or 64 bit integer (and for correctness sake throw an exception if the argument is too large to fit).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: litbisme				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36320</link>
		<dc:creator><![CDATA[litbisme]]></dc:creator>
		<pubDate>Fri, 13 Feb 2015 08:54:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36320</guid>
					<description><![CDATA[This would be trivial to do with proposal https://groups.google.com/a/isocpp.org/d/msg/std-proposals/oaEAiyoreV8/ELm56JGRSWIJ :)]]></description>
		<content:encoded><![CDATA[<p>This would be trivial to do with proposal <a href="https://groups.google.com/a/isocpp.org/d/msg/std-proposals/oaEAiyoreV8/ELm56JGRSWIJ" rel="nofollow">https://groups.google.com/a/isocpp.org/d/msg/std-proposals/oaEAiyoreV8/ELm56JGRSWIJ</a> :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Standback				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36243</link>
		<dc:creator><![CDATA[Standback]]></dc:creator>
		<pubDate>Sun, 08 Feb 2015 07:30:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36243</guid>
					<description><![CDATA[A lot of the answers here seem to me to be needlessly complex. 
If our concern is readability and newbie-friendliness, then all you need to do is set the tricky-ish definition on its own, so it&#039;s clear:

[code]
	auto mySize = someObject.size();
	decltype(mySize) i; // index looping from 0 to mySize
	for (i=0; i &#060; mySize; i++) { … }
[/code]

I don&#039;t see this as hurting our pro-auto-ness; decltype isn&#039;t any less automatic or flexible than auto is. Our type is *still* deduced at compile-time according to the values it depends on, rather than being hard-coded. But you could also use the explicitly type initializer idiom:

[code]
	auto mySize = someObject.size();
	auto i = static_cast&#060;decltype(mySize)&#062;(0); // index looping from 0 to mySize
	for (i=0; i &#060; mySize; i++) { … }
[/code]

I this is maybe a little less readable for novices, but the point is that the only conceivably-confusing part is on its own, doing *only* the job of declaration. That makes it easy to understand - you don&#039;t need to understand the whole loop; and the loop (in and of itself) is still perfectly clear. All that&#039;s happening is that the c++11-newbie says &quot;Huh, a variable is being declared here and I don&#039;t really understand its type or why it&#039;s so complicated&quot;; and then they look it up and have a clear, obvious answer. 

(This is also why I left &quot;i=0&quot; in, even though I could rely on initialization at declaration - I want the loop to be crystal-clear, even if the type of the index variable isn&#039;t.)]]></description>
		<content:encoded><![CDATA[<p>A lot of the answers here seem to me to be needlessly complex.<br />
If our concern is readability and newbie-friendliness, then all you need to do is set the tricky-ish definition on its own, so it&#8217;s clear:</p>
<pre class="brush: plain; title: ; notranslate">
	auto mySize = someObject.size();
	decltype(mySize) i; // index looping from 0 to mySize
	for (i=0; i &lt; mySize; i++) { … }
</pre>
<p>I don&#8217;t see this as hurting our pro-auto-ness; decltype isn&#8217;t any less automatic or flexible than auto is. Our type is *still* deduced at compile-time according to the values it depends on, rather than being hard-coded. But you could also use the explicitly type initializer idiom:</p>
<pre class="brush: plain; title: ; notranslate">
	auto mySize = someObject.size();
	auto i = static_cast&lt;decltype(mySize)&gt;(0); // index looping from 0 to mySize
	for (i=0; i &lt; mySize; i++) { … }
</pre>
<p>I this is maybe a little less readable for novices, but the point is that the only conceivably-confusing part is on its own, doing *only* the job of declaration. That makes it easy to understand &#8211; you don&#8217;t need to understand the whole loop; and the loop (in and of itself) is still perfectly clear. All that&#8217;s happening is that the c++11-newbie says &#8220;Huh, a variable is being declared here and I don&#8217;t really understand its type or why it&#8217;s so complicated&#8221;; and then they look it up and have a clear, obvious answer. </p>
<p>(This is also why I left &#8220;i=0&#8221; in, even though I could rely on initialization at declaration &#8211; I want the loop to be crystal-clear, even if the type of the index variable isn&#8217;t.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: AMH News				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36242</link>
		<dc:creator><![CDATA[AMH News]]></dc:creator>
		<pubDate>Sun, 08 Feb 2015 07:01:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36242</guid>
					<description><![CDATA[yeah auto is better make it simple !]]></description>
		<content:encoded><![CDATA[<p>yeah auto is better make it simple !</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Advances in electron microscopy reveal secrets of HIV and other viruses - Trendingnewsz.com				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36155</link>
		<dc:creator><![CDATA[Advances in electron microscopy reveal secrets of HIV and other viruses - Trendingnewsz.com]]></dc:creator>
		<pubDate>Wed, 04 Feb 2015 17:53:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36155</guid>
					<description><![CDATA[[&#8230;] visualization of the V2 variable loop of the HIV Env protein (red) puts it at the bottom of the structure. (Cheng lab) New visualization [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] visualization of the V2 variable loop of the HIV Env protein (red) puts it at the bottom of the structure. (Cheng lab) New visualization [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Etheria				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36047</link>
		<dc:creator><![CDATA[Etheria]]></dc:creator>
		<pubDate>Sat, 31 Jan 2015 20:45:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36047</guid>
					<description><![CDATA[That works. You could also multiply with 0:
for(auto mySize = someObject.size(), i = mySize * 0; i &#060; mySize; i++) …]]></description>
		<content:encoded><![CDATA[<p>That works. You could also multiply with 0:<br />
for(auto mySize = someObject.size(), i = mySize * 0; i &lt; mySize; i++) …</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johannes Schaub				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36044</link>
		<dc:creator><![CDATA[Johannes Schaub]]></dc:creator>
		<pubDate>Sat, 31 Jan 2015 15:39:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36044</guid>
					<description><![CDATA[I wonder whether this is acceptable?

    for(auto mySize = someObject.size(), i = mySize - mySize; i &#060; mySize; i++) ...]]></description>
		<content:encoded><![CDATA[<p>I wonder whether this is acceptable?</p>
<p>    for(auto mySize = someObject.size(), i = mySize &#8211; mySize; i &lt; mySize; i++) &#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: p sarkar				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-36023</link>
		<dc:creator><![CDATA[p sarkar]]></dc:creator>
		<pubDate>Fri, 30 Jan 2015 18:57:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-36023</guid>
					<description><![CDATA[Thanks, for catching that Joe. The above versions don&#039;t work indeed (segfaults.) But the following works:
[code]
for (auto i = someObject.size(); i &#062; 0; --i) {
  // use i-1 as the index
}
// Or the bit more cryptic:
for (auto i = someObject.size(); i-- &#062; 0; ) {
  // Use i
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Thanks, for catching that Joe. The above versions don&#8217;t work indeed (segfaults.) But the following works:</p>
<pre class="brush: plain; title: ; notranslate">
for (auto i = someObject.size(); i &gt; 0; --i) {
  // use i-1 as the index
}
// Or the bit more cryptic:
for (auto i = someObject.size(); i-- &gt; 0; ) {
  // Use i
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joe				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35996</link>
		<dc:creator><![CDATA[Joe]]></dc:creator>
		<pubDate>Fri, 30 Jan 2015 02:45:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35996</guid>
					<description><![CDATA[p sarkar, your code will result in an endless loop, at least for standard containers like vectors and strings.   std::size_t is unsigned, so it is never less than 0.]]></description>
		<content:encoded><![CDATA[<p>p sarkar, your code will result in an endless loop, at least for standard containers like vectors and strings.   std::size_t is unsigned, so it is never less than 0.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: p sarkar				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35992</link>
		<dc:creator><![CDATA[p sarkar]]></dc:creator>
		<pubDate>Fri, 30 Jan 2015 00:43:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35992</guid>
					<description><![CDATA[Would love range based solutions. If order of evaluation does not matter, one way to side-step the issue is:
[code]
for (auto i = someObject.size() - 1; i &#062;= 0; --i) { ... }
for (auto i = someObject.size(); --i &#062;= 0; ) { ... }
[/code]]]></description>
		<content:encoded><![CDATA[<p>Would love range based solutions. If order of evaluation does not matter, one way to side-step the issue is:</p>
<pre class="brush: plain; title: ; notranslate">
for (auto i = someObject.size() - 1; i &gt;= 0; --i) { ... }
for (auto i = someObject.size(); --i &gt;= 0; ) { ... }
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: diehertz				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35980</link>
		<dc:creator><![CDATA[diehertz]]></dc:creator>
		<pubDate>Thu, 29 Jan 2015 18:37:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35980</guid>
					<description><![CDATA[Somehow my link didn&#039;t make it into my reply, another shot:
https://gist.github.com/DieHertz/f83b33ffe33e1c07abfc]]></description>
		<content:encoded><![CDATA[<p>Somehow my link didn&#8217;t make it into my reply, another shot:<br />
<script src="https://gist.github.com/DieHertz/f83b33ffe33e1c07abfc.js"></script></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: diehertz				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35975</link>
		<dc:creator><![CDATA[diehertz]]></dc:creator>
		<pubDate>Thu, 29 Jan 2015 15:43:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35975</guid>
					<description><![CDATA[I use such code for the primary reason that we compile with -Wall, and signed/unsigned comparisons won&#039;t let me get away with auto i = 0 :-)
Besides, it looks much more attractive, and compiles into optimal code just like hand-written loop.
https://gist.github.com/DieHertz/f83b33ffe33e1c07abfc]]></description>
		<content:encoded><![CDATA[<p>I use such code for the primary reason that we compile with -Wall, and signed/unsigned comparisons won&#8217;t let me get away with auto i = 0 :-)<br />
Besides, it looks much more attractive, and compiles into optimal code just like hand-written loop.<br />
<script src="https://gist.github.com/DieHertz/f83b33ffe33e1c07abfc.js"></script></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Непросмотренные ссылки – 11 &#124; Откомпилируй Это				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35779</link>
		<dc:creator><![CDATA[Непросмотренные ссылки – 11 &#124; Откомпилируй Это]]></dc:creator>
		<pubDate>Thu, 22 Jan 2015 07:17:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35779</guid>
					<description><![CDATA[[&#8230;] Reader Q&#038;A: auto and for loop index variables [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Reader Q&amp;A: auto and for loop index variables [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gene Bushuyev				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35690</link>
		<dc:creator><![CDATA[Gene Bushuyev]]></dc:creator>
		<pubDate>Mon, 19 Jan 2015 19:44:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35690</guid>
					<description><![CDATA[Ranges is a good idea in general, but they wouldn&#039;t resolve this issue, they would just provide a superficially different syntax. 
The issue here is the type conversion, and it&#039;s int 0 that should be converted to the size_type, not the other argument to int. And unless we decide on some construct that always casts the first argument to the second argument type (might not be a great idea) we have to specify the type explicitly. Thus, the obvious solutions are still the most readable and correct ones:
[code]
for(size_type i = 0, size = someObject.size(); i &#060; size; ++i)  ...
for(auto i = (size_type)0, size = someObject.size(); i &#060; size; ++i)  ...
[/code]
And if size_type is something frequently found in the code, then creating a user-defined literal will make it shorter, and easier to read:
[code]
size_type operator&#034;&#034; _sz(unsigned long long i) { return size_type(i); }
for(auto i = 0_sz, size = someObject.size(); i &#060; size; ++i)  ...
[/code]
Also, if 0 is frequently converted to size_type, it makes sense to define a constant of that type:
[code]
const size_type zero = (size_type)0;
for(auto i = zero, size = someObject.size(); i &#060; size; ++i)  ...
[/code]]]></description>
		<content:encoded><![CDATA[<p>Ranges is a good idea in general, but they wouldn&#8217;t resolve this issue, they would just provide a superficially different syntax.<br />
The issue here is the type conversion, and it&#8217;s int 0 that should be converted to the size_type, not the other argument to int. And unless we decide on some construct that always casts the first argument to the second argument type (might not be a great idea) we have to specify the type explicitly. Thus, the obvious solutions are still the most readable and correct ones:</p>
<pre class="brush: plain; title: ; notranslate">
for(size_type i = 0, size = someObject.size(); i &lt; size; ++i)  ...
for(auto i = (size_type)0, size = someObject.size(); i &lt; size; ++i)  ...
</pre>
<p>And if size_type is something frequently found in the code, then creating a user-defined literal will make it shorter, and easier to read:</p>
<pre class="brush: plain; title: ; notranslate">
size_type operator&quot;&quot; _sz(unsigned long long i) { return size_type(i); }
for(auto i = 0_sz, size = someObject.size(); i &lt; size; ++i)  ...
</pre>
<p>Also, if 0 is frequently converted to size_type, it makes sense to define a constant of that type:</p>
<pre class="brush: plain; title: ; notranslate">
const size_type zero = (size_type)0;
for(auto i = zero, size = someObject.size(); i &lt; size; ++i)  ...
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Steve				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35687</link>
		<dc:creator><![CDATA[Steve]]></dc:creator>
		<pubDate>Mon, 19 Jan 2015 18:00:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35687</guid>
					<description><![CDATA[How about

[code]
    std::vector&#060; int &#062; v { 0, 1, 2, 3, 4 };

    for ( auto&#038;&#038; t = v.size(), i = 0*t; i &#060; t; ++i )
    {
        std::cout &#060;&#060; i &#060;&#060; &#034;\n&#034;;
    }
[/code]]]></description>
		<content:encoded><![CDATA[<p>How about</p>
<pre class="brush: plain; title: ; notranslate">
    std::vector&lt; int &gt; v { 0, 1, 2, 3, 4 };

    for ( auto&amp;&amp; t = v.size(), i = 0*t; i &lt; t; ++i )
    {
        std::cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;
    }
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon Ferquel				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35673</link>
		<dc:creator><![CDATA[Simon Ferquel]]></dc:creator>
		<pubDate>Mon, 19 Jan 2015 08:41:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35673</guid>
					<description><![CDATA[One thing worth noting also, is that the for-range-loop construct does not require real iterators (ie: it does not check any iterator traits, and only use a very small part of the public signature of a full-fledged iterator). 
For a type to work with the for range loop, you only need to have a [code]begin(MyType&#038;)[/code] and [code]end(MyType&#038;)[/code] returning an object supporting the following members: 
[code]
T operator*()const; // return the value currently pointed to by the iterator
void operator++(); // move the iterator to the next value
bool operator!=(const TIterator&#038;) const; // compare the iterator to another one (used to check if we reached the end of the loop
[/code]
So it is really easy to extend existing components to support a for-range-loop construct.]]></description>
		<content:encoded><![CDATA[<p>One thing worth noting also, is that the for-range-loop construct does not require real iterators (ie: it does not check any iterator traits, and only use a very small part of the public signature of a full-fledged iterator).<br />
For a type to work with the for range loop, you only need to have a </p>
<pre class="brush: plain; title: ; notranslate">begin(MyType&amp;)</pre>
<p> and </p>
<pre class="brush: plain; title: ; notranslate">end(MyType&amp;)</pre>
<p> returning an object supporting the following members: </p>
<pre class="brush: plain; title: ; notranslate">
T operator*()const; // return the value currently pointed to by the iterator
void operator++(); // move the iterator to the next value
bool operator!=(const TIterator&amp;) const; // compare the iterator to another one (used to check if we reached the end of the loop
</pre>
<p>So it is really easy to extend existing components to support a for-range-loop construct.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joe				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35656</link>
		<dc:creator><![CDATA[Joe]]></dc:creator>
		<pubDate>Mon, 19 Jan 2015 03:03:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35656</guid>
					<description><![CDATA[It might be overkill, but one option is to define an inline function that returns a 0 of the correct type for the container.

[code]
template &#060;class C&#062;
auto constexpr zero(const C &#038;c) -&#062; decltype(size(c)) {
    return 0;
}
[/code]

Then user code could look like

[code]
for (auto i = zero(myContainer); i &#060; size(myContainer); ++i) {
   /// Do whatever
}
[/code]

An possible alternative name for this function is firstIndex.]]></description>
		<content:encoded><![CDATA[<p>It might be overkill, but one option is to define an inline function that returns a 0 of the correct type for the container.</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;class C&gt;
auto constexpr zero(const C &amp;c) -&gt; decltype(size(c)) {
    return 0;
}
</pre>
<p>Then user code could look like</p>
<pre class="brush: plain; title: ; notranslate">
for (auto i = zero(myContainer); i &lt; size(myContainer); ++i) {
   /// Do whatever
}
</pre>
<p>An possible alternative name for this function is firstIndex.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35562</link>
		<dc:creator><![CDATA[Martin]]></dc:creator>
		<pubDate>Sat, 17 Jan 2015 05:08:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35562</guid>
					<description><![CDATA[&lt;code&gt;
{auto i = 0; for(auto e: container) { 
... 
++i;
}}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p><code><br />
{auto i = 0; for(auto e: container) {<br />
...<br />
++i;<br />
}}<br />
</code></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew Fioravante				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35529</link>
		<dc:creator><![CDATA[Matthew Fioravante]]></dc:creator>
		<pubDate>Fri, 16 Jan 2015 15:20:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35529</guid>
					<description><![CDATA[I usually just do this:

[code]
for(int i = 0; i &#060; int(container.size()); ++i) {
}
[/code]

It&#039;s not perfect, but the majority of the time my array will never have anything close to 2 billion elements. Having a habit of using signed ints also prevents writing infinite loops when you traverse the array from back to front using indices. Using ssize_t could be another option if you&#039;re concerned about sizeof(int). 

I like to use ints everywhere unless a more specific integral type is needed. If you make your loop variable unsigned then when you use it within the loop you&#039;re likely to be doing math and comparisons between signed and unsigned.

Fancy ranges and meta programming are nice but a lot of times we just have 2 arrays and want to iterate over them both with a simple index. No reason to over think things.]]></description>
		<content:encoded><![CDATA[<p>I usually just do this:</p>
<pre class="brush: plain; title: ; notranslate">
for(int i = 0; i &lt; int(container.size()); ++i) {
}
</pre>
<p>It&#8217;s not perfect, but the majority of the time my array will never have anything close to 2 billion elements. Having a habit of using signed ints also prevents writing infinite loops when you traverse the array from back to front using indices. Using ssize_t could be another option if you&#8217;re concerned about sizeof(int). </p>
<p>I like to use ints everywhere unless a more specific integral type is needed. If you make your loop variable unsigned then when you use it within the loop you&#8217;re likely to be doing math and comparisons between signed and unsigned.</p>
<p>Fancy ranges and meta programming are nice but a lot of times we just have 2 arrays and want to iterate over them both with a simple index. No reason to over think things.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35519</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Fri, 16 Jan 2015 10:05:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35519</guid>
					<description><![CDATA[Wow some really scary answers! If not a generic template, then leave as is, if a template then rewrite using the appropriate iteration style. Life can be simple sometimes.....even in c++!]]></description>
		<content:encoded><![CDATA[<p>Wow some really scary answers! If not a generic template, then leave as is, if a template then rewrite using the appropriate iteration style. Life can be simple sometimes&#8230;..even in c++!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Vaughn Cato				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35492</link>
		<dc:creator><![CDATA[Vaughn Cato]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 20:50:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35492</guid>
					<description><![CDATA[Although this isn&#039;t much different than other suggestions, I would suggest something like:

[code]

  for (auto i : indices_of(someObject)) { ... }

[/code]

where `indices_of` is a function which returns a suitable range object.  For example:

[code]

template &#060;typename T&#062;
struct index_range {
  T n;

  struct iterator {
    T index;

    bool operator!=(iterator that) const { return index!=that.index; }
    iterator operator++() { ++index; return *this; }
    T operator*() const { return index; }
  };

  iterator begin() const { return {0}; }
  iterator end() const { return {n}; }
};

template &#060;typename T, typename Index = typename T::size_type&#062;
index_range&#060;Index&#062; indices_of(const T&#038; container)
{
  return {container.size()};
}

int main()
{
  std::vector&#060;int&#062; v = {1,2,3};

  for (auto i : indices_of(v)) {
    std::cout &#060;&#060; i &#060;&#060; &#034;\n&#034;;
  }
}

[/code]

One nice thing about this approach is that `indices_of` could even be generalized to work with `std::map` or other containers whose indices aren&#039;t integers, or whose indices don&#039;t start at zero.]]></description>
		<content:encoded><![CDATA[<p>Although this isn&#8217;t much different than other suggestions, I would suggest something like:</p>
<pre class="brush: plain; title: ; notranslate">

  for (auto i : indices_of(someObject)) { ... }

</pre>
<p>where `indices_of` is a function which returns a suitable range object.  For example:</p>
<pre class="brush: plain; title: ; notranslate">

template &lt;typename T&gt;
struct index_range {
  T n;

  struct iterator {
    T index;

    bool operator!=(iterator that) const { return index!=that.index; }
    iterator operator++() { ++index; return *this; }
    T operator*() const { return index; }
  };

  iterator begin() const { return {0}; }
  iterator end() const { return {n}; }
};

template &lt;typename T, typename Index = typename T::size_type&gt;
index_range&lt;Index&gt; indices_of(const T&amp; container)
{
  return {container.size()};
}

int main()
{
  std::vector&lt;int&gt; v = {1,2,3};

  for (auto i : indices_of(v)) {
    std::cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;
  }
}

</pre>
<p>One nice thing about this approach is that `indices_of` could even be generalized to work with `std::map` or other containers whose indices aren&#8217;t integers, or whose indices don&#8217;t start at zero.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: wokste				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35490</link>
		<dc:creator><![CDATA[wokste]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 19:40:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35490</guid>
					<description><![CDATA[I have seen many suggestions for ranges and I like them. However, I would like to be able to quickly construct ranges for certain data structures:
[code]
for (auto i : someContainer.range()){    ... use i as an index ...}
[/code]
I personally do not know if this is feasable, but I just look how the API would be the cleanest. In general, this .range() function should only be available for data structures with simple integer domain for keys.]]></description>
		<content:encoded><![CDATA[<p>I have seen many suggestions for ranges and I like them. However, I would like to be able to quickly construct ranges for certain data structures:</p>
<pre class="brush: plain; title: ; notranslate">
for (auto i : someContainer.range()){    ... use i as an index ...}
</pre>
<p>I personally do not know if this is feasable, but I just look how the API would be the cleanest. In general, this .range() function should only be available for data structures with simple integer domain for keys.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Enrico				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35486</link>
		<dc:creator><![CDATA[Enrico]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 19:28:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35486</guid>
					<description><![CDATA[Sorry, one function was missing:
[code]
template &#060;typename T&#062;
static inline constexpr auto null(T&#038;&#038;) noexcept(noexcept(null&#060;T&#062;())) {
    return null&#060;T&#062;();
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Sorry, one function was missing:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename T&gt;
static inline constexpr auto null(T&amp;&amp;) noexcept(noexcept(null&lt;T&gt;())) {
    return null&lt;T&gt;();
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Enrico				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35485</link>
		<dc:creator><![CDATA[Enrico]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 19:26:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35485</guid>
					<description><![CDATA[I also like the &#039;range of values&#039; approach because it enforces code locality as the iteration boundaries are tied together and it is also very succinct.
As for the &quot;null of a certain index type&quot; problem we have some handy functions in our code base that merely call the default constructor (if any) and is basically syntactic sugar for the &lt;code&gt;decltype(mySize){}&lt;/code&gt; approach, but clearly states the intent of the caller:

[code]
template &#060;typename T&#062;
using remove_cv_ref_t = std::remove_const_t&#060;std::remove_reference_t&#060;T&#062;&#062;;

template &#060;typename T&#062;
using has_nothrow_default = std::is_nothrow_default_constructible&#060;remove_cv_ref_t&#060;T&#062;&#062;;

template &#060;typename T&#062;
static inline constexpr remove_cv_ref_t&#060;T&#062;  null() noexcept(has_nothrow_default&#060;T&#062;{}()) {
    static_assert(std::is_default_constructible&#060;remove_cv_ref_t&#060;T&#062;&#062;{}(),
                  &#034;type must be default constructible to generate null object!&#034;);
    return {};
}
[/code]
to be used like this:
[code]
constexpr std::size_t sizeBuffer = 64;
for (auto i = null(sizeBuffer); i &#060; sizeBuffer; ++i) {
    static_assert(std::is_same&#060;decltype(i), std::size_t&#062;::value, &#034;???&#034;);
    // ...
}

constexpr std::uint8_t numElems = 64;
for (auto i = null(numElems); i &#060; numElems; ++i) {
    static_assert(std::is_same&#060;decltype(i), std::uint8_t&#062;::value, &#034;???&#034;);
    // ...
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>I also like the &#8216;range of values&#8217; approach because it enforces code locality as the iteration boundaries are tied together and it is also very succinct.<br />
As for the &#8220;null of a certain index type&#8221; problem we have some handy functions in our code base that merely call the default constructor (if any) and is basically syntactic sugar for the <code>decltype(mySize){}</code> approach, but clearly states the intent of the caller:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename T&gt;
using remove_cv_ref_t = std::remove_const_t&lt;std::remove_reference_t&lt;T&gt;&gt;;

template &lt;typename T&gt;
using has_nothrow_default = std::is_nothrow_default_constructible&lt;remove_cv_ref_t&lt;T&gt;&gt;;

template &lt;typename T&gt;
static inline constexpr remove_cv_ref_t&lt;T&gt;  null() noexcept(has_nothrow_default&lt;T&gt;{}()) {
    static_assert(std::is_default_constructible&lt;remove_cv_ref_t&lt;T&gt;&gt;{}(),
                  &quot;type must be default constructible to generate null object!&quot;);
    return {};
}
</pre>
<p>to be used like this:</p>
<pre class="brush: plain; title: ; notranslate">
constexpr std::size_t sizeBuffer = 64;
for (auto i = null(sizeBuffer); i &lt; sizeBuffer; ++i) {
    static_assert(std::is_same&lt;decltype(i), std::size_t&gt;::value, &quot;???&quot;);
    // ...
}

constexpr std::uint8_t numElems = 64;
for (auto i = null(numElems); i &lt; numElems; ++i) {
    static_assert(std::is_same&lt;decltype(i), std::uint8_t&gt;::value, &quot;???&quot;);
    // ...
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Etheria				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35470</link>
		<dc:creator><![CDATA[Etheria]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 15:03:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35470</guid>
					<description><![CDATA[To be honest, I just use

[code]for (size_t i = 0; i &#060; v.size(); i++)[/code]

We can talk all we want about ranges. Sure, they would be nice, but we don&#039;t have them yet, and especially for newbies, are we going to recommend a 3rd party library or writing our own solution for something so trivial? Just use size_t. It&#039;s what the standard library uses, and so good practice IMO should be to use size_t (or a lesser unsigned type) for the size for your own classes.

It work seamlessly with the standard library and it should work with most 3rd party libraries and/or your own classes without signed/unsigned warnings and/or narrowing warnings.]]></description>
		<content:encoded><![CDATA[<p>To be honest, I just use</p>
<pre class="brush: plain; title: ; notranslate">for (size_t i = 0; i &lt; v.size(); i++)</pre>
<p>We can talk all we want about ranges. Sure, they would be nice, but we don&#8217;t have them yet, and especially for newbies, are we going to recommend a 3rd party library or writing our own solution for something so trivial? Just use size_t. It&#8217;s what the standard library uses, and so good practice IMO should be to use size_t (or a lesser unsigned type) for the size for your own classes.</p>
<p>It work seamlessly with the standard library and it should work with most 3rd party libraries and/or your own classes without signed/unsigned warnings and/or narrowing warnings.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Riccardo				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35469</link>
		<dc:creator><![CDATA[Riccardo]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 14:57:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35469</guid>
					<description><![CDATA[It&#039;s actually a very interesting topic. I see a lot of unsigned/signed mismatches from static analysis tools due to these situations.

I currently favour:

[code]for (decltype(someObject.size()) i = 0; i &#060; someObject.size(); i++) { … }[/code] 

I hope in the near future to be able to use non-member std::size() which is more generic as it works with built-in arrays too:

[code]for (decltype(std::size(someObject)) i = 0; i &#060; std::size(someObject); i++) { … }[/code]]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s actually a very interesting topic. I see a lot of unsigned/signed mismatches from static analysis tools due to these situations.</p>
<p>I currently favour:</p>
<pre class="brush: plain; title: ; notranslate">for (decltype(someObject.size()) i = 0; i &lt; someObject.size(); i++) { … }</pre>
<p>I hope in the near future to be able to use non-member std::size() which is more generic as it works with built-in arrays too:</p>
<pre class="brush: plain; title: ; notranslate">for (decltype(std::size(someObject)) i = 0; i &lt; std::size(someObject); i++) { … }</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: evincarofautumn				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35464</link>
		<dc:creator><![CDATA[evincarofautumn]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 13:51:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35464</guid>
					<description><![CDATA[The fact that some programmers may not be familiar with a language feature is not a reason to avoid it, particularly if it makes the code more correct! decltype is fine here, and you can write it even more neatly than the original:

for (decltype(someObject.size()) i = 0; i &#060; someObject.size(); i++) { … }

All these answers suggesting ranges are great, but even farther afield and less searchable than decltype.]]></description>
		<content:encoded><![CDATA[<p>The fact that some programmers may not be familiar with a language feature is not a reason to avoid it, particularly if it makes the code more correct! decltype is fine here, and you can write it even more neatly than the original:</p>
<p>for (decltype(someObject.size()) i = 0; i &lt; someObject.size(); i++) { … }</p>
<p>All these answers suggesting ranges are great, but even farther afield and less searchable than decltype.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35463</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 13:38:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35463</guid>
					<description><![CDATA[In &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4254.html&quot; rel=&quot;nofollow&quot;&gt;N4254&lt;/a&gt; I proposed the &quot;z&quot; suffix for size_t literals:
[code]auto s = 0z; // s has type size_t[/code]
This allows code like this:
[code]
#include &#060;cstddef&#062;
#include &#060;vector&#062;
using namespace std::support_literals;

int main()
{
  auto v = std::vector&#060;int&#062; { 98, 03, 11, 14, 17 };
  for (auto i = 0z, s = v.size(); i &#060; s; ++i) { 
    /* use both i and v[i] */ 
  }
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4254.html" rel="nofollow">N4254</a> I proposed the &#8220;z&#8221; suffix for size_t literals:</p>
<pre class="brush: plain; title: ; notranslate">auto s = 0z; // s has type size_t</pre>
<p>This allows code like this:</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;cstddef&gt;
#include &lt;vector&gt;
using namespace std::support_literals;

int main()
{
  auto v = std::vector&lt;int&gt; { 98, 03, 11, 14, 17 };
  for (auto i = 0z, s = v.size(); i &lt; s; ++i) { 
    /* use both i and v[i] */ 
  }
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Elliot Goodrich				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35461</link>
		<dc:creator><![CDATA[Elliot Goodrich]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 13:18:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35461</guid>
					<description><![CDATA[I wrote a interval arithmetic library (https://github.com/elliotgoodrich/EZInterval) that allows iterating over intervals. The ez::make_interval variable has overloaded operator[] and operator() to let you choose whether the interval is open or closed.

[code]// prints 012345
for(auto i : ez::make_interval[0][5])
    std::cout &#060;&#060; i;

// prints 01234 (
for(auto i : ez::make_interval[0](5))
    std::cout &#060;&#060; i;

// prints 12345
for(auto i : ez::make_interval(0)[5])
    std::cout &#060;&#060; i;

// prints 1234
for(auto i : ez::make_interval(0)(5))
    std::cout &#060;&#060; i;[/code]

This works with any other type that acts like a numeric type, e,g pointers and iterators

[code]std::vector&#060;int&#062; v = {1, 11, 21, 1112, 3112, 132112};

// prints &#034;1 11 21 1112 3112 132112 &#034;
for(std::vector&#060;int&#062;::iterator it : ez::make_interval[v.begin()](v.end()))
    std::cout &#060;&#060; *it &#060;&#060; &#034; &#034;;[/code]

I&#039;ve made a change and will commit later so that the type of i in the examples above will be the std::common_type of the lower and upper bound variables so ez::make_interval[0](size) will give you back a type of std::size_t when you iterate over it.]]></description>
		<content:encoded><![CDATA[<p>I wrote a interval arithmetic library (<a href="https://github.com/elliotgoodrich/EZInterval" rel="nofollow">https://github.com/elliotgoodrich/EZInterval</a>) that allows iterating over intervals. The ez::make_interval variable has overloaded operator[] and operator() to let you choose whether the interval is open or closed.</p>
<pre class="brush: plain; title: ; notranslate">// prints 012345
for(auto i : ez::make_interval[0][5])
    std::cout &lt;&lt; i;

// prints 01234 (
for(auto i : ez::make_interval[0](5))
    std::cout &lt;&lt; i;

// prints 12345
for(auto i : ez::make_interval(0)[5])
    std::cout &lt;&lt; i;

// prints 1234
for(auto i : ez::make_interval(0)(5))
    std::cout &lt;&lt; i;</pre>
<p>This works with any other type that acts like a numeric type, e,g pointers and iterators</p>
<pre class="brush: plain; title: ; notranslate">std::vector&lt;int&gt; v = {1, 11, 21, 1112, 3112, 132112};

// prints &quot;1 11 21 1112 3112 132112 &quot;
for(std::vector&lt;int&gt;::iterator it : ez::make_interval[v.begin()](v.end()))
    std::cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</pre>
<p>I&#8217;ve made a change and will commit later so that the type of i in the examples above will be the std::common_type of the lower and upper bound variables so ez::make_interval[0](size) will give you back a type of std::size_t when you iterate over it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: marcmutz				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35457</link>
		<dc:creator><![CDATA[marcmutz]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 11:46:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35457</guid>
					<description><![CDATA[(please excuse the spam, there&#039;s no preview for comments...)

The 0*-trick only works if &lt;code&gt;decltype(std::declval&#060;int&#062;() * std::declval&#060;decltype(someObject.size())&#062;())&lt;/code&gt; is the same as &lt;code&gt;decltype(someObject.size())&lt;/code&gt;.

This is the case for &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;size_t&lt;/code&gt; and &lt;code&gt;ssize_t&lt;/code&gt;, but not for &quot;smaller&quot; types, such as &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;uchar&lt;/code&gt;, because they&#039;re promoted to &lt;code&gt;int&lt;/code&gt; for any arithmetic. That also rules out xor and subtracting the size form itself to create a 0 value.

In generic code, what&#039;s wrong with plain old (for a certain definition of &quot;old&quot;)

[code]
for ( auto end = someObject.size(), i = decltype(end)(0); i != end; ++i)
[/code]

?]]></description>
		<content:encoded><![CDATA[<p>(please excuse the spam, there&#8217;s no preview for comments&#8230;)</p>
<p>The 0*-trick only works if <code>decltype(std::declval&lt;int&gt;() * std::declval&lt;decltype(someObject.size())&gt;())</code> is the same as <code>decltype(someObject.size())</code>.</p>
<p>This is the case for <code>int</code>, <code>uint</code>, <code>size_t</code> and <code>ssize_t</code>, but not for &#8220;smaller&#8221; types, such as <code>short</code> or <code>uchar</code>, because they&#8217;re promoted to <code>int</code> for any arithmetic. That also rules out xor and subtracting the size form itself to create a 0 value.</p>
<p>In generic code, what&#8217;s wrong with plain old (for a certain definition of &#8220;old&#8221;)</p>
<pre class="brush: plain; title: ; notranslate">
for ( auto end = someObject.size(), i = decltype(end)(0); i != end; ++i)
</pre>
<p>?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: TonyB				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35452</link>
		<dc:creator><![CDATA[TonyB]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 10:57:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35452</guid>
					<description><![CDATA[similar to Herb&#039;s solution, but without a multiplication in sight: for( auto i = mySize - mySize; ...]]></description>
		<content:encoded><![CDATA[<p>similar to Herb&#8217;s solution, but without a multiplication in sight: for( auto i = mySize &#8211; mySize; &#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: red1939				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35443</link>
		<dc:creator><![CDATA[red1939]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 09:05:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35443</guid>
					<description><![CDATA[As it was mentioned earlier: writing irange(end), irange(begin, end) and irange(begin, end, step) range wrappers (returning iterators) is simple to write yourself and from what I&#039;ve checked even Visual Studio (which many times failed to optimize enough) and the performance (and assembly for anyone wondering) is the same as for regular for but you get terse syntax.]]></description>
		<content:encoded><![CDATA[<p>As it was mentioned earlier: writing irange(end), irange(begin, end) and irange(begin, end, step) range wrappers (returning iterators) is simple to write yourself and from what I&#8217;ve checked even Visual Studio (which many times failed to optimize enough) and the performance (and assembly for anyone wondering) is the same as for regular for but you get terse syntax.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35442</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 08:54:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35442</guid>
					<description><![CDATA[I proposed the &quot;z&quot; literal suffix for size_t variables (see N4254 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4254.html) so that one can write &quot;auto s = 0z; // s has type size_t&quot;]]></description>
		<content:encoded><![CDATA[<p>I proposed the &#8220;z&#8221; literal suffix for size_t variables (see N4254 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4254.html" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4254.html</a>) so that one can write &#8220;auto s = 0z; // s has type size_t&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: max0x7ba				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35441</link>
		<dc:creator><![CDATA[max0x7ba]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 08:36:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35441</guid>
					<description><![CDATA[I sometimes do reverse loops for this reason:

[code]
for(auto i = v.size(); i--;)
[/code]]]></description>
		<content:encoded><![CDATA[<p>I sometimes do reverse loops for this reason:</p>
<pre class="brush: plain; title: ; notranslate">
for(auto i = v.size(); i--;)
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marco Arena				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35439</link>
		<dc:creator><![CDATA[Marco Arena]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 07:57:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35439</guid>
					<description><![CDATA[Guys, what about performance of

[code]
for (auto i : ranges::view::iota(0, size-1))
[/code]

compared to the simpler:

[code]
for (auto i=0; i&#060;size; i++)
[/code]

?

Is the compiler still able to optimize/vectorize? I&#039;m asking because I don&#039;t know and I&#039;m sure some of you do.
Thanks!

Marco]]></description>
		<content:encoded><![CDATA[<p>Guys, what about performance of</p>
<pre class="brush: plain; title: ; notranslate">
for (auto i : ranges::view::iota(0, size-1))
</pre>
<p>compared to the simpler:</p>
<pre class="brush: plain; title: ; notranslate">
for (auto i=0; i&lt;size; i++)
</pre>
<p>?</p>
<p>Is the compiler still able to optimize/vectorize? I&#8217;m asking because I don&#8217;t know and I&#8217;m sure some of you do.<br />
Thanks!</p>
<p>Marco</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gevorg Voskanyan				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35438</link>
		<dc:creator><![CDATA[Gevorg Voskanyan]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 07:02:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35438</guid>
					<description><![CDATA[Here&#039;s an idea off the top of my head:
[code]
template &#060; typename C &#062;
auto begin_index( const C &#038;c ) -&#062; decltype( c.size() )
{
	return 0;
}

template &#060; typename T &#062;
void f( const std::vector&#060; T &#062; &#038;v )
{
	for ( auto i = begin_index( v ); i &#060; v.size(); ++i ) { ... }

	// if C++17 brings us std::size(), then this will look more elegant:
	for ( auto i = begin_index( v ); i &#060; size( v ); ++i ) { ... }
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s an idea off the top of my head:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt; typename C &gt;
auto begin_index( const C &amp;c ) -&gt; decltype( c.size() )
{
	return 0;
}

template &lt; typename T &gt;
void f( const std::vector&lt; T &gt; &amp;v )
{
	for ( auto i = begin_index( v ); i &lt; v.size(); ++i ) { ... }

	// if C++17 brings us std::size(), then this will look more elegant:
	for ( auto i = begin_index( v ); i &lt; size( v ); ++i ) { ... }
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Patrice Roy				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35436</link>
		<dc:creator><![CDATA[Patrice Roy]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 05:41:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35436</guid>
					<description><![CDATA[How about something like this? It&#039;s a back-of-the-envelope solution, and I haven&#039;t given more than a few seconds to the naming of it all, but it works for the obvious cases (I have not done anything that remotely looks like real testing, and it&#039;s a bit late here):

[code]
#include &#060;iostream&#062;
#include &#060;vector&#062;
#include &#060;algorithm&#062;
#include &#060;iterator&#062;
using namespace std;

template &#060;class C&#062;
   auto size(const C &#038;cont) -&#062; decltype(cont.size())
   {
      return cont.size();
   }
template &#060;class C, std::size_t N&#062;
   std::size_t size(const C (&#038;arr)[N])
   {
      return N;
   }

template &#060;class T&#062;
   class value_range
      : public std::iterator&#060;std::bidirectional_iterator_tag, T&#062;
   {
      T first, last;
   public:
      template &#060;class U&#062;
         class value_iterator
         {
            U cur;
         public:
            value_iterator(U init)
               : cur{init}
            {
            }
            value_iterator&#038; operator++()
            {
               ++cur;
               return *this;
            }
            value_iterator operator++(int)
            {
               auto temp { *this };
               operator++();
               return temp;
            }
            value_iterator&#038; operator--()
            {
               --cur;
               return *this;
            }
            value_iterator operator--(int)
            {
               auto temp{ *this };
               operator--();
               return temp;
            }
            bool operator==(const value_iterator &#038;other) const
            {
               return cur == other.cur;
            }
            bool operator!=(const value_iterator &#038;other) const
            {
               return !(*this == other);
            }
            U operator*()
            {
               return cur;
            }
            U operator*() const
            {
               return cur;
            }
         };
      using iterator = value_iterator&#060;T&#062;;
      using const_iterator = value_iterator&#060;T&#062;;
      value_range(T first, T last)
         : first{ first }, last{ last }
      {
      }
      iterator begin() { return first; }
      iterator end() { return last; }
      const_iterator begin() const { return first; }
      const_iterator end() const { return last; }
      const_iterator cbegin() const { return first; }
      const_iterator cend() const { return last; }
   };

template &#060;class C&#062;
   auto value_range_from(C &#038;cont) -&#062; value_range&#060;decltype(size(cont))&#062;
   {
      return value_range&#060;decltype(size(cont))&#062;{ 0, size(cont) };
   }

int main()
{
   int arr[] = { 2, 3, 5, 7, 11 };
   vector&#060;int&#062; v(begin(arr), end(arr));
   for (const auto &#038;val : arr)
      cout &#060;&#060; val &#060;&#060; &#039; &#039;;
   cout &#060;&#060; &#039;\n&#039;;
   for (const auto &#038;val : v)
      cout &#060;&#060; val &#060;&#060; &#039; &#039;;
   cout &#060;&#060; &#039;\n&#039;;
   for (auto i : value_range_from(arr))
      cout &#060;&#060; &#034;arr[&#034; &#060;&#060; i &#060;&#060; &#034;] == &#034; &#060;&#060; arr[i] &#060;&#060; &#034;; &#034;;
   cout &#060;&#060; &#039;\n&#039;;
   for (auto i : value_range_from(v))
      cout &#060;&#060; &#034;v[&#034; &#060;&#060; i &#060;&#060; &#034;] == &#034; &#060;&#060; v[i] &#060;&#060; &#034;; &#034;;
   cout &#060;&#060; &#039;\n&#039;;
}

[/code]]]></description>
		<content:encoded><![CDATA[<p>How about something like this? It&#8217;s a back-of-the-envelope solution, and I haven&#8217;t given more than a few seconds to the naming of it all, but it works for the obvious cases (I have not done anything that remotely looks like real testing, and it&#8217;s a bit late here):</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
using namespace std;

template &lt;class C&gt;
   auto size(const C &amp;cont) -&gt; decltype(cont.size())
   {
      return cont.size();
   }
template &lt;class C, std::size_t N&gt;
   std::size_t size(const C (&amp;arr)[N])
   {
      return N;
   }

template &lt;class T&gt;
   class value_range
      : public std::iterator&lt;std::bidirectional_iterator_tag, T&gt;
   {
      T first, last;
   public:
      template &lt;class U&gt;
         class value_iterator
         {
            U cur;
         public:
            value_iterator(U init)
               : cur{init}
            {
            }
            value_iterator&amp; operator++()
            {
               ++cur;
               return *this;
            }
            value_iterator operator++(int)
            {
               auto temp { *this };
               operator++();
               return temp;
            }
            value_iterator&amp; operator--()
            {
               --cur;
               return *this;
            }
            value_iterator operator--(int)
            {
               auto temp{ *this };
               operator--();
               return temp;
            }
            bool operator==(const value_iterator &amp;other) const
            {
               return cur == other.cur;
            }
            bool operator!=(const value_iterator &amp;other) const
            {
               return !(*this == other);
            }
            U operator*()
            {
               return cur;
            }
            U operator*() const
            {
               return cur;
            }
         };
      using iterator = value_iterator&lt;T&gt;;
      using const_iterator = value_iterator&lt;T&gt;;
      value_range(T first, T last)
         : first{ first }, last{ last }
      {
      }
      iterator begin() { return first; }
      iterator end() { return last; }
      const_iterator begin() const { return first; }
      const_iterator end() const { return last; }
      const_iterator cbegin() const { return first; }
      const_iterator cend() const { return last; }
   };

template &lt;class C&gt;
   auto value_range_from(C &amp;cont) -&gt; value_range&lt;decltype(size(cont))&gt;
   {
      return value_range&lt;decltype(size(cont))&gt;{ 0, size(cont) };
   }

int main()
{
   int arr[] = { 2, 3, 5, 7, 11 };
   vector&lt;int&gt; v(begin(arr), end(arr));
   for (const auto &amp;val : arr)
      cout &lt;&lt; val &lt;&lt; ' ';
   cout &lt;&lt; '\n';
   for (const auto &amp;val : v)
      cout &lt;&lt; val &lt;&lt; ' ';
   cout &lt;&lt; '\n';
   for (auto i : value_range_from(arr))
      cout &lt;&lt; &quot;arr[&quot; &lt;&lt; i &lt;&lt; &quot;] == &quot; &lt;&lt; arr[i] &lt;&lt; &quot;; &quot;;
   cout &lt;&lt; '\n';
   for (auto i : value_range_from(v))
      cout &lt;&lt; &quot;v[&quot; &lt;&lt; i &lt;&lt; &quot;] == &quot; &lt;&lt; v[i] &lt;&lt; &quot;; &quot;;
   cout &lt;&lt; '\n';
}

</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bames53				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35433</link>
		<dc:creator><![CDATA[bames53]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 04:58:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35433</guid>
					<description><![CDATA[@Juan Carlos Arevalo Baeza

Using range-v3 (and a range compatible range-for-loop) your idea looks like:

for (auto i : ranges::view::iota(0, size-1))

I guess we can also get indexes and values together:

for (auto i_v : ranges::view::zip(ranges::view::iota(0), v))
  std::cout &#060;&#060; &#034;Index: &#034; &#060;&#060; std::get(*i) &#060;&#060; &#034; Value: &#034; &#060;&#060; std::get(*i) &#060;&#060; &#039;\n&#039;;]]></description>
		<content:encoded><![CDATA[<p>@Juan Carlos Arevalo Baeza</p>
<p>Using range-v3 (and a range compatible range-for-loop) your idea looks like:</p>
<p>for (auto i : ranges::view::iota(0, size-1))</p>
<p>I guess we can also get indexes and values together:</p>
<p>for (auto i_v : ranges::view::zip(ranges::view::iota(0), v))<br />
  std::cout &lt;&lt; &quot;Index: &quot; &lt;&lt; std::get(*i) &lt;&lt; &quot; Value: &quot; &lt;&lt; std::get(*i) &lt;&lt; &#039;\n&#039;;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bames53				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35429</link>
		<dc:creator><![CDATA[bames53]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 04:22:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35429</guid>
					<description><![CDATA[&#039;Generic&#039; code is good not just for templates, but also for portable code, where different platforms may define things differently. So in non-template code you might need `0` to avoid warnings on one platform and `0u` to avoid them on another.

Needing indexes and values seems common enough that perhaps their should be a special syntax for it.

Failing that perhaps a standard algorithm: `for_each(Range &#038;&#038;r, Functor &#038;&#038;f)` where the functor can optional accept both an index and the elements.

And one maybe-improvement over the options presented here: `for (auto size = v.size(), i = 0*size; i &#060; size; ++i) {`]]></description>
		<content:encoded><![CDATA[<p>&#8216;Generic&#8217; code is good not just for templates, but also for portable code, where different platforms may define things differently. So in non-template code you might need `0` to avoid warnings on one platform and `0u` to avoid them on another.</p>
<p>Needing indexes and values seems common enough that perhaps their should be a special syntax for it.</p>
<p>Failing that perhaps a standard algorithm: `for_each(Range &amp;&amp;r, Functor &amp;&amp;f)` where the functor can optional accept both an index and the elements.</p>
<p>And one maybe-improvement over the options presented here: `for (auto size = v.size(), i = 0*size; i &lt; size; ++i) {`</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: FJW				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35427</link>
		<dc:creator><![CDATA[FJW]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 04:07:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35427</guid>
					<description><![CDATA[[code]
    for ( auto i: count_until(mySize) ) ...
[/code]
Is indeed the way to go; aside from that though, we still need a (preferably core-language) integer-literal for &lt;code&gt;std::size_t&lt;/code&gt; (also for the &lt;code&gt;std::[u]int*_t&lt;/code&gt;-typedefs). It is really very sad that there is no simpler way of generating a zero of those types than writing out something like &lt;code&gt;std::size_t{}&lt;/code&gt;.

&lt;code&gt;std::size_t&lt;/code&gt; is certainly one of the most often needed integer-types, but people still access containers with &lt;code&gt;int&lt;/code&gt;s because they are so much more convenient to type. This is really a terrible situation.]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">
    for ( auto i: count_until(mySize) ) ...
</pre>
<p>Is indeed the way to go; aside from that though, we still need a (preferably core-language) integer-literal for <code>std::size_t</code> (also for the <code>std::[u]int*_t</code>-typedefs). It is really very sad that there is no simpler way of generating a zero of those types than writing out something like <code>std::size_t{}</code>.</p>
<p><code>std::size_t</code> is certainly one of the most often needed integer-types, but people still access containers with <code>int</code>s because they are so much more convenient to type. This is really a terrible situation.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35426</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 03:53:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35426</guid>
					<description><![CDATA[Great points on the index-range examples. We do need an iterable &#039;range of values&#039; in the standard library, but you can roll your own in the several ways suggested in the meantime.]]></description>
		<content:encoded><![CDATA[<p>Great points on the index-range examples. We do need an iterable &#8216;range of values&#8217; in the standard library, but you can roll your own in the several ways suggested in the meantime.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35424</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 03:50:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35424</guid>
					<description><![CDATA[@Herb, I was wondering if you agree with these statements:

1) &quot;Using an unsigned instead of an int to gain one more bit to represent positive integers is almost never a good idea.&quot; (Stroustrup) 

2) Implicit conversion rules make unsigned types into bug attractors (http://stackoverflow.com/a/10168569/297451)
Eg: size_t x = 0; for(size_t i=10; i&#062;=x; --i) {}


If so, is it reasonable to cast away the unsigned-ness with a static_cast or boost::numeric_cast?]]></description>
		<content:encoded><![CDATA[<p>@Herb, I was wondering if you agree with these statements:</p>
<p>1) &#8220;Using an unsigned instead of an int to gain one more bit to represent positive integers is almost never a good idea.&#8221; (Stroustrup) </p>
<p>2) Implicit conversion rules make unsigned types into bug attractors (<a href="http://stackoverflow.com/a/10168569/297451" rel="nofollow">http://stackoverflow.com/a/10168569/297451</a>)<br />
Eg: size_t x = 0; for(size_t i=10; i&gt;=x; &#8211;i) {}</p>
<p>If so, is it reasonable to cast away the unsigned-ness with a static_cast or boost::numeric_cast?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: enerjazzer				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35418</link>
		<dc:creator><![CDATA[enerjazzer]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 02:48:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35418</guid>
					<description><![CDATA[I think a simple counting range would get the best of the two worlds:
[code]for ( auto i: count_until(mySize) ) ...[/code]
(assuming the compiler can optimize this as efficiently as plain for loop) 

Implementation of such a range is trivial and left as an exercise for a reader :)]]></description>
		<content:encoded><![CDATA[<p>I think a simple counting range would get the best of the two worlds:</p>
<pre class="brush: plain; title: ; notranslate">for ( auto i: count_until(mySize) ) ...</pre>
<p>(assuming the compiler can optimize this as efficiently as plain for loop) </p>
<p>Implementation of such a range is trivial and left as an exercise for a reader :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35415</link>
		<dc:creator><![CDATA[Matthew]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 02:22:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35415</guid>
					<description><![CDATA[How about:

[code]
  auto mySize = someObject.size(), i = mySize;
  for (i = 0; i &#060; mySize; i++) { }
[/code]]]></description>
		<content:encoded><![CDATA[<p>How about:</p>
<pre class="brush: plain; title: ; notranslate">
  auto mySize = someObject.size(), i = mySize;
  for (i = 0; i &lt; mySize; i++) { }
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John Smith				</title>
				<link>https://herbsutter.com/2015/01/14/reader-qa-auto-and-for-loop-index-variables/#comment-35412</link>
		<dc:creator><![CDATA[John Smith]]></dc:creator>
		<pubDate>Thu, 15 Jan 2015 02:02:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2552#comment-35412</guid>
					<description><![CDATA[I believe range-for is still the solution here. I&#039;ll use boost::irange here, but you can roll your own simple wrapper for this quite easily:

[code]
#include &#060;boost/range/irange.hpp&#062;
// ...
template&#060;typename T, typename U, typename V = int&#062;
inline decltype(auto) range(T a, U b, V s = 1) {
  using D = decltype(true ? a : b); 
  return boost::irange&#060;D&#062;(a, b, s);
}
// ...
void g(...);
// ... 
auto f(std::vector&#060;int&#062; const&#038; v) {
  for(auto&#038;&#038; i : range(0, v.size())) {
    g(i);
  }
}
[/code]

This lets the usual integer type promotion machinery of C++ do its thing (which, depending how you see it, can be a good or bad thing---but it&#039;s predictable at least).]]></description>
		<content:encoded><![CDATA[<p>I believe range-for is still the solution here. I&#8217;ll use boost::irange here, but you can roll your own simple wrapper for this quite easily:</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;boost/range/irange.hpp&gt;
// ...
template&lt;typename T, typename U, typename V = int&gt;
inline decltype(auto) range(T a, U b, V s = 1) {
  using D = decltype(true ? a : b); 
  return boost::irange&lt;D&gt;(a, b, s);
}
// ...
void g(...);
// ... 
auto f(std::vector&lt;int&gt; const&amp; v) {
  for(auto&amp;&amp; i : range(0, v.size())) {
    g(i);
  }
}
</pre>
<p>This lets the usual integer type promotion machinery of C++ do its thing (which, depending how you see it, can be a good or bad thing&#8212;but it&#8217;s predictable at least).</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
