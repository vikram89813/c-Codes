<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Effective Concurrency: Use Thread Pools Correctly &#8211; Keep Tasks Short and Nonblocking	</title>
	<atom:link href="https://herbsutter.com/2009/04/20/effective-concurrency-use-thread-pools-correctly-keep-tasks-short-and-nonblocking/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2009/04/20/effective-concurrency-use-thread-pools-correctly-keep-tasks-short-and-nonblocking/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Andrei				</title>
				<link>https://herbsutter.com/2009/04/20/effective-concurrency-use-thread-pools-correctly-keep-tasks-short-and-nonblocking/#comment-1177</link>
		<dc:creator><![CDATA[Andrei]]></dc:creator>
		<pubDate>Wed, 22 Apr 2009 01:09:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2009/04/20/effective-concurrency-use-thread-pools-correctly-keep-tasks-short-and-nonblocking/#comment-1177</guid>
					<description><![CDATA[thank you for making this list
cool to have all of them listed in one place]]></description>
		<content:encoded><![CDATA[<p>thank you for making this list<br />
cool to have all of them listed in one place</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: George				</title>
				<link>https://herbsutter.com/2009/04/20/effective-concurrency-use-thread-pools-correctly-keep-tasks-short-and-nonblocking/#comment-1176</link>
		<dc:creator><![CDATA[George]]></dc:creator>
		<pubDate>Tue, 21 Apr 2009 11:32:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2009/04/20/effective-concurrency-use-thread-pools-correctly-keep-tasks-short-and-nonblocking/#comment-1176</guid>
					<description><![CDATA[1. Task size:
I agree that tasks should not be too small but IMO they don&#039;t have to be small in general. As long as the thread pool is kept busy with enough tasks it does not matter if the tasks are small or large. Large tasks should remain large and should not be split into smaller pieces which would produce more overhead.

It also doesn&#039;t matter if the pool is running out of tasks because in this state the pool is inefficient anyway.
If the remaining tasks are still divisible they can be split to get a better thread utilization. If not, it&#039;s still the fastest way to run on a single thread.

2. Blocking tasks
If thread affinity is not an issue it&#039;s possible to add blocking tasks to the thread pool if they are executed on fibers. But this requires a powerful Fiber API that provides a user mode scheduler and primitives for fiber synchronization.

Coincidentally, I&#039;ve already implemented such a fiber-based thread pool at http://www.fiberpool.de/en/index.html ;-) ...but MS also announced a similar framework for Windows 7 and VS2010..

George]]></description>
		<content:encoded><![CDATA[<p>1. Task size:<br />
I agree that tasks should not be too small but IMO they don&#8217;t have to be small in general. As long as the thread pool is kept busy with enough tasks it does not matter if the tasks are small or large. Large tasks should remain large and should not be split into smaller pieces which would produce more overhead.</p>
<p>It also doesn&#8217;t matter if the pool is running out of tasks because in this state the pool is inefficient anyway.<br />
If the remaining tasks are still divisible they can be split to get a better thread utilization. If not, it&#8217;s still the fastest way to run on a single thread.</p>
<p>2. Blocking tasks<br />
If thread affinity is not an issue it&#8217;s possible to add blocking tasks to the thread pool if they are executed on fibers. But this requires a powerful Fiber API that provides a user mode scheduler and primitives for fiber synchronization.</p>
<p>Coincidentally, I&#8217;ve already implemented such a fiber-based thread pool at <a href="http://www.fiberpool.de/en/index.html" rel="nofollow">http://www.fiberpool.de/en/index.html</a> ;-) &#8230;but MS also announced a similar framework for Windows 7 and VS2010..</p>
<p>George</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
