<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Server Concurrency != Client Concurrency	</title>
	<atom:link href="https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Steve				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-788</link>
		<dc:creator><![CDATA[Steve]]></dc:creator>
		<pubDate>Wed, 20 Aug 2008 20:40:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-788</guid>
					<description><![CDATA[Nice article!  A couple of comments:

There&#039;s another way to think about the issue you call &quot;inherent concurrency&quot;. Typical server jobs (such as database systems) are often measured by total throughput (eg transactions per second) whereas many client applications are sensitive to response time in order to support interactive behavior. This difference can lead to very different strategies when considering how to extract parallel performance.

Also, you point out that locks are error-prone, but there is another serious problem with locks - programming with explicit locks can often serialize a program, sometimes in subtle ways.  This results in losing the benefits of parallelism as threads line up to acquire the lock one at a time.

Another alternative to explicit-lock programming, in addition to the transactional model you describe, is the &quot;hyperobject&quot; concept that our company (Cilk Arts) describes at http://www.cilk.com/multicore-products/cilk-hyperobjects.]]></description>
		<content:encoded><![CDATA[<p>Nice article!  A couple of comments:</p>
<p>There&#8217;s another way to think about the issue you call &#8220;inherent concurrency&#8221;. Typical server jobs (such as database systems) are often measured by total throughput (eg transactions per second) whereas many client applications are sensitive to response time in order to support interactive behavior. This difference can lead to very different strategies when considering how to extract parallel performance.</p>
<p>Also, you point out that locks are error-prone, but there is another serious problem with locks &#8211; programming with explicit locks can often serialize a program, sometimes in subtle ways.  This results in losing the benefits of parallelism as threads line up to acquire the lock one at a time.</p>
<p>Another alternative to explicit-lock programming, in addition to the transactional model you describe, is the &#8220;hyperobject&#8221; concept that our company (Cilk Arts) describes at <a href="http://www.cilk.com/multicore-products/cilk-hyperobjects" rel="nofollow">http://www.cilk.com/multicore-products/cilk-hyperobjects</a>.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ahmadfarhan				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-762</link>
		<dc:creator><![CDATA[ahmadfarhan]]></dc:creator>
		<pubDate>Wed, 06 Aug 2008 12:46:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-762</guid>
					<description><![CDATA[i&#039;ve not much experience in client app concurrency and admittedly I&#039;m not very interested in it either. But I love your writing and the anology you&#039;ve given and read the post the whole way through.. 

great work.]]></description>
		<content:encoded><![CDATA[<p>i&#8217;ve not much experience in client app concurrency and admittedly I&#8217;m not very interested in it either. But I love your writing and the anology you&#8217;ve given and read the post the whole way through.. </p>
<p>great work.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Top Posts &#171; WordPress.com				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-758</link>
		<dc:creator><![CDATA[Top Posts &#171; WordPress.com]]></dc:creator>
		<pubDate>Wed, 06 Aug 2008 00:06:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-758</guid>
					<description><![CDATA[[...]  Server Concurrency != Client Concurrency Today I received an email that asked: [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;]  Server Concurrency != Client Concurrency Today I received an email that asked: [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Keith Long				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-757</link>
		<dc:creator><![CDATA[Keith Long]]></dc:creator>
		<pubDate>Tue, 05 Aug 2008 20:11:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-757</guid>
					<description><![CDATA[I agree with the above comments, but client side concurrency more important than server-side.  I can&#039;t see this, with a large amount of client-side code being developed for either the browser or flex that are single-threaded languages, I&#039;ve never heard anyone complaining!

On the server-side for transaction true the server does automatically use the processing power when multiple users are accessing it. 

The reality how many people write applications that care about client-side performance like GIS, Game Development, Graphics packages? The sad fact is most of us write bespoke business applications.

In finance the biggest problem is long batch runs that can be solved by using concurrency.  Nobody really cares if it takes a few seconds for a transaction to go through, but they do start caring when the nightly process runs contract by contract and starts to creap into the start of the new working day.]]></description>
		<content:encoded><![CDATA[<p>I agree with the above comments, but client side concurrency more important than server-side.  I can&#8217;t see this, with a large amount of client-side code being developed for either the browser or flex that are single-threaded languages, I&#8217;ve never heard anyone complaining!</p>
<p>On the server-side for transaction true the server does automatically use the processing power when multiple users are accessing it. </p>
<p>The reality how many people write applications that care about client-side performance like GIS, Game Development, Graphics packages? The sad fact is most of us write bespoke business applications.</p>
<p>In finance the biggest problem is long batch runs that can be solved by using concurrency.  Nobody really cares if it takes a few seconds for a transaction to go through, but they do start caring when the nightly process runs contract by contract and starts to creap into the start of the new working day.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jason Dusek				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-756</link>
		<dc:creator><![CDATA[Jason Dusek]]></dc:creator>
		<pubDate>Tue, 05 Aug 2008 03:36:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-756</guid>
					<description><![CDATA[Haskell&#039;s STM is an implementation of transactional memory that relies on the type system to detect &quot;shared&quot; operations and ensure they operate in a multi-view concurreny style.

  http://research.microsoft.com/~simonpj/papers/stm/#beautiful]]></description>
		<content:encoded><![CDATA[<p>Haskell&#8217;s STM is an implementation of transactional memory that relies on the type system to detect &#8220;shared&#8221; operations and ensure they operate in a multi-view concurreny style.</p>
<p>  <a href="http://research.microsoft.com/~simonpj/papers/stm/#beautiful" rel="nofollow">http://research.microsoft.com/~simonpj/papers/stm/#beautiful</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul Keeble				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-755</link>
		<dc:creator><![CDATA[Paul Keeble]]></dc:creator>
		<pubDate>Mon, 04 Aug 2008 21:10:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-755</guid>
					<description><![CDATA[I&#039;m not convinced this is only a client side problem. Although its easy to put many users through a server side app that means there is a limited amount of processing that can be done for anyone user. We likely have the same single threaded performance for the next 5 years.

On that basis the most complex an app can be is set to about 0.5 seconds of processing (web app). What a frightening thought.

Scalability in data is still a big problem, the relational database is in need of a lot more parrallel processing. We&#039;re not done yet needing faster algorithms, we could certainly use them.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not convinced this is only a client side problem. Although its easy to put many users through a server side app that means there is a limited amount of processing that can be done for anyone user. We likely have the same single threaded performance for the next 5 years.</p>
<p>On that basis the most complex an app can be is set to about 0.5 seconds of processing (web app). What a frightening thought.</p>
<p>Scalability in data is still a big problem, the relational database is in need of a lot more parrallel processing. We&#8217;re not done yet needing faster algorithms, we could certainly use them.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: vu64				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-754</link>
		<dc:creator><![CDATA[vu64]]></dc:creator>
		<pubDate>Mon, 04 Aug 2008 01:42:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-754</guid>
					<description><![CDATA[I think Herb&#039;s working on a new book &quot;Effective Concurrency&quot;. I hope he&#039;ll cover the topics you mentioned.]]></description>
		<content:encoded><![CDATA[<p>I think Herb&#8217;s working on a new book &#8220;Effective Concurrency&#8221;. I hope he&#8217;ll cover the topics you mentioned.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Giuseppe				</title>
				<link>https://herbsutter.com/2008/08/01/server-concurrency-client-concurrency/#comment-748</link>
		<dc:creator><![CDATA[Giuseppe]]></dc:creator>
		<pubDate>Sat, 02 Aug 2008 11:34:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/08/01/server-concurrency-client-concurrency/#comment-748</guid>
					<description><![CDATA[Dear Herb,

you are right regarding the much greater difficulties in making client code concurrent. You cite &quot;library&quot; or &quot;language&quot; approaches to the problem. 

I think that a &quot;pattern&quot; approach would also be very much desirable. There are a few common ways of parallelizing sequential code. Maybe starting to collect these approaches from practical experiences, abstracting patterns, and publishing them is the most correct approach at this stage. 

Can you cite anybody that is following this approach?]]></description>
		<content:encoded><![CDATA[<p>Dear Herb,</p>
<p>you are right regarding the much greater difficulties in making client code concurrent. You cite &#8220;library&#8221; or &#8220;language&#8221; approaches to the problem. </p>
<p>I think that a &#8220;pattern&#8221; approach would also be very much desirable. There are a few common ways of parallelizing sequential code. Maybe starting to collect these approaches from practical experiences, abstracting patterns, and publishing them is the most correct approach at this stage. </p>
<p>Can you cite anybody that is following this approach?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
