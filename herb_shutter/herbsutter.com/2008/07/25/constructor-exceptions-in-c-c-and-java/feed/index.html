<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Constructor Exceptions in C++, C#, and Java	</title>
	<atom:link href="https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: iresha				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1640</link>
		<dc:creator><![CDATA[iresha]]></dc:creator>
		<pubDate>Fri, 01 Jan 2010 00:12:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1640</guid>
					<description><![CDATA[This is really good to know as I can see this as an interview question. Thanks!]]></description>
		<content:encoded><![CDATA[<p>This is really good to know as I can see this as an interview question. Thanks!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1475</link>
		<dc:creator><![CDATA[David]]></dc:creator>
		<pubDate>Tue, 15 Sep 2009 00:10:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1475</guid>
					<description><![CDATA[Whoa, there. For Java it seems that finalizers do run if the constructor throws an exception.

The wording in the JLS for object creation says that, after allocation, the initialization either &quot;completes abruptly&quot; or &quot;completes normally&quot;. Then the section on finalization says:

&quot;The completion of an object&#039;s constructor happens-before (§17.4.5) the execution of its finalize method (in the formal sense of happens-before).&quot;

And that&#039;s all it says. The word &quot;completion&quot; is not qualified, so I could infer that finalizers always run after any completion, including the &quot;abrupt completion&quot; when a constructor throws an exception.

It&#039;s a little sloppy because the section on creation makes a careful distinction between field initialization and the constructors. (Because of that I could also infer that if a field initialization fails then maybe the finalizer isn&#039;t run?)

References: Java Language Specification (3rd ed), sections 12.5 and 12.6]]></description>
		<content:encoded><![CDATA[<p>Whoa, there. For Java it seems that finalizers do run if the constructor throws an exception.</p>
<p>The wording in the JLS for object creation says that, after allocation, the initialization either &#8220;completes abruptly&#8221; or &#8220;completes normally&#8221;. Then the section on finalization says:</p>
<p>&#8220;The completion of an object&#8217;s constructor happens-before (§17.4.5) the execution of its finalize method (in the formal sense of happens-before).&#8221;</p>
<p>And that&#8217;s all it says. The word &#8220;completion&#8221; is not qualified, so I could infer that finalizers always run after any completion, including the &#8220;abrupt completion&#8221; when a constructor throws an exception.</p>
<p>It&#8217;s a little sloppy because the section on creation makes a careful distinction between field initialization and the constructors. (Because of that I could also infer that if a field initialization fails then maybe the finalizer isn&#8217;t run?)</p>
<p>References: Java Language Specification (3rd ed), sections 12.5 and 12.6</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jared				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1468</link>
		<dc:creator><![CDATA[Jared]]></dc:creator>
		<pubDate>Thu, 10 Sep 2009 17:04:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1468</guid>
					<description><![CDATA[This article is incorrect. Finalizers in C# WILL be called even if an exception is thrown in the constructor.]]></description>
		<content:encoded><![CDATA[<p>This article is incorrect. Finalizers in C# WILL be called even if an exception is thrown in the constructor.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Patrice Roy				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1108</link>
		<dc:creator><![CDATA[Patrice Roy]]></dc:creator>
		<pubDate>Wed, 25 Feb 2009 22:33:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-1108</guid>
					<description><![CDATA[A colleague of mine uses C# these days and thought along the same lines you (and I) do. The problem he has is that something like this, in C#, prints out «Dead!» (same effect with IDisposable and Dispose(), BTW). Maybe I&#039;m missing something, but my understanding was that C#&#039;s finalizer (~X() in this case) would not be called, X&#039;s constructor having never completed normally, but the fact is: it is called and it does print... Any thoughts?

using System;

namespace Whatever
{
   class Program
   {
      public class X
      {
         public X()
         {
            throw new Exception();
         }
         ~X()
         {
            Console.WriteLine(&quot;Dead!&quot;);
         }
      }
      static void Main(string[] args)
      {
         try
         {
            X x = new X();
         }
         catch (Exception)
         {
         }
      }
   }
}]]></description>
		<content:encoded><![CDATA[<p>A colleague of mine uses C# these days and thought along the same lines you (and I) do. The problem he has is that something like this, in C#, prints out «Dead!» (same effect with IDisposable and Dispose(), BTW). Maybe I&#8217;m missing something, but my understanding was that C#&#8217;s finalizer (~X() in this case) would not be called, X&#8217;s constructor having never completed normally, but the fact is: it is called and it does print&#8230; Any thoughts?</p>
<p>using System;</p>
<p>namespace Whatever<br />
{<br />
   class Program<br />
   {<br />
      public class X<br />
      {<br />
         public X()<br />
         {<br />
            throw new Exception();<br />
         }<br />
         ~X()<br />
         {<br />
            Console.WriteLine(&#8220;Dead!&#8221;);<br />
         }<br />
      }<br />
      static void Main(string[] args)<br />
      {<br />
         try<br />
         {<br />
            X x = new X();<br />
         }<br />
         catch (Exception)<br />
         {<br />
         }<br />
      }<br />
   }<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Shahzad Afzal				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-932</link>
		<dc:creator><![CDATA[Shahzad Afzal]]></dc:creator>
		<pubDate>Wed, 17 Dec 2008 13:25:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-932</guid>
					<description><![CDATA[Hmmm very interesting post and lot of healthy information. 
I was looking for what to do in we got exception in constructor or destructor?

;) actually this questions was asked in my today interview that time i didn&#039;t know at all.

Now after reading the post......... i got good info.
Thanks you all.......]]></description>
		<content:encoded><![CDATA[<p>Hmmm very interesting post and lot of healthy information.<br />
I was looking for what to do in we got exception in constructor or destructor?</p>
<p>;) actually this questions was asked in my today interview that time i didn&#8217;t know at all.</p>
<p>Now after reading the post&#8230;&#8230;&#8230; i got good info.<br />
Thanks you all&#8230;&#8230;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Julian				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-914</link>
		<dc:creator><![CDATA[Julian]]></dc:creator>
		<pubDate>Tue, 18 Nov 2008 09:41:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-914</guid>
					<description><![CDATA[Very interesting post!

I was actually searching for something else but i stopped a moment to read your point.

Julian]]></description>
		<content:encoded><![CDATA[<p>Very interesting post!</p>
<p>I was actually searching for something else but i stopped a moment to read your point.</p>
<p>Julian</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thiago Delgado Pinto				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-801</link>
		<dc:creator><![CDATA[Thiago Delgado Pinto]]></dc:creator>
		<pubDate>Sun, 21 Sep 2008 21:50:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-801</guid>
					<description><![CDATA[In C++, the delete operator already checks for null pointer.

So,

if ( ptr != NULL ) delete ptr;

is redundant.

Use

delete ptr;

directly instead.]]></description>
		<content:encoded><![CDATA[<p>In C++, the delete operator already checks for null pointer.</p>
<p>So,</p>
<p>if ( ptr != NULL ) delete ptr;</p>
<p>is redundant.</p>
<p>Use</p>
<p>delete ptr;</p>
<p>directly instead.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: oleg				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-800</link>
		<dc:creator><![CDATA[oleg]]></dc:creator>
		<pubDate>Thu, 11 Sep 2008 23:17:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-800</guid>
					<description><![CDATA[If call the constructor which has an exception handling, how would I inform the caller about the exception? Should I then include try catch in caller? And what type of exceptions I should be prepared to deal with?

The intention is to create an Object which will analyze on its own whether data source exists and if it is not, fails and informs caller about this.

Lets say:
class FileProcessing{
 public FileProcessing(string fName)
 {
   try{  
      StreamReader sr = new StreamReader(fName);
    }
    catch(FileNotFoundException fnfex)
    {
    }

 }
 public ReplaceOldNames()
 {
 }
}

Should I generate custom exception? Or it is a way to pass FileNotFoundException ?

Thank you]]></description>
		<content:encoded><![CDATA[<p>If call the constructor which has an exception handling, how would I inform the caller about the exception? Should I then include try catch in caller? And what type of exceptions I should be prepared to deal with?</p>
<p>The intention is to create an Object which will analyze on its own whether data source exists and if it is not, fails and informs caller about this.</p>
<p>Lets say:<br />
class FileProcessing{<br />
 public FileProcessing(string fName)<br />
 {<br />
   try{<br />
      StreamReader sr = new StreamReader(fName);<br />
    }<br />
    catch(FileNotFoundException fnfex)<br />
    {<br />
    }</p>
<p> }<br />
 public ReplaceOldNames()<br />
 {<br />
 }<br />
}</p>
<p>Should I generate custom exception? Or it is a way to pass FileNotFoundException ?</p>
<p>Thank you</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marko				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-797</link>
		<dc:creator><![CDATA[Marko]]></dc:creator>
		<pubDate>Fri, 05 Sep 2008 23:11:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-797</guid>
					<description><![CDATA[what&#039;s with using dispose for C#? Dispose is not the destructor (C# has the same ~ syntax as C++ for destructors). The dispose method will never get called by the GC. user code has to explicitly call it like you did with the using syntax. GC calls the C# destructor (aka finalizer) when cleaning up the object which DOES get called even when the constructor throws an exception.

dispose was meant for unmanaged resources which have to be manually released as the GC does not know about them.

i thought i had a pretty good handle on finalize/dispose but i&#039;m confused now...]]></description>
		<content:encoded><![CDATA[<p>what&#8217;s with using dispose for C#? Dispose is not the destructor (C# has the same ~ syntax as C++ for destructors). The dispose method will never get called by the GC. user code has to explicitly call it like you did with the using syntax. GC calls the C# destructor (aka finalizer) when cleaning up the object which DOES get called even when the constructor throws an exception.</p>
<p>dispose was meant for unmanaged resources which have to be manually released as the GC does not know about them.</p>
<p>i thought i had a pretty good handle on finalize/dispose but i&#8217;m confused now&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jonas				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-790</link>
		<dc:creator><![CDATA[Jonas]]></dc:creator>
		<pubDate>Sun, 24 Aug 2008 11:24:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-790</guid>
					<description><![CDATA[One differense that has bitten me in C# here is that in C++ all member and base object whose constructor has run will have its destructor run . But that will not be the case for a C# using statement.]]></description>
		<content:encoded><![CDATA[<p>One differense that has bitten me in C# here is that in C++ all member and base object whose constructor has run will have its destructor run . But that will not be the case for a C# using statement.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mateusz Loskot				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-789</link>
		<dc:creator><![CDATA[Mateusz Loskot]]></dc:creator>
		<pubDate>Sat, 23 Aug 2008 07:03:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-789</guid>
					<description><![CDATA[Herb,

Thanks for the great article, especially comparison to C# and Java. I&#039;ve learned a lot.

However, it&#039;s still unclear to me what consequences are expected in C# and Java from not calling disposer on Widget when Gadgets construction does not complete. 

In C++, the situation is clear: memory allocated for Widget leaks. What happen with Widget in C# and Java? Isn&#039;t it collected at some point?]]></description>
		<content:encoded><![CDATA[<p>Herb,</p>
<p>Thanks for the great article, especially comparison to C# and Java. I&#8217;ve learned a lot.</p>
<p>However, it&#8217;s still unclear to me what consequences are expected in C# and Java from not calling disposer on Widget when Gadgets construction does not complete. </p>
<p>In C++, the situation is clear: memory allocated for Widget leaks. What happen with Widget in C# and Java? Isn&#8217;t it collected at some point?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Oleksii Skidan				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-776</link>
		<dc:creator><![CDATA[Oleksii Skidan]]></dc:creator>
		<pubDate>Tue, 12 Aug 2008 13:14:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-776</guid>
					<description><![CDATA[Beg your pardon, the dele operator in the catch block shall look like this of course: delete [] foo_; -)]]></description>
		<content:encoded><![CDATA[<p>Beg your pardon, the dele operator in the catch block shall look like this of course: delete [] foo_; -)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Oleksii Skidan				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-774</link>
		<dc:creator><![CDATA[Oleksii Skidan]]></dc:creator>
		<pubDate>Tue, 12 Aug 2008 08:45:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-774</guid>
					<description><![CDATA[Oops, the HTML tags seems to eat up my include directive :-) It&#039;s iostream.

Cheers,
Oleksii Skidan]]></description>
		<content:encoded><![CDATA[<p>Oops, the HTML tags seems to eat up my include directive :-) It&#8217;s iostream.</p>
<p>Cheers,<br />
Oleksii Skidan</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Oleksii Skidan				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-773</link>
		<dc:creator><![CDATA[Oleksii Skidan]]></dc:creator>
		<pubDate>Tue, 12 Aug 2008 08:44:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-773</guid>
					<description><![CDATA[Hi Herb,

There&#039;s a little exception to the rule. It&#039;s the operator new [] ;-) For example, let&#039;s take into consideration the following code:

#include    

template void unused(const T) {}

class Foo
{
public:
    static int nctors;
    static int ndtors;

    Foo()
    {
        if(maxn &#060;= Foo::n++)
        {
            throw 3;
        }

        std::cout&#060;&#060;__PRETTY_FUNCTION__&#060;&#060;&quot;: Succeeded\n&quot;;

        ++Foo::nctors;
    }

    ~Foo()
    {
        std::cout&#060;&#060;__PRETTY_FUNCTION__&#060;&#060;&quot;: Called\n&quot;;

        ++Foo::ndtors;
    }
private:
    static int n;
    static const int maxn = 210;
};

int Foo::n      = 0;
int Foo::nctors = 0;
int Foo::ndtors = 0;

class Bar
{
public:
    // We&#039;ll certanly call destructors for constructed objects...
    Bar()
        : foo_(new Foo[300])
    {
        std::cout&#060;&#060;__PRETTY_FUNCTION__&#060;&#060;&quot;: Succeeded\n&quot;;
    }

    ~Bar()
    {
        std::cout&#060;&#060;__PRETTY_FUNCTION__&#060;&#060;&quot;: Called\n&quot;;
    }
private:
    Foo* foo_;
};

int main()
{
    try
    {
        Bar bar;

        unused(bar);
    }
    catch(...) {}

    std::cout&#060;&#060;&quot;Foo constructors called: &quot;&#060;&#060;Foo::nctors&#060;&#060;std::endl;
    std::cout&#060;&#060;&quot;Foo destructors  called: &quot;&#060;&#060;Foo::ndtors&#060;&#060;std::endl;
}

I&#039;ll throw away all the blah succeeded/called and leave only the output of the last two lines of main():

Foo constructors called: 210
Foo destructors  called: 210

Let&#039;s examine the code. The Bar did never exist just like poor Parrot ;-) But Foo::~Foo was called (a bit like paradox). I guess you should point this out in your Exceptional C++ books. It&#039;s quite possible that a novice programmer will try to write something like that:

Bar()
try
    : foo_(new Foo[300])
{
    std::cout&#060;&#060;__PRETTY_FUNCTION__&#060;&#060;&quot;: Succeeded\n&quot;;
}
catch(...)
{
    delete foo_;    ///&#060; Oh no! Gush, my compiler gone crazy 8-)
}


Regards,
Oleksii Skidan]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>There&#8217;s a little exception to the rule. It&#8217;s the operator new [] ;-) For example, let&#8217;s take into consideration the following code:</p>
<p>#include    </p>
<p>template void unused(const T) {}</p>
<p>class Foo<br />
{<br />
public:<br />
    static int nctors;<br />
    static int ndtors;</p>
<p>    Foo()<br />
    {<br />
        if(maxn &lt;= Foo::n++)<br />
        {<br />
            throw 3;<br />
        }</p>
<p>        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;&#8220;: Succeeded\n&#8221;;</p>
<p>        ++Foo::nctors;<br />
    }</p>
<p>    ~Foo()<br />
    {<br />
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;&#8220;: Called\n&#8221;;</p>
<p>        ++Foo::ndtors;<br />
    }<br />
private:<br />
    static int n;<br />
    static const int maxn = 210;<br />
};</p>
<p>int Foo::n      = 0;<br />
int Foo::nctors = 0;<br />
int Foo::ndtors = 0;</p>
<p>class Bar<br />
{<br />
public:<br />
    // We&#8217;ll certanly call destructors for constructed objects&#8230;<br />
    Bar()<br />
        : foo_(new Foo[300])<br />
    {<br />
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;&#8220;: Succeeded\n&#8221;;<br />
    }</p>
<p>    ~Bar()<br />
    {<br />
        std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;&#8220;: Called\n&#8221;;<br />
    }<br />
private:<br />
    Foo* foo_;<br />
};</p>
<p>int main()<br />
{<br />
    try<br />
    {<br />
        Bar bar;</p>
<p>        unused(bar);<br />
    }<br />
    catch(&#8230;) {}</p>
<p>    std::cout&lt;&lt;&#8220;Foo constructors called: &#8220;&lt;&lt;Foo::nctors&lt;&lt;std::endl;<br />
    std::cout&lt;&lt;&#8220;Foo destructors  called: &#8220;&lt;&lt;Foo::ndtors&lt;&lt;std::endl;<br />
}</p>
<p>I&#8217;ll throw away all the blah succeeded/called and leave only the output of the last two lines of main():</p>
<p>Foo constructors called: 210<br />
Foo destructors  called: 210</p>
<p>Let&#8217;s examine the code. The Bar did never exist just like poor Parrot ;-) But Foo::~Foo was called (a bit like paradox). I guess you should point this out in your Exceptional C++ books. It&#8217;s quite possible that a novice programmer will try to write something like that:</p>
<p>Bar()<br />
try<br />
    : foo_(new Foo[300])<br />
{<br />
    std::cout&lt;&lt;__PRETTY_FUNCTION__&lt;&lt;&#8220;: Succeeded\n&#8221;;<br />
}<br />
catch(&#8230;)<br />
{<br />
    delete foo_;    ///&lt; Oh no! Gush, my compiler gone crazy 8-)<br />
}</p>
<p>Regards,<br />
Oleksii Skidan</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: augustinus				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-746</link>
		<dc:creator><![CDATA[augustinus]]></dc:creator>
		<pubDate>Fri, 01 Aug 2008 13:44:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-746</guid>
					<description><![CDATA[Hi ActionMan,

   Thank you, I&#039;ll double check my poor memo.]]></description>
		<content:encoded><![CDATA[<p>Hi ActionMan,</p>
<p>   Thank you, I&#8217;ll double check my poor memo.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ActionMan				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-742</link>
		<dc:creator><![CDATA[ActionMan]]></dc:creator>
		<pubDate>Tue, 29 Jul 2008 00:14:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-742</guid>
					<description><![CDATA[Augustinus, 
deleting a null pointer should only cause an access violation in VS6.

VS7/8/9 all perform the correct behaviour as Herb stated.]]></description>
		<content:encoded><![CDATA[<p>Augustinus,<br />
deleting a null pointer should only cause an access violation in VS6.</p>
<p>VS7/8/9 all perform the correct behaviour as Herb stated.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: #aaron				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-741</link>
		<dc:creator><![CDATA[#aaron]]></dc:creator>
		<pubDate>Mon, 28 Jul 2008 17:35:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-741</guid>
					<description><![CDATA[Note:  in previous post, &quot;auto_ptr w;&quot; should have read &quot;auto_ptr LT Widget GT w;&quot;, where LT and GT are the less-than and greater-than symbols respectively (comment form bug).]]></description>
		<content:encoded><![CDATA[<p>Note:  in previous post, &#8220;auto_ptr w;&#8221; should have read &#8220;auto_ptr LT Widget GT w;&#8221;, where LT and GT are the less-than and greater-than symbols respectively (comment form bug).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: #aaron				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-740</link>
		<dc:creator><![CDATA[#aaron]]></dc:creator>
		<pubDate>Mon, 28 Jul 2008 17:34:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-740</guid>
					<description><![CDATA[Herb, 

The deck was stacked for the C++ example.  A smart pointer would solve this problem (performing the cleanup that the original author intended):

// C++ w RAII
class Gadget {
   std::auto_ptr w;

public:
   Gadget() {
     w.reset(new Widget());
     throw new exception();
     // … or some API call might throw
   };

   ~Gadget() {
     // nothing to do, auto_ptr will always delete
     // the widget, even if the destructor isn&#039;t invoked.
   }
};

// C# (equivalent)
class Gadget : IDisposable {
   private Widget w;

   public Gadget() {
     bool complete = false;
     try{
       w = new Widget();
       throw new Exception();
       // … or some API call might throw
       complete=true;
     }finally{
       
       if(!complete)
       { 
         // manually invoke cleanup on base class
         // and on each member object
         if(w != null) w.Dispose();
       }
     }
   };

   public void Dispose() {
     // … eliding other mechanics, eventually calls:
     if( w != null ) w.Dispose();
     // or just “w = null;” if Widget isn’t IDisposable
   }
};


#aaron]]></description>
		<content:encoded><![CDATA[<p>Herb, </p>
<p>The deck was stacked for the C++ example.  A smart pointer would solve this problem (performing the cleanup that the original author intended):</p>
<p>// C++ w RAII<br />
class Gadget {<br />
   std::auto_ptr w;</p>
<p>public:<br />
   Gadget() {<br />
     w.reset(new Widget());<br />
     throw new exception();<br />
     // … or some API call might throw<br />
   };</p>
<p>   ~Gadget() {<br />
     // nothing to do, auto_ptr will always delete<br />
     // the widget, even if the destructor isn&#8217;t invoked.<br />
   }<br />
};</p>
<p>// C# (equivalent)<br />
class Gadget : IDisposable {<br />
   private Widget w;</p>
<p>   public Gadget() {<br />
     bool complete = false;<br />
     try{<br />
       w = new Widget();<br />
       throw new Exception();<br />
       // … or some API call might throw<br />
       complete=true;<br />
     }finally{</p>
<p>       if(!complete)<br />
       {<br />
         // manually invoke cleanup on base class<br />
         // and on each member object<br />
         if(w != null) w.Dispose();<br />
       }<br />
     }<br />
   };</p>
<p>   public void Dispose() {<br />
     // … eliding other mechanics, eventually calls:<br />
     if( w != null ) w.Dispose();<br />
     // or just “w = null;” if Widget isn’t IDisposable<br />
   }<br />
};</p>
<p>#aaron</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: augustinus				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-739</link>
		<dc:creator><![CDATA[augustinus]]></dc:creator>
		<pubDate>Mon, 28 Jul 2008 11:12:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-739</guid>
					<description><![CDATA[Hi Herb,

    Sorry for bothering, please %s/quiet/quite/g in my recent comments, thank you]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>    Sorry for bothering, please %s/quiet/quite/g in my recent comments, thank you</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: augustinus				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-738</link>
		<dc:creator><![CDATA[augustinus]]></dc:creator>
		<pubDate>Mon, 28 Jul 2008 11:09:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-738</guid>
					<description><![CDATA[Hi Herb,

    Or I suspect that access violation is actually coming from deleting a null memory address of the pointer itself, not a null pointer?]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>    Or I suspect that access violation is actually coming from deleting a null memory address of the pointer itself, not a null pointer?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: augustinus				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-737</link>
		<dc:creator><![CDATA[augustinus]]></dc:creator>
		<pubDate>Mon, 28 Jul 2008 11:04:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-737</guid>
					<description><![CDATA[Hi Herb,

    I&#039;m not quiet sure that it&#039;s always true to say &quot;Delete is a no-op if the pointer passed to it is null,&quot; isn&#039;t it usually getting access violation with VS2005/VC8 ?]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>    I&#8217;m not quiet sure that it&#8217;s always true to say &#8220;Delete is a no-op if the pointer passed to it is null,&#8221; isn&#8217;t it usually getting access violation with VS2005/VC8 ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-736</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Mon, 28 Jul 2008 02:39:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-736</guid>
					<description><![CDATA[I think it&#039;s useful to point out that in C++, a common solution automatic destruction of members is to introduce a new base class, and then let the base manage object lifetimes.  This is done in several parts of the GNU STL implementation (such as std::vector).  I&#039;m pretty sure there&#039;s an example of this in &quot;[More] Exceptional C++&quot; as well.]]></description>
		<content:encoded><![CDATA[<p>I think it&#8217;s useful to point out that in C++, a common solution automatic destruction of members is to introduce a new base class, and then let the base manage object lifetimes.  This is done in several parts of the GNU STL implementation (such as std::vector).  I&#8217;m pretty sure there&#8217;s an example of this in &#8220;[More] Exceptional C++&#8221; as well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ian Reay &#187; Blog Archive &#187; Interesting Items (1)				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-731</link>
		<dc:creator><![CDATA[Ian Reay &#187; Blog Archive &#187; Interesting Items (1)]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 16:34:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-731</guid>
					<description><![CDATA[[...] Constructor Exceptions in C++, C#, and Java  [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Constructor Exceptions in C++, C#, and Java  [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jr				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-730</link>
		<dc:creator><![CDATA[jr]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 16:12:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-730</guid>
					<description><![CDATA[Laurentiu: your destructor in Base is not virtual. Thus the delete call will call Base::~Base() instead of Derived::~Derived()]]></description>
		<content:encoded><![CDATA[<p>Laurentiu: your destructor in Base is not virtual. Thus the delete call will call Base::~Base() instead of Derived::~Derived()</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-729</link>
		<dc:creator><![CDATA[Simon]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 15:52:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-729</guid>
					<description><![CDATA[&#062; C++ [...]
&#062; throw new exception();

You didn&#039;t really mean to throw a pointer here, did you? ;)]]></description>
		<content:encoded><![CDATA[<p>&gt; C++ [&#8230;]<br />
&gt; throw new exception();</p>
<p>You didn&#8217;t really mean to throw a pointer here, did you? ;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Laurentiu B.				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-728</link>
		<dc:creator><![CDATA[Laurentiu B.]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 13:43:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-728</guid>
					<description><![CDATA[15.2.2 in the C++ Language Specification says it clear: an object that is partially constructed will have destructors executed for all of its fully constructed subobjects.

But what about this example, which is like the OO &quot;Hello, world!&quot; escorted by the Goodbye message:

// ...

class Base {
public:
  Base()  { cout &#060;&#060; &quot;Hello from Base()&quot;  &#060;&#060; endl; }
  ~Base() { cout &#060;&#060; &quot;Goodbye from ~Base()&quot; &#060;&#060; endl; }
};

class Derived : public Base {
public:
  Derived()  { cout &#060;&#060; &quot;Hello from Derived()&quot;  &#060;&#060; endl; }
  ~Derived() { cout &#060;&#060; &quot;Nobody loves me&quot; &#060;&#060; endl; }
};

int main()
{
  Base *pbase = new Derived();
  delete pbase;
}

After the execution we&#039;ll have:

Hello from Base2()
Hello from Derived2()
Goodbye from ~Base2()

Don&#039;t we have a fully constructed object of type Derived? 

In the last paragraph of the section &quot;A Look At the Calling Code&quot; Mr. Sutter said (at a general level): &quot;[...] we can say for all cases: The destructor/dispose is guaranteed to be run if and only if the constructor completed successfully.&quot;
What if the Widget is derived from Gadget?
Then in the first case from the quoted section, if myGadget is dynamically allocated by new Widget(), the ~Widget() will not be called if the ~Gadget() isn&#039;t virtual.
In the second case, if the exception is thrown from Widget(), the destructor for Gadget is still called.

So, the successfully completeness of an object should be completed (mmm) with the storage location type (stack or heap) - considering that the storage is allocated before the object construction start - and with the proper use of the polymorphism rules.


Excuse my language. My English language.]]></description>
		<content:encoded><![CDATA[<p>15.2.2 in the C++ Language Specification says it clear: an object that is partially constructed will have destructors executed for all of its fully constructed subobjects.</p>
<p>But what about this example, which is like the OO &#8220;Hello, world!&#8221; escorted by the Goodbye message:</p>
<p>// &#8230;</p>
<p>class Base {<br />
public:<br />
  Base()  { cout &lt;&lt; &#8220;Hello from Base()&#8221;  &lt;&lt; endl; }<br />
  ~Base() { cout &lt;&lt; &#8220;Goodbye from ~Base()&#8221; &lt;&lt; endl; }<br />
};</p>
<p>class Derived : public Base {<br />
public:<br />
  Derived()  { cout &lt;&lt; &#8220;Hello from Derived()&#8221;  &lt;&lt; endl; }<br />
  ~Derived() { cout &lt;&lt; &#8220;Nobody loves me&#8221; &lt;&lt; endl; }<br />
};</p>
<p>int main()<br />
{<br />
  Base *pbase = new Derived();<br />
  delete pbase;<br />
}</p>
<p>After the execution we&#8217;ll have:</p>
<p>Hello from Base2()<br />
Hello from Derived2()<br />
Goodbye from ~Base2()</p>
<p>Don&#8217;t we have a fully constructed object of type Derived? </p>
<p>In the last paragraph of the section &#8220;A Look At the Calling Code&#8221; Mr. Sutter said (at a general level): &#8220;[&#8230;] we can say for all cases: The destructor/dispose is guaranteed to be run if and only if the constructor completed successfully.&#8221;<br />
What if the Widget is derived from Gadget?<br />
Then in the first case from the quoted section, if myGadget is dynamically allocated by new Widget(), the ~Widget() will not be called if the ~Gadget() isn&#8217;t virtual.<br />
In the second case, if the exception is thrown from Widget(), the destructor for Gadget is still called.</p>
<p>So, the successfully completeness of an object should be completed (mmm) with the storage location type (stack or heap) &#8211; considering that the storage is allocated before the object construction start &#8211; and with the proper use of the polymorphism rules.</p>
<p>Excuse my language. My English language.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Val				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-727</link>
		<dc:creator><![CDATA[Val]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 12:51:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-727</guid>
					<description><![CDATA[&quot;I’ve covered some of these concepts and consequences before in GotW #66, “Constructor Failures,” which appeared in updated and expanded form as Items 17 and 18 of More Exceptional C++.&quot; Herb Sutter

It&#039;s also covered in The C++ Programming Language/Special Edition/ by Stroustrup par 14.4.1]]></description>
		<content:encoded><![CDATA[<p>&#8220;I’ve covered some of these concepts and consequences before in GotW #66, “Constructor Failures,” which appeared in updated and expanded form as Items 17 and 18 of More Exceptional C++.&#8221; Herb Sutter</p>
<p>It&#8217;s also covered in The C++ Programming Language/Special Edition/ by Stroustrup par 14.4.1</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Motti				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-726</link>
		<dc:creator><![CDATA[Motti]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 07:46:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-726</guid>
					<description><![CDATA[Talking about differences between C++/Java/C# could you find the time to discuss the motivation for virtual function calls to behave differently in these languages? 
I found C++&#039;s way to be confusing at first glance but after a second thought it makes much more sense and I can&#039;t really understand Java/C#s&#039; choice.
(http://en.wikipedia.org/wiki/Virtual_functions#Behavior_During_Construction)]]></description>
		<content:encoded><![CDATA[<p>Talking about differences between C++/Java/C# could you find the time to discuss the motivation for virtual function calls to behave differently in these languages?<br />
I found C++&#8217;s way to be confusing at first glance but after a second thought it makes much more sense and I can&#8217;t really understand Java/C#s&#8217; choice.<br />
(<a href="http://en.wikipedia.org/wiki/Virtual_functions#Behavior_During_Construction" rel="nofollow">http://en.wikipedia.org/wiki/Virtual_functions#Behavior_During_Construction</a>)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jagan				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-725</link>
		<dc:creator><![CDATA[Jagan]]></dc:creator>
		<pubDate>Sun, 27 Jul 2008 01:51:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-725</guid>
					<description><![CDATA[Hi   ugasoft!
In that case Base is destructed no matter if the Derived object is a normal object or a pointer.]]></description>
		<content:encoded><![CDATA[<p>Hi   ugasoft!<br />
In that case Base is destructed no matter if the Derived object is a normal object or a pointer.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Heffernan				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-722</link>
		<dc:creator><![CDATA[David Heffernan]]></dc:creator>
		<pubDate>Sat, 26 Jul 2008 14:04:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-722</guid>
					<description><![CDATA[Jack:

You probably forgot to include override on your destructor (which has to be called Destroy).  Since it&#039;s called by the framework then you need this for it to be called.  But exceptions raised in a Delphi constructor do indeed result in the Destroy running.

The documentation say:

&quot;If an exception is raised during execution of a constructor that was invoked on a class reference, the Destroy destructor is automatically called to destroy the unfinished object.&quot;


You can also take look at the implementation of _ClassCreate in System.pas if you really don&#039;t believe that Delphi behaves in this way.

Actually this behaviour is great for the majority of resources that are created.  You have to be a little careful with non-native resources (e.g. system handles, windows etc.) but otherwise it means that exceptions in constructors can be dealt with easily.]]></description>
		<content:encoded><![CDATA[<p>Jack:</p>
<p>You probably forgot to include override on your destructor (which has to be called Destroy).  Since it&#8217;s called by the framework then you need this for it to be called.  But exceptions raised in a Delphi constructor do indeed result in the Destroy running.</p>
<p>The documentation say:</p>
<p>&#8220;If an exception is raised during execution of a constructor that was invoked on a class reference, the Destroy destructor is automatically called to destroy the unfinished object.&#8221;</p>
<p>You can also take look at the implementation of _ClassCreate in System.pas if you really don&#8217;t believe that Delphi behaves in this way.</p>
<p>Actually this behaviour is great for the majority of resources that are created.  You have to be a little careful with non-native resources (e.g. system handles, windows etc.) but otherwise it means that exceptions in constructors can be dealt with easily.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ugasoft				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-721</link>
		<dc:creator><![CDATA[ugasoft]]></dc:creator>
		<pubDate>Sat, 26 Jul 2008 10:47:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-721</guid>
					<description><![CDATA[Thank you Herb.
Can you explain what happen if the constructor of a derived class throw an exception, after the base subobject has been constructed?
Does the Berived object never exist? (probably it doesn&#039;t)
And what about the Base? (probably it does)

(I&#039;m a C++ programmer)]]></description>
		<content:encoded><![CDATA[<p>Thank you Herb.<br />
Can you explain what happen if the constructor of a derived class throw an exception, after the base subobject has been constructed?<br />
Does the Berived object never exist? (probably it doesn&#8217;t)<br />
And what about the Base? (probably it does)</p>
<p>(I&#8217;m a C++ programmer)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jack smith				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-720</link>
		<dc:creator><![CDATA[Jack smith]]></dc:creator>
		<pubDate>Sat, 26 Jul 2008 07:04:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-720</guid>
					<description><![CDATA[Thanks Barry because I was just exploring the varying same topic in Delphi.W32. Not sure if I have done something wrong. When I deliberately throw an exception in the constructor, the class&#039; destructor does not seem to be called. My trace never fired!

With respect to the acceptable practice of calling embedded object&#039;s Free() in the destructor, in C++ all fully constructor embedded objects are automatically destroyed; only partially constructed aren&#039;t.

Hence, as far as destruction is concerned, there isn&#039;t much difference between Delphi and C++.]]></description>
		<content:encoded><![CDATA[<p>Thanks Barry because I was just exploring the varying same topic in Delphi.W32. Not sure if I have done something wrong. When I deliberately throw an exception in the constructor, the class&#8217; destructor does not seem to be called. My trace never fired!</p>
<p>With respect to the acceptable practice of calling embedded object&#8217;s Free() in the destructor, in C++ all fully constructor embedded objects are automatically destroyed; only partially constructed aren&#8217;t.</p>
<p>Hence, as far as destruction is concerned, there isn&#8217;t much difference between Delphi and C++.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: orcmid				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-719</link>
		<dc:creator><![CDATA[orcmid]]></dc:creator>
		<pubDate>Sat, 26 Jul 2008 01:25:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-719</guid>
					<description><![CDATA[Yes, nice one, and Barry&#039;s comparison with Delphi is informative too.]]></description>
		<content:encoded><![CDATA[<p>Yes, nice one, and Barry&#8217;s comparison with Delphi is informative too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Jansson				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-718</link>
		<dc:creator><![CDATA[Peter Jansson]]></dc:creator>
		<pubDate>Fri, 25 Jul 2008 21:25:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-718</guid>
					<description><![CDATA[Hi, I just wanted to say thank you for this post. It has been of great value for me. Regards, Peter.]]></description>
		<content:encoded><![CDATA[<p>Hi, I just wanted to say thank you for this post. It has been of great value for me. Regards, Peter.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Barry Kelly				</title>
				<link>https://herbsutter.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-716</link>
		<dc:creator><![CDATA[Barry Kelly]]></dc:creator>
		<pubDate>Fri, 25 Jul 2008 20:59:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2008/07/25/constructor-exceptions-in-c-c-and-java/#comment-716</guid>
					<description><![CDATA[Here&#039;s an &quot;exception&quot; for you: Delphi.

When an exception is thrown in a Delphi constructor, the destructor is automatically called and the exception rethrown.

This works especially well in Delphi because of two object construction conventions:

* The memory for an object&#039;s fields is always zeroed out before the constructor is entered (TObject.InitInstance)
* The normal way to free an object in Delphi is to call the nonvirtual instance method TObject.Free, which will only invoke the destructor /if &quot;Self&quot; is not *nil*/.

Thus, it is safe to have a destructor that is a list of calls to &#039;.Free&#039; on fields referring to owned objects, even though many of those objects might not have been created yet when and if an exception gets thrown in the constructor.

Getting the same semantic behaviour in other languages that are less like Delphi can be somewhat painful, because exceptions thrown in constructors need special handling - you can&#039;t rely on destructor cleanup.]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s an &#8220;exception&#8221; for you: Delphi.</p>
<p>When an exception is thrown in a Delphi constructor, the destructor is automatically called and the exception rethrown.</p>
<p>This works especially well in Delphi because of two object construction conventions:</p>
<p>* The memory for an object&#8217;s fields is always zeroed out before the constructor is entered (TObject.InitInstance)<br />
* The normal way to free an object in Delphi is to call the nonvirtual instance method TObject.Free, which will only invoke the destructor /if &#8220;Self&#8221; is not *nil*/.</p>
<p>Thus, it is safe to have a destructor that is a list of calls to &#8216;.Free&#8217; on fields referring to owned objects, even though many of those objects might not have been created yet when and if an exception gets thrown in the constructor.</p>
<p>Getting the same semantic behaviour in other languages that are less like Delphi can be somewhat painful, because exceptions thrown in constructors need special handling &#8211; you can&#8217;t rely on destructor cleanup.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
