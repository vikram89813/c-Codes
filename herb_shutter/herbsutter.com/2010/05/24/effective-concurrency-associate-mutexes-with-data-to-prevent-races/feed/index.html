<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Effective Concurrency: Associate Mutexes with Data to Prevent Races	</title>
	<atom:link href="https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Todd Seiler &#187; Concurrency &#38; Parallelism				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2266</link>
		<dc:creator><![CDATA[Todd Seiler &#187; Concurrency &#38; Parallelism]]></dc:creator>
		<pubDate>Mon, 06 Sep 2010 06:08:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2266</guid>
					<description><![CDATA[[...] Multicore Articles http://docs.sun.com/app/docs/doc/816-5137 https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/ http://msdn.microsoft.com/en-us/library/ee416321.aspx [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Multicore Articles <a href="http://docs.sun.com/app/docs/doc/816-5137" rel="nofollow">http://docs.sun.com/app/docs/doc/816-5137</a> <a href="https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/" rel="nofollow">https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/</a> <a href="http://msdn.microsoft.com/en-us/library/ee416321.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/ee416321.aspx</a> [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2104</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 May 2010 01:03:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2104</guid>
					<description><![CDATA[Yes, that&#039;s a useful technique too. The tradeoff is that you then need a special lock type; in this design I decided to illustrate the technique in a way that hooks into the C++0x standard locks so that you can write things like lock_guard&#060;Group1&#062;; (see my reply to a later comment asking about this).]]></description>
		<content:encoded><![CDATA[<p>Yes, that&#8217;s a useful technique too. The tradeoff is that you then need a special lock type; in this design I decided to illustrate the technique in a way that hooks into the C++0x standard locks so that you can write things like lock_guard&lt;Group1&gt;; (see my reply to a later comment asking about this).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2103</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 May 2010 01:01:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2103</guid>
					<description><![CDATA[David is spot-on that you want mutexes to cover invariants, not just individual pieces of data. How to design the groups of data that should be covered by the same mutex (or, which mutexes protect which data) is the subject of another article. This article focuses only on the question of how to ensure that you then used the mutexes correctly.]]></description>
		<content:encoded><![CDATA[<p>David is spot-on that you want mutexes to cover invariants, not just individual pieces of data. How to design the groups of data that should be covered by the same mutex (or, which mutexes protect which data) is the subject of another article. This article focuses only on the question of how to ensure that you then used the mutexes correctly.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2102</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 May 2010 00:57:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2102</guid>
					<description><![CDATA[Re map: Yes, thank the Lords of Templates. For types like that, you write a typedef to get rid of the comma. Fun stuff.

Re lock_guard: Actually that is correct and slickly intended. The reason I wrote the group to provide lock/try_lock/unlock was specifically to make it satisfy the C++0x mutex concept, so that you can use the group itself with all the C++0x locking machinery including lock_guard&#060;Group1&#062;. Pretty snazzy, huh?]]></description>
		<content:encoded><![CDATA[<p>Re map: Yes, thank the Lords of Templates. For types like that, you write a typedef to get rid of the comma. Fun stuff.</p>
<p>Re lock_guard: Actually that is correct and slickly intended. The reason I wrote the group to provide lock/try_lock/unlock was specifically to make it satisfy the C++0x mutex concept, so that you can use the group itself with all the C++0x locking machinery including lock_guard&lt;Group1&gt;. Pretty snazzy, huh?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2101</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 May 2010 00:53:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2101</guid>
					<description><![CDATA[Right, that is the other (orthogonal) issue. As mentioned in the intro, this article focuses on eliminating races by associating data with locks; the earlier article focuses on exactly the issue eliminating deadlocks by using lock ordering to ensure locks are taken in a consistent order (typically, but not only, by using lock hierarchies). 

Both parts are necessary, and the techniques compose well.

In addition to races and deadlocks, there&#039;s actually a third issue: Composability. I intend to cover that one in a future article, possibly next month&#039;s.]]></description>
		<content:encoded><![CDATA[<p>Right, that is the other (orthogonal) issue. As mentioned in the intro, this article focuses on eliminating races by associating data with locks; the earlier article focuses on exactly the issue eliminating deadlocks by using lock ordering to ensure locks are taken in a consistent order (typically, but not only, by using lock hierarchies). </p>
<p>Both parts are necessary, and the techniques compose well.</p>
<p>In addition to races and deadlocks, there&#8217;s actually a third issue: Composability. I intend to cover that one in a future article, possibly next month&#8217;s.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2100</link>
		<dc:creator><![CDATA[Sebastian]]></dc:creator>
		<pubDate>Wed, 26 May 2010 18:24:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2100</guid>
					<description><![CDATA[The PROTECTED_MEMBER macro won&#039;t work for types like map &#060; int,int &#062; due to the comma. I see that you have put parenthesis around it but (map &#060; int,int &#062; ) isn&#039;t a type, is it?

Also, lock_guard &#060; Group1 &#062; doesn&#039;t seem correct. Group1 is not a mutex.]]></description>
		<content:encoded><![CDATA[<p>The PROTECTED_MEMBER macro won&#8217;t work for types like map &lt; int,int &gt; due to the comma. I see that you have put parenthesis around it but (map &lt; int,int &gt; ) isn&#8217;t a type, is it?</p>
<p>Also, lock_guard &lt; Group1 &gt; doesn&#8217;t seem correct. Group1 is not a mutex.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Trammell Hudson				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2099</link>
		<dc:creator><![CDATA[Trammell Hudson]]></dc:creator>
		<pubDate>Tue, 25 May 2010 23:30:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2099</guid>
					<description><![CDATA[One very important topic (from the &quot;Use Lock Hierarchies&quot; article) that this doesn&#039;t cover is lock ordering -- if one thread calls:

lock_guard hold(data1);
lock_guard hold(data2);

and another thread calls:

lock_guard hold(data2);
lock_guard hold(data1);

These will be &quot;correct&quot; in that the testcase won&#039;t complain, but the two threads will deadlock.  Sometimes.]]></description>
		<content:encoded><![CDATA[<p>One very important topic (from the &#8220;Use Lock Hierarchies&#8221; article) that this doesn&#8217;t cover is lock ordering &#8212; if one thread calls:</p>
<p>lock_guard hold(data1);<br />
lock_guard hold(data2);</p>
<p>and another thread calls:</p>
<p>lock_guard hold(data2);<br />
lock_guard hold(data1);</p>
<p>These will be &#8220;correct&#8221; in that the testcase won&#8217;t complain, but the two threads will deadlock.  Sometimes.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Svoboda				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2098</link>
		<dc:creator><![CDATA[David Svoboda]]></dc:creator>
		<pubDate>Tue, 25 May 2010 20:53:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2098</guid>
					<description><![CDATA[The previous comment is spot-on. Using mutexes to protect data is a good start, but it doesn&#039;t solve all problems. For instance, to use your &#039;transfer-element-between-tables&#039; example, this code:

  // lock mutTable1
  table1.erase( x );
  // unlock mutTable1
  // lock mutTable2
  table2.insert( x );
  // unlock mutTable2

would pass your &#039;protect-the-data&#039; test. It however fails the invariant that x is in either table1 or table2. For the purposes of your program, this may not be a problem. But it may be, in which case you need some lock that protects *both* table1 and table2.  But a better way to think about it is that your mutex would guarantee that any transfer between table1 and table2 was atomic...no observer could ever see that x was neither in table1 nor table2.

There is a lot of research in Java about making more general locks...for instance, the @GuardedBy annotation associates locks with data (essentially your approach). See this CERT secure coding rule in Java for more information about using annotations (along with analysis tools) to eliminate race conditions:

https://www.securecoding.cert.org/confluence/x/cwCMAg]]></description>
		<content:encoded><![CDATA[<p>The previous comment is spot-on. Using mutexes to protect data is a good start, but it doesn&#8217;t solve all problems. For instance, to use your &#8216;transfer-element-between-tables&#8217; example, this code:</p>
<p>  // lock mutTable1<br />
  table1.erase( x );<br />
  // unlock mutTable1<br />
  // lock mutTable2<br />
  table2.insert( x );<br />
  // unlock mutTable2</p>
<p>would pass your &#8216;protect-the-data&#8217; test. It however fails the invariant that x is in either table1 or table2. For the purposes of your program, this may not be a problem. But it may be, in which case you need some lock that protects *both* table1 and table2.  But a better way to think about it is that your mutex would guarantee that any transfer between table1 and table2 was atomic&#8230;no observer could ever see that x was neither in table1 nor table2.</p>
<p>There is a lot of research in Java about making more general locks&#8230;for instance, the @GuardedBy annotation associates locks with data (essentially your approach). See this CERT secure coding rule in Java for more information about using annotations (along with analysis tools) to eliminate race conditions:</p>
<p><a href="https://www.securecoding.cert.org/confluence/x/cwCMAg" rel="nofollow">https://www.securecoding.cert.org/confluence/x/cwCMAg</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Edd				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2097</link>
		<dc:creator><![CDATA[Edd]]></dc:creator>
		<pubDate>Tue, 25 May 2010 12:08:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2097</guid>
					<description><![CDATA[Rather than thinking of a mutex as protecting data, I prefer to think of them as protectors of invariants. Lock hierarchies then fall out naturally for invariants involving other invariants naturally. I suspect this distinction would also help in deciding which objects should go in to which &#039;MyData&#039; class.

I saw something similar on codeproject once, actually (can&#039;t find the link now). The approach taken then was to have something like a &#039;guardian&#039; class that holds a private MyData object and a mutex. To access the MyData object inside, you had to create a special kind of lock whose constructor took a reference to the guardian object. While the lock exists, the guardian&#039;s mutex would acquired as usual but the lock provided a get() method and overloaded the &#039;arrow operator&#039; to return a pointer to the MyData inside the guardian. In this way, you fundamentally could not get to the MyData object without holding the lock. This approach is even more race-free-by-construction as even the asserts aren&#039;t needed!

I could sketch this out in code, by I fear the commenting system will eat my C++ templates :)]]></description>
		<content:encoded><![CDATA[<p>Rather than thinking of a mutex as protecting data, I prefer to think of them as protectors of invariants. Lock hierarchies then fall out naturally for invariants involving other invariants naturally. I suspect this distinction would also help in deciding which objects should go in to which &#8216;MyData&#8217; class.</p>
<p>I saw something similar on codeproject once, actually (can&#8217;t find the link now). The approach taken then was to have something like a &#8216;guardian&#8217; class that holds a private MyData object and a mutex. To access the MyData object inside, you had to create a special kind of lock whose constructor took a reference to the guardian object. While the lock exists, the guardian&#8217;s mutex would acquired as usual but the lock provided a get() method and overloaded the &#8216;arrow operator&#8217; to return a pointer to the MyData inside the guardian. In this way, you fundamentally could not get to the MyData object without holding the lock. This approach is even more race-free-by-construction as even the asserts aren&#8217;t needed!</p>
<p>I could sketch this out in code, by I fear the commenting system will eat my C++ templates :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Leo Sutic				</title>
				<link>https://herbsutter.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2095</link>
		<dc:creator><![CDATA[Leo Sutic]]></dc:creator>
		<pubDate>Mon, 24 May 2010 22:07:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/05/24/effective-concurrency-associate-mutexes-with-data-to-prevent-races/#comment-2095</guid>
					<description><![CDATA[&quot;// use table1 and table2 (both are shared)
table1.erase( x );
table2.insert( x );

Quick: What locks should you take to make this code correct?&quot;

I know that the examples given in the EC series should be seen as illustrative and I don&#039;t want to detract from what the article is trying to teach, but I&#039;d just like to give one answer that I think is relevant for a completely different strategy: Lock x.

One way of getting concurrency in this case is to have a function 

    int lock_number(x)

that maps keys to any number of locks, and then lock mutex[lock_number(x)].

Then we know that relevant parts of both table1 and table2 are locked for the duration of the transaction. This assumes that the internals of table1 and table2 are written in such ways that they, too, are split according to the lock_number function.]]></description>
		<content:encoded><![CDATA[<p>&#8220;// use table1 and table2 (both are shared)<br />
table1.erase( x );<br />
table2.insert( x );</p>
<p>Quick: What locks should you take to make this code correct?&#8221;</p>
<p>I know that the examples given in the EC series should be seen as illustrative and I don&#8217;t want to detract from what the article is trying to teach, but I&#8217;d just like to give one answer that I think is relevant for a completely different strategy: Lock x.</p>
<p>One way of getting concurrency in this case is to have a function </p>
<p>    int lock_number(x)</p>
<p>that maps keys to any number of locks, and then lock mutex[lock_number(x)].</p>
<p>Then we know that relevant parts of both table1 and table2 are locked for the duration of the transaction. This assumes that the internals of table1 and table2 are written in such ways that they, too, are split according to the lock_number function.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
