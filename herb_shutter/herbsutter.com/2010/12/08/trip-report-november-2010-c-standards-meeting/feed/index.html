<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Trip Report: November 2010 C++ Standards Meeting	</title>
	<atom:link href="https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: C++0x完成最终草案国际标准(FDIS) &#171; Wooleon&#039;s Blog				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-3238</link>
		<dc:creator><![CDATA[C++0x完成最终草案国际标准(FDIS) &#171; Wooleon&#039;s Blog]]></dc:creator>
		<pubDate>Sat, 02 Jul 2011 15:16:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-3238</guid>
					<description><![CDATA[[...] spring 2011 ISO C++ meeting was held on March 21-25 in Madrid, Spain. As previously reported , the goal of this meeting was to finish responding to national body comments on the Final [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] spring 2011 ISO C++ meeting was held on March 21-25 in Madrid, Spain. As previously reported , the goal of this meeting was to finish responding to national body comments on the Final [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: We Have FDIS! (Trip Report: March 2011 C++ Standards Meeting) &#171; Sutter&#8217;s Mill				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2798</link>
		<dc:creator><![CDATA[We Have FDIS! (Trip Report: March 2011 C++ Standards Meeting) &#171; Sutter&#8217;s Mill]]></dc:creator>
		<pubDate>Sat, 26 Mar 2011 03:22:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2798</guid>
					<description><![CDATA[[...] spring 2011 ISO C++ meeting was held on March 21-25 in Madrid, Spain. As previously reported, the goal of this meeting was to finish responding to national body comments on the Final Committee [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] spring 2011 ISO C++ meeting was held on March 21-25 in Madrid, Spain. As previously reported, the goal of this meeting was to finish responding to national body comments on the Final Committee [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: James				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2777</link>
		<dc:creator><![CDATA[James]]></dc:creator>
		<pubDate>Sun, 23 Jan 2011 13:51:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2777</guid>
					<description><![CDATA[Never mind about the exception moves; I figured out why that would be bad.]]></description>
		<content:encoded><![CDATA[<p>Never mind about the exception moves; I figured out why that would be bad.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dalle				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2776</link>
		<dc:creator><![CDATA[Dalle]]></dc:creator>
		<pubDate>Sun, 23 Jan 2011 09:39:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2776</guid>
					<description><![CDATA[Yes, I know about pure virtual, but that makes the base class abstract. I want something which doesn&#039;t make the base class abstract, but still forces derived classes to implement a virtual function.

class B explicit {
   virtual B* clone() must_override {
      return new B(*this);
   }
};

class D : public B {
   virtual B* clone() must_override {
      return new D(*this);
   }
};

class F : public D {
}; // error as the clone function wasn&#039;t defined.]]></description>
		<content:encoded><![CDATA[<p>Yes, I know about pure virtual, but that makes the base class abstract. I want something which doesn&#8217;t make the base class abstract, but still forces derived classes to implement a virtual function.</p>
<p>class B explicit {<br />
   virtual B* clone() must_override {<br />
      return new B(*this);<br />
   }<br />
};</p>
<p>class D : public B {<br />
   virtual B* clone() must_override {<br />
      return new D(*this);<br />
   }<br />
};</p>
<p>class F : public D {<br />
}; // error as the clone function wasn&#8217;t defined.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: James				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2775</link>
		<dc:creator><![CDATA[James]]></dc:creator>
		<pubDate>Sun, 23 Jan 2011 05:38:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2775</guid>
					<description><![CDATA[Gah, that typo was supposed to be:

template  struct hash&#060;2string&#062;;]]></description>
		<content:encoded><![CDATA[<p>Gah, that typo was supposed to be:</p>
<p>template  struct hash&lt;2string&gt;;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: James				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2774</link>
		<dc:creator><![CDATA[James]]></dc:creator>
		<pubDate>Sun, 23 Jan 2011 05:35:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2774</guid>
					<description><![CDATA[Just a couple quick small things:

I&#039;ve been browsing through N3225, and it looks like the automatic move constructor and assignment method won&#039;t be generated for std::exception or derivatives (thanks to the new restrictions); is this intentional?  I also see that 15.3.16 still specifies that caught objects are copy-initialized from the thrown object; I&#039;d have thought this would be a great place for a move operation (particularly in low-memory situations, although admittedly exceptions tend to be pretty small).

Also, I noticed a typo on p. 645 in the  header synopsis:

template  struct hash;]]></description>
		<content:encoded><![CDATA[<p>Just a couple quick small things:</p>
<p>I&#8217;ve been browsing through N3225, and it looks like the automatic move constructor and assignment method won&#8217;t be generated for std::exception or derivatives (thanks to the new restrictions); is this intentional?  I also see that 15.3.16 still specifies that caught objects are copy-initialized from the thrown object; I&#8217;d have thought this would be a great place for a move operation (particularly in low-memory situations, although admittedly exceptions tend to be pretty small).</p>
<p>Also, I noticed a typo on p. 645 in the  header synopsis:</p>
<p>template  struct hash;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: James				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2773</link>
		<dc:creator><![CDATA[James]]></dc:creator>
		<pubDate>Sun, 23 Jan 2011 05:21:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2773</guid>
					<description><![CDATA[We already have pure virtual for that.  (Nothing says you can&#039;t provide an implementation; see 10.3.11.)

Or did you want something that doesn&#039;t also make the class abstract?]]></description>
		<content:encoded><![CDATA[<p>We already have pure virtual for that.  (Nothing says you can&#8217;t provide an implementation; see 10.3.11.)</p>
<p>Or did you want something that doesn&#8217;t also make the class abstract?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dalle				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2772</link>
		<dc:creator><![CDATA[Dalle]]></dc:creator>
		<pubDate>Sat, 22 Jan 2011 21:59:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2772</guid>
					<description><![CDATA[I&#039;m also guessing a very low probability for a `must_override` keyword? For virtual member functions which has implementation in base class, but must be overridden in derived classes, such as clone-functions.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m also guessing a very low probability for a `must_override` keyword? For virtual member functions which has implementation in base class, but must be overridden in derived classes, such as clone-functions.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Suncho				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2752</link>
		<dc:creator><![CDATA[Suncho]]></dc:creator>
		<pubDate>Mon, 10 Jan 2011 23:57:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2752</guid>
					<description><![CDATA[Wow.  This is crazy.  Am I the only one who doesn&#039;t like these virtual control attributes/keywords to begin with?  Can someone convince me (or link to an article convincing me) why these are good?  It seems to me that they make the language more complicated for very little benefit.  It&#039;s not usually that hard to debug code that accidentally hides or overrides a base-class function.

I can understand putting in attributes as compiler checks.  For example, the standard could recommend that compilers generate warning any time you hide or override a base-class function.  Then you can add attributes to the derived class functions to clarify your intentions kill the warnings.  Or perhaps, you could only have a warning for when a function not declared as virtual overrides a virtual function or when the base-class function has a [[final]] attribute.

@Herb Sutter - I completely agree with you that attributes should have no semantic effect on a program, but why was the answer to turn them into keywords?  Why wasn&#039;t the answer simply to remove their semantic effect?

Speaking of which, I&#039;m getting tired of keywords that have multiple meanings.  &#039;auto&#039; is bad enough, but it&#039;s somewhat acceptible because it&#039;s hardly ever used for its original meaning.  But now we have &#039;new&#039;, &#039;delete&#039;, and &#039;explicit&#039; meaning completely different things from what we&#039;re used to.  I can understand the reasoning behind this if people are dead-set against context-sensitive keywords and they&#039;re also dead-set against introducing new global keywords.  But if we&#039;re going to have context-sensitve keywords anyway, why not make them something unique and descriptive to add clarity?

@Dalle - To your first question: I hope not.  I hope these keywords have no effect on classes derived from base classes that use them.  Then again, I&#039;m kinda hoping they have no effect at all (except, perhaps, to disable warnings).

Similarly is it *REALLY* necessary for destructors to be noexcept by default?  I agree that all destructors should be noexcept, but should we make the language harder to use in order to achieve this goal?  By making it the default, we&#039;re making it so programmers have to learn that certain special functions (destructors) that behave differently when &quot;noexcept&quot; isn&#039;t specified.  Why not try to keep the language more consistent and therefore simpler?  Why not issue a warning if a destructor isn&#039;t marked &quot;noexcept,&quot; then if folks want to clean up their warnings, they&#039;ll have to add it themselves.

I can think of a lot of useful warnings to add that would catch plenty of errors and be easy to turn off using attributes.  For example, if a single-argument constructor isn&#039;t declared explicit, you could generate a warning unless the [[implicit]] attribute is used.  That&#039;s just off the top of my head.

p.s. Why is [[noreturn]] an attribute and noexcept a keyword?  Don&#039;t they both express similar things and allow for similar compiler optimizations?  IMO, they should both be attributes.  In either case, if the code is well-formed, they have no semantic effect.]]></description>
		<content:encoded><![CDATA[<p>Wow.  This is crazy.  Am I the only one who doesn&#8217;t like these virtual control attributes/keywords to begin with?  Can someone convince me (or link to an article convincing me) why these are good?  It seems to me that they make the language more complicated for very little benefit.  It&#8217;s not usually that hard to debug code that accidentally hides or overrides a base-class function.</p>
<p>I can understand putting in attributes as compiler checks.  For example, the standard could recommend that compilers generate warning any time you hide or override a base-class function.  Then you can add attributes to the derived class functions to clarify your intentions kill the warnings.  Or perhaps, you could only have a warning for when a function not declared as virtual overrides a virtual function or when the base-class function has a [[final]] attribute.</p>
<p>@Herb Sutter &#8211; I completely agree with you that attributes should have no semantic effect on a program, but why was the answer to turn them into keywords?  Why wasn&#8217;t the answer simply to remove their semantic effect?</p>
<p>Speaking of which, I&#8217;m getting tired of keywords that have multiple meanings.  &#8216;auto&#8217; is bad enough, but it&#8217;s somewhat acceptible because it&#8217;s hardly ever used for its original meaning.  But now we have &#8216;new&#8217;, &#8216;delete&#8217;, and &#8216;explicit&#8217; meaning completely different things from what we&#8217;re used to.  I can understand the reasoning behind this if people are dead-set against context-sensitive keywords and they&#8217;re also dead-set against introducing new global keywords.  But if we&#8217;re going to have context-sensitve keywords anyway, why not make them something unique and descriptive to add clarity?</p>
<p>@Dalle &#8211; To your first question: I hope not.  I hope these keywords have no effect on classes derived from base classes that use them.  Then again, I&#8217;m kinda hoping they have no effect at all (except, perhaps, to disable warnings).</p>
<p>Similarly is it *REALLY* necessary for destructors to be noexcept by default?  I agree that all destructors should be noexcept, but should we make the language harder to use in order to achieve this goal?  By making it the default, we&#8217;re making it so programmers have to learn that certain special functions (destructors) that behave differently when &#8220;noexcept&#8221; isn&#8217;t specified.  Why not try to keep the language more consistent and therefore simpler?  Why not issue a warning if a destructor isn&#8217;t marked &#8220;noexcept,&#8221; then if folks want to clean up their warnings, they&#8217;ll have to add it themselves.</p>
<p>I can think of a lot of useful warnings to add that would catch plenty of errors and be easy to turn off using attributes.  For example, if a single-argument constructor isn&#8217;t declared explicit, you could generate a warning unless the [[implicit]] attribute is used.  That&#8217;s just off the top of my head.</p>
<p>p.s. Why is [[noreturn]] an attribute and noexcept a keyword?  Don&#8217;t they both express similar things and allow for similar compiler optimizations?  IMO, they should both be attributes.  In either case, if the code is well-formed, they have no semantic effect.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2708</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 14 Dec 2010 20:02:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2708</guid>
					<description><![CDATA[We plan to work on TR2 (the second set of standard library extensions) right away as soon as C++0x is done. TR2 has one thing voted into it so far: file system iterators. Other likely candidates for inclusion in TR2 are reader-writer locks, thread pools, sockets, and other features.

As for concepts and modules, it depends entirely whether the people who originally proposed those features, or other experts, decide to return to work on them further to progress the proposals. In my own opinion, what each of these two features needs most at this point is some real-world experience to work through its design, to find and fix the design bugs and prove that the approach is solid.]]></description>
		<content:encoded><![CDATA[<p>We plan to work on TR2 (the second set of standard library extensions) right away as soon as C++0x is done. TR2 has one thing voted into it so far: file system iterators. Other likely candidates for inclusion in TR2 are reader-writer locks, thread pools, sockets, and other features.</p>
<p>As for concepts and modules, it depends entirely whether the people who originally proposed those features, or other experts, decide to return to work on them further to progress the proposals. In my own opinion, what each of these two features needs most at this point is some real-world experience to work through its design, to find and fix the design bugs and prove that the approach is solid.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rick Yorgason				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2705</link>
		<dc:creator><![CDATA[Rick Yorgason]]></dc:creator>
		<pubDate>Sun, 12 Dec 2010 20:32:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2705</guid>
					<description><![CDATA[@Herb: Everybody appreciates all the hard work you guys have been putting into C++0x, and a break is well deserved, but I guess the worry we all have is that when you use phrases like &quot;what we had after C++98 shipped&quot; it implies that the committee is going to go into hibernation again, doing little more than defect reports.

We&#039;re all looking forward to concepts, modules, and TR2, and it would be a shame to have to wait 13 years for them.  When does the committee expect to have these TRs ready?]]></description>
		<content:encoded><![CDATA[<p>@Herb: Everybody appreciates all the hard work you guys have been putting into C++0x, and a break is well deserved, but I guess the worry we all have is that when you use phrases like &#8220;what we had after C++98 shipped&#8221; it implies that the committee is going to go into hibernation again, doing little more than defect reports.</p>
<p>We&#8217;re all looking forward to concepts, modules, and TR2, and it would be a shame to have to wait 13 years for them.  When does the committee expect to have these TRs ready?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2702</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 10 Dec 2010 21:31:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2702</guid>
					<description><![CDATA[@Alfonse: There are several reasons. Briefly:

1. Like we did after shipping C++98, we need to stop changing the language for a time to let implementations catch up. No compiler implements 100% of draft C++0x yet (though I should add that many do implement major features, and as usual EDG is out in front leading the way to 100% conformance).

2. The committee is about exhausted. Besides three weeks a year of international travel (and the meetings are each six days, including Saturday, where most days are dawn-to-late-night work for most people), there&#039;s a lot of time spent between meetings preparing for them, working on designs, and not to mention having additional meetings by teleconference (typically 4-6/year lately) or in person (typically 1-2/year extra face-to-face meetings lately for large subgroups).

@jalf: We decided at our August 2010 meeting to scale back to two meetings a year. That was only done once we saw the volume on the final round of international comments and had triaged them all and resolved something like half, including all the controversial ones, and knew we could make the current schedule with high confidence. Even so, I&#039;m scheduling the second meeting of 2011 for August in case we need another one after Madrid to finish the FDIS, but we probably won&#039;t need it.

@Keith: &quot;alignas&quot; now joins &quot;alignof&quot; as a full reserved keyword (not a contextual keyword).]]></description>
		<content:encoded><![CDATA[<p>@Alfonse: There are several reasons. Briefly:</p>
<p>1. Like we did after shipping C++98, we need to stop changing the language for a time to let implementations catch up. No compiler implements 100% of draft C++0x yet (though I should add that many do implement major features, and as usual EDG is out in front leading the way to 100% conformance).</p>
<p>2. The committee is about exhausted. Besides three weeks a year of international travel (and the meetings are each six days, including Saturday, where most days are dawn-to-late-night work for most people), there&#8217;s a lot of time spent between meetings preparing for them, working on designs, and not to mention having additional meetings by teleconference (typically 4-6/year lately) or in person (typically 1-2/year extra face-to-face meetings lately for large subgroups).</p>
<p>@jalf: We decided at our August 2010 meeting to scale back to two meetings a year. That was only done once we saw the volume on the final round of international comments and had triaged them all and resolved something like half, including all the controversial ones, and knew we could make the current schedule with high confidence. Even so, I&#8217;m scheduling the second meeting of 2011 for August in case we need another one after Madrid to finish the FDIS, but we probably won&#8217;t need it.</p>
<p>@Keith: &#8220;alignas&#8221; now joins &#8220;alignof&#8221; as a full reserved keyword (not a contextual keyword).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dalle				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2700</link>
		<dc:creator><![CDATA[Dalle]]></dc:creator>
		<pubDate>Fri, 10 Dec 2010 11:54:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2700</guid>
					<description><![CDATA[If a base class has an class-virt-specifier (explicit, that is), is this property applied to derived classes as well?

For instance, is the following well-formed or ill-formed? I would expect this would be ill-formed.

class B explicit {
   virtual void h();
};

class D : public B {
   virtual void h();
};

By the way, is it possible to derive from unnamed classes using decltype?

For instance, is the following well-formed or ill-formed?

class {
   virtual void h();
} b;

class D : public decltype(b) {
   virtual void h();
};]]></description>
		<content:encoded><![CDATA[<p>If a base class has an class-virt-specifier (explicit, that is), is this property applied to derived classes as well?</p>
<p>For instance, is the following well-formed or ill-formed? I would expect this would be ill-formed.</p>
<p>class B explicit {<br />
   virtual void h();<br />
};</p>
<p>class D : public B {<br />
   virtual void h();<br />
};</p>
<p>By the way, is it possible to derive from unnamed classes using decltype?</p>
<p>For instance, is the following well-formed or ill-formed?</p>
<p>class {<br />
   virtual void h();<br />
} b;</p>
<p>class D : public decltype(b) {<br />
   virtual void h();<br />
};</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jalf				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2698</link>
		<dc:creator><![CDATA[jalf]]></dc:creator>
		<pubDate>Fri, 10 Dec 2010 05:01:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2698</guid>
					<description><![CDATA[@Alfonse: I&#039;d imagine it&#039;s because the committee members have lives (and day jobs) they need to attend to. They&#039;re not getting paid for sitting in the committee, so it&#039;s natural to want to keep it at a pace that doesn&#039;t place too many demands on the committee members.

But that said, it does seem surprising to scale down effective immediately. I&#039;d have expected 3 meetings in 2011 as well, just to make sure C++0x gets out the door without further delays.]]></description>
		<content:encoded><![CDATA[<p>@Alfonse: I&#8217;d imagine it&#8217;s because the committee members have lives (and day jobs) they need to attend to. They&#8217;re not getting paid for sitting in the committee, so it&#8217;s natural to want to keep it at a pace that doesn&#8217;t place too many demands on the committee members.</p>
<p>But that said, it does seem surprising to scale down effective immediately. I&#8217;d have expected 3 meetings in 2011 as well, just to make sure C++0x gets out the door without further delays.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Keith Jeffery				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2696</link>
		<dc:creator><![CDATA[Keith Jeffery]]></dc:creator>
		<pubDate>Thu, 09 Dec 2010 23:21:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2696</guid>
					<description><![CDATA[Hi Herb,

Thanks for the report; I always appreciate these.

Is &quot;align&quot; a contextual keyword, or a fully reserved keyword?]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>Thanks for the report; I always appreciate these.</p>
<p>Is &#8220;align&#8221; a contextual keyword, or a fully reserved keyword?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2672</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Thu, 09 Dec 2010 07:09:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2672</guid>
					<description><![CDATA[This is all well and good, except for one thing. Why scale back the meetings?

It seems to me that C++0x advanced much faster during the 3 meetings-per-year period. There are a number of parts of C++0x that were important but were put off in the interest of getting C++0x out the door. Concepts, Modules, etc.

I thought the committee was going to move to a 3-5 year release schedule. If so, then the committee needs to be more proactive in getting specs out the door. And the 3 meetings seemed to make that happen more effectively.]]></description>
		<content:encoded><![CDATA[<p>This is all well and good, except for one thing. Why scale back the meetings?</p>
<p>It seems to me that C++0x advanced much faster during the 3 meetings-per-year period. There are a number of parts of C++0x that were important but were put off in the interest of getting C++0x out the door. Concepts, Modules, etc.</p>
<p>I thought the committee was going to move to a 3-5 year release schedule. If so, then the committee needs to be more proactive in getting specs out the door. And the 3 meetings seemed to make that happen more effectively.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2670</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 09 Dec 2010 05:54:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2670</guid>
					<description><![CDATA[@Alex: Right you are, thanks for catching the typo. Last month&#039;s meeting was in IL, next August&#039;s will be in IN. Fixed.]]></description>
		<content:encoded><![CDATA[<p>@Alex: Right you are, thanks for catching the typo. Last month&#8217;s meeting was in IL, next August&#8217;s will be in IN. Fixed.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alex Gezerlis				</title>
				<link>https://herbsutter.com/2010/12/08/trip-report-november-2010-c-standards-meeting/#comment-2667</link>
		<dc:creator><![CDATA[Alex Gezerlis]]></dc:creator>
		<pubDate>Thu, 09 Dec 2010 03:55:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=485#comment-2667</guid>
					<description><![CDATA[Hi Herb,

In the main text you write:

&quot;the fallback will be to target FDIS at the following meeting (Indiana in August).&quot;

while at the bottom you say:

&quot;August 15-19, 2011: Bloomington, IL, USA&quot;

There&#039;s a Bloomington in both Illinois and Indiana, but you have to pick one. :-) 

Cheers,
Alex]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>In the main text you write:</p>
<p>&#8220;the fallback will be to target FDIS at the following meeting (Indiana in August).&#8221;</p>
<p>while at the bottom you say:</p>
<p>&#8220;August 15-19, 2011: Bloomington, IL, USA&#8221;</p>
<p>There&#8217;s a Bloomington in both Illinois and Indiana, but you have to pick one. :-) </p>
<p>Cheers,<br />
Alex</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
