<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Effective Concurrency: Prefer Using Active Objects Instead of Naked Threads	</title>
	<atom:link href="https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Sponsers				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-3001</link>
		<dc:creator><![CDATA[Sponsers]]></dc:creator>
		<pubDate>Wed, 18 May 2011 17:19:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-3001</guid>
					<description><![CDATA[Состоятельный человек ищет себе девушку 
 для   настоящих 
отношений, параметры параметры: от 18 до 20 лет рост  
до 175 см. волосы светлые, модельное телосложение. личный помощник   т.79262036777 Руслан 
теги: 
объявления знакомства  
 знакомства через интернет]]></description>
		<content:encoded><![CDATA[<p>Состоятельный человек ищет себе девушку<br />
 для   настоящих<br />
отношений, параметры параметры: от 18 до 20 лет рост<br />
до 175 см. волосы светлые, модельное телосложение. личный помощник   т.79262036777 Руслан<br />
теги:<br />
объявления знакомства<br />
 знакомства через интернет</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Let&#8217;s try the new C++0x type of Active Object &#124; Kjellkod&#039;s Blog				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2279</link>
		<dc:creator><![CDATA[Let&#8217;s try the new C++0x type of Active Object &#124; Kjellkod&#039;s Blog]]></dc:creator>
		<pubDate>Sat, 11 Sep 2010 12:32:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2279</guid>
					<description><![CDATA[[...] by kjellkod   When Herb Sutter wrote about Active Objects in this Effective Concurrency blog series Prefer Using Active Objects Instead of Naked Threads I was thrilled since I was waiting for that since his Effective Concurrency seminar in Kista, [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] by kjellkod   When Herb Sutter wrote about Active Objects in this Effective Concurrency blog series Prefer Using Active Objects Instead of Naked Threads I was thrilled since I was waiting for that since his Effective Concurrency seminar in Kista, [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kjell Hedström				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2216</link>
		<dc:creator><![CDATA[Kjell Hedström]]></dc:creator>
		<pubDate>Thu, 12 Aug 2010 19:10:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2216</guid>
					<description><![CDATA[Thanks for yet another great article Herb. 

I think that instead of using Message objects (for pre C++0x developers) it could be benificial to follow the idiom of generic function callbacks ( your Gotw: 83 et.al ).

This way you can easily make the Active object and Backgrounder without message objects focus on the core with cleaner code as a result. 

Inspired by your Effective Concurrency Europe 2009 seminar I ended up with something like this :) 

I.e. : (cut-down &#038; pseudo-ish version)
Class Active {
  private:
   ....
   void run() {
      while(!done){
        smart_ptr msg= mq.pop();
        msg(); // executes msg 
       }
     }

  public:
    ....
     ~Active() {
       send(bind(this, &#038;Active::DoDone));
       thd-&#062;join();
    }
   ....
};


class Background {
...
public:
   void Save(smart_ptr data) {
      active-&#062;send(bind(this, &#038;Background::DoSave, data);  
  }
...
};


Standard pre C++0x but still with the clean look thanks to some template touch :)

Cheers]]></description>
		<content:encoded><![CDATA[<p>Thanks for yet another great article Herb. </p>
<p>I think that instead of using Message objects (for pre C++0x developers) it could be benificial to follow the idiom of generic function callbacks ( your Gotw: 83 et.al ).</p>
<p>This way you can easily make the Active object and Backgrounder without message objects focus on the core with cleaner code as a result. </p>
<p>Inspired by your Effective Concurrency Europe 2009 seminar I ended up with something like this :) </p>
<p>I.e. : (cut-down &amp; pseudo-ish version)<br />
Class Active {<br />
  private:<br />
   &#8230;.<br />
   void run() {<br />
      while(!done){<br />
        smart_ptr msg= mq.pop();<br />
        msg(); // executes msg<br />
       }<br />
     }</p>
<p>  public:<br />
    &#8230;.<br />
     ~Active() {<br />
       send(bind(this, &amp;Active::DoDone));<br />
       thd-&gt;join();<br />
    }<br />
   &#8230;.<br />
};</p>
<p>class Background {<br />
&#8230;<br />
public:<br />
   void Save(smart_ptr data) {<br />
      active-&gt;send(bind(this, &amp;Background::DoSave, data);<br />
  }<br />
&#8230;<br />
};</p>
<p>Standard pre C++0x but still with the clean look thanks to some template touch :)</p>
<p>Cheers</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2171</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 28 Jul 2010 19:22:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2171</guid>
					<description><![CDATA[@Thomas: Yes, function follows the rule of all function objects -- they are intended to be cheap to copy. So if you want to avoid copying state, hold it by pointer/shared_ptr.]]></description>
		<content:encoded><![CDATA[<p>@Thomas: Yes, function follows the rule of all function objects &#8212; they are intended to be cheap to copy. So if you want to avoid copying state, hold it by pointer/shared_ptr.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thomas Petit				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2162</link>
		<dc:creator><![CDATA[Thomas Petit]]></dc:creator>
		<pubDate>Fri, 23 Jul 2010 10:04:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2162</guid>
					<description><![CDATA[Very nice and detailed article. So nice, that I went head ahead and try to use it in one my program. 
From this experience, I get some concern about the C++0X way. While I really like the terseness of it, it seems to be a bit more error-prone and can become inefficient if you don&#039;t pay close attention.

In my case I wanted to pass a Medium-sized data to an active object. By medium-sized I mean a piece of data big enough that you can afford to copy it one time for the purpose of thread isolation, but NOT many times. (for example a buffer of char[4096])

It worked very easily with OO style message.
struct MMediumSized
{
   MediumSizedData data;
   MMediumSized(const MediumSizedData&#038; data):data(data){}
   void Execute(){...}
}

void foo(const MediumSizedData&#038; data)
{
   a.Send(std::unique_ptr(new MMediumSized(data)));
}

The Send() function forced me to do the right thing, thanks to taking an unique_ptr as parameter. The MediumSizedData is copied *once* into the message (in the constructor of MMediumSized) and then the unique_ptr to the message is moved into the message queue, then moved out, get executed and then get automatically destroyed.

I hit way more problems when moving to lambda and std::function. My first impulse was to do :

void foo(const MediumSizedData&#038; data)
{
   a.Send( [&#038;data](){ ...} );
}
I didn&#039;t pay enough attention that the data was captured by reference, so there is no copy at all which cause data race in the program.
Then I changed to :

void foo(const MediumSizedData&#038; data)
{
a.Send( [data]() {...} );
}

The program was correct, but way slower than the OO version. I put some traces into MediumSizedData copy constructor and realized that every time I called foo() and the message was executed, MediumSizedData get in fact copied 5 times !! It seems that&#039;s because std::function really love to make copy. I cannot figure out what happen exactly in the internals of std::function but is seems that my lambda get copied a LOT inside.

So I finally realize that you have to use a shared_ptr to get the right semantics :
void foo(const MediumSizedData&#038; data)
{
   std::shared_ptr data_copy(new MediumSizedData(data));
   a.Send( [data_copy]() {...} );
}
I would prefer an unique_ptr but unfortunately it seems that std::function make always a copy of its internals and never a move.

TL:DR :
It&#039;s very clear in the OO style that you dynamically allocate a message and then only manipulate and pass a *pointer* around whereas the std::function way looks more mysterious. What really happen when I construct a std::function from a lambda ? What really happen when I a push a std::function into the message queue ?]]></description>
		<content:encoded><![CDATA[<p>Very nice and detailed article. So nice, that I went head ahead and try to use it in one my program.<br />
From this experience, I get some concern about the C++0X way. While I really like the terseness of it, it seems to be a bit more error-prone and can become inefficient if you don&#8217;t pay close attention.</p>
<p>In my case I wanted to pass a Medium-sized data to an active object. By medium-sized I mean a piece of data big enough that you can afford to copy it one time for the purpose of thread isolation, but NOT many times. (for example a buffer of char[4096])</p>
<p>It worked very easily with OO style message.<br />
struct MMediumSized<br />
{<br />
   MediumSizedData data;<br />
   MMediumSized(const MediumSizedData&amp; data):data(data){}<br />
   void Execute(){&#8230;}<br />
}</p>
<p>void foo(const MediumSizedData&amp; data)<br />
{<br />
   a.Send(std::unique_ptr(new MMediumSized(data)));<br />
}</p>
<p>The Send() function forced me to do the right thing, thanks to taking an unique_ptr as parameter. The MediumSizedData is copied *once* into the message (in the constructor of MMediumSized) and then the unique_ptr to the message is moved into the message queue, then moved out, get executed and then get automatically destroyed.</p>
<p>I hit way more problems when moving to lambda and std::function. My first impulse was to do :</p>
<p>void foo(const MediumSizedData&amp; data)<br />
{<br />
   a.Send( [&amp;data](){ &#8230;} );<br />
}<br />
I didn&#8217;t pay enough attention that the data was captured by reference, so there is no copy at all which cause data race in the program.<br />
Then I changed to :</p>
<p>void foo(const MediumSizedData&amp; data)<br />
{<br />
a.Send( [data]() {&#8230;} );<br />
}</p>
<p>The program was correct, but way slower than the OO version. I put some traces into MediumSizedData copy constructor and realized that every time I called foo() and the message was executed, MediumSizedData get in fact copied 5 times !! It seems that&#8217;s because std::function really love to make copy. I cannot figure out what happen exactly in the internals of std::function but is seems that my lambda get copied a LOT inside.</p>
<p>So I finally realize that you have to use a shared_ptr to get the right semantics :<br />
void foo(const MediumSizedData&amp; data)<br />
{<br />
   std::shared_ptr data_copy(new MediumSizedData(data));<br />
   a.Send( [data_copy]() {&#8230;} );<br />
}<br />
I would prefer an unique_ptr but unfortunately it seems that std::function make always a copy of its internals and never a move.</p>
<p>TL:DR :<br />
It&#8217;s very clear in the OO style that you dynamically allocate a message and then only manipulate and pass a *pointer* around whereas the std::function way looks more mysterious. What really happen when I construct a std::function from a lambda ? What really happen when I a push a std::function into the message queue ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bill				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2149</link>
		<dc:creator><![CDATA[Bill]]></dc:creator>
		<pubDate>Wed, 14 Jul 2010 07:04:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2149</guid>
					<description><![CDATA[I&#039;ve been hoping for some focus on actor-model type concurrency and more focus on futures/messages, etc.
Thanks Herb =)]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve been hoping for some focus on actor-model type concurrency and more focus on futures/messages, etc.<br />
Thanks Herb =)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2146</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 13 Jul 2010 16:35:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2146</guid>
					<description><![CDATA[Yes, no specific ETA but not before next year. In the meantime, they are all freely available via the links above.]]></description>
		<content:encoded><![CDATA[<p>Yes, no specific ETA but not before next year. In the meantime, they are all freely available via the links above.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Manish				</title>
				<link>https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2144</link>
		<dc:creator><![CDATA[Manish]]></dc:creator>
		<pubDate>Tue, 13 Jul 2010 06:50:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/#comment-2144</guid>
					<description><![CDATA[Hi,

Excellent read. 
Are you planning to compile all the column in the book?

Thanks]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>Excellent read.<br />
Are you planning to compile all the column in the book?</p>
<p>Thanks</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
