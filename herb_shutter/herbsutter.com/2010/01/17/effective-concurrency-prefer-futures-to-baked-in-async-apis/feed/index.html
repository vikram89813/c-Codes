<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Effective Concurrency: Prefer Futures to Baked-In &#8220;Async APIs&#8221;	</title>
	<atom:link href="https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-2059</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 29 Apr 2010 20:39:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-2059</guid>
					<description><![CDATA[I&#039;m working on it. :) Specifically, the EC articles are drafts of Items for the book.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m working on it. :) Specifically, the EC articles are drafts of Items for the book.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olle				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-2033</link>
		<dc:creator><![CDATA[Olle]]></dc:creator>
		<pubDate>Tue, 20 Apr 2010 07:33:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-2033</guid>
					<description><![CDATA[Any news on the Effective Concurrency book?]]></description>
		<content:encoded><![CDATA[<p>Any news on the Effective Concurrency book?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ Standard (C++0x) Thread Library &#124; Roman&#39;s knowledgebase				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1877</link>
		<dc:creator><![CDATA[C++ Standard (C++0x) Thread Library &#124; Roman&#39;s knowledgebase]]></dc:creator>
		<pubDate>Sun, 28 Mar 2010 14:25:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1877</guid>
					<description><![CDATA[[...] Effective Concurrency: Prefer Futures to Baked-In “Async APIs” VN:F [1.8.6_1065]Rating: 0.0/10 (0 votes cast) [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Effective Concurrency: Prefer Futures to Baked-In “Async APIs” VN:F [1.8.6_1065]Rating: 0.0/10 (0 votes cast) [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrew Marshall				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1857</link>
		<dc:creator><![CDATA[Andrew Marshall]]></dc:creator>
		<pubDate>Mon, 22 Mar 2010 15:29:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1857</guid>
					<description><![CDATA[I like the idea of separating the &#039;What&#039; from the &#039;How&#039;, but I think that the Begin/End pattern still has its place if the &#039;What&#039; and the &#039;How&#039; are inextricably linked. 

For example, here at Leica we have a lot of hardware control code for our microscopes, which is, at the lowest level, inherently asynchronous. Generally, that is how we want the API to be used. If a user wants synchronous hardware control, he can implement his own wrapper on top of our API - I prefer this approach because synchronous execution would be the exception, rather than the rule.

I&#039;d be interested in your thoughts on this.

Regards,
Andrew.]]></description>
		<content:encoded><![CDATA[<p>I like the idea of separating the &#8216;What&#8217; from the &#8216;How&#8217;, but I think that the Begin/End pattern still has its place if the &#8216;What&#8217; and the &#8216;How&#8217; are inextricably linked. </p>
<p>For example, here at Leica we have a lot of hardware control code for our microscopes, which is, at the lowest level, inherently asynchronous. Generally, that is how we want the API to be used. If a user wants synchronous hardware control, he can implement his own wrapper on top of our API &#8211; I prefer this approach because synchronous execution would be the exception, rather than the rule.</p>
<p>I&#8217;d be interested in your thoughts on this.</p>
<p>Regards,<br />
Andrew.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mohan				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1703</link>
		<dc:creator><![CDATA[mohan]]></dc:creator>
		<pubDate>Tue, 26 Jan 2010 14:18:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1703</guid>
					<description><![CDATA[I was reading the article &#039; Prefer futures to baked in async API&#039;. I could see one advantage of using BeginXXX, EndXXX pattern like .net. For example, if i have a class where only few of its methods can be async then i can explicitly expose them with BeginXXX/EndXXX.]]></description>
		<content:encoded><![CDATA[<p>I was reading the article &#8216; Prefer futures to baked in async API&#8217;. I could see one advantage of using BeginXXX, EndXXX pattern like .net. For example, if i have a class where only few of its methods can be async then i can explicitly expose them with BeginXXX/EndXXX.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mogur				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1692</link>
		<dc:creator><![CDATA[Mogur]]></dc:creator>
		<pubDate>Tue, 19 Jan 2010 10:46:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1692</guid>
					<description><![CDATA[Great column.

Am I the only one that cannot see correctly the code of examples 4 and 5? At least it is done on purpose , the local vars declaration are missing, and I think this is the key part of the code, where the future is used :)]]></description>
		<content:encoded><![CDATA[<p>Great column.</p>
<p>Am I the only one that cannot see correctly the code of examples 4 and 5? At least it is done on purpose , the local vars declaration are missing, and I think this is the key part of the code, where the future is used :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kevin Gadd				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1691</link>
		<dc:creator><![CDATA[Kevin Gadd]]></dc:creator>
		<pubDate>Mon, 18 Jan 2010 20:38:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1691</guid>
					<description><![CDATA[An architecture based on Futures is equally capable of hooking into IOCP, as long as you factor things correctly. The Win32 API for IOCP is actually closer in structure to Futures than it is to Begin/End - you perform an IO and pass in an OVERLAPPED that either specifies an event to signal or a callback to invoke on completion. You&#039;re never actually required to call any sort of &#039;End&#039; function, and the OVERLAPPED always represents a single IO at any given time. It&#039;s basically a reusable Future.]]></description>
		<content:encoded><![CDATA[<p>An architecture based on Futures is equally capable of hooking into IOCP, as long as you factor things correctly. The Win32 API for IOCP is actually closer in structure to Futures than it is to Begin/End &#8211; you perform an IO and pass in an OVERLAPPED that either specifies an event to signal or a callback to invoke on completion. You&#8217;re never actually required to call any sort of &#8216;End&#8217; function, and the OVERLAPPED always represents a single IO at any given time. It&#8217;s basically a reusable Future.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1690</link>
		<dc:creator><![CDATA[Richard]]></dc:creator>
		<pubDate>Mon, 18 Jan 2010 11:17:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1690</guid>
					<description><![CDATA[@Barry Kelly: coincidentally just opened this for a read: http://blogs.msdn.com/dsyme/archive/2010/01/09/async-and-parallel-design-patterns-in-f-parallelizing-cpu-and-i-o-computations.aspx]]></description>
		<content:encoded><![CDATA[<p>@Barry Kelly: coincidentally just opened this for a read: <a href="http://blogs.msdn.com/dsyme/archive/2010/01/09/async-and-parallel-design-patterns-in-f-parallelizing-cpu-and-i-o-computations.aspx" rel="nofollow">http://blogs.msdn.com/dsyme/archive/2010/01/09/async-and-parallel-design-patterns-in-f-parallelizing-cpu-and-i-o-computations.aspx</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1689</link>
		<dc:creator><![CDATA[Richard]]></dc:creator>
		<pubDate>Mon, 18 Jan 2010 11:15:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1689</guid>
					<description><![CDATA[One (slightly pedantic) correction: you don&#039;t need to call ar.AsyncWaitHandle.WaitOne() before calling EndZZZ(...) for correctly implemented Begin/End pair. The pattern states that EndZZZ will block if the operation has not completed.

This does not really alter the point, and general mechanisms using something like futures are certainly easier (in general) for both implementer and consumer of an API. (The exceptions are where something like Begin/End can hook into lower level abstractions like IO Completion.)]]></description>
		<content:encoded><![CDATA[<p>One (slightly pedantic) correction: you don&#8217;t need to call ar.AsyncWaitHandle.WaitOne() before calling EndZZZ(&#8230;) for correctly implemented Begin/End pair. The pattern states that EndZZZ will block if the operation has not completed.</p>
<p>This does not really alter the point, and general mechanisms using something like futures are certainly easier (in general) for both implementer and consumer of an API. (The exceptions are where something like Begin/End can hook into lower level abstractions like IO Completion.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Barry Kelly				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1688</link>
		<dc:creator><![CDATA[Barry Kelly]]></dc:creator>
		<pubDate>Mon, 18 Jan 2010 05:30:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1688</guid>
					<description><![CDATA[I&#039;ll make my comment here, as it doesn&#039;t require me to create an account.

Async programming is useful for minimizing the number of threads while simultaneously having many concurrent IO operations in flight. Going with a task parallelism library for the same operation means you&#039;re going to sacrifice one of those goals, typically the many concurrent IOs.

The annoying thing is that the Begin/End async pattern in .NET is programmable (and with the AsyncCallback, more or less designed to be programmed) in continuation passing style. But CPS is a mechanical translation of straight-line normal imperative code.

So my position is rather different. Compiler / language tooling should be improved in this area, so that straight-line code, in the right context (e.g. F#-style async workflow) can be mechanically transformed into a a monadic nesting of continuations. That way you get to have your cake and eat it too.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ll make my comment here, as it doesn&#8217;t require me to create an account.</p>
<p>Async programming is useful for minimizing the number of threads while simultaneously having many concurrent IO operations in flight. Going with a task parallelism library for the same operation means you&#8217;re going to sacrifice one of those goals, typically the many concurrent IOs.</p>
<p>The annoying thing is that the Begin/End async pattern in .NET is programmable (and with the AsyncCallback, more or less designed to be programmed) in continuation passing style. But CPS is a mechanical translation of straight-line normal imperative code.</p>
<p>So my position is rather different. Compiler / language tooling should be improved in this area, so that straight-line code, in the right context (e.g. F#-style async workflow) can be mechanically transformed into a a monadic nesting of continuations. That way you get to have your cake and eat it too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kevin Gadd				</title>
				<link>https://herbsutter.com/2010/01/17/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1687</link>
		<dc:creator><![CDATA[Kevin Gadd]]></dc:creator>
		<pubDate>Mon, 18 Jan 2010 04:03:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/2010/01/18/effective-concurrency-prefer-futures-to-baked-in-async-apis/#comment-1687</guid>
					<description><![CDATA[One nice enhancement to the Future model is being able to add callbacks directly to a future, like in Twisted. It makes it straightforward to attach work to the end of a deferred computation without having to modify the call site. Doing that also means that you can attach a continuation to the Future instead of suspending your thread by blocking on an event.]]></description>
		<content:encoded><![CDATA[<p>One nice enhancement to the Future model is being able to add callbacks directly to a future, like in Twisted. It makes it straightforward to attach work to the end of a deferred computation without having to modify the call site. Doing that also means that you can attach a continuation to the Future instead of suspending your thread by blocking on an event.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
