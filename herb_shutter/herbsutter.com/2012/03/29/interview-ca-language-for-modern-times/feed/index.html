<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Interview: C++&#8211;A Language for Modern Times	</title>
	<atom:link href="https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Linkage: March 29th, 2012 to April 17th, 2012 &#124; ben lowery				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5235</link>
		<dc:creator><![CDATA[Linkage: March 29th, 2012 to April 17th, 2012 &#124; ben lowery]]></dc:creator>
		<pubDate>Tue, 17 Apr 2012 17:05:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5235</guid>
					<description><![CDATA[[...] Interview: C++&#8211;A Language for Modern Times [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Interview: C++&ndash;A Language for Modern Times [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: josuegomes				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5179</link>
		<dc:creator><![CDATA[josuegomes]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 18:49:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5179</guid>
					<description><![CDATA[It would be nice to have a list of C++98 idioms (like this one pass expensive objects by const reference) that can be improved in C++11. Or maybe a book? C++11 for C++ developers :-)]]></description>
		<content:encoded><![CDATA[<p>It would be nice to have a list of C++98 idioms (like this one pass expensive objects by const reference) that can be improved in C++11. Or maybe a book? C++11 for C++ developers :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Purvis Bedenbaugh				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5178</link>
		<dc:creator><![CDATA[Purvis Bedenbaugh]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 16:18:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5178</guid>
					<description><![CDATA[Nice interview. I appreciate the links for learning more. 
Would there be any chance that the articles in the &quot;welcome back to C++&quot; series (http://msdn.microsoft.com/en-us/library/hh279654(v=vs.110).aspx) could be formatted as a single web page, with all sections expanded ?
It makes it easier to put on an Amazon Kindel :)
Thank-you for your efforts in making the benefits C++ accessible to a wider audience.]]></description>
		<content:encoded><![CDATA[<p>Nice interview. I appreciate the links for learning more.<br />
Would there be any chance that the articles in the &#8220;welcome back to C++&#8221; series (<a href="http://msdn.microsoft.com/en-us/library/hh279654(v=vs.110)" rel="nofollow">http://msdn.microsoft.com/en-us/library/hh279654(v=vs.110)</a>.aspx) could be formatted as a single web page, with all sections expanded ?<br />
It makes it easier to put on an Amazon Kindel :)<br />
Thank-you for your efforts in making the benefits C++ accessible to a wider audience.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Henrik Vallgren (@Henrik_Vallgren)				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5032</link>
		<dc:creator><![CDATA[Henrik Vallgren (@Henrik_Vallgren)]]></dc:creator>
		<pubDate>Tue, 03 Apr 2012 05:03:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5032</guid>
					<description><![CDATA[Hi,

Is the overhead of futures+asyncs something that I should worry about? Should I sometimes, for performance reasons, consider using std::future&#060;std::vector&#062; rather than std::vector&#060;std::future&#062;?

Some old-style API&#039;s require a T* plus size, which I suspect could be mapped to a future&#060;vector&#062; but not to a vector&#060;future&#062; (I expect that future adds an extra data to each item). 

Best regards,
Henrik]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>Is the overhead of futures+asyncs something that I should worry about? Should I sometimes, for performance reasons, consider using std::future&lt;std::vector&gt; rather than std::vector&lt;std::future&gt;?</p>
<p>Some old-style API&#8217;s require a T* plus size, which I suspect could be mapped to a future&lt;vector&gt; but not to a vector&lt;future&gt; (I expect that future adds an extra data to each item). </p>
<p>Best regards,<br />
Henrik</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: monamimani				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5031</link>
		<dc:creator><![CDATA[monamimani]]></dc:creator>
		<pubDate>Tue, 03 Apr 2012 03:45:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5031</guid>
					<description><![CDATA[Hi, first of all really great interview, and short. This will be the reference I give to people that tell me they never need C++ and that managed code will rulled them all.

I have a kind of technical question, first, i don&#039;t know ConcRt (written from what i heard herb said) and I don&#039;t know how a work stealling thred pool work ( I should google that) but Herb said that if those lambda would do a bit more, they would be schedule on a different thread. How does it this happen. We can&#039;t know at compile time the time an instruction will take, so how does it know when to spin the lambda on a different thread or not? If this kind of info is like the secret sauce of ConcRt, maybe some literature ref would be good?

thanks alot]]></description>
		<content:encoded><![CDATA[<p>Hi, first of all really great interview, and short. This will be the reference I give to people that tell me they never need C++ and that managed code will rulled them all.</p>
<p>I have a kind of technical question, first, i don&#8217;t know ConcRt (written from what i heard herb said) and I don&#8217;t know how a work stealling thred pool work ( I should google that) but Herb said that if those lambda would do a bit more, they would be schedule on a different thread. How does it this happen. We can&#8217;t know at compile time the time an instruction will take, so how does it know when to spin the lambda on a different thread or not? If this kind of info is like the secret sauce of ConcRt, maybe some literature ref would be good?</p>
<p>thanks alot</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5023</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 03 Apr 2012 01:16:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5023</guid>
					<description><![CDATA[@MichaelTK: I blogged a reply here: http://tinyurl.com/6rf2ubf .]]></description>
		<content:encoded><![CDATA[<p>@MichaelTK: I blogged a reply here: <a href="http://tinyurl.com/6rf2ubf" rel="nofollow">http://tinyurl.com/6rf2ubf</a> .</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Reader Q&#38;A: When will better JITs save managed code? &#171; Sutter’s Mill				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5022</link>
		<dc:creator><![CDATA[Reader Q&#38;A: When will better JITs save managed code? &#171; Sutter’s Mill]]></dc:creator>
		<pubDate>Tue, 03 Apr 2012 01:15:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5022</guid>
					<description><![CDATA[[...] the comments on last week’s interview, MichaelTK asked: @Herb: You mentioned two things I don’t fully understand in your [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] the comments on last week’s interview, MichaelTK asked: @Herb: You mentioned two things I don’t fully understand in your [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MichaelTK				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5020</link>
		<dc:creator><![CDATA[MichaelTK]]></dc:creator>
		<pubDate>Mon, 02 Apr 2012 11:31:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5020</guid>
					<description><![CDATA[@Herb: You mentioned two things I don&#039;t fully understand in your talk.

1) Why would C++ be a better choice for very large scale applications than NET/Java? I mean the zero abstraction penalty (which is more a JIT compiler issue and not intrinsically hardwired into C#) , okay, but besides that?

2) C++ really only has a few language features which actually let you write faster code in theory. In practice, JIT compilers are just not good enough, yet, to fully optimize on C++ pace and that&#039;s one of the main reasons why C++ excels at efficiency. This yields two questions. Why does Microsoft not put effort into a static C++ like compiler for C#/NET, say in manner of NGen, so that C# actually has even the slightest chance of being competitive with C++? Otherwise, saying C++ is more efficient than C# is not a theoretical issue, but caused by bad JIT compilers. If we had such a C++ paced JIT compiler (the recently deceased &quot;Phoenix&quot; for one), couldn&#039;t we easily bring C# on C++ pace by just adding a few important language features like constness, immutability, restricted pointers, scoped classes and stuff like that?

All this wondering is just because I find it rather weird that Microsoft is kinda giving up on NET performance wise, while in theory they would only need to create a good static compiler and a few new language features to make it kick-ass again. Also the C++.AMP could be named C#.AMP without too much effort...]]></description>
		<content:encoded><![CDATA[<p>@Herb: You mentioned two things I don&#8217;t fully understand in your talk.</p>
<p>1) Why would C++ be a better choice for very large scale applications than NET/Java? I mean the zero abstraction penalty (which is more a JIT compiler issue and not intrinsically hardwired into C#) , okay, but besides that?</p>
<p>2) C++ really only has a few language features which actually let you write faster code in theory. In practice, JIT compilers are just not good enough, yet, to fully optimize on C++ pace and that&#8217;s one of the main reasons why C++ excels at efficiency. This yields two questions. Why does Microsoft not put effort into a static C++ like compiler for C#/NET, say in manner of NGen, so that C# actually has even the slightest chance of being competitive with C++? Otherwise, saying C++ is more efficient than C# is not a theoretical issue, but caused by bad JIT compilers. If we had such a C++ paced JIT compiler (the recently deceased &#8220;Phoenix&#8221; for one), couldn&#8217;t we easily bring C# on C++ pace by just adding a few important language features like constness, immutability, restricted pointers, scoped classes and stuff like that?</p>
<p>All this wondering is just because I find it rather weird that Microsoft is kinda giving up on NET performance wise, while in theory they would only need to create a good static compiler and a few new language features to make it kick-ass again. Also the C++.AMP could be named C#.AMP without too much effort&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kenneth Ho				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5019</link>
		<dc:creator><![CDATA[Kenneth Ho]]></dc:creator>
		<pubDate>Mon, 02 Apr 2012 02:21:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5019</guid>
					<description><![CDATA[@bkuhns, @Herb: thanks for the comment.]]></description>
		<content:encoded><![CDATA[<p>@bkuhns, @Herb: thanks for the comment.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5015</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 01 Apr 2012 18:44:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5015</guid>
					<description><![CDATA[@Kenneth: You don&#039;t want to write move(s) there for the reasons bkuhns mentioned -- it doesn&#039;t help (the language already knows to treat a return expression as an rvalue so it can automatically be moved from) and might hurt (slightly if it disables RVO, which is no longer as important an optimization because it only elides a move instead of a copy, but still is a useful incremental optimization).

@Olaf: I understand, and others such as Andrei have pointed this out in the past, but as I mentioned the usual C++98 guidance was nevertheless to pass by const&#038;. The rule &quot;pass an expensive object by value if you&#039;re going to copy it anyway&quot; has more upside and less downside in C++11 (thanks to move semantics), so it&#039;s definitely time to adopt it now.]]></description>
		<content:encoded><![CDATA[<p>@Kenneth: You don&#8217;t want to write move(s) there for the reasons bkuhns mentioned &#8212; it doesn&#8217;t help (the language already knows to treat a return expression as an rvalue so it can automatically be moved from) and might hurt (slightly if it disables RVO, which is no longer as important an optimization because it only elides a move instead of a copy, but still is a useful incremental optimization).</p>
<p>@Olaf: I understand, and others such as Andrei have pointed this out in the past, but as I mentioned the usual C++98 guidance was nevertheless to pass by const&amp;. The rule &#8220;pass an expensive object by value if you&#8217;re going to copy it anyway&#8221; has more upside and less downside in C++11 (thanks to move semantics), so it&#8217;s definitely time to adopt it now.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bkuhns				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5013</link>
		<dc:creator><![CDATA[bkuhns]]></dc:creator>
		<pubDate>Sun, 01 Apr 2012 13:35:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5013</guid>
					<description><![CDATA[@Kenneth Ho, I don&#039;t think Herb meant to return move(s); that&#039;s forcing the compiler into move semantics. It&#039;s making you /think/ about needing the move there. In the latest standard, as I understand it, the compiler will opt for std::string&#039;s move constructor when returning by value. At best, the compiler will inline the call and the copy/move will be elided. At worst case, the new standard will ensure move semantics are used. Explicitly stating move() removes the compiler&#039;s choice for further optimization, it makes you think more, and clutters the code.]]></description>
		<content:encoded><![CDATA[<p>@Kenneth Ho, I don&#8217;t think Herb meant to return move(s); that&#8217;s forcing the compiler into move semantics. It&#8217;s making you /think/ about needing the move there. In the latest standard, as I understand it, the compiler will opt for std::string&#8217;s move constructor when returning by value. At best, the compiler will inline the call and the copy/move will be elided. At worst case, the new standard will ensure move semantics are used. Explicitly stating move() removes the compiler&#8217;s choice for further optimization, it makes you think more, and clutters the code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5007</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Sat, 31 Mar 2012 15:20:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5007</guid>
					<description><![CDATA[&#062; See my example code above. So you could reuse and return resource owned by s to callers of flip().
But you don&#039;t need move semantics for flip(string s) to be a good idea.]]></description>
		<content:encoded><![CDATA[<p>&gt; See my example code above. So you could reuse and return resource owned by s to callers of flip().<br />
But you don&#8217;t need move semantics for flip(string s) to be a good idea.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kenneth Ho				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5006</link>
		<dc:creator><![CDATA[Kenneth Ho]]></dc:creator>
		<pubDate>Sat, 31 Mar 2012 15:04:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5006</guid>
					<description><![CDATA[@Herb: Regarding option 4, didn&#039;t you mean:
&lt;pre&gt;
    string flip( string s ) {
        reverse( s.begin(), s.end() );
        return move(s); // turning s into an rvalue so to it would bind with string::string(string&#038;&#038;) and omit copying
    }
&lt;/pre&gt;

@Olaf:
&#062; I agree on return-by-value, but how does it affect/change pass-by-value?

See my example code above. So you could reuse and return resource owned by s to callers of flip().]]></description>
		<content:encoded><![CDATA[<p>@Herb: Regarding option 4, didn&#8217;t you mean:</p>
<pre>
    string flip( string s ) {
        reverse( s.begin(), s.end() );
        return move(s); // turning s into an rvalue so to it would bind with string::string(string&amp;&amp;) and omit copying
    }
</pre>
<p>@Olaf:<br />
&gt; I agree on return-by-value, but how does it affect/change pass-by-value?</p>
<p>See my example code above. So you could reuse and return resource owned by s to callers of flip().</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5005</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Sat, 31 Mar 2012 12:23:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5005</guid>
					<description><![CDATA[@Herb: Sorry, no idea where Herbert came from. :p]]></description>
		<content:encoded><![CDATA[<p>@Herb: Sorry, no idea where Herbert came from. :p</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5004</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Sat, 31 Mar 2012 12:22:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5004</guid>
					<description><![CDATA[@Herbert:
&#062; and then make a local copy inside the function:
That&#039;s just plain silly. 

&#062; Now, of course, move semantics changes everything, because it gives a real performance incentive to write pass-by-value and return-by-value 
I agree on return-by-value, but how does it affect/change pass-by-value? Both with and without move semantics I&#039;d pass by value if the value is going to be modified.

IMO const std::string&#038; is hardly ever really the right argument type as it might force the caller to construct an unnecessary std::string. Not all strings are std::string. The right type would be a ptr range / string ref (const char* pair). Unfortunately, C++ still doesn&#039;t these.]]></description>
		<content:encoded><![CDATA[<p>@Herbert:<br />
&gt; and then make a local copy inside the function:<br />
That&#8217;s just plain silly. </p>
<p>&gt; Now, of course, move semantics changes everything, because it gives a real performance incentive to write pass-by-value and return-by-value<br />
I agree on return-by-value, but how does it affect/change pass-by-value? Both with and without move semantics I&#8217;d pass by value if the value is going to be modified.</p>
<p>IMO const std::string&amp; is hardly ever really the right argument type as it might force the caller to construct an unnecessary std::string. Not all strings are std::string. The right type would be a ptr range / string ref (const char* pair). Unfortunately, C++ still doesn&#8217;t these.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-5000</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 30 Mar 2012 19:17:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-5000</guid>
					<description><![CDATA[@Robert: Thanks, fixed. I compiled the code, but didn&#039;t unit-test it. :)]]></description>
		<content:encoded><![CDATA[<p>@Robert: Thanks, fixed. I compiled the code, but didn&#8217;t unit-test it. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert Charlebois				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-4999</link>
		<dc:creator><![CDATA[Robert Charlebois]]></dc:creator>
		<pubDate>Fri, 30 Mar 2012 17:37:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-4999</guid>
					<description><![CDATA[Herb, for option 1: return tmp, not s.]]></description>
		<content:encoded><![CDATA[<p>Herb, for option 1: return tmp, not s.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-4998</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 30 Mar 2012 17:26:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-4998</guid>
					<description><![CDATA[@Olaf: The typical C++98 advice is to take the expensive-to-copy object by const&#038; and then make a local copy inside the function:

&lt;pre&gt;    // Option 1: Typical C++98 style
    string flip( const string&#038; s ) {
        string tmp = s;
        reverse( tmp.begin(), tmp.end() );
        return tmp;
    }

    // calling code
    string s = &quot;xyzzy&quot;;
    string reverse = flip( s );    // nice and natural calling code for a value-like type&lt;/pre&gt;

and if you wanted to avoid the copy (without relying on RVO &quot;maybe&quot; kicking in) you might resort to an out parameter instead of a natural return value:

&lt;pre&gt;    // Option 2: Or use an out parameter
    void flip( const string&#038; src, string&#038; dst ) {
        dst = src;
        reverse( dst.begin(), dst.end() );
    }

    // calling code
    string s = &quot;xyzzy&quot;;
    string reverse;
    flip( s, reverse );    // kind of odd, but works&lt;/pre&gt;

or something else, such as in-place semantics which moves the burden to every caller to make a copy when he doesn&#039;t want to modify the original:

&lt;pre&gt;    // Option 3: Or use in-place semantics
    void flip( string&#038; s ) {
        reverse( s.begin(), s.end() );
    }

    // calling code
    string s = &quot;xyzzy&quot;;
    string reverse = s;
    flip( reverse );    // also a little odd, but works&lt;/pre&gt;

and so on.

Of course, you could also have already written it the C++11 way, like this, taking a parameter by value on the grounds that you&#039;re going to modify it anyway:

&lt;pre&gt;    // Option 4 (C++11 recommended style): Clean, safe, *and* fast
    string flip( string s ) {
        reverse( s.begin(), s.end() );
        return s;
    }

    // calling code
    string s = &quot;xyzzy&quot;;
    string reverse = flip( s );    // natural, and guaranteed zero copying of temporary objects&lt;/pre&gt;

but in C++98 this style was considered &quot;odd&quot; and &quot;probably too cute,&quot; and the only person I can recall who advocated for this style was Andrei Alexandrescu. Now, of course, move semantics changes everything, because it gives a real performance incentive to write pass-by-value and return-by-value along with a guarantee that move will kick in, no RVO required (although RVO can still happen, but is way less important because it eliminates a move instead of a deep copy).]]></description>
		<content:encoded><![CDATA[<p>@Olaf: The typical C++98 advice is to take the expensive-to-copy object by const&amp; and then make a local copy inside the function:</p>
<pre>    // Option 1: Typical C++98 style
    string flip( const string&amp; s ) {
        string tmp = s;
        reverse( tmp.begin(), tmp.end() );
        return tmp;
    }

    // calling code
    string s = "xyzzy";
    string reverse = flip( s );    // nice and natural calling code for a value-like type</pre>
<p>and if you wanted to avoid the copy (without relying on RVO &#8220;maybe&#8221; kicking in) you might resort to an out parameter instead of a natural return value:</p>
<pre>    // Option 2: Or use an out parameter
    void flip( const string&amp; src, string&amp; dst ) {
        dst = src;
        reverse( dst.begin(), dst.end() );
    }

    // calling code
    string s = "xyzzy";
    string reverse;
    flip( s, reverse );    // kind of odd, but works</pre>
<p>or something else, such as in-place semantics which moves the burden to every caller to make a copy when he doesn&#8217;t want to modify the original:</p>
<pre>    // Option 3: Or use in-place semantics
    void flip( string&amp; s ) {
        reverse( s.begin(), s.end() );
    }

    // calling code
    string s = "xyzzy";
    string reverse = s;
    flip( reverse );    // also a little odd, but works</pre>
<p>and so on.</p>
<p>Of course, you could also have already written it the C++11 way, like this, taking a parameter by value on the grounds that you&#8217;re going to modify it anyway:</p>
<pre>    // Option 4 (C++11 recommended style): Clean, safe, *and* fast
    string flip( string s ) {
        reverse( s.begin(), s.end() );
        return s;
    }

    // calling code
    string s = "xyzzy";
    string reverse = flip( s );    // natural, and guaranteed zero copying of temporary objects</pre>
<p>but in C++98 this style was considered &#8220;odd&#8221; and &#8220;probably too cute,&#8221; and the only person I can recall who advocated for this style was Andrei Alexandrescu. Now, of course, move semantics changes everything, because it gives a real performance incentive to write pass-by-value and return-by-value along with a guarantee that move will kick in, no RVO required (although RVO can still happen, but is way less important because it eliminates a move instead of a deep copy).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-4997</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Fri, 30 Mar 2012 11:17:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-4997</guid>
					<description><![CDATA[You say in C++98 you&#039;d have to write &quot;flip(const string&#038; s)&quot;, but IMO that&#039;s false, as you&#039;re modifying s in the function.]]></description>
		<content:encoded><![CDATA[<p>You say in C++98 you&#8217;d have to write &#8220;flip(const string&amp; s)&#8221;, but IMO that&#8217;s false, as you&#8217;re modifying s in the function.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: XP				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-4991</link>
		<dc:creator><![CDATA[XP]]></dc:creator>
		<pubDate>Fri, 30 Mar 2012 04:38:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-4991</guid>
					<description><![CDATA[But without XP SP3 targeting support in VS11, many of us will have to write not-so-modern C++ for at least an year or two. Sad.]]></description>
		<content:encoded><![CDATA[<p>But without XP SP3 targeting support in VS11, many of us will have to write not-so-modern C++ for at least an year or two. Sad.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: M.S. Babaei				</title>
				<link>https://herbsutter.com/2012/03/29/interview-ca-language-for-modern-times/#comment-4989</link>
		<dc:creator><![CDATA[M.S. Babaei]]></dc:creator>
		<pubDate>Fri, 30 Mar 2012 01:00:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1429#comment-4989</guid>
					<description><![CDATA[Return of the king....]]></description>
		<content:encoded><![CDATA[<p>Return of the king&#8230;.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
