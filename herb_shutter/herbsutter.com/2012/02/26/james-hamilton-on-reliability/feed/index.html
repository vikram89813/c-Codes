<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: James Hamilton on reliability	</title>
	<atom:link href="https://herbsutter.com/2012/02/26/james-hamilton-on-reliability/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/02/26/james-hamilton-on-reliability/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: paercebal				</title>
				<link>https://herbsutter.com/2012/02/26/james-hamilton-on-reliability/#comment-4855</link>
		<dc:creator><![CDATA[paercebal]]></dc:creator>
		<pubDate>Tue, 28 Feb 2012 09:53:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1394#comment-4855</guid>
					<description><![CDATA[Tested the 2012-02-27 and 2012-02-28 (Paris time) and the link works.

Now, after reading the article, I understand the risks (and thus the means to avoid them) related to critical systems like satellites and other space modules, but for a normal application like the ones most of us work on, the prospect of double/triple/checksum testing anything from hardware to software is daunting.

Quoting the text: &quot;At scale, error detection and correction at lower levels fails to correct or even detect some problems. Software stacks above introduce errors. Hardware introduces more errors. Firmware introduces errors. Errors creep in everywhere and absolutely nobody and nothing can be trusted [...] Upon deep investigation at some customer sites, we found the software was fine, but each customer had one, and sometimes several, latent data corruptions on disk. Perhaps it was introduced by hardware, perhaps firmware, or possibly software&quot;

I just assumed that hardware corruption (one of my HD just died recently, after a long data corrupting agony, so I tasted that bitter medicine) was a &quot;fact of life&quot; and that I had better things to do (like, correcting my own bugs) than trying to protect the customer from hardware faults or others things I had no control upon.

C++ has multiple virtues, but immunization from hardware problems, electricity interruption, or even alien invasion are not among them (or perhaps, Alien invasion would be ok, if done on Mac by Jeff Goldblum).

And I still believe this (if not, I would be panicking right now).

Still interesting to know because of how it could very well apply on different components of the same &quot;application&quot; working together (like a rich client, a server, its plugins, all forming a large application, as far as the client is concerned)... Food for thoughts...]]></description>
		<content:encoded><![CDATA[<p>Tested the 2012-02-27 and 2012-02-28 (Paris time) and the link works.</p>
<p>Now, after reading the article, I understand the risks (and thus the means to avoid them) related to critical systems like satellites and other space modules, but for a normal application like the ones most of us work on, the prospect of double/triple/checksum testing anything from hardware to software is daunting.</p>
<p>Quoting the text: &#8220;At scale, error detection and correction at lower levels fails to correct or even detect some problems. Software stacks above introduce errors. Hardware introduces more errors. Firmware introduces errors. Errors creep in everywhere and absolutely nobody and nothing can be trusted [&#8230;] Upon deep investigation at some customer sites, we found the software was fine, but each customer had one, and sometimes several, latent data corruptions on disk. Perhaps it was introduced by hardware, perhaps firmware, or possibly software&#8221;</p>
<p>I just assumed that hardware corruption (one of my HD just died recently, after a long data corrupting agony, so I tasted that bitter medicine) was a &#8220;fact of life&#8221; and that I had better things to do (like, correcting my own bugs) than trying to protect the customer from hardware faults or others things I had no control upon.</p>
<p>C++ has multiple virtues, but immunization from hardware problems, electricity interruption, or even alien invasion are not among them (or perhaps, Alien invasion would be ok, if done on Mac by Jeff Goldblum).</p>
<p>And I still believe this (if not, I would be panicking right now).</p>
<p>Still interesting to know because of how it could very well apply on different components of the same &#8220;application&#8221; working together (like a rich client, a server, its plugins, all forming a large application, as far as the client is concerned)&#8230; Food for thoughts&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Pulu				</title>
				<link>https://herbsutter.com/2012/02/26/james-hamilton-on-reliability/#comment-4852</link>
		<dc:creator><![CDATA[Pulu]]></dc:creator>
		<pubDate>Mon, 27 Feb 2012 05:08:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1394#comment-4852</guid>
					<description><![CDATA[The link appears to be broken. Ironically.]]></description>
		<content:encoded><![CDATA[<p>The link appears to be broken. Ironically.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
