<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GoingNative 2012: Day 2 Tomorrow (Friday)	</title>
	<atom:link href="https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/#comment-4813</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Thu, 16 Feb 2012 23:00:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1375#comment-4813</guid>
					<description><![CDATA[&#062; If you don’t have the right bricks you can’t build proper houses.

And if you try to build a house using &quot;array_ref&quot;, there won&#039;t be any time for &quot;xml_node&quot;. The analogy broke down somewhere in there, but my point is simple: *time* is the biggest issue.

Every day spent talking about &quot;array_ref&quot; means a day not spent talking about JSON parsing, XML parsing, or any number of the other major things that Herb wants.

Personally, I believe that the committee should be doing things like &quot;array_ref&quot; and such. But I also believe that they shouldn&#039;t be doing things like JSON/XML parsing and whatnot.

Think about it. Should an &quot;xml_node&quot; return an &quot;array_ref&quot; of its children, or a linked list as is traditional in XML processors? Should JSON arrays return &quot;array_ref&quot;? If so, what type? Should we incorporate Boost.Variant into the standard, so that the JSON parse tree is well-typed, or do we use the typical enum and union syntax?

The little things *massively* affect the big things. You don&#039;t want to spend years standardizing XML parsing and then decide that the user should be able to get an &quot;array_ref&quot; of attributes or something.]]></description>
		<content:encoded><![CDATA[<p>&gt; If you don’t have the right bricks you can’t build proper houses.</p>
<p>And if you try to build a house using &#8220;array_ref&#8221;, there won&#8217;t be any time for &#8220;xml_node&#8221;. The analogy broke down somewhere in there, but my point is simple: *time* is the biggest issue.</p>
<p>Every day spent talking about &#8220;array_ref&#8221; means a day not spent talking about JSON parsing, XML parsing, or any number of the other major things that Herb wants.</p>
<p>Personally, I believe that the committee should be doing things like &#8220;array_ref&#8221; and such. But I also believe that they shouldn&#8217;t be doing things like JSON/XML parsing and whatnot.</p>
<p>Think about it. Should an &#8220;xml_node&#8221; return an &#8220;array_ref&#8221; of its children, or a linked list as is traditional in XML processors? Should JSON arrays return &#8220;array_ref&#8221;? If so, what type? Should we incorporate Boost.Variant into the standard, so that the JSON parse tree is well-typed, or do we use the typical enum and union syntax?</p>
<p>The little things *massively* affect the big things. You don&#8217;t want to spend years standardizing XML parsing and then decide that the user should be able to get an &#8220;array_ref&#8221; of attributes or something.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/#comment-4789</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Thu, 09 Feb 2012 09:04:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1375#comment-4789</guid>
					<description><![CDATA[&#062; But I have no idea what “array_ref” and such are for.

See http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3334.html

&#062;  Those are minor trivialities 

If you don&#039;t have the right bricks you can&#039;t build proper houses.]]></description>
		<content:encoded><![CDATA[<p>&gt; But I have no idea what “array_ref” and such are for.</p>
<p>See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3334.html" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3334.html</a></p>
<p>&gt;  Those are minor trivialities </p>
<p>If you don&#8217;t have the right bricks you can&#8217;t build proper houses.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/#comment-4786</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Thu, 09 Feb 2012 05:03:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1375#comment-4786</guid>
					<description><![CDATA[&#062; But even simpler things like array_ref/data_ref/str_ref, shared_array, a range interface for all algorithms are even more important.

The range stuff I can understand. But I have no idea what &quot;array_ref&quot; and such are for.

Furthermore, when it comes to &quot;getting something done&quot;, range-based algorithms aren&#039;t something I see as an impediment to my work. They&#039;re a nicety, some good quality-of-life stuff, but nothing more than that.

If the argument is that people want to use other languages because they have a larger, more feature-rich standard library, they&#039;re *not* talking about range stuff or shared_arrays. Those are minor trivialities compared to networking and such.]]></description>
		<content:encoded><![CDATA[<p>&gt; But even simpler things like array_ref/data_ref/str_ref, shared_array, a range interface for all algorithms are even more important.</p>
<p>The range stuff I can understand. But I have no idea what &#8220;array_ref&#8221; and such are for.</p>
<p>Furthermore, when it comes to &#8220;getting something done&#8221;, range-based algorithms aren&#8217;t something I see as an impediment to my work. They&#8217;re a nicety, some good quality-of-life stuff, but nothing more than that.</p>
<p>If the argument is that people want to use other languages because they have a larger, more feature-rich standard library, they&#8217;re *not* talking about range stuff or shared_arrays. Those are minor trivialities compared to networking and such.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/#comment-4784</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Wed, 08 Feb 2012 23:03:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1375#comment-4784</guid>
					<description><![CDATA[&#062; This stops being possible when C++ has a gigantic standard library. 

Isn&#039;t a large part of the standard library just portable C++? 

&#062; Porting for example, Python to another platform is an arduous task.

Is it? I&#039;d expect most of it to be written in a portable language.

I do find it kinda strange that Herb seems to focus on higher level libs. IMO lower level libs are more important to get standardized first. Standard binary (a)sync file/network IO for example would be great.
Having standard compression and crypto would be welcome too.
But even simpler things like array_ref/data_ref/str_ref, shared_array, a range interface for all algorithms are even more important.
You can&#039;t do high level stuff without getting the low level stuff right first.]]></description>
		<content:encoded><![CDATA[<p>&gt; This stops being possible when C++ has a gigantic standard library. </p>
<p>Isn&#8217;t a large part of the standard library just portable C++? </p>
<p>&gt; Porting for example, Python to another platform is an arduous task.</p>
<p>Is it? I&#8217;d expect most of it to be written in a portable language.</p>
<p>I do find it kinda strange that Herb seems to focus on higher level libs. IMO lower level libs are more important to get standardized first. Standard binary (a)sync file/network IO for example would be great.<br />
Having standard compression and crypto would be welcome too.<br />
But even simpler things like array_ref/data_ref/str_ref, shared_array, a range interface for all algorithms are even more important.<br />
You can&#8217;t do high level stuff without getting the low level stuff right first.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2012/02/02/goingnative-2012-day-2-tomorrow-friday/#comment-4783</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Wed, 08 Feb 2012 16:51:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1375#comment-4783</guid>
					<description><![CDATA[Going Native was absolutely excellent from all involved.

I did have one question. In your Day 2 keynote, you really pushed hard for a much, *much* larger standard library. And I find this disconcerting, for one very important reason.

The first language ported to *any* platform is C. No question about that. The reason being? It&#039;s vital to compiling the OS, but also because it&#039;s tiny. C compilers are small and simple; they can easily be bootstrapped. The C-standard library is similarly microscopic.

What is the second language ported to any platform? C++. Why? For similar reasons to C. Important software is written using it. But also, its standard library is fairly small. You don&#039;t have to port much more than some basic file IO. `std::vector` is pretty cross-platform. You need to port `std::streambuf`, and a few OS and locale-related functions. But that&#039;s it.

This stops being possible when C++ has a gigantic standard library. Porting for example, Python to another platform is an arduous task.

The reason languages like C#, Java, and Python can have immense standard libraries is that there is only *one* implementation of them. OK, there are a couple of Java implementations, and .NET has one in the form of Mono. But these are generally also-rans as far as implementations go. There is one .NET implementation: Microsoft&#039;s. That&#039;s the standard. There is one Java implementation: Sun/Oracle&#039;s. That&#039;s the standard. There is one Python implementation.

C++ has 3 major implementations: GCC+libstdc++, Visual Studio, and Clang&#038;libc++, as well as a plethora of minor ones (ICC, etc). You are asking all of these developers to implement some pretty heavyweight code. XML parsers (that&#039;s pretty substantial for real XML, which means XML IDs, DTDs, XInclude, etc), JSON parsers, sockets, and other stuff. That&#039;s a *lot* of work. And that means a **lot** of bugs.

To make this even remotely feasible, you would need the various C++ interests to create an open-source repository for most of these libraries so that they can share implementations. At which point... all you have is Boost that just happens to be shipped with your compiler.

I just don&#039;t see this as a good idea.

Plus, there&#039;s the very real possibility of the standards committee screwing them up. Take an XML parser. Is that going to be properly C++ized, so that it meshes well with standard algorithms? Will it&#039;s DOM-style interface be an iterator-compatible interface? How does that affect parsing performance? Will the parser be able to be in-situ like RapidXML for that added bit of performance, or will it have to do something else? What parts of XML will it include? Will XSD be included as well (I hope not, because that makes it much more complex)? Will it offer several different styles of parser (reader/writer, SAX-style push parser, and DOM-style tree), or will it just force one on you? How do you deal with Unicode in XML? Does the parser provide a small set of Unicode encodings that it supports, and if you don&#039;t use them, you&#039;re out of luck? Or is it extensible in some way? What&#039;s the interface for extending it, and does it differ between the three parser styles?

The thing about XML parsing today is that you can pick up what you want off the shelf. If I need serious XML processing, I go to LibXML2. It is a full, proper XML parser that has many styles of parsing files. It 

C#, Java, and Python were all defined by *fiat*. For better or worse, their APIs were developed by one tiny group/person, who said, &quot;Our API will look like this!&quot; The committee could easily get bogged down in minutiae over these libraries.

And if they don&#039;t, if the committee basically just rubber-stamps proposals, then we could very easily get a big problem: one thing in the standard doesn&#039;t really work well with other things in the same standard. One of the points of a standard is interoperability: all the pieces work together. With C++, this is mostly true, but there are... odd places. `iostream` really looks out of place next to the STL-derived containers and algorithms. A bit of glue was added with the streambuf iterators, but then... do we really need the iostreams if we can just create a streambuf and input/output iterate over them with algorithms?

Big libraries are not something that committee-based standards are really capable of doing. C# may be an ECMA standard, but that&#039;s because Microsoft did most of the work internally and just said, &quot;Hey, review this and make sure it&#039;s not stupid.&quot; If we&#039;re going to have dozens of contributors for library components running in and dropping code, basically saying, &quot;standardize this pretty much as is,&quot; that&#039;s going to be a real problem.

I get the problem, I really do. Standard libraries are the first stop for people looking for a way to solve problems. And XML, JSON, etc, are problems that a lot of applications need solving. But I don&#039;t think direct standardization is the way to go for these things. It could very easily do more harm in the long-run, creating buggy standard libraries with esoteric, poorly-constructed interfaces that nobody uses anyway.

Personally, I&#039;ve always felt that C++, like C, should have standard libraries that are very general. They should provide common utilities that could be used in pretty much any program. They shouldn&#039;t be providing specific functionality that would be called for directly by design.]]></description>
		<content:encoded><![CDATA[<p>Going Native was absolutely excellent from all involved.</p>
<p>I did have one question. In your Day 2 keynote, you really pushed hard for a much, *much* larger standard library. And I find this disconcerting, for one very important reason.</p>
<p>The first language ported to *any* platform is C. No question about that. The reason being? It&#8217;s vital to compiling the OS, but also because it&#8217;s tiny. C compilers are small and simple; they can easily be bootstrapped. The C-standard library is similarly microscopic.</p>
<p>What is the second language ported to any platform? C++. Why? For similar reasons to C. Important software is written using it. But also, its standard library is fairly small. You don&#8217;t have to port much more than some basic file IO. `std::vector` is pretty cross-platform. You need to port `std::streambuf`, and a few OS and locale-related functions. But that&#8217;s it.</p>
<p>This stops being possible when C++ has a gigantic standard library. Porting for example, Python to another platform is an arduous task.</p>
<p>The reason languages like C#, Java, and Python can have immense standard libraries is that there is only *one* implementation of them. OK, there are a couple of Java implementations, and .NET has one in the form of Mono. But these are generally also-rans as far as implementations go. There is one .NET implementation: Microsoft&#8217;s. That&#8217;s the standard. There is one Java implementation: Sun/Oracle&#8217;s. That&#8217;s the standard. There is one Python implementation.</p>
<p>C++ has 3 major implementations: GCC+libstdc++, Visual Studio, and Clang&amp;libc++, as well as a plethora of minor ones (ICC, etc). You are asking all of these developers to implement some pretty heavyweight code. XML parsers (that&#8217;s pretty substantial for real XML, which means XML IDs, DTDs, XInclude, etc), JSON parsers, sockets, and other stuff. That&#8217;s a *lot* of work. And that means a **lot** of bugs.</p>
<p>To make this even remotely feasible, you would need the various C++ interests to create an open-source repository for most of these libraries so that they can share implementations. At which point&#8230; all you have is Boost that just happens to be shipped with your compiler.</p>
<p>I just don&#8217;t see this as a good idea.</p>
<p>Plus, there&#8217;s the very real possibility of the standards committee screwing them up. Take an XML parser. Is that going to be properly C++ized, so that it meshes well with standard algorithms? Will it&#8217;s DOM-style interface be an iterator-compatible interface? How does that affect parsing performance? Will the parser be able to be in-situ like RapidXML for that added bit of performance, or will it have to do something else? What parts of XML will it include? Will XSD be included as well (I hope not, because that makes it much more complex)? Will it offer several different styles of parser (reader/writer, SAX-style push parser, and DOM-style tree), or will it just force one on you? How do you deal with Unicode in XML? Does the parser provide a small set of Unicode encodings that it supports, and if you don&#8217;t use them, you&#8217;re out of luck? Or is it extensible in some way? What&#8217;s the interface for extending it, and does it differ between the three parser styles?</p>
<p>The thing about XML parsing today is that you can pick up what you want off the shelf. If I need serious XML processing, I go to LibXML2. It is a full, proper XML parser that has many styles of parsing files. It </p>
<p>C#, Java, and Python were all defined by *fiat*. For better or worse, their APIs were developed by one tiny group/person, who said, &#8220;Our API will look like this!&#8221; The committee could easily get bogged down in minutiae over these libraries.</p>
<p>And if they don&#8217;t, if the committee basically just rubber-stamps proposals, then we could very easily get a big problem: one thing in the standard doesn&#8217;t really work well with other things in the same standard. One of the points of a standard is interoperability: all the pieces work together. With C++, this is mostly true, but there are&#8230; odd places. `iostream` really looks out of place next to the STL-derived containers and algorithms. A bit of glue was added with the streambuf iterators, but then&#8230; do we really need the iostreams if we can just create a streambuf and input/output iterate over them with algorithms?</p>
<p>Big libraries are not something that committee-based standards are really capable of doing. C# may be an ECMA standard, but that&#8217;s because Microsoft did most of the work internally and just said, &#8220;Hey, review this and make sure it&#8217;s not stupid.&#8221; If we&#8217;re going to have dozens of contributors for library components running in and dropping code, basically saying, &#8220;standardize this pretty much as is,&#8221; that&#8217;s going to be a real problem.</p>
<p>I get the problem, I really do. Standard libraries are the first stop for people looking for a way to solve problems. And XML, JSON, etc, are problems that a lot of applications need solving. But I don&#8217;t think direct standardization is the way to go for these things. It could very easily do more harm in the long-run, creating buggy standard libraries with esoteric, poorly-constructed interfaces that nobody uses anyway.</p>
<p>Personally, I&#8217;ve always felt that C++, like C, should have standard libraries that are very general. They should provide common utilities that could be used in pretty much any program. They shouldn&#8217;t be providing specific functionality that would be called for directly by design.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
