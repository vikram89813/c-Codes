<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Compatibility	</title>
	<atom:link href="https://herbsutter.com/2012/12/04/compatibility/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/12/04/compatibility/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Patrick Fromberg				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-13854</link>
		<dc:creator><![CDATA[Patrick Fromberg]]></dc:creator>
		<pubDate>Mon, 16 Dec 2013 02:41:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-13854</guid>
					<description><![CDATA[I agree with Nicol Bola that backward compatibility should be achieved with upgrade tools for the old code. That qualifies as easy enough migration path.

I want to remind that backward compatibility is mostly a sacrifice to vendors that are not willing to recompile their code anyway (with or without tool aid) and thus force you to use an old compiler too if you link against their DLLs for e.g. I have three versions of Visual Studio installed as a consequence of such antisocial behavior.

But the good vendors are probably thankful to get a free check and cleanup of their code and not raise compatibility complaints.]]></description>
		<content:encoded><![CDATA[<p>I agree with Nicol Bola that backward compatibility should be achieved with upgrade tools for the old code. That qualifies as easy enough migration path.</p>
<p>I want to remind that backward compatibility is mostly a sacrifice to vendors that are not willing to recompile their code anyway (with or without tool aid) and thus force you to use an old compiler too if you link against their DLLs for e.g. I have three versions of Visual Studio installed as a consequence of such antisocial behavior.</p>
<p>But the good vendors are probably thankful to get a free check and cleanup of their code and not raise compatibility complaints.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: A B				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7719</link>
		<dc:creator><![CDATA[A B]]></dc:creator>
		<pubDate>Mon, 31 Dec 2012 20:37:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7719</guid>
					<description><![CDATA[@Olaf van der Spek
Implicit type conversions (as STL puts it: &quot;C wants desperately to compile your code.&quot;)]]></description>
		<content:encoded><![CDATA[<p>@Olaf van der Spek<br />
Implicit type conversions (as STL puts it: &#8220;C wants desperately to compile your code.&#8221;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt P. Dziubinski				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7557</link>
		<dc:creator><![CDATA[Matt P. Dziubinski]]></dc:creator>
		<pubDate>Sat, 22 Dec 2012 18:23:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7557</guid>
					<description><![CDATA[In particular, when I say &quot;the supporting infrastructure,&quot; I mean pragma restrictions:
http://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Restrictions
http://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-12.html
http://www.adaic.org/resources/add_content/docs/95style/html/sec_10/10-7-2.html
They seem be *somewhat* similar in spirit to, say, C++ AMP&#039;s &quot;restrict&quot; keyword, except for a considerably finer control granularity (in terms of what&#039;s configurable -- see, for instance, the &quot;language defined restrictions identifiers&quot; in the wikibooks&#039; article) and scope: &quot;unless otherwise specified for a particular restriction, a partition shall obey the restriction if a pragma Restrictions applies to any compilation unit included in the partition.&quot;]]></description>
		<content:encoded><![CDATA[<p>In particular, when I say &#8220;the supporting infrastructure,&#8221; I mean pragma restrictions:<br />
<a href="http://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Restrictions" rel="nofollow">http://en.wikibooks.org/wiki/Ada_Programming/Pragmas/Restrictions</a><br />
<a href="http://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-12.html" rel="nofollow">http://www.adaic.org/resources/add_content/standards/05rm/html/RM-13-12.html</a><br />
<a href="http://www.adaic.org/resources/add_content/docs/95style/html/sec_10/10-7-2.html" rel="nofollow">http://www.adaic.org/resources/add_content/docs/95style/html/sec_10/10-7-2.html</a><br />
They seem be *somewhat* similar in spirit to, say, C++ AMP&#8217;s &#8220;restrict&#8221; keyword, except for a considerably finer control granularity (in terms of what&#8217;s configurable &#8212; see, for instance, the &#8220;language defined restrictions identifiers&#8221; in the wikibooks&#8217; article) and scope: &#8220;unless otherwise specified for a particular restriction, a partition shall obey the restriction if a pragma Restrictions applies to any compilation unit included in the partition.&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt P. Dziubinski				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7556</link>
		<dc:creator><![CDATA[Matt P. Dziubinski]]></dc:creator>
		<pubDate>Sat, 22 Dec 2012 18:18:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7556</guid>
					<description><![CDATA[A thought regarding subsets of programming languages -- perhaps the Ada&#039;s Ravenscar profile (and, possibly more importantly, the supporting infrastructure) is an interesting approach: http://en.wikipedia.org/wiki/Ravenscar_profile]]></description>
		<content:encoded><![CDATA[<p>A thought regarding subsets of programming languages &#8212; perhaps the Ada&#8217;s Ravenscar profile (and, possibly more importantly, the supporting infrastructure) is an interesting approach: <a href="http://en.wikipedia.org/wiki/Ravenscar_profile" rel="nofollow">http://en.wikipedia.org/wiki/Ravenscar_profile</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Laurent LR				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7278</link>
		<dc:creator><![CDATA[Laurent LR]]></dc:creator>
		<pubDate>Fri, 07 Dec 2012 09:57:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7278</guid>
					<description><![CDATA[Apparently, the comment system does not like angle brackets, so I&#039;m reposting with adequate quoting.

@Matt : 

Regarding : Imagine they come out with C++15 and that it changes some big but outdated C feature like c-strings (string literals create std::string directly instead)

They won’t, and for the following reasons :
1) out-of-the-box compatibility with C is a top design goal when it comes to changing C++. It is a strength of the language not a drawback. The seldom incompatibilities with C are with regards to C++ having a more consistent, stronger typesystem than C. C-strings are used everywhere in C code, so you’re sure to break code like
const char *foo = “bar”;
which is omnipresent in C programs. That’s a no-go for Bjarne and the committee.
2) They already addressed this specific case. Since C++11, you have a cheap alternative, namely you can define a UDL (user-defined literal) like operator “”s, so that :
- “foo” has type const char *
- “foo”s has type std::string

That’s not the point, I’m just kicking the strawman out.

Regarding: This is not a good situation when trying to move the language forward.

I agree, that’s why the committee is doing an excellent job breaking C compatibility only over-their-dead-body, while still moving the language forward.

Regarding : We need 1)

Honestly, I don’t know what we need. There is a 2006 paper presenting a module system http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf, with a more complete presentation thanI could ever give. I think it’s a good idea because the module manifest would be compiler-generated.

Regarding : We need 2) 3) 4)

You mean, an ABI version, maybe. This could fit with the proposal in 1), and I think it would be a good thing. It would allow tools to generate correct thunks when calling code from a different ABI version. But there is a catch : C++ must link with existing linkers, not specifically designed for C++. They will encounter the same problem as with “who owns template instantiations?”. Who owns the thunks? Now if the thunks are to be local… Wait a minute! Is it not the same problem as calling a C function from C++ code ? How about just wrapping the headers with :
extern “C++11″ {}]]></description>
		<content:encoded><![CDATA[<p>Apparently, the comment system does not like angle brackets, so I&#8217;m reposting with adequate quoting.</p>
<p>@Matt : </p>
<p>Regarding : Imagine they come out with C++15 and that it changes some big but outdated C feature like c-strings (string literals create std::string directly instead)</p>
<p>They won’t, and for the following reasons :<br />
1) out-of-the-box compatibility with C is a top design goal when it comes to changing C++. It is a strength of the language not a drawback. The seldom incompatibilities with C are with regards to C++ having a more consistent, stronger typesystem than C. C-strings are used everywhere in C code, so you’re sure to break code like<br />
const char *foo = “bar”;<br />
which is omnipresent in C programs. That’s a no-go for Bjarne and the committee.<br />
2) They already addressed this specific case. Since C++11, you have a cheap alternative, namely you can define a UDL (user-defined literal) like operator “”s, so that :<br />
&#8211; “foo” has type const char *<br />
&#8211; “foo”s has type std::string</p>
<p>That’s not the point, I’m just kicking the strawman out.</p>
<p>Regarding: This is not a good situation when trying to move the language forward.</p>
<p>I agree, that’s why the committee is doing an excellent job breaking C compatibility only over-their-dead-body, while still moving the language forward.</p>
<p>Regarding : We need 1)</p>
<p>Honestly, I don’t know what we need. There is a 2006 paper presenting a module system <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf</a>, with a more complete presentation thanI could ever give. I think it’s a good idea because the module manifest would be compiler-generated.</p>
<p>Regarding : We need 2) 3) 4)</p>
<p>You mean, an ABI version, maybe. This could fit with the proposal in 1), and I think it would be a good thing. It would allow tools to generate correct thunks when calling code from a different ABI version. But there is a catch : C++ must link with existing linkers, not specifically designed for C++. They will encounter the same problem as with “who owns template instantiations?”. Who owns the thunks? Now if the thunks are to be local… Wait a minute! Is it not the same problem as calling a C function from C++ code ? How about just wrapping the headers with :<br />
extern “C++11″ {}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Laurent LR				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7275</link>
		<dc:creator><![CDATA[Laurent LR]]></dc:creator>
		<pubDate>Fri, 07 Dec 2012 08:33:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7275</guid>
					<description><![CDATA[@Matt : &#060;&#062; They won&#039;t, and for the following reasons :
1) out-of-the-box compatibility with C is a top design goal when it comes to changing C++. It is a strength of the language not a drawback. The seldom incompatibilities with C are with regards to C++ having a more consistent, stronger typesystem than C. C-strings are used everywhere in C code, so you&#039;re sure to break code like
    const char *foo = &quot;bar&quot;;
which is omnipresent in C programs. That&#039;s a no-go for Bjarne and the committee.
2) They already addressed this specific case. Since C++11, you have a cheap alternative, namely you can define a UDL (user-defined literal) like operator &quot;&quot;s, so that :
    - &quot;foo&quot; has type const char *
    - &quot;foo&quot;s has type std::string

That&#039;s not the point, I&#039;m just kicking the strawman out.

&#060;&#062; I agree, that&#039;s why the committee is doing an excellent job breaking C compatibility only over-their-dead-body, while still moving the language forward.

&#060;&#062; Honestly, I don&#039;t know what we need. There is a 2006 paper presenting a module system http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf, with a more complete presentation that I could ever give. I think it&#039;s a good idea because the module manifest would be compiler-generated.

&#060;&#062; You mean, an ABI version, maybe. This could fit with the proposal in 1), and I think it would be a good thing. It would allow tools to generate correct thunks when calling code from a different ABI version. But there is a catch : C++ must link with existing linkers, not specifically designed for C++. They will encounter the same problem as with &quot;who owns template instantiations?&quot;. Who owns the thunks? Now if the thunks are to be local... Wait a minute! Is it not the same problem as calling a C function from C++ code ? How about just wrapping the headers with :
    extern &quot;C++11&quot; {}]]></description>
		<content:encoded><![CDATA[<p>@Matt : &lt;&gt; They won&#8217;t, and for the following reasons :<br />
1) out-of-the-box compatibility with C is a top design goal when it comes to changing C++. It is a strength of the language not a drawback. The seldom incompatibilities with C are with regards to C++ having a more consistent, stronger typesystem than C. C-strings are used everywhere in C code, so you&#8217;re sure to break code like<br />
    const char *foo = &#8220;bar&#8221;;<br />
which is omnipresent in C programs. That&#8217;s a no-go for Bjarne and the committee.<br />
2) They already addressed this specific case. Since C++11, you have a cheap alternative, namely you can define a UDL (user-defined literal) like operator &#8220;&#8221;s, so that :<br />
    &#8211; &#8220;foo&#8221; has type const char *<br />
    &#8211; &#8220;foo&#8221;s has type std::string</p>
<p>That&#8217;s not the point, I&#8217;m just kicking the strawman out.</p>
<p>&lt;&gt; I agree, that&#8217;s why the committee is doing an excellent job breaking C compatibility only over-their-dead-body, while still moving the language forward.</p>
<p>&lt;&gt; Honestly, I don&#8217;t know what we need. There is a 2006 paper presenting a module system <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf</a>, with a more complete presentation that I could ever give. I think it&#8217;s a good idea because the module manifest would be compiler-generated.</p>
<p>&lt;&gt; You mean, an ABI version, maybe. This could fit with the proposal in 1), and I think it would be a good thing. It would allow tools to generate correct thunks when calling code from a different ABI version. But there is a catch : C++ must link with existing linkers, not specifically designed for C++. They will encounter the same problem as with &#8220;who owns template instantiations?&#8221;. Who owns the thunks? Now if the thunks are to be local&#8230; Wait a minute! Is it not the same problem as calling a C function from C++ code ? How about just wrapping the headers with :<br />
    extern &#8220;C++11&#8221; {}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7251</link>
		<dc:creator><![CDATA[Matt]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 16:33:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7251</guid>
					<description><![CDATA[@spmisra
Imagine they come out with C++15 and that it changes some big but outdated C feature like c-strings (string literals create std::string directly instead).  This wouldn&#039;t cause any ABI changes but it would cause tons of old code to break.  If I wanted to write new code in the new version but use libraries written in C++11 I would either have to be lucky enough to be using a library that happened not to use c-strings in an incompatible way in it&#039;s headers, or I would have to write a wrapper layer and then hope that my compiler produces compatible ABI for the two different versions (no guarantee of that in the standard).  It only gets worse the more things you change.

This is not a good situation when trying to move the language forward.

We need:
1) A module system that the compiler is aware of so it can distinguish between different code bases.
2) A standard way of specifying language version. This couldn&#039;t be done using flags because the standard has no control over that. If we don&#039;t do this then we depend on the build system to figure out the language versions of our libraries (which may themselves contain multiple versions).
3) Specify in the standard that a single version of a compiler MUST support outputting ABI compatible code for all supported language versions.
4) Possibly specify which versions of the language a compiler MUST support to be fully compliant which would change as new versions were added and old ones were rotated out.  Not sure if this really necessary or not.

Without something along those lines we will always be timid when adding and removing features from the language, and we will always have slow uptake of new versions.]]></description>
		<content:encoded><![CDATA[<p>@spmisra<br />
Imagine they come out with C++15 and that it changes some big but outdated C feature like c-strings (string literals create std::string directly instead).  This wouldn&#8217;t cause any ABI changes but it would cause tons of old code to break.  If I wanted to write new code in the new version but use libraries written in C++11 I would either have to be lucky enough to be using a library that happened not to use c-strings in an incompatible way in it&#8217;s headers, or I would have to write a wrapper layer and then hope that my compiler produces compatible ABI for the two different versions (no guarantee of that in the standard).  It only gets worse the more things you change.</p>
<p>This is not a good situation when trying to move the language forward.</p>
<p>We need:<br />
1) A module system that the compiler is aware of so it can distinguish between different code bases.<br />
2) A standard way of specifying language version. This couldn&#8217;t be done using flags because the standard has no control over that. If we don&#8217;t do this then we depend on the build system to figure out the language versions of our libraries (which may themselves contain multiple versions).<br />
3) Specify in the standard that a single version of a compiler MUST support outputting ABI compatible code for all supported language versions.<br />
4) Possibly specify which versions of the language a compiler MUST support to be fully compliant which would change as new versions were added and old ones were rotated out.  Not sure if this really necessary or not.</p>
<p>Without something along those lines we will always be timid when adding and removing features from the language, and we will always have slow uptake of new versions.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Laurent LR				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7235</link>
		<dc:creator><![CDATA[Laurent LR]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 12:40:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7235</guid>
					<description><![CDATA[@Olaf : Let&#039;s put aside the fact that compatibility with C has already been broken, early, and at least twice. (implicit conversion from a void* to T*, and implicit conversion of a string literal to a non-const char *) I&#039; The language will still get bigger due to backward compatibility, but the design aims of the committee has always been to replace unsafe C features by safer alternatives, and to simplify the language. (by still making the language bigger for backward compatibility, but providing uniform ways of saying related things)

I&#039;d say that only one kind of significant improvement is impossible : except breaking compatibility to remove what ought not be used anymore, due to the presence of far superior alternatives. 

@tivadj : C++ is not C. More precisely C++ is not C plus extensions, it&#039;s C plus extensions minus inferior alternatives. The drawback is not &quot;backward compatibility&quot;, it&#039;s that it is the programmer&#039;s responsibility not to use backward compatibility features to produce new code.

@Ran : I am enthusiastic about C++11, and eagerly waiting for it since back in 2005. It&#039;s a significant improvement over previous versions, more than any other language has ever had. (I love move semantics! I&#039;m moving things around all day now, and &quot;Look, Ma! No pointers in app code!&quot;) I disagree with you. I think it&#039;s perfectly normal to be enthousiastic about C++11, and to show enthusiasm. It&#039;s feels like a more correct language than C++03.]]></description>
		<content:encoded><![CDATA[<p>@Olaf : Let&#8217;s put aside the fact that compatibility with C has already been broken, early, and at least twice. (implicit conversion from a void* to T*, and implicit conversion of a string literal to a non-const char *) I&#8217; The language will still get bigger due to backward compatibility, but the design aims of the committee has always been to replace unsafe C features by safer alternatives, and to simplify the language. (by still making the language bigger for backward compatibility, but providing uniform ways of saying related things)</p>
<p>I&#8217;d say that only one kind of significant improvement is impossible : except breaking compatibility to remove what ought not be used anymore, due to the presence of far superior alternatives. </p>
<p>@tivadj : C++ is not C. More precisely C++ is not C plus extensions, it&#8217;s C plus extensions minus inferior alternatives. The drawback is not &#8220;backward compatibility&#8221;, it&#8217;s that it is the programmer&#8217;s responsibility not to use backward compatibility features to produce new code.</p>
<p>@Ran : I am enthusiastic about C++11, and eagerly waiting for it since back in 2005. It&#8217;s a significant improvement over previous versions, more than any other language has ever had. (I love move semantics! I&#8217;m moving things around all day now, and &#8220;Look, Ma! No pointers in app code!&#8221;) I disagree with you. I think it&#8217;s perfectly normal to be enthousiastic about C++11, and to show enthusiasm. It&#8217;s feels like a more correct language than C++03.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ran				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7228</link>
		<dc:creator><![CDATA[Ran]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 08:41:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7228</guid>
					<description><![CDATA[I was misunderstood (and got too many thumbs down),
I&#039;m completely C++ fanatic, I don&#039;t know any other languge!
the point was that Herb Sutter and others, talk too much about how c++11 is good, that for a listener from the outside, it sounds AS IF they are not convinced themselves.
like a man telling his wife he loves her twenty times a day. it doesn&#039;t feel right.
that it what I meant. 
I&#039;m completely into C++, C++11 is great, 

I hope I was clearer now.]]></description>
		<content:encoded><![CDATA[<p>I was misunderstood (and got too many thumbs down),<br />
I&#8217;m completely C++ fanatic, I don&#8217;t know any other languge!<br />
the point was that Herb Sutter and others, talk too much about how c++11 is good, that for a listener from the outside, it sounds AS IF they are not convinced themselves.<br />
like a man telling his wife he loves her twenty times a day. it doesn&#8217;t feel right.<br />
that it what I meant.<br />
I&#8217;m completely into C++, C++11 is great, </p>
<p>I hope I was clearer now.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: spmisra				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7226</link>
		<dc:creator><![CDATA[spmisra]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 05:23:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7226</guid>
					<description><![CDATA[Reblogged this on &lt;a href=&quot;http://spmisra.wordpress.com/2012/12/06/compatibility/&quot; rel=&quot;nofollow&quot;&gt;BrainWorks&lt;/a&gt; and commented: 
Some interesting thought I think I should share.]]></description>
		<content:encoded><![CDATA[<p>Reblogged this on <a href="http://spmisra.wordpress.com/2012/12/06/compatibility/" rel="nofollow">BrainWorks</a> and commented:<br />
Some interesting thought I think I should share.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: spmisra				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7225</link>
		<dc:creator><![CDATA[spmisra]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 04:49:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7225</guid>
					<description><![CDATA[@Nicol : I agree, CLang paves the way, and helps noob experimenters like me to use C++ parsers and code generator.
@HotDeal, Ran : I do not agree. I think C++ committee has a definite aim and is doing a good job. There is more discussion because people are curious. And its nice of the C++ community to talk and educate people, its not worthless rambling.
@Rick Yorgason: I am not an expert, but i don&#039;t think a standard AST will be enough, because again then it may not give enough room for improvement and optimization. I thinks its not only language that will make it compatible, but the way we design our systems. Now a days no one uses a single language, with a plethora of languages at work, design should dictate the communication. Apart from that CLang has a novel way of integrating languages, but CLang is a tool. So leas leave the AST part to tools.
@tivadj : I think it was an excellent decision, C++ could not let go of &quot;struct&quot; keyword, so it would be good to maintain compatibility with C. C++ is not bigger C, its different, its just similar.
@Matt : I think we do not need this, we already have #ifdef&#039;s and compiler options for those kind of things. So it will be better not to introduce VERSION.]]></description>
		<content:encoded><![CDATA[<p>@Nicol : I agree, CLang paves the way, and helps noob experimenters like me to use C++ parsers and code generator.<br />
@HotDeal, Ran : I do not agree. I think C++ committee has a definite aim and is doing a good job. There is more discussion because people are curious. And its nice of the C++ community to talk and educate people, its not worthless rambling.<br />
@Rick Yorgason: I am not an expert, but i don&#8217;t think a standard AST will be enough, because again then it may not give enough room for improvement and optimization. I thinks its not only language that will make it compatible, but the way we design our systems. Now a days no one uses a single language, with a plethora of languages at work, design should dictate the communication. Apart from that CLang has a novel way of integrating languages, but CLang is a tool. So leas leave the AST part to tools.<br />
@tivadj : I think it was an excellent decision, C++ could not let go of &#8220;struct&#8221; keyword, so it would be good to maintain compatibility with C. C++ is not bigger C, its different, its just similar.<br />
@Matt : I think we do not need this, we already have #ifdef&#8217;s and compiler options for those kind of things. So it will be better not to introduce VERSION.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: HotDeal				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7224</link>
		<dc:creator><![CDATA[HotDeal]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 04:15:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7224</guid>
					<description><![CDATA[I&#039;m with Ran.  It&#039;s really hard to get behind a technology that the technologist are not even sure if it&#039;s good enough.  It is a little scary.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m with Ran.  It&#8217;s really hard to get behind a technology that the technologist are not even sure if it&#8217;s good enough.  It is a little scary.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rick Yorgason				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7202</link>
		<dc:creator><![CDATA[Rick Yorgason]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 11:49:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7202</guid>
					<description><![CDATA[Out of curiosity, did your private experiments come up with any insight about what stands in the way of a simple migration path? Will modules be enough? Will we need a standardized AST format to make compiled modules inter-compatible?]]></description>
		<content:encoded><![CDATA[<p>Out of curiosity, did your private experiments come up with any insight about what stands in the way of a simple migration path? Will modules be enough? Will we need a standardized AST format to make compiled modules inter-compatible?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: WhatIsHeDoing				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7199</link>
		<dc:creator><![CDATA[WhatIsHeDoing]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 11:10:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7199</guid>
					<description><![CDATA[The backwards-compatibility point is moot if you migrate to a Service-Oriented Architecture.]]></description>
		<content:encoded><![CDATA[<p>The backwards-compatibility point is moot if you migrate to a Service-Oriented Architecture.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: tivadj				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7192</link>
		<dc:creator><![CDATA[tivadj]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 08:48:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7192</guid>
					<description><![CDATA[It was the Bjarne&#039;s mistake to make C++ backward compatible with C. Instead of inheritance &quot;NewLang IS OldLang&quot; it is better to use composition plus code-generators to fill the gap.
Sometimes I wonder how the world would look if Bjarne choose this way with C++.]]></description>
		<content:encoded><![CDATA[<p>It was the Bjarne&#8217;s mistake to make C++ backward compatible with C. Instead of inheritance &#8220;NewLang IS OldLang&#8221; it is better to use composition plus code-generators to fill the gap.<br />
Sometimes I wonder how the world would look if Bjarne choose this way with C++.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ran				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7191</link>
		<dc:creator><![CDATA[Ran]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 08:23:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7191</guid>
					<description><![CDATA[there are lots of &#039;why c++?&#039; and &#039;is c++ dead?&#039; and &#039;c++ resurrection&#039; etc.
and lots of words trying to convince that c++ is good and c++11 is even better.
I say: enough!
there is no point in all these talks.
It starts sound like that the c++ community itself is not certain that c++11 is really good.
when you talk too much about something you are sure of... well, enough.]]></description>
		<content:encoded><![CDATA[<p>there are lots of &#8216;why c++?&#8217; and &#8216;is c++ dead?&#8217; and &#8216;c++ resurrection&#8217; etc.<br />
and lots of words trying to convince that c++ is good and c++11 is even better.<br />
I say: enough!<br />
there is no point in all these talks.<br />
It starts sound like that the c++ community itself is not certain that c++11 is really good.<br />
when you talk too much about something you are sure of&#8230; well, enough.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pjmlp				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7177</link>
		<dc:creator><![CDATA[pjmlp]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 21:17:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7177</guid>
					<description><![CDATA[This seems to follow a bit the same path of &quot;worse is better&quot; principle, regardless of much better a given technology is, if the old way is not taken into account, it might just fail.]]></description>
		<content:encoded><![CDATA[<p>This seems to follow a bit the same path of &#8220;worse is better&#8221; principle, regardless of much better a given technology is, if the old way is not taken into account, it might just fail.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7172</link>
		<dc:creator><![CDATA[Matt]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 19:03:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7172</guid>
					<description><![CDATA[perl5 has managed to make big changes to the language while keeping everything in the same ecosystem with it&#039;s  &quot;use VERSION&quot; statements.  I&#039;ve never understood why it hasn&#039;t been copied by other languages.  We would probably need real modules first but as long as you had a compiler that could enable different language features depending on the module (how many compilers don&#039;t already support a ton of dialects as it is?) and had rules for managing the ABI differences I think it would be pretty easy to manage on the development side and would free C++ to become a true modern language.]]></description>
		<content:encoded><![CDATA[<p>perl5 has managed to make big changes to the language while keeping everything in the same ecosystem with it&#8217;s  &#8220;use VERSION&#8221; statements.  I&#8217;ve never understood why it hasn&#8217;t been copied by other languages.  We would probably need real modules first but as long as you had a compiler that could enable different language features depending on the module (how many compilers don&#8217;t already support a ton of dialects as it is?) and had rules for managing the ABI differences I think it would be pretty easy to manage on the development side and would free C++ to become a true modern language.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Nicol Bolas				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7171</link>
		<dc:creator><![CDATA[Nicol Bolas]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 18:46:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7171</guid>
					<description><![CDATA[I think Clang represents the greatest possibility for having a New C++ kind of language. The fact that it exports an AST syntax tree that can be converted back and forth from text to tree without losing any information allows it to become the basis of a transformation into a new language.

And thus, backwards compatibility can be achieved by simply running code through a tool that is able to convert 100% of the code into the new language. Variables are renamed to avoid conflicts with new keywords, and so forth. If the new language has the same expressiveness as C++, then such an automated transformation must be possible.

The problem until now has been that there is no tool to be able to do it. We now have one. This moves the problem from lack-of-tool support to lack-of-will. That is, we need people who actually want to do this and are willing to put in the considerable time and effort to see it done.]]></description>
		<content:encoded><![CDATA[<p>I think Clang represents the greatest possibility for having a New C++ kind of language. The fact that it exports an AST syntax tree that can be converted back and forth from text to tree without losing any information allows it to become the basis of a transformation into a new language.</p>
<p>And thus, backwards compatibility can be achieved by simply running code through a tool that is able to convert 100% of the code into the new language. Variables are renamed to avoid conflicts with new keywords, and so forth. If the new language has the same expressiveness as C++, then such an automated transformation must be possible.</p>
<p>The problem until now has been that there is no tool to be able to do it. We now have one. This moves the problem from lack-of-tool support to lack-of-will. That is, we need people who actually want to do this and are willing to put in the considerable time and effort to see it done.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/12/04/compatibility/#comment-7167</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 18:16:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1691#comment-7167</guid>
					<description><![CDATA[I&#039;m wondering, what kind of significant improvements to C++ are impossible due to backwards compatibility issues?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m wondering, what kind of significant improvements to C++ are impossible due to backwards compatibility issues?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
