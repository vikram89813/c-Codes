<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Perspective: &#8220;Why C++ Is Not &#8216;Back&#8217;&#8221;	</title>
	<atom:link href="https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: gast128				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-13906</link>
		<dc:creator><![CDATA[gast128]]></dc:creator>
		<pubDate>Mon, 23 Dec 2013 16:02:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-13906</guid>
					<description><![CDATA[I have a love-hate relationship with c++. I like the plain abstraction, its syntax and its value semantics. On the other hand I cannot appreciate the following things:
- compilation speed. In my work we have a 100 project solution, which takes 1 hour to build. We already use pch and all the compilation tricks. Other people here use c# and that compiles in minutes. Is it related to all the Boost template stuff, or is MS deliberately holding back c++ compilation?
- templates. They are very handy but there are many dark corners. When we upgraded to vstudio 2008 we encountered a problem which took us days. It turned out to be a non obvious issue which was correctly rejected.
- c++ tendency to allow redefinition of variables in various scopes. Also with overloads there are many pitfalls.
- universal references. I am not sure who voted the current syntax in. The rules of turning a rvalue into a lvalue are not obvious.
- backward compatibility is good for the short term (everything stays compilable) but blocks long term evolution. I wouldn&#039;t mind if a proposal break old code if that would improve build speeds (e.g. in the template syntax). Ofc there is many c++ code written, but can&#039;t this be solved by compiler flags? K&#038;R C has also died.]]></description>
		<content:encoded><![CDATA[<p>I have a love-hate relationship with c++. I like the plain abstraction, its syntax and its value semantics. On the other hand I cannot appreciate the following things:<br />
&#8211; compilation speed. In my work we have a 100 project solution, which takes 1 hour to build. We already use pch and all the compilation tricks. Other people here use c# and that compiles in minutes. Is it related to all the Boost template stuff, or is MS deliberately holding back c++ compilation?<br />
&#8211; templates. They are very handy but there are many dark corners. When we upgraded to vstudio 2008 we encountered a problem which took us days. It turned out to be a non obvious issue which was correctly rejected.<br />
&#8211; c++ tendency to allow redefinition of variables in various scopes. Also with overloads there are many pitfalls.<br />
&#8211; universal references. I am not sure who voted the current syntax in. The rules of turning a rvalue into a lvalue are not obvious.<br />
&#8211; backward compatibility is good for the short term (everything stays compilable) but blocks long term evolution. I wouldn&#8217;t mind if a proposal break old code if that would improve build speeds (e.g. in the template syntax). Ofc there is many c++ code written, but can&#8217;t this be solved by compiler flags? K&amp;R C has also died.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Craig				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-12977</link>
		<dc:creator><![CDATA[Craig]]></dc:creator>
		<pubDate>Fri, 18 Oct 2013 21:41:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-12977</guid>
					<description><![CDATA[Managed languages are the right choice for the large majority of use cases. C is usually the most pragmatic choice for use cases that call for a lower level of abstraction and/or higher level of control.

C++ just doesn&#039;t have enough to offer to justify it&#039;s horrifying complexity, internal inconsistency and glacial compilation speed. Ensuring the job security of and dependence upon the sadists willing to learn it is just about the only thing it has going for it.]]></description>
		<content:encoded><![CDATA[<p>Managed languages are the right choice for the large majority of use cases. C is usually the most pragmatic choice for use cases that call for a lower level of abstraction and/or higher level of control.</p>
<p>C++ just doesn&#8217;t have enough to offer to justify it&#8217;s horrifying complexity, internal inconsistency and glacial compilation speed. Ensuring the job security of and dependence upon the sadists willing to learn it is just about the only thing it has going for it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: dhina				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-12286</link>
		<dc:creator><![CDATA[dhina]]></dc:creator>
		<pubDate>Thu, 22 Aug 2013 17:37:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-12286</guid>
					<description><![CDATA[@Bob
&quot; 9 out of every 10 job postings do not require knowledge of c++ or c&quot;
9 out of every 10 programmer in the world knows gc’d language like c#/java/python etc.  More demand, more supply.]]></description>
		<content:encoded><![CDATA[<p>@Bob<br />
&#8221; 9 out of every 10 job postings do not require knowledge of c++ or c&#8221;<br />
9 out of every 10 programmer in the world knows gc’d language like c#/java/python etc.  More demand, more supply.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bob				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-12207</link>
		<dc:creator><![CDATA[Bob]]></dc:creator>
		<pubDate>Sat, 17 Aug 2013 02:36:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-12207</guid>
					<description><![CDATA[There is currently a higher demand for programmers than can be filled.  I am guessing 9 out of every 10 job postings do not require knowledge of c++ or c and only expect training in a gc&#039;d language like c#/java/python etc.  So given this metric I&#039;d agree with John that you don&#039;t &quot;need&quot; it unless you really 
want to pursue a field that demands it&#039;s 
low evel/latency.  Secondly with Moores law approaching an end a low energy intensity language like c++ only becomes more valuable as embedded devices become more and more ubiquitous in our daily lives.  I hope the c++ standards committee considers this and supports additions that are &#039;light&#039; and most importantly safe as lives will depend on code correctness.]]></description>
		<content:encoded><![CDATA[<p>There is currently a higher demand for programmers than can be filled.  I am guessing 9 out of every 10 job postings do not require knowledge of c++ or c and only expect training in a gc&#8217;d language like c#/java/python etc.  So given this metric I&#8217;d agree with John that you don&#8217;t &#8220;need&#8221; it unless you really<br />
want to pursue a field that demands it&#8217;s<br />
low evel/latency.  Secondly with Moores law approaching an end a low energy intensity language like c++ only becomes more valuable as embedded devices become more and more ubiquitous in our daily lives.  I hope the c++ standards committee considers this and supports additions that are &#8216;light&#8217; and most importantly safe as lives will depend on code correctness.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dhina				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7467</link>
		<dc:creator><![CDATA[Dhina]]></dc:creator>
		<pubDate>Sat, 15 Dec 2012 09:57:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7467</guid>
					<description><![CDATA[It is waste of time fighting over languages because one language does not suit all industries.  I worked mainly in the financial industry where C++ is used extensively.  I have seen good C++ developers quitting jobs for better opportunities/pay and non-C++ developers getting fired.  It many be different in other industries.]]></description>
		<content:encoded><![CDATA[<p>It is waste of time fighting over languages because one language does not suit all industries.  I worked mainly in the financial industry where C++ is used extensively.  I have seen good C++ developers quitting jobs for better opportunities/pay and non-C++ developers getting fired.  It many be different in other industries.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: KCs				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7436</link>
		<dc:creator><![CDATA[KCs]]></dc:creator>
		<pubDate>Fri, 14 Dec 2012 04:52:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7436</guid>
					<description><![CDATA[For me the biggest problem with C++ is code readability, and maintainability. When you read C++ code (especially written by someone else) you can never be sure what it means, and what path it will follow. The many examples on GotW just reinforces this feeling, that I have to do a small research when I read a single line of code because it could mean 7 things.]]></description>
		<content:encoded><![CDATA[<p>For me the biggest problem with C++ is code readability, and maintainability. When you read C++ code (especially written by someone else) you can never be sure what it means, and what path it will follow. The many examples on GotW just reinforces this feeling, that I have to do a small research when I read a single line of code because it could mean 7 things.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: HTML4++ &#124; Coder Radio &#124; Jupiter Broadcasting				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7354</link>
		<dc:creator><![CDATA[HTML4++ &#124; Coder Radio &#124; Jupiter Broadcasting]]></dc:creator>
		<pubDate>Mon, 10 Dec 2012 20:23:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7354</guid>
					<description><![CDATA[[...] Perspective: Why C++ is not back [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Perspective: Why C++ is not back [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: tonyk				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7343</link>
		<dc:creator><![CDATA[tonyk]]></dc:creator>
		<pubDate>Mon, 10 Dec 2012 14:49:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7343</guid>
					<description><![CDATA[Thank you for your reply, Herb!]]></description>
		<content:encoded><![CDATA[<p>Thank you for your reply, Herb!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7303</link>
		<dc:creator><![CDATA[John]]></dc:creator>
		<pubDate>Fri, 07 Dec 2012 20:04:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7303</guid>
					<description><![CDATA[@Joe: Please keep in mind that Dalvik VM is not the best implementation of Java. In fact XobotOS (Android ported to C#) is much faster than Dalvik (http://www.infoq.com/news/2012/05/XobotOS).]]></description>
		<content:encoded><![CDATA[<p>@Joe: Please keep in mind that Dalvik VM is not the best implementation of Java. In fact XobotOS (Android ported to C#) is much faster than Dalvik (<a href="http://www.infoq.com/news/2012/05/XobotOS" rel="nofollow">http://www.infoq.com/news/2012/05/XobotOS</a>).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joe				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7288</link>
		<dc:creator><![CDATA[Joe]]></dc:creator>
		<pubDate>Fri, 07 Dec 2012 13:39:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7288</guid>
					<description><![CDATA[@earwicker: I do agree that brittleness in general is bad, and one of the limitations of C++ that I will readily admit is that it is unforgiving of sloppiness. Unfortunately, with C++ it can lead to the introduction of subtle bugs if there isn&#039;t pretty strong code review catching such things.

That said, I also believe that sloppy programmers cost you time and money no matter what language you are using. They tend to create unmaintainable software that requires refactoring. I don&#039;t really believe that C++ is any less conducive to refactoring than C#, however, aside from that the tools for doing so are well behind what&#039;s available in C#.

As for the getting X right from the beginning stuff, that is advice meant to tell you that if you don&#039;t include such considerations from the start then you can be ready for completely overhauling your architecture - to the point of basically starting from scratch - when you finally realize that what you have is fundamentally unable to support  what you need to do. There is no language that makes such things easy, and I haven&#039;t really found the care you have to exercise in C++ in avoiding undefined behavior to be the real limiting factor there.

I&#039;m not going to defend how easy it is to trash memory in C or C++, but on the other hand it&#039;s a problem I rarely encounter simply because I don&#039;t do much pointer arithmetic, and I don&#039;t allow developers working on my projects to do so, either.

Also, while the sky may not have fallen with Android requiring applications to be written in Java, and despite the fact that I prefer Android to iOS, I can also admit that I have seen even high-end Android phones get laggy in a way I haven&#039;t really experienced on iOS. It&#039;s not sky-falling bad, but it is noticeable, and it&#039;s something I wish wouldn&#039;t happen. Now, whether that&#039;s the fact that everything is running in the Dalvik VM I can&#039;t say, but it is a real phenomenon.]]></description>
		<content:encoded><![CDATA[<p>@earwicker: I do agree that brittleness in general is bad, and one of the limitations of C++ that I will readily admit is that it is unforgiving of sloppiness. Unfortunately, with C++ it can lead to the introduction of subtle bugs if there isn&#8217;t pretty strong code review catching such things.</p>
<p>That said, I also believe that sloppy programmers cost you time and money no matter what language you are using. They tend to create unmaintainable software that requires refactoring. I don&#8217;t really believe that C++ is any less conducive to refactoring than C#, however, aside from that the tools for doing so are well behind what&#8217;s available in C#.</p>
<p>As for the getting X right from the beginning stuff, that is advice meant to tell you that if you don&#8217;t include such considerations from the start then you can be ready for completely overhauling your architecture &#8211; to the point of basically starting from scratch &#8211; when you finally realize that what you have is fundamentally unable to support  what you need to do. There is no language that makes such things easy, and I haven&#8217;t really found the care you have to exercise in C++ in avoiding undefined behavior to be the real limiting factor there.</p>
<p>I&#8217;m not going to defend how easy it is to trash memory in C or C++, but on the other hand it&#8217;s a problem I rarely encounter simply because I don&#8217;t do much pointer arithmetic, and I don&#8217;t allow developers working on my projects to do so, either.</p>
<p>Also, while the sky may not have fallen with Android requiring applications to be written in Java, and despite the fact that I prefer Android to iOS, I can also admit that I have seen even high-end Android phones get laggy in a way I haven&#8217;t really experienced on iOS. It&#8217;s not sky-falling bad, but it is noticeable, and it&#8217;s something I wish wouldn&#8217;t happen. Now, whether that&#8217;s the fact that everything is running in the Dalvik VM I can&#8217;t say, but it is a real phenomenon.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7232</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Thu, 06 Dec 2012 10:47:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7232</guid>
					<description><![CDATA[@Joe - &quot;I also don’t find the “resources don’t matter” argument particularly convincing.&quot;

You&#039;re absolutely right there - we have yet to reach the far-off horizon where computation is free. In particular, when your software is running in the cloud you are typically charged in real money for every CPU cycle you waste! So it is possible to put a dollar value on the ability to save cycles and for a very heavily used application it will quickly add up to something worthwhile.

Same goes for mobile devices and battery life, of course.

But what of the assumption that C++ (or any other language that inherits C&#039;s memory-trashing undefined behaviour foundations, such as Objective C) is the solution to this problem? 

Almost all Android apps are written in Java and run in a virtual machine, and the sky hasn&#039;t fallen in yet. Why is that? C++ offers the power of micro-optimisation, but we all know that the big savings come from choosing the right algorithms.

The most widely abused phrase in software advice is &quot;You have to get X right from the beginning, it can&#039;t be bolted on as an afterthought&quot;. The problem here is that X can be practically anything about your software (security, thread-safety, usability, performant algorithms), and we can&#039;t do it all from the beginning and get it right, because they are all choices that affect each other! Something&#039;s got to give. What we need is the ability to change our minds as we go along. i.e. we need software that is malleable, not brittle: easy to modify while preserving correctness, etc.

This, ultimately, is why C&#039;s memory-trashing undefined behaviour foundations are a problem: because they contribute to brittleness. A working C/C++/Objective C program is balanced on a tightrope halfway across the Grand Canyon, and the best thing to do is try not to shake the tightrope. Acrobatics are out of the question at that point.]]></description>
		<content:encoded><![CDATA[<p>@Joe &#8211; &#8220;I also don’t find the “resources don’t matter” argument particularly convincing.&#8221;</p>
<p>You&#8217;re absolutely right there &#8211; we have yet to reach the far-off horizon where computation is free. In particular, when your software is running in the cloud you are typically charged in real money for every CPU cycle you waste! So it is possible to put a dollar value on the ability to save cycles and for a very heavily used application it will quickly add up to something worthwhile.</p>
<p>Same goes for mobile devices and battery life, of course.</p>
<p>But what of the assumption that C++ (or any other language that inherits C&#8217;s memory-trashing undefined behaviour foundations, such as Objective C) is the solution to this problem? </p>
<p>Almost all Android apps are written in Java and run in a virtual machine, and the sky hasn&#8217;t fallen in yet. Why is that? C++ offers the power of micro-optimisation, but we all know that the big savings come from choosing the right algorithms.</p>
<p>The most widely abused phrase in software advice is &#8220;You have to get X right from the beginning, it can&#8217;t be bolted on as an afterthought&#8221;. The problem here is that X can be practically anything about your software (security, thread-safety, usability, performant algorithms), and we can&#8217;t do it all from the beginning and get it right, because they are all choices that affect each other! Something&#8217;s got to give. What we need is the ability to change our minds as we go along. i.e. we need software that is malleable, not brittle: easy to modify while preserving correctness, etc.</p>
<p>This, ultimately, is why C&#8217;s memory-trashing undefined behaviour foundations are a problem: because they contribute to brittleness. A working C/C++/Objective C program is balanced on a tightrope halfway across the Grand Canyon, and the best thing to do is try not to shake the tightrope. Acrobatics are out of the question at that point.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joe				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7221</link>
		<dc:creator><![CDATA[Joe]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 23:05:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7221</guid>
					<description><![CDATA[I find it interesting that someone mentions WPF as a highly productive tool for GUIs when I have found it to be the opposite. It&#039;s quite quick when you want to do flashy things, but if you need standard Windows behavior, you frequently have to reimplement it yourself, because the framework doesn&#039;t provide it out of the box (for example, something as simple as graying out a button with an icon when it&#039;s disabled requires writing your own image filter - but it just happens in the C API).

The result is an army of developers reinventing the square wheel as they poorly approximate the behavior of every normal application. Windows Forms is better about this, since it&#039;s a thin wrapper around the Windows API, but it&#039;s far from perfect. The number of C# developers who understand even the basics of window relationships and whether a window should or should not appear on the taskbar, how to put a window on top of its owner without putting it on top of every window in the system, etc., is shockingly small. But then if speed is your main goal and not correctness or making good use of system resources, C# is a great choice. Right tool for the job and all that.

Don&#039;t get me wrong. I actually like C# quite a bit. But I think the benefits are oversold (though not to the absurd hype degree they were with Java).

As for the portability argument, having actually written portable code in both C# and C++ that ran on both Windows and Android, I can say I vastly prefer C++ for the task. Mono is nice, but it isn&#039;t a panacea. New versions of the framework have required me to change my code to keep it compiling. Once I ported my support libraries - which took time, but not a lot in the grand scheme of things - I never touch my C++ code. And the C++ code is noticeably faster to start up.

I would also throw in for the benefits of RAII over anything that the managed languages offer. C++ / CLI is the only exception, because it has the right idea with allowing you to treat managed objects as though they were scope-bound. Really, the managed languages could have this if they allowed you to attach an implicit finally to every instance of an object, but they don&#039;t. The using and try-with-resources statements are very poor approximations of RAII, and the amount of code in C# I have seen where developers fail to release resources properly makes any arguments that these languages let you concentrate on more important things than that ring hollow. Garbage collection is nice, but I haven&#039;t found myself spending all that much time worrying about memory management in C++, either.

I also don&#039;t find the &quot;resources don&#039;t matter&quot; argument particularly convincing. While it&#039;s not uncommon anymore for even cheap machines to have 4 to 8 GB of RAM, if the user has to run a number of these resource-hungry programs, or if they are using other programs that legitimately use a lot of RAM, it&#039;s not as much RAM as it sounds like. Also, my experience with WPF-based programs in particular is that they are shamefully slow to start up - for example, I can click the icon for Visual Studio 2010, let the splash screen display for 10-15 seconds, then click the icon for Visual Studio 2008 and 2008 will still finish loading well before 2010.

That said, I do appreciate when someone can talk about the limitations of C++, which are unarguably there, without resorting to the Linus Torvalds or C++ FQA methods.]]></description>
		<content:encoded><![CDATA[<p>I find it interesting that someone mentions WPF as a highly productive tool for GUIs when I have found it to be the opposite. It&#8217;s quite quick when you want to do flashy things, but if you need standard Windows behavior, you frequently have to reimplement it yourself, because the framework doesn&#8217;t provide it out of the box (for example, something as simple as graying out a button with an icon when it&#8217;s disabled requires writing your own image filter &#8211; but it just happens in the C API).</p>
<p>The result is an army of developers reinventing the square wheel as they poorly approximate the behavior of every normal application. Windows Forms is better about this, since it&#8217;s a thin wrapper around the Windows API, but it&#8217;s far from perfect. The number of C# developers who understand even the basics of window relationships and whether a window should or should not appear on the taskbar, how to put a window on top of its owner without putting it on top of every window in the system, etc., is shockingly small. But then if speed is your main goal and not correctness or making good use of system resources, C# is a great choice. Right tool for the job and all that.</p>
<p>Don&#8217;t get me wrong. I actually like C# quite a bit. But I think the benefits are oversold (though not to the absurd hype degree they were with Java).</p>
<p>As for the portability argument, having actually written portable code in both C# and C++ that ran on both Windows and Android, I can say I vastly prefer C++ for the task. Mono is nice, but it isn&#8217;t a panacea. New versions of the framework have required me to change my code to keep it compiling. Once I ported my support libraries &#8211; which took time, but not a lot in the grand scheme of things &#8211; I never touch my C++ code. And the C++ code is noticeably faster to start up.</p>
<p>I would also throw in for the benefits of RAII over anything that the managed languages offer. C++ / CLI is the only exception, because it has the right idea with allowing you to treat managed objects as though they were scope-bound. Really, the managed languages could have this if they allowed you to attach an implicit finally to every instance of an object, but they don&#8217;t. The using and try-with-resources statements are very poor approximations of RAII, and the amount of code in C# I have seen where developers fail to release resources properly makes any arguments that these languages let you concentrate on more important things than that ring hollow. Garbage collection is nice, but I haven&#8217;t found myself spending all that much time worrying about memory management in C++, either.</p>
<p>I also don&#8217;t find the &#8220;resources don&#8217;t matter&#8221; argument particularly convincing. While it&#8217;s not uncommon anymore for even cheap machines to have 4 to 8 GB of RAM, if the user has to run a number of these resource-hungry programs, or if they are using other programs that legitimately use a lot of RAM, it&#8217;s not as much RAM as it sounds like. Also, my experience with WPF-based programs in particular is that they are shamefully slow to start up &#8211; for example, I can click the icon for Visual Studio 2010, let the splash screen display for 10-15 seconds, then click the icon for Visual Studio 2008 and 2008 will still finish loading well before 2010.</p>
<p>That said, I do appreciate when someone can talk about the limitations of C++, which are unarguably there, without resorting to the Linus Torvalds or C++ FQA methods.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Glen				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7219</link>
		<dc:creator><![CDATA[Glen]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 20:21:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7219</guid>
					<description><![CDATA[@Jason Bilmez

You&#039;re far too hard on John, calling him &quot;full of hot air&quot;. It&#039;s as if you don&#039;t think people are entitled to opinions unless they are drenched in facts and figures to support them. John was quite reasonable in this thoughts on C++ and I don&#039;t think you gave him fair credit for that.

The fact is, if John presented facts and figures, you&#039;d just argue about those and so would I and everyone else, but It wouldn&#039;t change a thing.

You&#039;re missing the point: John relayed his life experience with C++ and C#, not some theoretical opinion or language analysis of them. No amount of facts can undo or re-live his experience as it is what he experienced and what he was relaying. It doesn&#039;t neccessarily make him wrong or full of hot air just because his experience doesn&#039;t match yours.

In other words, just because John &quot;can&#039;t handle&quot; C++ and maybe you (Jason) can; that doesn&#039;t mean C++ is not high maintenance. Give John a break.

It&#039;s like trying to advise the guy reading all this who&#039;s thinking &quot;C# or C++? - which is right for me?&quot;. The answer is &quot;whichever one you can handle best!&quot;. That probably isn&#039;t the answer they want to hear, but it&#039;s probably the only honest answer anyone can simply offer in this case.

What  else do you say:  &quot;Do you like an easy life?&quot;, &quot;Do you like catching tigers by the tail?&quot;.

People are different, hence all the debate and differences. Some catch tigers better than others. Some get bitten. Who are the smarter ones, those avoiding the risks of getting bitten or those catching tigers tails?

For myself, I too find C++ less productive than C#, but I choose to blame it on the tools more than the language. 

John has taken his a side. I personally find C++ more enjoyable than C# and have the opinion that if the tooling for C++ catches up to C# (and it almost has), I&#039;ll be as productive in C++ as C# if not more so and hopefully that&#039;ll mean people will let me keep using C++. But will they?

Not everyone will catch tigers by the tail even with better tools and maybe the world will go with with them. So the jury is far from in on that and so asking is C++ back, will it stay, did it ever leave, will C++ &quot;beat&quot; C#, these are all fair questions to wonder. I don&#039;t know, &quot;I hope so&quot; is my answer.

I hope Herb gets C++ VS2013 out the door with all the features we could ever need, if he does that, maybe John will come back to C++ and prove himself wrong, who knows. It&#039;s open to go either way IMO.

What I can say is that John definitely is not &quot;full of hot air&quot; for wondering these quesitons out loud. That much I do know. I think that was Herb&#039;s basic point too. We can be C++ fans, but we should not be zealots.]]></description>
		<content:encoded><![CDATA[<p>@Jason Bilmez</p>
<p>You&#8217;re far too hard on John, calling him &#8220;full of hot air&#8221;. It&#8217;s as if you don&#8217;t think people are entitled to opinions unless they are drenched in facts and figures to support them. John was quite reasonable in this thoughts on C++ and I don&#8217;t think you gave him fair credit for that.</p>
<p>The fact is, if John presented facts and figures, you&#8217;d just argue about those and so would I and everyone else, but It wouldn&#8217;t change a thing.</p>
<p>You&#8217;re missing the point: John relayed his life experience with C++ and C#, not some theoretical opinion or language analysis of them. No amount of facts can undo or re-live his experience as it is what he experienced and what he was relaying. It doesn&#8217;t neccessarily make him wrong or full of hot air just because his experience doesn&#8217;t match yours.</p>
<p>In other words, just because John &#8220;can&#8217;t handle&#8221; C++ and maybe you (Jason) can; that doesn&#8217;t mean C++ is not high maintenance. Give John a break.</p>
<p>It&#8217;s like trying to advise the guy reading all this who&#8217;s thinking &#8220;C# or C++? &#8211; which is right for me?&#8221;. The answer is &#8220;whichever one you can handle best!&#8221;. That probably isn&#8217;t the answer they want to hear, but it&#8217;s probably the only honest answer anyone can simply offer in this case.</p>
<p>What  else do you say:  &#8220;Do you like an easy life?&#8221;, &#8220;Do you like catching tigers by the tail?&#8221;.</p>
<p>People are different, hence all the debate and differences. Some catch tigers better than others. Some get bitten. Who are the smarter ones, those avoiding the risks of getting bitten or those catching tigers tails?</p>
<p>For myself, I too find C++ less productive than C#, but I choose to blame it on the tools more than the language. </p>
<p>John has taken his a side. I personally find C++ more enjoyable than C# and have the opinion that if the tooling for C++ catches up to C# (and it almost has), I&#8217;ll be as productive in C++ as C# if not more so and hopefully that&#8217;ll mean people will let me keep using C++. But will they?</p>
<p>Not everyone will catch tigers by the tail even with better tools and maybe the world will go with with them. So the jury is far from in on that and so asking is C++ back, will it stay, did it ever leave, will C++ &#8220;beat&#8221; C#, these are all fair questions to wonder. I don&#8217;t know, &#8220;I hope so&#8221; is my answer.</p>
<p>I hope Herb gets C++ VS2013 out the door with all the features we could ever need, if he does that, maybe John will come back to C++ and prove himself wrong, who knows. It&#8217;s open to go either way IMO.</p>
<p>What I can say is that John definitely is not &#8220;full of hot air&#8221; for wondering these quesitons out loud. That much I do know. I think that was Herb&#8217;s basic point too. We can be C++ fans, but we should not be zealots.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris Carpenter				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7216</link>
		<dc:creator><![CDATA[Chris Carpenter]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 19:04:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7216</guid>
					<description><![CDATA[@earwicker

You are right, why would we use a language that supports something we don&#039;t want to do? Going back to your knife analogy, why use a knife when we could use a slicer specific to what we are trying to cut? I mean, with a knife you can cut all kinds of things, including things you will never want to cut! Plus, you might cut your finger, or accidentally stab someone else! Using a slicer with hand guards that is specific to the object being cut is much safer, and more efficient.]]></description>
		<content:encoded><![CDATA[<p>@earwicker</p>
<p>You are right, why would we use a language that supports something we don&#8217;t want to do? Going back to your knife analogy, why use a knife when we could use a slicer specific to what we are trying to cut? I mean, with a knife you can cut all kinds of things, including things you will never want to cut! Plus, you might cut your finger, or accidentally stab someone else! Using a slicer with hand guards that is specific to the object being cut is much safer, and more efficient.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7215</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 17:18:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7215</guid>
					<description><![CDATA[@Rob G - &quot;I’ve been programming in C++ for around 20 years, and have never found that I have to treat memory as a flat space.&quot;

Yes, me too. But about five years ago, I realised: why use a language that supports something you&#039;d never want to do? Which allows you so easily to do it by accident?

&quot;In modern C++, you can use standard collection classes and – and this is an area I’ve yet to see in most mainstream languages – algorithms. This allows programming at a very high level of abstraction with effectively no cost.&quot;

Are you entirely happy with back_inserter and the way it has to be used when writing to the end of a vector (and what happens if you don&#039;t)? If so, I have to ask you the same question you asked me: are you serious? :)

It should also be well known that C++ is not unique in having a library of reusable algorithms that work over sequences.]]></description>
		<content:encoded><![CDATA[<p>@Rob G &#8211; &#8220;I’ve been programming in C++ for around 20 years, and have never found that I have to treat memory as a flat space.&#8221;</p>
<p>Yes, me too. But about five years ago, I realised: why use a language that supports something you&#8217;d never want to do? Which allows you so easily to do it by accident?</p>
<p>&#8220;In modern C++, you can use standard collection classes and – and this is an area I’ve yet to see in most mainstream languages – algorithms. This allows programming at a very high level of abstraction with effectively no cost.&#8221;</p>
<p>Are you entirely happy with back_inserter and the way it has to be used when writing to the end of a vector (and what happens if you don&#8217;t)? If so, I have to ask you the same question you asked me: are you serious? :)</p>
<p>It should also be well known that C++ is not unique in having a library of reusable algorithms that work over sequences.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rob G				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7206</link>
		<dc:creator><![CDATA[Rob G]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 14:04:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7206</guid>
					<description><![CDATA[@Michael said &quot;The only reason that makes C++ syntax ugly, and tools difficult to write for, is that C++ syntax is not LR(1).&quot;,

Fortunately, the CLang project exposes the parser. Hopefully, this will lead to a number of tools that help in this direction. I&#039;m hoping other compilers will follow suit.]]></description>
		<content:encoded><![CDATA[<p>@Michael said &#8220;The only reason that makes C++ syntax ugly, and tools difficult to write for, is that C++ syntax is not LR(1).&#8221;,</p>
<p>Fortunately, the CLang project exposes the parser. Hopefully, this will lead to a number of tools that help in this direction. I&#8217;m hoping other compilers will follow suit.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rob G				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7205</link>
		<dc:creator><![CDATA[Rob G]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 14:01:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7205</guid>
					<description><![CDATA[@earwicker - Are you serious? I&#039;ve been programming in C++ for around 20 years, and have never found that I have to treat memory as a flat space. Indeed, the language, more than any other I&#039;ve used, allows the developer to design to take the constraints of memory architectures into consideration.

In modern C++, you can use standard collection classes and - and this is an area I&#039;ve yet to see in most mainstream languages - algorithms. This allows programming at a very high level of abstraction with effectively no cost.]]></description>
		<content:encoded><![CDATA[<p>@earwicker &#8211; Are you serious? I&#8217;ve been programming in C++ for around 20 years, and have never found that I have to treat memory as a flat space. Indeed, the language, more than any other I&#8217;ve used, allows the developer to design to take the constraints of memory architectures into consideration.</p>
<p>In modern C++, you can use standard collection classes and &#8211; and this is an area I&#8217;ve yet to see in most mainstream languages &#8211; algorithms. This allows programming at a very high level of abstraction with effectively no cost.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7198</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 11:06:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7198</guid>
					<description><![CDATA[There are many great similarities between C++ and the other languages being discussed here. With C++11 (and even Java 8) the gap shrinks further. But there is one fundamental difference that will never be usefully eliminated and that is the way that C++ assumes that memory is a uniform array of randomly accessible bunches of bits of fixed size. (Of course the C++ standard is written in such a way as to disguise this assumption but there is no practical way to implement C++ without assuming a flat address space of raw numbers that can be reinterpreted by the code however it wishes).

But it has to be recognised that the flat address space is itself an *abstraction*. It is not the lowest-level representation. The OS has to go to some effort to trick each user process into believing that it has access to a flat address space. Access is definitely NOT uniformly fast across all memory: any C++ expert on performance will tell you about the importance of understanding all the layers of caching: the CPU levels, main memory, virtual memory, and that each of these can be hundreds or thousands of times faster than the next.

What is the purpose of this abstraction? It obscures the performance characteristics, hiding them behind an illusion - I&#039;d go further and call it a lie! That&#039;s how misleading it is, from a performance perspective. To write fast code in C++ you have to know that memory isn&#039;t really a flat space.

So perhaps the purpose of the flat memory abstraction is ease-of-use: &quot;Okay, your program may be slow, but it will easy to get right!&quot; But no one could seriously defend it on that basis when comparing it with the most popular alternative: the managed memory abstraction, in which we allocate objects such that it is simply not possible to read (or write) &quot;before&quot; or &quot;after&quot; the object - such locations don&#039;t exist, there being no operations provided for accessing them, the notion of a type is fundamental so a given memory unit always stores an object of a known concrete type (seems kind of sensible, doesn&#039;t it?) and as an added bonus we tend to get practically perfect (non-conservative, compacting, very fast to allocate) GC under this abstraction.

Of course, as Mr Sutter has demonstrated, it is possible to create a new language (lets call it C++/CLI /clr:safe!) in which we provide new features that assume the managed memory abstraction, and simultaneously eliminate all the features of the language that assume the flat address space abstraction. But there are various obstacles to the user community of that language ever becoming as large as those of C++, Java or C#. It requires you to completely rewrite your existing C++ code, and given that hurdle, most people will look at easier-to-learn languages instead.]]></description>
		<content:encoded><![CDATA[<p>There are many great similarities between C++ and the other languages being discussed here. With C++11 (and even Java 8) the gap shrinks further. But there is one fundamental difference that will never be usefully eliminated and that is the way that C++ assumes that memory is a uniform array of randomly accessible bunches of bits of fixed size. (Of course the C++ standard is written in such a way as to disguise this assumption but there is no practical way to implement C++ without assuming a flat address space of raw numbers that can be reinterpreted by the code however it wishes).</p>
<p>But it has to be recognised that the flat address space is itself an *abstraction*. It is not the lowest-level representation. The OS has to go to some effort to trick each user process into believing that it has access to a flat address space. Access is definitely NOT uniformly fast across all memory: any C++ expert on performance will tell you about the importance of understanding all the layers of caching: the CPU levels, main memory, virtual memory, and that each of these can be hundreds or thousands of times faster than the next.</p>
<p>What is the purpose of this abstraction? It obscures the performance characteristics, hiding them behind an illusion &#8211; I&#8217;d go further and call it a lie! That&#8217;s how misleading it is, from a performance perspective. To write fast code in C++ you have to know that memory isn&#8217;t really a flat space.</p>
<p>So perhaps the purpose of the flat memory abstraction is ease-of-use: &#8220;Okay, your program may be slow, but it will easy to get right!&#8221; But no one could seriously defend it on that basis when comparing it with the most popular alternative: the managed memory abstraction, in which we allocate objects such that it is simply not possible to read (or write) &#8220;before&#8221; or &#8220;after&#8221; the object &#8211; such locations don&#8217;t exist, there being no operations provided for accessing them, the notion of a type is fundamental so a given memory unit always stores an object of a known concrete type (seems kind of sensible, doesn&#8217;t it?) and as an added bonus we tend to get practically perfect (non-conservative, compacting, very fast to allocate) GC under this abstraction.</p>
<p>Of course, as Mr Sutter has demonstrated, it is possible to create a new language (lets call it C++/CLI /clr:safe!) in which we provide new features that assume the managed memory abstraction, and simultaneously eliminate all the features of the language that assume the flat address space abstraction. But there are various obstacles to the user community of that language ever becoming as large as those of C++, Java or C#. It requires you to completely rewrite your existing C++ code, and given that hurdle, most people will look at easier-to-learn languages instead.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: spmisra				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7188</link>
		<dc:creator><![CDATA[spmisra]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 05:20:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7188</guid>
					<description><![CDATA[I think the fundamental principle that people do not understand is we have to be productive. Language is just a means to talk to the computer, and all languages are built on some usage specs. Every body have to choose the language based on the specs they have at hand, time line for development, and their current skills. Rather than trying hard to adapt a particular language to job at hand, we have to delve into our skill sets and think what can make the things easier. 

We can always use a Sword to cut vegetables, but why use knife? Just so that we do the work easily, be safe, save our head, and hand, and also spend time with our friends and family. So I do not think C++ was gone or will go away or rule the world. These debates are getting converted to religious discussions.

* Although I love C++ I do not wish to write web pages in C++. Why? Simple I do not want brain surgery.
* Although I love C++ I talk to my &quot;Human&quot; friends in plain English or my native language. I do not wish &quot;Happy birth day&quot; like &quot;std::cout&#060;&#060;Happy Birthday&#060;&#060;std::endl&#034; to my friend. rather I use plain English. Why? Because English is the right tool to use there (Human to Human talk).
* Although I love C++ I am writing these comments in English rather than C++, though I know most of the people here are far more knowledgeable in C++ than I am.
* Although I love C++ I have I use gmail or yahoo mail, rather than get my hands dirty with a e-mail api, create a mail server, compose my email, build it and execute it to send it. Because I know of better tools to send mail. I don&#039;t give damn about the language they use to send my mail.

So in simple terms, be productive, and most importantly happy. Always use the right tool. Do not shape your foot as per your shoes, always buy the right shoes. 

And regarding C++, I do not think it is complicated. Learning is a gradual process, regardless of any language you use, you have to learn. The main thing is keep on learning, and improve your skills and the programs you write. Just tell me any one here who always write code that is never modified or improved?
C++ provides you different tools, you have to use the best one/ones. Its not like you can&#039;t compile a program if you do not write templates or don&#039;t use r-value or blah blah features. You can compile a simple loop, which has the same structure in all languages.

Languages are like rivers, always small stream of libraries or features will be added to them. It happens with all languages, natural language too. The new features in C++ are not bogus, it adds expressiveness to them. Lets you type less, care about memory less.

So start from specs, reflect on your skill sets, and see what can be best for you. If you choose C++ do not be afraid. But remember, C++ can&#039;t heal a wound, medicine and doctors are the right tools.]]></description>
		<content:encoded><![CDATA[<p>I think the fundamental principle that people do not understand is we have to be productive. Language is just a means to talk to the computer, and all languages are built on some usage specs. Every body have to choose the language based on the specs they have at hand, time line for development, and their current skills. Rather than trying hard to adapt a particular language to job at hand, we have to delve into our skill sets and think what can make the things easier. </p>
<p>We can always use a Sword to cut vegetables, but why use knife? Just so that we do the work easily, be safe, save our head, and hand, and also spend time with our friends and family. So I do not think C++ was gone or will go away or rule the world. These debates are getting converted to religious discussions.</p>
<p>* Although I love C++ I do not wish to write web pages in C++. Why? Simple I do not want brain surgery.<br />
* Although I love C++ I talk to my &#8220;Human&#8221; friends in plain English or my native language. I do not wish &#8220;Happy birth day&#8221; like &#8220;std::cout&lt;&lt;Happy Birthday&lt;&lt;std::endl&quot; to my friend. rather I use plain English. Why? Because English is the right tool to use there (Human to Human talk).<br />
* Although I love C++ I am writing these comments in English rather than C++, though I know most of the people here are far more knowledgeable in C++ than I am.<br />
* Although I love C++ I have I use gmail or yahoo mail, rather than get my hands dirty with a e-mail api, create a mail server, compose my email, build it and execute it to send it. Because I know of better tools to send mail. I don&#039;t give damn about the language they use to send my mail.</p>
<p>So in simple terms, be productive, and most importantly happy. Always use the right tool. Do not shape your foot as per your shoes, always buy the right shoes. </p>
<p>And regarding C++, I do not think it is complicated. Learning is a gradual process, regardless of any language you use, you have to learn. The main thing is keep on learning, and improve your skills and the programs you write. Just tell me any one here who always write code that is never modified or improved?<br />
C++ provides you different tools, you have to use the best one/ones. Its not like you can&#039;t compile a program if you do not write templates or don&#039;t use r-value or blah blah features. You can compile a simple loop, which has the same structure in all languages.</p>
<p>Languages are like rivers, always small stream of libraries or features will be added to them. It happens with all languages, natural language too. The new features in C++ are not bogus, it adds expressiveness to them. Lets you type less, care about memory less.</p>
<p>So start from specs, reflect on your skill sets, and see what can be best for you. If you choose C++ do not be afraid. But remember, C++ can&#039;t heal a wound, medicine and doctors are the right tools.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7187</link>
		<dc:creator><![CDATA[Michael]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 04:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7187</guid>
					<description><![CDATA[&#062; You will find this to be true, for example, with the new uniform initialization syntax. Once enough people have migrated to the new syntax, which is better in virtually every way, sometime in the future we could contemplate removing the old and shearing off complexity. In the meantime, the old complexity and several Effective C++ Items can be ignored (such as a infamous vexing parse), as you simply won’t encounter those issues if you use only the new initialization syntax.

If the new way is better in virtually every way but we need to keep backwards-compatibility anyway, a recommendation to compiler writers to spit out a warning when the old way is used, would be very welcome - unless something is *actively nudging* users into doing things *only* the new way, the &quot;language is bigger&quot; issue would still exist because newcomers need to learn the old way, the new way, *and* why the new way is better.]]></description>
		<content:encoded><![CDATA[<p>&gt; You will find this to be true, for example, with the new uniform initialization syntax. Once enough people have migrated to the new syntax, which is better in virtually every way, sometime in the future we could contemplate removing the old and shearing off complexity. In the meantime, the old complexity and several Effective C++ Items can be ignored (such as a infamous vexing parse), as you simply won’t encounter those issues if you use only the new initialization syntax.</p>
<p>If the new way is better in virtually every way but we need to keep backwards-compatibility anyway, a recommendation to compiler writers to spit out a warning when the old way is used, would be very welcome &#8211; unless something is *actively nudging* users into doing things *only* the new way, the &#8220;language is bigger&#8221; issue would still exist because newcomers need to learn the old way, the new way, *and* why the new way is better.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7184</link>
		<dc:creator><![CDATA[Michael]]></dc:creator>
		<pubDate>Wed, 05 Dec 2012 04:03:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7184</guid>
					<description><![CDATA[The only reason that makes C++ syntax ugly, and tools difficult to write for, is that C++ syntax is not LR(1).  Take a look at the managed languages and notice that their tool support is vastly superior to C++.  Cut the backwards compatibility and make the language easy to parse.  Too bad this will never happen.

Another reason is, there&#039;s no one standard ubiquitous library that provides a way for people to work in an &quot;I just want this done and will care about performance later&quot; manner.  Not everyone wants to waste time selecting a library when a standard one is available.  Contrast Java&#039;s standard library, Microsoft&#039;s BCL with the standard C++11 library...libraries are what make people productive, I&#039;d say waaaay more frequently than a new language feature does unless the old language was so deficient, which I never felt C++ was (well, the new use of the auto keyword is good, but it&#039;s icing on the cake)

Well, maybe Boost is, but it&#039;s still not standard.  The day the entire Boost library is incorporated as part of standard C++ will be the day of its resurgence.  Regex, and Threading are in the right direction but not enough.  Most applications can use a few more features in , built-in HTTP support, UTF-8 without adding ICS, etc.]]></description>
		<content:encoded><![CDATA[<p>The only reason that makes C++ syntax ugly, and tools difficult to write for, is that C++ syntax is not LR(1).  Take a look at the managed languages and notice that their tool support is vastly superior to C++.  Cut the backwards compatibility and make the language easy to parse.  Too bad this will never happen.</p>
<p>Another reason is, there&#8217;s no one standard ubiquitous library that provides a way for people to work in an &#8220;I just want this done and will care about performance later&#8221; manner.  Not everyone wants to waste time selecting a library when a standard one is available.  Contrast Java&#8217;s standard library, Microsoft&#8217;s BCL with the standard C++11 library&#8230;libraries are what make people productive, I&#8217;d say waaaay more frequently than a new language feature does unless the old language was so deficient, which I never felt C++ was (well, the new use of the auto keyword is good, but it&#8217;s icing on the cake)</p>
<p>Well, maybe Boost is, but it&#8217;s still not standard.  The day the entire Boost library is incorporated as part of standard C++ will be the day of its resurgence.  Regex, and Threading are in the right direction but not enough.  Most applications can use a few more features in , built-in HTTP support, UTF-8 without adding ICS, etc.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rob K				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7175</link>
		<dc:creator><![CDATA[Rob K]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 19:57:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7175</guid>
					<description><![CDATA[&quot;C++ *does not allow them to do that* – there’s just too much that can go wrong; until you’re a C++ expert you will be writing code that is fundamentally unsound. That’s not something to be proud of. That’s a failure!&quot;

This is absolutely NOT true. If an non-expert isn&#039;t writing fundamentally sound code in C++, he won&#039;t be writing it in any other language either. You don&#039;t have to know the language inside and out to write robust code that does the job. In my 20 years of programming mostly in C++, 90% of the code I&#039;ve written has used probably only the core 30% to 40% of the language. 

You can spell spaghetti in any language. I&#039;ve seen a lot of C++ code written by idiots, and lot of C#, Basic, Java, and Delphi code written by idiots. It&#039;s every bit of it crap, and it&#039;s not the fault of the languages. It&#039;s the fault of the idiots who code without understanding. The same people who code without understanding in C++, code without understanding in C# or Basic or Java or whatever language you care to name.

On the notion that C#, etc. is somehow faster to write in... I have not found this to be the case. In fact, the lack of RAII in the language, and the crap that&#039;s been added to get around that, for me, make it slower to write good code. And why does everyone hate on multiple inheritance all the time? If you don&#039;t need it, don&#039;t use it. It will cost you nothing if you don&#039;t use it. You should prefer composition to inheritance anyway, regardless of the language you&#039;re writing in. And guess what? The managed languages have a weak form of multiple inheritance kludged in anyway. It&#039;s called interfaces. Going back to my earlier point, the programmers who would misuse multiple inheritance are going to misuse the features of whatever language they&#039;re programming in.

The problem is not the language, the problem is the programmers. I&#039;ve had far too many coworkers who have no clue that blogs like this exist, or that these sorts of discussion occur. They know what they learned in school. They know what they might learn in any training their employers put them through. But that&#039;s all they know. They have no curiosity or desire to improve their craft. They don&#039;t unit test, let alone write code that&#039;s unit testable.]]></description>
		<content:encoded><![CDATA[<p>&#8220;C++ *does not allow them to do that* – there’s just too much that can go wrong; until you’re a C++ expert you will be writing code that is fundamentally unsound. That’s not something to be proud of. That’s a failure!&#8221;</p>
<p>This is absolutely NOT true. If an non-expert isn&#8217;t writing fundamentally sound code in C++, he won&#8217;t be writing it in any other language either. You don&#8217;t have to know the language inside and out to write robust code that does the job. In my 20 years of programming mostly in C++, 90% of the code I&#8217;ve written has used probably only the core 30% to 40% of the language. </p>
<p>You can spell spaghetti in any language. I&#8217;ve seen a lot of C++ code written by idiots, and lot of C#, Basic, Java, and Delphi code written by idiots. It&#8217;s every bit of it crap, and it&#8217;s not the fault of the languages. It&#8217;s the fault of the idiots who code without understanding. The same people who code without understanding in C++, code without understanding in C# or Basic or Java or whatever language you care to name.</p>
<p>On the notion that C#, etc. is somehow faster to write in&#8230; I have not found this to be the case. In fact, the lack of RAII in the language, and the crap that&#8217;s been added to get around that, for me, make it slower to write good code. And why does everyone hate on multiple inheritance all the time? If you don&#8217;t need it, don&#8217;t use it. It will cost you nothing if you don&#8217;t use it. You should prefer composition to inheritance anyway, regardless of the language you&#8217;re writing in. And guess what? The managed languages have a weak form of multiple inheritance kludged in anyway. It&#8217;s called interfaces. Going back to my earlier point, the programmers who would misuse multiple inheritance are going to misuse the features of whatever language they&#8217;re programming in.</p>
<p>The problem is not the language, the problem is the programmers. I&#8217;ve had far too many coworkers who have no clue that blogs like this exist, or that these sorts of discussion occur. They know what they learned in school. They know what they might learn in any training their employers put them through. But that&#8217;s all they know. They have no curiosity or desire to improve their craft. They don&#8217;t unit test, let alone write code that&#8217;s unit testable.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7174</link>
		<dc:creator><![CDATA[David]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 19:51:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7174</guid>
					<description><![CDATA[Some really strange comments here.   The idea that C++ is extremely difficult is garbage.   You can make it that way but it is very possible to write clear and well organized programs in C++ without getting bogged down in esoterica.   If you focus on using the more advanced concepts then of course you will have a longer learning curve.  

Mind you I&#039;m far from being a professional programmer yet have code that was written by me running production for years.   Sadly one reason I&#039;ve switched to Python, for some things, has little to do with code complexity of C++ but rather the excellent libraries that are more or less standard and available for Python.   The standard library and boost simply aren&#039;t enough in comparison.   

So if I might suggest to those in the standards making process, we don&#039;t need continuous revisions to C++ that deny the importance of standard libraries.   In fact beyond modules I can&#039;t think of anything more important for C++15 than a significantly improved standard library.   The idea that a language can exist alone without a well thought out and standardized  library is just asinine these days.   At the end of the day it isn&#039;t that Python is &quot;&quot;simpler&quot;&quot; as it isn&#039;t really, it is the library support that makes a difference.   

One other thing which may be hard to do with C++ right now, but C++ could be vastly improved readability wise by moving away from ASCII limited character sets.    Maybe that would require a new language, &quot;E&quot; maybe, but having an expanded character set, if used wisely could lead to far more readable C++ code.   I still find it funny that at this point in time languages still insist on 8(7) bit character sets.   In the end reading C++ often isn&#039;t difficult from the comprehension stand point but rather is difficult from the mental parsing that has to go on.]]></description>
		<content:encoded><![CDATA[<p>Some really strange comments here.   The idea that C++ is extremely difficult is garbage.   You can make it that way but it is very possible to write clear and well organized programs in C++ without getting bogged down in esoterica.   If you focus on using the more advanced concepts then of course you will have a longer learning curve.  </p>
<p>Mind you I&#8217;m far from being a professional programmer yet have code that was written by me running production for years.   Sadly one reason I&#8217;ve switched to Python, for some things, has little to do with code complexity of C++ but rather the excellent libraries that are more or less standard and available for Python.   The standard library and boost simply aren&#8217;t enough in comparison.   </p>
<p>So if I might suggest to those in the standards making process, we don&#8217;t need continuous revisions to C++ that deny the importance of standard libraries.   In fact beyond modules I can&#8217;t think of anything more important for C++15 than a significantly improved standard library.   The idea that a language can exist alone without a well thought out and standardized  library is just asinine these days.   At the end of the day it isn&#8217;t that Python is &#8220;&#8221;simpler&#8221;&#8221; as it isn&#8217;t really, it is the library support that makes a difference.   </p>
<p>One other thing which may be hard to do with C++ right now, but C++ could be vastly improved readability wise by moving away from ASCII limited character sets.    Maybe that would require a new language, &#8220;E&#8221; maybe, but having an expanded character set, if used wisely could lead to far more readable C++ code.   I still find it funny that at this point in time languages still insist on 8(7) bit character sets.   In the end reading C++ often isn&#8217;t difficult from the comprehension stand point but rather is difficult from the mental parsing that has to go on.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Damien				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7169</link>
		<dc:creator><![CDATA[Damien]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 18:26:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7169</guid>
					<description><![CDATA[As an engineer, and not a computer scientist, I think a lot of the language warriors are missing an important point.  The days of &quot;One Language To Rule Them All&quot; are over, dead and gone.  I think we&#039;re entering an era of using the right tool and the right skillset for the job.  The Engineering disciplines have been doing that for a long time, whereas in programming that approach is still pretty immature (but growing fast).  The right tool for the job is why other languages and platforms are growing alongside C++.  C++ isn&#039;t dropping off much though.  

High-performance parallel math code is still mostly written in Fortran, because it&#039;s the best tool for the job.  Some is in C.  A high-performance cache-aware BLAS library in C#?  Yeah, right.  It&#039;s the wrong tool.  So is C++ for that matter.  C++ is the tool for fine-grained application parallelism though (Intel TBB &#038; friends), and multi/manycore is everywhere.  Need a GUI and higher-level business logic?  C#/WPF, Java, and/or JS/HTML5.  On average, you&#039;ll deliver that faster with those technologies than you will with C++.  Yeah , I know there&#039;s QT for C++ GUIs, I like it a lot, but even as a C++ expert I&#039;m still faster and more efficient with C#/WPF doing GUI development.

Along with One Language To Rule Them All going the way of the dinosaurs, so is only having one major skillset (if all you have is a hammer, everything looks like a nail....)  If you&#039;re only good at one thing, your career is going to be pretty limited anyway.]]></description>
		<content:encoded><![CDATA[<p>As an engineer, and not a computer scientist, I think a lot of the language warriors are missing an important point.  The days of &#8220;One Language To Rule Them All&#8221; are over, dead and gone.  I think we&#8217;re entering an era of using the right tool and the right skillset for the job.  The Engineering disciplines have been doing that for a long time, whereas in programming that approach is still pretty immature (but growing fast).  The right tool for the job is why other languages and platforms are growing alongside C++.  C++ isn&#8217;t dropping off much though.  </p>
<p>High-performance parallel math code is still mostly written in Fortran, because it&#8217;s the best tool for the job.  Some is in C.  A high-performance cache-aware BLAS library in C#?  Yeah, right.  It&#8217;s the wrong tool.  So is C++ for that matter.  C++ is the tool for fine-grained application parallelism though (Intel TBB &amp; friends), and multi/manycore is everywhere.  Need a GUI and higher-level business logic?  C#/WPF, Java, and/or JS/HTML5.  On average, you&#8217;ll deliver that faster with those technologies than you will with C++.  Yeah , I know there&#8217;s QT for C++ GUIs, I like it a lot, but even as a C++ expert I&#8217;m still faster and more efficient with C#/WPF doing GUI development.</p>
<p>Along with One Language To Rule Them All going the way of the dinosaurs, so is only having one major skillset (if all you have is a hammer, everything looks like a nail&#8230;.)  If you&#8217;re only good at one thing, your career is going to be pretty limited anyway.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Burp				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7168</link>
		<dc:creator><![CDATA[Burp]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 18:25:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7168</guid>
					<description><![CDATA[C++ is only complicated because certain old &quot;features&quot; still have to be used, once new modern variants of these things are in, the language will be a great deal more enjoyable

header files + slow compilation -&#062;  modules
monomorphic lambda -&#062; polymorphic lambda with hopefully less syntax
complex pure functional language used for compile time manipulation -&#062; better compile time evaluation(static_if, better CTFE)
no reflection, forcing idiotic custom &quot;solutions&quot; -&#062; compile time reflection

But anyway, C# is no solution, its abstraction and reuse capabilities are worse then C++ as it stands today!  Generic are a joke compared to templates.  D gets many things right, which C++ (currently) gets wrong, although it missed the target on a few key things(GC, classes).]]></description>
		<content:encoded><![CDATA[<p>C++ is only complicated because certain old &#8220;features&#8221; still have to be used, once new modern variants of these things are in, the language will be a great deal more enjoyable</p>
<p>header files + slow compilation -&gt;  modules<br />
monomorphic lambda -&gt; polymorphic lambda with hopefully less syntax<br />
complex pure functional language used for compile time manipulation -&gt; better compile time evaluation(static_if, better CTFE)<br />
no reflection, forcing idiotic custom &#8220;solutions&#8221; -&gt; compile time reflection</p>
<p>But anyway, C# is no solution, its abstraction and reuse capabilities are worse then C++ as it stands today!  Generic are a joke compared to templates.  D gets many things right, which C++ (currently) gets wrong, although it missed the target on a few key things(GC, classes).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7166</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 18:04:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7166</guid>
					<description><![CDATA[General: Thanks for the generally high level of comments, especially nearer the start. I was hoping this would continue as a balanced discussion instead of degenerating into barbs. :)

A few thoughts:

Paraphrasing Bjarne, I usually summarize C++&#039;s three top (but not only) strengths as: (a) efficient abstraction (abstractions often compile away, don&#039;t pay for what you don&#039;t use, leave no room for a language lower, etc.); (b) flexibility (you can always express what you want, opt out of guard rails, etc.); and (c) portability (you get the efficiently on all platforms, programs you can largely take anywhere as long as you put any platform-specific code in a particular module and just port that and the rest comes along).

In that context:

@Zenju: Yes, C++ always lets you &quot;open the hood&quot; and take control. I would always add, though, that you don&#039;t always need to open the hood. It&#039;s just that you can whenever you need to.

@Magnum: Actually, I do hear a lot from people who find themselves enormously more productive when they switch to C#. And that&#039;s fine -- I know others feel the other way, but it depends very much on what you&#039;re doing. As Andrei Alexandrescu put it in a talk last year, &#039;developing code in C++ is generally slower than in other languages, but paradoxically developing efficient code is faster in C++.&#039; The reason is that that&#039;s what it&#039;s geared for -- efficiently by default, efficiency as a first-order concern, with the ability to opt out. If you&#039;re not targeting the three (a)/(b)/(c) C++ design values above, you&#039;ll have a worse experience in C++, not because C++ sucks or because you suck :) but just because of &quot;fit&quot; -- not using an appropriate tool, one designed for the job you want to do. If you are targeting those design values, then you&#039;ll have a worse experience in Java and C#, not because they suck or because you suck :) but just because you should be using a different tool. So much of these debates come down to using the right tool for the job..

@Jon: Yes, C++ is complex and the complexity is largely because of C compatibility. I agree with Bjarne that there&#039;s a small language struggling to get out -- I&#039;ve participated in private experiments to specify such a language, and you can do it in well under half the complexity of C++ without losing the expressivity and flexibility of C++. However, it does require changes to syntax (mainly) and semantics (secondarily) that amount to making it a new language, which makes it a massive breaking change for programs (where existing code doesn&#039;t compile and would need to be rewritten manually or with a tool) and programmers (where existing developers need retraining). That&#039;s a very big tradeoff. So just as C++ &#039;won&#039; in the 90s because of its own strengths plus its C compatibility, C++11 is being adopted because of its own strengths plus its C++98 compatibility. At the end of the day compatibility continues to be a very strong force and advantage that isn&#039;t lightly tossed aside to &quot;improve&quot; things. However, it&#039;s still worthwhile and some interesting things may come of it. Stay tuned, but expect (possible) news in years rather than months.

@tonyk; Actually, no, a good C++ programmer doesn&#039;t need to know all those things. That&#039;s a common misconception though. And &quot;ADDING&quot; features can make a language simpler, because it migrates people to using the new simpler alternatives instead of the old ones. You will find this to be true, for example, with the new uniform initialization syntax. Once enough people have migrated to the new syntax, which is better in virtually every way, sometime in the future we could contemplate removing the old and shearing off complexity. In the meantime, the old complexity and several Effective C++ Items can be ignored (such as a infamous vexing parse), as you simply won&#039;t encounter those issues if you use only the new initialization syntax.

General philosophical question: &quot;When does adding a feature make a language simpler?&quot; When it lets you express your intent more directly, notably by adding direct support for an important abstraction (e.g., virtual functions), or to express your intent more consistently, such as by adding a simpler facility that lets you ignore multiple older complex options.

@bittermanandy @LoupValiant: I agree that what Don Box calls &quot;reveling in complexity&quot; is generally a bad thing regardless of language. C++ has complexity, and some do revel in it. But &quot;just because you can doesn&#039;t mean you should&quot; -- that&#039;s a knock against them (IMO) rather than against C++.]]></description>
		<content:encoded><![CDATA[<p>General: Thanks for the generally high level of comments, especially nearer the start. I was hoping this would continue as a balanced discussion instead of degenerating into barbs. :)</p>
<p>A few thoughts:</p>
<p>Paraphrasing Bjarne, I usually summarize C++&#8217;s three top (but not only) strengths as: (a) efficient abstraction (abstractions often compile away, don&#8217;t pay for what you don&#8217;t use, leave no room for a language lower, etc.); (b) flexibility (you can always express what you want, opt out of guard rails, etc.); and (c) portability (you get the efficiently on all platforms, programs you can largely take anywhere as long as you put any platform-specific code in a particular module and just port that and the rest comes along).</p>
<p>In that context:</p>
<p>@Zenju: Yes, C++ always lets you &#8220;open the hood&#8221; and take control. I would always add, though, that you don&#8217;t always need to open the hood. It&#8217;s just that you can whenever you need to.</p>
<p>@Magnum: Actually, I do hear a lot from people who find themselves enormously more productive when they switch to C#. And that&#8217;s fine &#8212; I know others feel the other way, but it depends very much on what you&#8217;re doing. As Andrei Alexandrescu put it in a talk last year, &#8216;developing code in C++ is generally slower than in other languages, but paradoxically developing efficient code is faster in C++.&#8217; The reason is that that&#8217;s what it&#8217;s geared for &#8212; efficiently by default, efficiency as a first-order concern, with the ability to opt out. If you&#8217;re not targeting the three (a)/(b)/(c) C++ design values above, you&#8217;ll have a worse experience in C++, not because C++ sucks or because you suck :) but just because of &#8220;fit&#8221; &#8212; not using an appropriate tool, one designed for the job you want to do. If you are targeting those design values, then you&#8217;ll have a worse experience in Java and C#, not because they suck or because you suck :) but just because you should be using a different tool. So much of these debates come down to using the right tool for the job..</p>
<p>@Jon: Yes, C++ is complex and the complexity is largely because of C compatibility. I agree with Bjarne that there&#8217;s a small language struggling to get out &#8212; I&#8217;ve participated in private experiments to specify such a language, and you can do it in well under half the complexity of C++ without losing the expressivity and flexibility of C++. However, it does require changes to syntax (mainly) and semantics (secondarily) that amount to making it a new language, which makes it a massive breaking change for programs (where existing code doesn&#8217;t compile and would need to be rewritten manually or with a tool) and programmers (where existing developers need retraining). That&#8217;s a very big tradeoff. So just as C++ &#8216;won&#8217; in the 90s because of its own strengths plus its C compatibility, C++11 is being adopted because of its own strengths plus its C++98 compatibility. At the end of the day compatibility continues to be a very strong force and advantage that isn&#8217;t lightly tossed aside to &#8220;improve&#8221; things. However, it&#8217;s still worthwhile and some interesting things may come of it. Stay tuned, but expect (possible) news in years rather than months.</p>
<p>@tonyk; Actually, no, a good C++ programmer doesn&#8217;t need to know all those things. That&#8217;s a common misconception though. And &#8220;ADDING&#8221; features can make a language simpler, because it migrates people to using the new simpler alternatives instead of the old ones. You will find this to be true, for example, with the new uniform initialization syntax. Once enough people have migrated to the new syntax, which is better in virtually every way, sometime in the future we could contemplate removing the old and shearing off complexity. In the meantime, the old complexity and several Effective C++ Items can be ignored (such as a infamous vexing parse), as you simply won&#8217;t encounter those issues if you use only the new initialization syntax.</p>
<p>General philosophical question: &#8220;When does adding a feature make a language simpler?&#8221; When it lets you express your intent more directly, notably by adding direct support for an important abstraction (e.g., virtual functions), or to express your intent more consistently, such as by adding a simpler facility that lets you ignore multiple older complex options.</p>
<p>@bittermanandy @LoupValiant: I agree that what Don Box calls &#8220;reveling in complexity&#8221; is generally a bad thing regardless of language. C++ has complexity, and some do revel in it. But &#8220;just because you can doesn&#8217;t mean you should&#8221; &#8212; that&#8217;s a knock against them (IMO) rather than against C++.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7160</link>
		<dc:creator><![CDATA[John]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 16:14:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7160</guid>
					<description><![CDATA[From Joe Duffy’s Weblog; http://www.bluebytesoftware.com/blog/2012/10/31/BewareTheString.aspx

.NET holds an enormous advantage over C++.
That might sound like an oxymoron, but our system can in fact beat the pants off all the popular native programming environments. The key to success? Thought and discipline.]]></description>
		<content:encoded><![CDATA[<p>From Joe Duffy’s Weblog; <a href="http://www.bluebytesoftware.com/blog/2012/10/31/BewareTheString.aspx" rel="nofollow">http://www.bluebytesoftware.com/blog/2012/10/31/BewareTheString.aspx</a></p>
<p>.NET holds an enormous advantage over C++.<br />
That might sound like an oxymoron, but our system can in fact beat the pants off all the popular native programming environments. The key to success? Thought and discipline.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Loup Vaillant				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7153</link>
		<dc:creator><![CDATA[Loup Vaillant]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 13:59:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7153</guid>
					<description><![CDATA[&quot;If (as it may be reasonable to argue) you need to be a C++ expert to use it “properly”, that is a point against it! Stop bragging about how good you personally are at C++ and how anyone who’d rather use a different language is just too uneducated to understand it.&quot;

Good luck with that one. People mostly don&#039;t want to solve problems, they want to show how smart they are (that would include me to some extent). That&#039;s how some people do Template Meta-programming with a straight face, instead of fixing the compiler, or writing a real macro system —that&#039;s how C++ itself started out for Church&#039;s sake!— or just choose a simpler language.

Think of this a big status game for a minute. Simple solutions are hard to reward because they don&#039;t do justice to the difficulty of the original problem. Complicated solutions on the other hand are much better at making the programmer look smart. Add some &quot;industrial strength&quot; in the sales speech, and you get one of the reasons for C++ success.

I don&#039;t know how to solve this. Ideally, we would have miracle tools that both yield simple solutions *and* make their users look smart. I&#039;m afraid the two are at odds.]]></description>
		<content:encoded><![CDATA[<p>&#8220;If (as it may be reasonable to argue) you need to be a C++ expert to use it “properly”, that is a point against it! Stop bragging about how good you personally are at C++ and how anyone who’d rather use a different language is just too uneducated to understand it.&#8221;</p>
<p>Good luck with that one. People mostly don&#8217;t want to solve problems, they want to show how smart they are (that would include me to some extent). That&#8217;s how some people do Template Meta-programming with a straight face, instead of fixing the compiler, or writing a real macro system —that&#8217;s how C++ itself started out for Church&#8217;s sake!— or just choose a simpler language.</p>
<p>Think of this a big status game for a minute. Simple solutions are hard to reward because they don&#8217;t do justice to the difficulty of the original problem. Complicated solutions on the other hand are much better at making the programmer look smart. Add some &#8220;industrial strength&#8221; in the sales speech, and you get one of the reasons for C++ success.</p>
<p>I don&#8217;t know how to solve this. Ideally, we would have miracle tools that both yield simple solutions *and* make their users look smart. I&#8217;m afraid the two are at odds.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bittermanandy				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7150</link>
		<dc:creator><![CDATA[bittermanandy]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 12:07:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7150</guid>
					<description><![CDATA[Nothing frustrates me more (and it&#039;s been seen among these very comments right here!) than the attitude that &quot;if you don&#039;t think C++ is best, you just don&#039;t know it well enough&quot;. The commenter is sometimes, but not always, honest enough to add the epithet &quot;...n00b&quot;.

I actually know C++ pretty damn well. Not as well as, say... Herb Sutter... but I&#039;ve read a lot of his books, and others, and have a decade or so of hands-on professional C++ experience. I know the language, I know its uses, I&#039;m not a guru but I am an expert. And the problem domains in which it is appropriate to use C++ are dwindling fast.

If (as it may be reasonable to argue) you need to be a C++ expert to use it &quot;properly&quot;, that is a point against it! Stop bragging about how good you personally are at C++ and how anyone who&#039;d rather use a different language is just too uneducated to understand it. Consider instead whether the vanishingly small number of C++ gurus in the world can write enough code on their own to keep the whole world going. Of course they can&#039;t.

An educated, intelligent programmer who has not achieved expert or guru status should be able to use a language that allows them to be productive and, notwithstanding the fact that all code has some bugs, write software that basically works... and write that code quickly and efficiently. C++ *does not allow them to do that* - there&#039;s just too much that can go wrong; until you&#039;re a C++ expert you will be writing code that is fundamentally unsound. That&#039;s not something to be proud of. That&#039;s a failure!

There are, *absolutely*, cases where C++ is still a valid choice or even the optimal choice. (I would be worried about my own future employment prospects if this were not the case). There are far more cases - the 90% case - where you just need to quickly write code that works. CPU efficiency? It&#039;d be nice, but Herb&#039;s promised us 256 processors next year. Memory efficiency? It&#039;d be nice, but my phone has more RAM than my Windows PC ever actually seems to use. Let&#039;s get the software done fast and use it. C++ is not a language that supports that priority... not even in C++11.

The 10% case (where performance and optimisation matters) still exists and C++ is still useful for it. But the &quot;resurgence&quot; of C++ really is a falsehood because that 10% case isn&#039;t growing - we don&#039;t suddenly have a need to write more highly-efficient code than was necessary ten years ago. And for those among us who look down on 90% of programmers who don&#039;t know C++ as well as they do but are writing code for the 90% case in other languages... I imagine COBOL programmers once looked down on people too.]]></description>
		<content:encoded><![CDATA[<p>Nothing frustrates me more (and it&#8217;s been seen among these very comments right here!) than the attitude that &#8220;if you don&#8217;t think C++ is best, you just don&#8217;t know it well enough&#8221;. The commenter is sometimes, but not always, honest enough to add the epithet &#8220;&#8230;n00b&#8221;.</p>
<p>I actually know C++ pretty damn well. Not as well as, say&#8230; Herb Sutter&#8230; but I&#8217;ve read a lot of his books, and others, and have a decade or so of hands-on professional C++ experience. I know the language, I know its uses, I&#8217;m not a guru but I am an expert. And the problem domains in which it is appropriate to use C++ are dwindling fast.</p>
<p>If (as it may be reasonable to argue) you need to be a C++ expert to use it &#8220;properly&#8221;, that is a point against it! Stop bragging about how good you personally are at C++ and how anyone who&#8217;d rather use a different language is just too uneducated to understand it. Consider instead whether the vanishingly small number of C++ gurus in the world can write enough code on their own to keep the whole world going. Of course they can&#8217;t.</p>
<p>An educated, intelligent programmer who has not achieved expert or guru status should be able to use a language that allows them to be productive and, notwithstanding the fact that all code has some bugs, write software that basically works&#8230; and write that code quickly and efficiently. C++ *does not allow them to do that* &#8211; there&#8217;s just too much that can go wrong; until you&#8217;re a C++ expert you will be writing code that is fundamentally unsound. That&#8217;s not something to be proud of. That&#8217;s a failure!</p>
<p>There are, *absolutely*, cases where C++ is still a valid choice or even the optimal choice. (I would be worried about my own future employment prospects if this were not the case). There are far more cases &#8211; the 90% case &#8211; where you just need to quickly write code that works. CPU efficiency? It&#8217;d be nice, but Herb&#8217;s promised us 256 processors next year. Memory efficiency? It&#8217;d be nice, but my phone has more RAM than my Windows PC ever actually seems to use. Let&#8217;s get the software done fast and use it. C++ is not a language that supports that priority&#8230; not even in C++11.</p>
<p>The 10% case (where performance and optimisation matters) still exists and C++ is still useful for it. But the &#8220;resurgence&#8221; of C++ really is a falsehood because that 10% case isn&#8217;t growing &#8211; we don&#8217;t suddenly have a need to write more highly-efficient code than was necessary ten years ago. And for those among us who look down on 90% of programmers who don&#8217;t know C++ as well as they do but are writing code for the 90% case in other languages&#8230; I imagine COBOL programmers once looked down on people too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: tonyk				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7149</link>
		<dc:creator><![CDATA[tonyk]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 10:16:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7149</guid>
					<description><![CDATA[100% agree with John Sonmez. New C++ 0x11 is really very BAD,BAD,BAD language. As a John himself, i am total C++ fan. The main problem of C++ 0x11 is that it is very big and difficult to learn.

Good C++ programmer must know: 
1) lowlevel things like what &quot;register&quot; / &quot;restrict&quot; / &quot;auto&quot; (old one) keywords stand for... 
2) templates ... Oh, crap. Int2Type/ StaticFactorial? I never used that stuff in production, but i have to learn that too!
3) good style: explicit/ virtual destructors/ exception-safety etc. 
4) whole bunch of STANDARD libraries and classes: what was the last &quot;you must use it&quot; autoptr class? 
4) new features like move semantics, initializers... Most of them are really &quot;syntatic-shit&quot; (as opposed to syntatic-sugar). 

Why do we use copy-constructors? Why C++ has copy-constructors and other languages DON&#039;T? Because of pointers. Most C++ programmers don&#039;t understand that! You see? My class has about 80% of garbage-wrap-around-code and 20% of payload now. C++ 0x is not as clear as C++ was before. But &quot;to-learn&quot; stuff grows!

I really can&#039;t understand why you folks don&#039;t stop ADDING and ADDING new features. Yes we need new features, but main idea of your additions is &quot;backward compatibility&quot;. My opinion: you can never do something good without cutting off unneeded stuf! As long as old stuff is kept FOR TOO LONG TIME (for example 15 years) -&#062; you are in big trouble. Stop doing things Microsoft way, remove features and stop supporting old stuff like Apple does.

For example:
What null_ptr is used for? Is it a real entity like functional langs has? I am sure -&#062; no one will ever see that null_ptr would have other value than ZERO. Because of backward-compatibility...

&quot;Old-C++&quot; was a bad language too ), but it had something C++ 0x doesn&#039;t ... It was WELL balanced language. I used to learn to code Haskell and that language is perfect: it has clarity and is very expressive. Haskell&#039;s grammar is about 1/10th of C++ grammar in size. Maybe that is the cause? 

I would never suggest my kids to learn C++ nowadays. Let it be Python, C# or something else.]]></description>
		<content:encoded><![CDATA[<p>100% agree with John Sonmez. New C++ 0x11 is really very BAD,BAD,BAD language. As a John himself, i am total C++ fan. The main problem of C++ 0x11 is that it is very big and difficult to learn.</p>
<p>Good C++ programmer must know:<br />
1) lowlevel things like what &#8220;register&#8221; / &#8220;restrict&#8221; / &#8220;auto&#8221; (old one) keywords stand for&#8230;<br />
2) templates &#8230; Oh, crap. Int2Type/ StaticFactorial? I never used that stuff in production, but i have to learn that too!<br />
3) good style: explicit/ virtual destructors/ exception-safety etc.<br />
4) whole bunch of STANDARD libraries and classes: what was the last &#8220;you must use it&#8221; autoptr class?<br />
4) new features like move semantics, initializers&#8230; Most of them are really &#8220;syntatic-shit&#8221; (as opposed to syntatic-sugar). </p>
<p>Why do we use copy-constructors? Why C++ has copy-constructors and other languages DON&#8217;T? Because of pointers. Most C++ programmers don&#8217;t understand that! You see? My class has about 80% of garbage-wrap-around-code and 20% of payload now. C++ 0x is not as clear as C++ was before. But &#8220;to-learn&#8221; stuff grows!</p>
<p>I really can&#8217;t understand why you folks don&#8217;t stop ADDING and ADDING new features. Yes we need new features, but main idea of your additions is &#8220;backward compatibility&#8221;. My opinion: you can never do something good without cutting off unneeded stuf! As long as old stuff is kept FOR TOO LONG TIME (for example 15 years) -&gt; you are in big trouble. Stop doing things Microsoft way, remove features and stop supporting old stuff like Apple does.</p>
<p>For example:<br />
What null_ptr is used for? Is it a real entity like functional langs has? I am sure -&gt; no one will ever see that null_ptr would have other value than ZERO. Because of backward-compatibility&#8230;</p>
<p>&#8220;Old-C++&#8221; was a bad language too ), but it had something C++ 0x doesn&#8217;t &#8230; It was WELL balanced language. I used to learn to code Haskell and that language is perfect: it has clarity and is very expressive. Haskell&#8217;s grammar is about 1/10th of C++ grammar in size. Maybe that is the cause? </p>
<p>I would never suggest my kids to learn C++ nowadays. Let it be Python, C# or something else.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Loup Vaillant				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7148</link>
		<dc:creator><![CDATA[Loup Vaillant]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 10:12:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7148</guid>
					<description><![CDATA[Beware the false dichotomy between &quot;native code&quot; and &quot;managed code&quot;. Sure the currently most used languages (C, C++, Java, C#, JavaScript) tend to make it true. It certainly is if you&#039;re a manager who deals with C-syntax only programmers. But a more polyglot team can use Go, Lisp, or Haskell, all of which can compile to native code. In this case, your argument is quite weakened.

One can compile Haskell code and ship the binaries. It can therefore be tested as thoroughly as C++ compiled code.

Native code based runtimes tend to be much smaller, and much faster to start than a VM that must warm up (or even a simpler interpreter such as Lua). If your service consists of many short lived requests, a native garbage collected language is probably a good option. Your point stands when you need long-lived processes though.]]></description>
		<content:encoded><![CDATA[<p>Beware the false dichotomy between &#8220;native code&#8221; and &#8220;managed code&#8221;. Sure the currently most used languages (C, C++, Java, C#, JavaScript) tend to make it true. It certainly is if you&#8217;re a manager who deals with C-syntax only programmers. But a more polyglot team can use Go, Lisp, or Haskell, all of which can compile to native code. In this case, your argument is quite weakened.</p>
<p>One can compile Haskell code and ship the binaries. It can therefore be tested as thoroughly as C++ compiled code.</p>
<p>Native code based runtimes tend to be much smaller, and much faster to start than a VM that must warm up (or even a simpler interpreter such as Lua). If your service consists of many short lived requests, a native garbage collected language is probably a good option. Your point stands when you need long-lived processes though.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: spmisra				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7147</link>
		<dc:creator><![CDATA[spmisra]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 09:33:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7147</guid>
					<description><![CDATA[Talking about cross platform usages of C++ i think Boost library, standard library and llvm based frontend CLang is doing a great work. It would be interesting to jit C++ also using llvm.]]></description>
		<content:encoded><![CDATA[<p>Talking about cross platform usages of C++ i think Boost library, standard library and llvm based frontend CLang is doing a great work. It would be interesting to jit C++ also using llvm.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pjmlp				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7146</link>
		<dc:creator><![CDATA[pjmlp]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 09:12:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7146</guid>
					<description><![CDATA[I do like C++ a lot, using it lately for some of my private projects (at work I use mainly Java/C#), after my employer started moving their projects from C++ to Java/C# in 2006.

Although I am quite enthusiastic with C++11 and the C++ renaissance, what I keep on noticed in all these discussions is that people continuously mix the languages with their implementations. There are native code compilers for Java and C#, but they tend to not be known by many developers. 

If the language caretakers would start offering nice native optimized compilers for their languages du jour, the need for C++ would decrease in some scenarios where a VM based solution is not possible.

But of course, many of us C++ fans tend to ignore this possibility, as it would decrease the publicity for C++.

I am still looking forward to see C++ pick up speed so that I can convince my boss to allow some of the new stuff to get coded in C++ again, I just don&#039;t want to wait 5 years to get some form of modules.

Does anyone remember how the computing world was 5 years ago and how the language landscape has changed meanwhile?]]></description>
		<content:encoded><![CDATA[<p>I do like C++ a lot, using it lately for some of my private projects (at work I use mainly Java/C#), after my employer started moving their projects from C++ to Java/C# in 2006.</p>
<p>Although I am quite enthusiastic with C++11 and the C++ renaissance, what I keep on noticed in all these discussions is that people continuously mix the languages with their implementations. There are native code compilers for Java and C#, but they tend to not be known by many developers. </p>
<p>If the language caretakers would start offering nice native optimized compilers for their languages du jour, the need for C++ would decrease in some scenarios where a VM based solution is not possible.</p>
<p>But of course, many of us C++ fans tend to ignore this possibility, as it would decrease the publicity for C++.</p>
<p>I am still looking forward to see C++ pick up speed so that I can convince my boss to allow some of the new stuff to get coded in C++ again, I just don&#8217;t want to wait 5 years to get some form of modules.</p>
<p>Does anyone remember how the computing world was 5 years ago and how the language landscape has changed meanwhile?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Magnum				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7143</link>
		<dc:creator><![CDATA[Magnum]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 07:18:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7143</guid>
					<description><![CDATA[Whenever I code in C# I feel my brain cells die, and my productivity plummets.  The language makes me feel stupid.  Must be because it&#039;s been designed as a lowest-common-denominator (corporate) language.

C++ on the other hand is a joy to code in.  It makes me feel like an artist.  I can produce quality code (ahem - my humble opinion of course) that is easy to extend and reuse.  There are tricks you can do in C++ (for debugging, experimenting -- using templates, inline code, dreaded macros) that aren&#039;t possible without really struggling in other languages.

Yes it takes a long time to learn, longer to become skillful, but hey we&#039;re fulltime pros here; it -should- take a long time to master your art.  It feels great to wield skills that I&#039;ve had to put a lot of effort into to learn.

I really would not like to code in an environment that is &quot;upgraded&quot; every couple of years.  You&#039;re continually chasing the &quot;feature football&quot;:  Microsoft adds some spiffy new feature to .Net/C# which programmers then have to pursue like a pack of footballers chasing a ball around a park.  In C++ it will take years for new, fantastic techniques we haven&#039;t dreamt of to come out using C++11&#039;s great new features.  This can&#039;t happen in C#/.Net&#039;s continual upgrade spiral of obsolescence.

If some C++ code of mine isn&#039;t doing what I want it to do, the question I need to answer is &quot;What am I making the computer do?&quot;  There is a direct relationship between your source code and what the CPU(s) does to raw memory that represents your data structures.  This doesn&#039;t exist in managed languages, there&#039;s a whole runtime that second-guesses your intentions and helpfully protects you from yourself.]]></description>
		<content:encoded><![CDATA[<p>Whenever I code in C# I feel my brain cells die, and my productivity plummets.  The language makes me feel stupid.  Must be because it&#8217;s been designed as a lowest-common-denominator (corporate) language.</p>
<p>C++ on the other hand is a joy to code in.  It makes me feel like an artist.  I can produce quality code (ahem &#8211; my humble opinion of course) that is easy to extend and reuse.  There are tricks you can do in C++ (for debugging, experimenting &#8212; using templates, inline code, dreaded macros) that aren&#8217;t possible without really struggling in other languages.</p>
<p>Yes it takes a long time to learn, longer to become skillful, but hey we&#8217;re fulltime pros here; it -should- take a long time to master your art.  It feels great to wield skills that I&#8217;ve had to put a lot of effort into to learn.</p>
<p>I really would not like to code in an environment that is &#8220;upgraded&#8221; every couple of years.  You&#8217;re continually chasing the &#8220;feature football&#8221;:  Microsoft adds some spiffy new feature to .Net/C# which programmers then have to pursue like a pack of footballers chasing a ball around a park.  In C++ it will take years for new, fantastic techniques we haven&#8217;t dreamt of to come out using C++11&#8217;s great new features.  This can&#8217;t happen in C#/.Net&#8217;s continual upgrade spiral of obsolescence.</p>
<p>If some C++ code of mine isn&#8217;t doing what I want it to do, the question I need to answer is &#8220;What am I making the computer do?&#8221;  There is a direct relationship between your source code and what the CPU(s) does to raw memory that represents your data structures.  This doesn&#8217;t exist in managed languages, there&#8217;s a whole runtime that second-guesses your intentions and helpfully protects you from yourself.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: spmisra				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7140</link>
		<dc:creator><![CDATA[spmisra]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 05:19:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7140</guid>
					<description><![CDATA[Here is a bit of my thoughts on the post:
In general I believe,
1. C++ gives people(experts) opportunity to better optimize. So if you do not want the optimizations, please do not use C++.
2. I have always seen many people blame the language for bugs. It is not, with power there always comes better responsibility. So if people think they cannot take those responsibility, or control the raw power, then use other languages. Please do not use C++.
3. It may or may not be a general preference language. If you want to learn using a language in short term and start writing nice GUIs then please do not learn C++ or use it. They application written by impatient C++ programers is always used to abuse C++ in public forums.
4. Also in most projects I have worked (by the way i work on C a lot in beginning of career, C++ mostly, JAVA frequently, python occasionally) I have always seen few developers getting lazy and working without thinking of long term bottle necks. This always happens due to various reasons. So if you do not want to think the difference between List and Vectors, or you do not care about it, please use some other language, not C++. Still if you choose to learn C++ do not complain about the learning curve.
6. This may be my personal view, but i have always noticed that out of 10 people working in a very high level language, at least 3-4 gradually think only of short term results. They do not worry about the performance hogs. For example we have been using C++ in server side for last 8-10 years, but in the same time changed the front end language twice. Major reason is performance hogs. Its not the language that brings this hogs, its just the lazy thinking that “I will code as per will, let the language take care of everything”. This is the mentality that brings these hogs. C++ shows early failure symptoms when you code like this, other languages just forgive you till the customer becomes unforgiving.
5. You cannot write nice GUIs with C++ in a week, do not try to learn it to write GUIs.
6. C does not solve all the problems, nor is template meta programming or overloading complex. It just takes a little bit time, patience and effort to learn it and appreciate it. It does not come over night. In C you can write fast code, but in C++ you can write fast code that can be maintained better, and extended easily. If you do not want to think in OO or Functional terms do not use C++, use C.
7. If you learn C++ as a big brother of C, there is always chance you will suffer. Please learn C++ as C++, this will set the proper learning context in your mind.]]></description>
		<content:encoded><![CDATA[<p>Here is a bit of my thoughts on the post:<br />
In general I believe,<br />
1. C++ gives people(experts) opportunity to better optimize. So if you do not want the optimizations, please do not use C++.<br />
2. I have always seen many people blame the language for bugs. It is not, with power there always comes better responsibility. So if people think they cannot take those responsibility, or control the raw power, then use other languages. Please do not use C++.<br />
3. It may or may not be a general preference language. If you want to learn using a language in short term and start writing nice GUIs then please do not learn C++ or use it. They application written by impatient C++ programers is always used to abuse C++ in public forums.<br />
4. Also in most projects I have worked (by the way i work on C a lot in beginning of career, C++ mostly, JAVA frequently, python occasionally) I have always seen few developers getting lazy and working without thinking of long term bottle necks. This always happens due to various reasons. So if you do not want to think the difference between List and Vectors, or you do not care about it, please use some other language, not C++. Still if you choose to learn C++ do not complain about the learning curve.<br />
6. This may be my personal view, but i have always noticed that out of 10 people working in a very high level language, at least 3-4 gradually think only of short term results. They do not worry about the performance hogs. For example we have been using C++ in server side for last 8-10 years, but in the same time changed the front end language twice. Major reason is performance hogs. Its not the language that brings this hogs, its just the lazy thinking that “I will code as per will, let the language take care of everything”. This is the mentality that brings these hogs. C++ shows early failure symptoms when you code like this, other languages just forgive you till the customer becomes unforgiving.<br />
5. You cannot write nice GUIs with C++ in a week, do not try to learn it to write GUIs.<br />
6. C does not solve all the problems, nor is template meta programming or overloading complex. It just takes a little bit time, patience and effort to learn it and appreciate it. It does not come over night. In C you can write fast code, but in C++ you can write fast code that can be maintained better, and extended easily. If you do not want to think in OO or Functional terms do not use C++, use C.<br />
7. If you learn C++ as a big brother of C, there is always chance you will suffer. Please learn C++ as C++, this will set the proper learning context in your mind.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7139</link>
		<dc:creator><![CDATA[Mike]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 04:03:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7139</guid>
					<description><![CDATA[That smaller, cleaner language you&#039;re looking for is the one that is based on modules (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf), not 50-year-old compiler technology.]]></description>
		<content:encoded><![CDATA[<p>That smaller, cleaner language you&#8217;re looking for is the one that is based on modules (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf</a>), not 50-year-old compiler technology.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7138</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 01:14:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7138</guid>
					<description><![CDATA[@Herb,

It seems to me that some of the dislike of C++ stems from its backwards compatibility constraints. 
Bjarne said: &quot;Within C++, there is a much smaller and cleaner language struggling to get out.&quot;

Has there been any effort trying to define that smaller language in standard C++?
For example, say we wanted to deprecate C-style casts. Could we make them warn/error by default, and when using old headers or libraries, you need something like &quot;#pragma allow_old_school_c++&quot;?]]></description>
		<content:encoded><![CDATA[<p>@Herb,</p>
<p>It seems to me that some of the dislike of C++ stems from its backwards compatibility constraints.<br />
Bjarne said: &#8220;Within C++, there is a much smaller and cleaner language struggling to get out.&#8221;</p>
<p>Has there been any effort trying to define that smaller language in standard C++?<br />
For example, say we wanted to deprecate C-style casts. Could we make them warn/error by default, and when using old headers or libraries, you need something like &#8220;#pragma allow_old_school_c++&#8221;?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jason Bilmez				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7137</link>
		<dc:creator><![CDATA[Jason Bilmez]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 00:54:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7137</guid>
					<description><![CDATA[A review of Jason&#039;s work history on SO and linkedin, the lack of any publicly reviewable code or concrete examples of his work are all indicators that his commentary on the subject of C++ to be nothing more than hot air.

His biggest argument: Not being as productive in C++ when compared to other languages (C#, Java etc). Blaming the tool when not used properly, blaming the technology for not allowing you to reach guru status within 6-12months of trivial use, blaming the presence of complexity, when not fully understanding its existence - are all signs of a novice, inadequate developer.

Further more to preface each argument, with &quot;I really love C++, but...&quot; Is like saying &quot;You&#039;re a really nice person but...&quot; Any technical debate that attempts to inject emotion or personal preference in lieu of properly thought through technical arguments and merits is also indicative of a lack of competence in said area of debate and more an indicator for a lust of self promotion and hot-air.]]></description>
		<content:encoded><![CDATA[<p>A review of Jason&#8217;s work history on SO and linkedin, the lack of any publicly reviewable code or concrete examples of his work are all indicators that his commentary on the subject of C++ to be nothing more than hot air.</p>
<p>His biggest argument: Not being as productive in C++ when compared to other languages (C#, Java etc). Blaming the tool when not used properly, blaming the technology for not allowing you to reach guru status within 6-12months of trivial use, blaming the presence of complexity, when not fully understanding its existence &#8211; are all signs of a novice, inadequate developer.</p>
<p>Further more to preface each argument, with &#8220;I really love C++, but&#8230;&#8221; Is like saying &#8220;You&#8217;re a really nice person but&#8230;&#8221; Any technical debate that attempts to inject emotion or personal preference in lieu of properly thought through technical arguments and merits is also indicative of a lack of competence in said area of debate and more an indicator for a lust of self promotion and hot-air.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Zenju				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7136</link>
		<dc:creator><![CDATA[Zenju]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 00:16:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7136</guid>
					<description><![CDATA[&#062; There are other major reasons in addition to those, such as:

He forgot the most important one:  Design without compromise. 

As much as C++&#039;s complexity may be seen as a disadvantage for newbies, it is giving the expert all the design tools at hand to express everything he wants directly, unlike any other &quot;simpler&quot; language.]]></description>
		<content:encoded><![CDATA[<p>&gt; There are other major reasons in addition to those, such as:</p>
<p>He forgot the most important one:  Design without compromise. </p>
<p>As much as C++&#8217;s complexity may be seen as a disadvantage for newbies, it is giving the expert all the design tools at hand to express everything he wants directly, unlike any other &#8220;simpler&#8221; language.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrew				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7135</link>
		<dc:creator><![CDATA[Andrew]]></dc:creator>
		<pubDate>Tue, 04 Dec 2012 00:04:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7135</guid>
					<description><![CDATA[C++ being good or not vs other languages... how many articles have been written about it?
I worked as a C++ developer for several years, now only C#

I wish there was a similar language to the C++(no intermediate language like in .net), having similar simplicity of the C# as a language(no OOP multi class inheritance language quirks) and being able to use the same framework awesomeness of .NET.]]></description>
		<content:encoded><![CDATA[<p>C++ being good or not vs other languages&#8230; how many articles have been written about it?<br />
I worked as a C++ developer for several years, now only C#</p>
<p>I wish there was a similar language to the C++(no intermediate language like in .net), having similar simplicity of the C# as a language(no OOP multi class inheritance language quirks) and being able to use the same framework awesomeness of .NET.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jsonmez				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7132</link>
		<dc:creator><![CDATA[jsonmez]]></dc:creator>
		<pubDate>Mon, 03 Dec 2012 22:21:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7132</guid>
					<description><![CDATA[Thanks Herb.  Good point about perspective.  And I appreciate you attitude on the subject.  We may not agree, but we can discus our different views in a productive way.

I learned a large amount about C++ from your excellent books and articles on C++.

@mrmcgibby great point! Rarely does any managed developer drop into the appropriate language like C or C++, myself included.  We all need to be better polyglot programmers, using the right tool for the right job.  :)]]></description>
		<content:encoded><![CDATA[<p>Thanks Herb.  Good point about perspective.  And I appreciate you attitude on the subject.  We may not agree, but we can discus our different views in a productive way.</p>
<p>I learned a large amount about C++ from your excellent books and articles on C++.</p>
<p>@mrmcgibby great point! Rarely does any managed developer drop into the appropriate language like C or C++, myself included.  We all need to be better polyglot programmers, using the right tool for the right job.  :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mrmcgibby				</title>
				<link>https://herbsutter.com/2012/12/03/perspective-why-c-is-not-back/#comment-7131</link>
		<dc:creator><![CDATA[mrmcgibby]]></dc:creator>
		<pubDate>Mon, 03 Dec 2012 22:00:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1684#comment-7131</guid>
					<description><![CDATA[Decent article.  I don&#039;t think it&#039;s *that* good.  He makes some good points about the failings of C++, but he doesn&#039;t really explain how some other language does it better.  It really comes off as yet another post by someone who needs to prioritize development speed over execution speed, which is where all these &quot;simpler&quot; languages tend to shine.  In my experience, these other languages execute fast enough on smaller projects, but start to break down on larger ones.  The response is that you should write the fast parts in C when needed.  However, this isn&#039;t a trivial barrier and may seriously break the design of the system.  These guys throw that approach around, but I don&#039;t generally see many of them actually *doing* it because really, the barrier is pretty large.]]></description>
		<content:encoded><![CDATA[<p>Decent article.  I don&#8217;t think it&#8217;s *that* good.  He makes some good points about the failings of C++, but he doesn&#8217;t really explain how some other language does it better.  It really comes off as yet another post by someone who needs to prioritize development speed over execution speed, which is where all these &#8220;simpler&#8221; languages tend to shine.  In my experience, these other languages execute fast enough on smaller projects, but start to break down on larger ones.  The response is that you should write the fast parts in C when needed.  However, this isn&#8217;t a trivial barrier and may seriously break the design of the system.  These guys throw that approach around, but I don&#8217;t generally see many of them actually *doing* it because really, the barrier is pretty large.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
