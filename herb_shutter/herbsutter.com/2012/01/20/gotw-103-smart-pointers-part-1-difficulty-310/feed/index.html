<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #103: Smart Pointers, Part 1 (Difficulty: 3/10)	</title>
	<atom:link href="https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: On what platform is func(shared_ptr(...), shared_ptr(...)) really dangerous? &#124; BlogoSfera				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-12105</link>
		<dc:creator><![CDATA[On what platform is func(shared_ptr(...), shared_ptr(...)) really dangerous? &#124; BlogoSfera]]></dc:creator>
		<pubDate>Tue, 06 Aug 2013 10:02:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-12105</guid>
					<description><![CDATA[[&#8230;] is some discussion about it, [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] is some discussion about it, [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Hal Pratt				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4782</link>
		<dc:creator><![CDATA[Hal Pratt]]></dc:creator>
		<pubDate>Wed, 08 Feb 2012 09:31:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4782</guid>
					<description><![CDATA[The solution to Waldemar&#039;s first problem is to use allocate_shared &#038; make the allocator a friend, or, anyway, it will be once LWG open issue #2070 is resolved (http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2070). In the meantime, I suppose you can just peek inside your vendor&#039;s allocate_shared implementation to see who to friend.]]></description>
		<content:encoded><![CDATA[<p>The solution to Waldemar&#8217;s first problem is to use allocate_shared &amp; make the allocator a friend, or, anyway, it will be once LWG open issue #2070 is resolved (<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2070" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2070</a>). In the meantime, I suppose you can just peek inside your vendor&#8217;s allocate_shared implementation to see who to friend.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Mach (phresnel)				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4780</link>
		<dc:creator><![CDATA[Sebastian Mach (phresnel)]]></dc:creator>
		<pubDate>Tue, 07 Feb 2012 16:21:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4780</guid>
					<description><![CDATA[(Xeo gave the purist auto_ptr answer. So here my purist answer on shared_ptr vs. unique_ptr)

Use shared_ptr to allow for multiple isochronal owners, none of which shall have exclusive right to delete.

Use unique_ptr to allow for exactly one isochronal owner.]]></description>
		<content:encoded><![CDATA[<p>(Xeo gave the purist auto_ptr answer. So here my purist answer on shared_ptr vs. unique_ptr)</p>
<p>Use shared_ptr to allow for multiple isochronal owners, none of which shall have exclusive right to delete.</p>
<p>Use unique_ptr to allow for exactly one isochronal owner.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul Michalik				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4740</link>
		<dc:creator><![CDATA[Paul Michalik]]></dc:creator>
		<pubDate>Sat, 28 Jan 2012 09:55:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4740</guid>
					<description><![CDATA[I can&#039;t add anything more that has been said above to the answers regarding the actual question. One point though, as an addition to Waldemar Pawlaszek&#039;s comment. There are situations when you can&#039;t use the full power of currently standardized smart pointers: When you need to pass resources between independently compiled components. &quot;Independent&quot; means possibly compiled with different versions of std implementations (with different implementation of std::shared_ptr &#038; friends) and/or linked against different run-time libraries. From such a component, you typically do not export the definition of T at all, so there is no way to construct with the aid of make_shared. That&#039;s when (at least to some extent) boost::intrusive_ptr jumps in, leaving the resource lifetime management completely up to the implementation.]]></description>
		<content:encoded><![CDATA[<p>I can&#8217;t add anything more that has been said above to the answers regarding the actual question. One point though, as an addition to Waldemar Pawlaszek&#8217;s comment. There are situations when you can&#8217;t use the full power of currently standardized smart pointers: When you need to pass resources between independently compiled components. &#8220;Independent&#8221; means possibly compiled with different versions of std implementations (with different implementation of std::shared_ptr &amp; friends) and/or linked against different run-time libraries. From such a component, you typically do not export the definition of T at all, so there is no way to construct with the aid of make_shared. That&#8217;s when (at least to some extent) boost::intrusive_ptr jumps in, leaving the resource lifetime management completely up to the implementation.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4725</link>
		<dc:creator><![CDATA[Martin]]></dc:creator>
		<pubDate>Tue, 24 Jan 2012 10:46:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4725</guid>
					<description><![CDATA[3. What’s the deal with auto_ptr? -- Apart from it&#039;s standard set of problems, auto_ptr is completely broken in VC8 / VS2005, which unfortunately is still my compiler at work. 

In VC8 the statement:  auto_ptr(T) = new T();  // will compile and crash at runtime. Note that I&#039;ve replaced the angle brackets for posting purposes.]]></description>
		<content:encoded><![CDATA[<p>3. What’s the deal with auto_ptr? &#8212; Apart from it&#8217;s standard set of problems, auto_ptr is completely broken in VC8 / VS2005, which unfortunately is still my compiler at work. </p>
<p>In VC8 the statement:  auto_ptr(T) = new T();  // will compile and crash at runtime. Note that I&#8217;ve replaced the angle brackets for posting purposes.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Waldemar Pawlaszek				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4714</link>
		<dc:creator><![CDATA[Waldemar Pawlaszek]]></dc:creator>
		<pubDate>Mon, 23 Jan 2012 08:15:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4714</guid>
					<description><![CDATA[@Kerrek SB: The question was not about constructing shared pointer but about allocating a memory for and constructing an object that is to be managed by shared_ptr. When the object is already constructed there is no use for the make_shared utility.

On the other hand in my work I&#039;ve recognized two problems with make_shared:
1. You cannot use make_shared with classes that have protected constructor. It is essential when the class have it&#039;s own &quot;create&quot; factory performing some additional work and we want to disallow the means for creating the object outside of the factory. Standard does not specify with who to be befriended (and even if, it would create a loophole) and there is no base class to inherit from that would do the work effectively.
2. When weak_ptr outlives shared_ptr the memory that have been occupied by the object can&#039;t be freed until all weak pointers will be destroyed.]]></description>
		<content:encoded><![CDATA[<p>@Kerrek SB: The question was not about constructing shared pointer but about allocating a memory for and constructing an object that is to be managed by shared_ptr. When the object is already constructed there is no use for the make_shared utility.</p>
<p>On the other hand in my work I&#8217;ve recognized two problems with make_shared:<br />
1. You cannot use make_shared with classes that have protected constructor. It is essential when the class have it&#8217;s own &#8220;create&#8221; factory performing some additional work and we want to disallow the means for creating the object outside of the factory. Standard does not specify with who to be befriended (and even if, it would create a loophole) and there is no base class to inherit from that would do the work effectively.<br />
2. When weak_ptr outlives shared_ptr the memory that have been occupied by the object can&#8217;t be freed until all weak pointers will be destroyed.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kerrek SB				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4711</link>
		<dc:creator><![CDATA[Kerrek SB]]></dc:creator>
		<pubDate>Mon, 23 Jan 2012 02:13:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4711</guid>
					<description><![CDATA[To add to the much belaboured point 2:

One further situation in which you don&#039;t use `make_shared` is when constructing a shared pointer *from* an existing unique pointer, possibly with a non-default deleter. The resulting shared pointer will have to be one of the type with separate refcontrol block (including the deleter information) and distinct dynamic resource (which already comes fully furnished from the unique pointer).

Interestingly enough, the construction-from-unique&#038;&#038; doesn&#039;t appear to allow you to specify an allocator.]]></description>
		<content:encoded><![CDATA[<p>To add to the much belaboured point 2:</p>
<p>One further situation in which you don&#8217;t use `make_shared` is when constructing a shared pointer *from* an existing unique pointer, possibly with a non-default deleter. The resulting shared pointer will have to be one of the type with separate refcontrol block (including the deleter information) and distinct dynamic resource (which already comes fully furnished from the unique pointer).</p>
<p>Interestingly enough, the construction-from-unique&amp;&amp; doesn&#8217;t appear to allow you to specify an allocator.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4702</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Sat, 21 Jan 2012 22:30:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4702</guid>
					<description><![CDATA[I&#039;d like to clarify one point: the distinction between strong and weak pointers. 

When using unique_ptr, there is only one owner of the resource at a time. However, unique_ptr may grant non-owning access to its resource. This is very important when, e.g., you want to call a library function that takes a pointer to your resource:
&lt;pre&gt;libFun(Foo *);
unique_ptr foo(new Foo);
libFun(foo.get());&lt;/pre&gt;
By &quot;library&quot; I mean any reusable code. It makes very little sense to have a library function that operates of Foo, but has no interest in the ownership of Foo, to have this signature:
&lt;pre&gt;libFun(unique_ptr &#038; foo);&lt;/pre&gt;
The pointer passed to libFun(Foo*) is a transient alias, or a &quot;weak pointer&quot; to the resource. It&#039;s a bad idea to let the function or a data structure store such a transient alias for two reasons: (1) The alias might become invalid when the owner is destroyed, (2) such aliases might appear in a different thread than the owner&#039;s. In the latter case, thread safety of a unique_ptr is compromised. A unique_ptr is thread-safe only if there are no aliases to it or to its contents (transitively), and there are no aliases inside its contents to data that&#039;s accessible from the outside. In general, a unique_ptr defines its own cluster of interlinked objects that have no connection to the outside (incoming or outgoing references). 

When using shared_ptr, many copies of it might coexist in the program at the same time. It&#039;s still not a good idea to store aliases to the resource it&#039;s protecting or to its transitive contents. 

shared_ptr implements a simple form of garbage collection -- reference counting. The problem with reference counting is that it doesn&#039;t deal well with cycles. If you have a graph data structure that contains back pointers, you can&#039;t turn them into shared_ptrs without risking cycles. The semi-safe way to implement back pointers in a shared_ptr-based data structure is to use weak_ptr. A weak_ptr doesn&#039;t take part in reference counting, so it doesn&#039;t create non-collectible cycles, but it can be (temporarily) converted into a shared_ptr to gain access to the resource. (Of course, if the resource has already been collected, this conversion will not work and it will result in an exception.) weak_ptrs are used, for instance, in shareable doubly-linked lists or trees with parent pointers.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;d like to clarify one point: the distinction between strong and weak pointers. </p>
<p>When using unique_ptr, there is only one owner of the resource at a time. However, unique_ptr may grant non-owning access to its resource. This is very important when, e.g., you want to call a library function that takes a pointer to your resource:</p>
<pre>libFun(Foo *);
unique_ptr foo(new Foo);
libFun(foo.get());</pre>
<p>By &#8220;library&#8221; I mean any reusable code. It makes very little sense to have a library function that operates of Foo, but has no interest in the ownership of Foo, to have this signature:</p>
<pre>libFun(unique_ptr &amp; foo);</pre>
<p>The pointer passed to libFun(Foo*) is a transient alias, or a &#8220;weak pointer&#8221; to the resource. It&#8217;s a bad idea to let the function or a data structure store such a transient alias for two reasons: (1) The alias might become invalid when the owner is destroyed, (2) such aliases might appear in a different thread than the owner&#8217;s. In the latter case, thread safety of a unique_ptr is compromised. A unique_ptr is thread-safe only if there are no aliases to it or to its contents (transitively), and there are no aliases inside its contents to data that&#8217;s accessible from the outside. In general, a unique_ptr defines its own cluster of interlinked objects that have no connection to the outside (incoming or outgoing references). </p>
<p>When using shared_ptr, many copies of it might coexist in the program at the same time. It&#8217;s still not a good idea to store aliases to the resource it&#8217;s protecting or to its transitive contents. </p>
<p>shared_ptr implements a simple form of garbage collection &#8212; reference counting. The problem with reference counting is that it doesn&#8217;t deal well with cycles. If you have a graph data structure that contains back pointers, you can&#8217;t turn them into shared_ptrs without risking cycles. The semi-safe way to implement back pointers in a shared_ptr-based data structure is to use weak_ptr. A weak_ptr doesn&#8217;t take part in reference counting, so it doesn&#8217;t create non-collectible cycles, but it can be (temporarily) converted into a shared_ptr to gain access to the resource. (Of course, if the resource has already been collected, this conversion will not work and it will result in an exception.) weak_ptrs are used, for instance, in shareable doubly-linked lists or trees with parent pointers.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alfonse				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4695</link>
		<dc:creator><![CDATA[Alfonse]]></dc:creator>
		<pubDate>Sat, 21 Jan 2012 03:45:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4695</guid>
					<description><![CDATA[1: When should you use shared_ptr vs. unique_ptr? List as many considerations as you can.

unique_ptr should be used for situations where a function or object needs to allocate something, but does not need to share ownership of that allocated object with some other object or function. The object/function will directly control the lifetime of the object.

unique_ptr should be used in situations where ownership can be *given* to another object/function. That is, after the function call, the current owner no longer has access to it anymore.

shared_ptr should be used in situations where multiple functions/objects can *simultaneously* claim ownership to the same allocated resource.

shared_ptr should also be used in situations where other functions/objects may want to weakly reference an object. This is useful for objects that need to monitor other objects, but don&#039;t fully claim ownership over the lifetime of that object. The object with the weak reference can check to see if the object still exists, but it does not prevent it from being destroyed.

2: Why should you always use make_shared to allocate objects whose lifetimes will be managed by shared_ptr? Explain.

shared_ptr offers a number of features. The main one is the ability for multiple copies of the shared_ptr to all claim ownership of the same object. In order to do this, shared_ptr requires a special control block of memory that stores a count of references to the managed pointer. This block is separate from the actual pointer being owned.

Consider the following.

auto variable = shared_ptr(new Typename);

Two memory allocations happen. `new Typename` allocates the object that will be owned. But the constructor of the shared_ptr also allocates the control block which contains the reference count. That is two separate allocations.

Since memory allocation is not exactly a lightweight activity, it is best to minimize it. Because make_shared does the construction of the type, it has the ability to combine the memory for the object and the control block into one allocation.

Therefore, where *possible*, it is best to use make_shared. However, it is not always possible. It cannot be used for managing memory from a source that is not a C++ object, such as an opaque pointer returned from a C-style API.

allocate_shared should be used in circumstances where a special memory allocator is needed.

So the question itself presupposes a conclusion that is incorrect, since make_shared cannot replace *all* uses of shared_ptr creation.

3: What’s the deal with auto_ptr?

auto_ptr was an attempt to replicate the effective functionality of unique_ptr using a language that couldn&#039;t express true move semantics. Its copy constructor actually *moved* the ownership rather than copying it.

One can make reasonably safe use of auto_ptr if one is careful. However, it cannot be used in a standard libary container due to its &quot;copying&quot; semantics. Standard containers that copy their elements at any time could easily break any stored auto_ptr. Something similar can happen for storing auto_ptr in an object without a specialized copy constructor/assignment operator.

Since unique_ptr uses C++11 features to explicitly disallow copying, and C++11 standard containers can store non-copyable objects via use of move constructors, auto_ptr is effectiveless useless. It was therefore deprecated in C++11.]]></description>
		<content:encoded><![CDATA[<p>1: When should you use shared_ptr vs. unique_ptr? List as many considerations as you can.</p>
<p>unique_ptr should be used for situations where a function or object needs to allocate something, but does not need to share ownership of that allocated object with some other object or function. The object/function will directly control the lifetime of the object.</p>
<p>unique_ptr should be used in situations where ownership can be *given* to another object/function. That is, after the function call, the current owner no longer has access to it anymore.</p>
<p>shared_ptr should be used in situations where multiple functions/objects can *simultaneously* claim ownership to the same allocated resource.</p>
<p>shared_ptr should also be used in situations where other functions/objects may want to weakly reference an object. This is useful for objects that need to monitor other objects, but don&#8217;t fully claim ownership over the lifetime of that object. The object with the weak reference can check to see if the object still exists, but it does not prevent it from being destroyed.</p>
<p>2: Why should you always use make_shared to allocate objects whose lifetimes will be managed by shared_ptr? Explain.</p>
<p>shared_ptr offers a number of features. The main one is the ability for multiple copies of the shared_ptr to all claim ownership of the same object. In order to do this, shared_ptr requires a special control block of memory that stores a count of references to the managed pointer. This block is separate from the actual pointer being owned.</p>
<p>Consider the following.</p>
<p>auto variable = shared_ptr(new Typename);</p>
<p>Two memory allocations happen. `new Typename` allocates the object that will be owned. But the constructor of the shared_ptr also allocates the control block which contains the reference count. That is two separate allocations.</p>
<p>Since memory allocation is not exactly a lightweight activity, it is best to minimize it. Because make_shared does the construction of the type, it has the ability to combine the memory for the object and the control block into one allocation.</p>
<p>Therefore, where *possible*, it is best to use make_shared. However, it is not always possible. It cannot be used for managing memory from a source that is not a C++ object, such as an opaque pointer returned from a C-style API.</p>
<p>allocate_shared should be used in circumstances where a special memory allocator is needed.</p>
<p>So the question itself presupposes a conclusion that is incorrect, since make_shared cannot replace *all* uses of shared_ptr creation.</p>
<p>3: What’s the deal with auto_ptr?</p>
<p>auto_ptr was an attempt to replicate the effective functionality of unique_ptr using a language that couldn&#8217;t express true move semantics. Its copy constructor actually *moved* the ownership rather than copying it.</p>
<p>One can make reasonably safe use of auto_ptr if one is careful. However, it cannot be used in a standard libary container due to its &#8220;copying&#8221; semantics. Standard containers that copy their elements at any time could easily break any stored auto_ptr. Something similar can happen for storing auto_ptr in an object without a specialized copy constructor/assignment operator.</p>
<p>Since unique_ptr uses C++11 features to explicitly disallow copying, and C++11 standard containers can store non-copyable objects via use of move constructors, auto_ptr is effectiveless useless. It was therefore deprecated in C++11.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4693</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Fri, 20 Jan 2012 23:09:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4693</guid>
					<description><![CDATA[1. Whenever the ownership of a resource (including heap-allocated memory) is well defined during the whole lifetime of the object, you should use unique_ptr. Ownership means responsibility for releasing the resource. Ownership may be passed by _moving_ unique_ptr.

Only if you can&#039;t clearly assign the owner to the resource should you use shared_ptr. This happens when access to a resource is shared between objects whose lifetimes cannot be predicted. shared_ptr implements the policy of &quot;last to leave the room turns off the lights&quot; (releases the resource).

In a multithreaded context, unique_ptr is the fastest and safest way of moving data between threads, as long as there are no stray aliases left behind. Uniqueness means that only one thread at a time has access to the resource and no additional synchronization is required. This is not true with shared_ptr, which facilitates sharing of resources between threads. The object in shared_ptr must implement its own synchronization. What shared_ptr provides is thread-safe reference counting, but at a non-trivial cost. 

2. make_shared is a substantial optimization. Normally a shared_ptr needs a separate heap object for storing the reference count. When shared_ptr is created using make_shared, the memory for the object and the reference count are allocated together. Besides saving one allocation, this also improves locality.

3. auto_ptr was a hack that is now deprecated. Move semantics and rvalue references allow clean and efficient implementation of unique_ptr. The major danger with auto_ptr is that it could be quietly passed using its copy constructor, which would invalidate the source auto_ptr. If that source auto_ptr was subsequently accessed, it would result in a fault. unique_ptr, on the other hand, cannot be passed quietly, unless it&#039;s an rvalue. The programmer has to explicitly call std::move to pass an lvalue unique_ptr. That makes for a safer code.]]></description>
		<content:encoded><![CDATA[<p>1. Whenever the ownership of a resource (including heap-allocated memory) is well defined during the whole lifetime of the object, you should use unique_ptr. Ownership means responsibility for releasing the resource. Ownership may be passed by _moving_ unique_ptr.</p>
<p>Only if you can&#8217;t clearly assign the owner to the resource should you use shared_ptr. This happens when access to a resource is shared between objects whose lifetimes cannot be predicted. shared_ptr implements the policy of &#8220;last to leave the room turns off the lights&#8221; (releases the resource).</p>
<p>In a multithreaded context, unique_ptr is the fastest and safest way of moving data between threads, as long as there are no stray aliases left behind. Uniqueness means that only one thread at a time has access to the resource and no additional synchronization is required. This is not true with shared_ptr, which facilitates sharing of resources between threads. The object in shared_ptr must implement its own synchronization. What shared_ptr provides is thread-safe reference counting, but at a non-trivial cost. </p>
<p>2. make_shared is a substantial optimization. Normally a shared_ptr needs a separate heap object for storing the reference count. When shared_ptr is created using make_shared, the memory for the object and the reference count are allocated together. Besides saving one allocation, this also improves locality.</p>
<p>3. auto_ptr was a hack that is now deprecated. Move semantics and rvalue references allow clean and efficient implementation of unique_ptr. The major danger with auto_ptr is that it could be quietly passed using its copy constructor, which would invalidate the source auto_ptr. If that source auto_ptr was subsequently accessed, it would result in a fault. unique_ptr, on the other hand, cannot be passed quietly, unless it&#8217;s an rvalue. The programmer has to explicitly call std::move to pass an lvalue unique_ptr. That makes for a safer code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: stackedcrooked				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4692</link>
		<dc:creator><![CDATA[stackedcrooked]]></dc:creator>
		<pubDate>Fri, 20 Jan 2012 23:01:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4692</guid>
					<description><![CDATA[The `unique_ptr`:
- Ownership transfer. Factories should ideally return `unique_ptr` instead of raw pointers.
- Safely pass an object between threads (only one thread can access it at a time).
- Can be used as a holder for the impl object in the pimpl idiom.
- Can be used in containers thanks to move semantics. But it&#039;s not very flexible.
- Can be used for the similar purposes as `boost::scoped_ptr`.

The `shared_ptr`:
- Shared ownership. I usually prefer single ownership though.
- Safely store pointers in a container. More flexible than `unique_ptr` in this regard.
- parent-child relations can be modeled using `shared_ptr` and `weak_ptr`.
- Accepts a `free`-function as a second constructor argument.
- It generates a &#039;free&#039;-function based on the type provided in the constructor. So `shared_ptr ptr(new SubClass());` is safe even if `Base` does not have a virtual destructor.

Concerning `make_shared`:
- Safe alternative to unnamed `shared_ptr` temporaries (see [documentation of boost::shared_ptr](http://www.boost.org/doc/libs/1_48_0/libs/smart_ptr/shared_ptr.htm#BestPractices) ).
- It&#039;s a nicer and compacter syntax.

Concerning `auto_ptr`:
- Has similar use as `unique_ptr` (ownership transfer, passing between threads) or `boost::scoped_ptr`.
- Not safe to use in containers.
- Dangerous to use for member variables in classes do not have a user-defined copy constructor and assignment operator. Even though the class obeys the rule-of-three, it is not safe to copy because it leaves the original invalidated.

With `auto_ptr` it&#039;s easy to shoot yourself in the foot by passing it to a function and then still try to use it:

    std::auto_ptr r = foo();
    bar(r); // This looks like a regular function call.
    std::cout &#060;value(); // Ouch! I forgot the object is no longer accessible!

With `unique_ptr` you must explicitly move the pointer by calling `std::move`. This makes me less likely to forget that I can no longer access it:

    std::unique_ptr ptr = foo();
    bar(std::move(ptr)); // alerts me that the object is no longer accessible]]></description>
		<content:encoded><![CDATA[<p>The `unique_ptr`:<br />
&#8211; Ownership transfer. Factories should ideally return `unique_ptr` instead of raw pointers.<br />
&#8211; Safely pass an object between threads (only one thread can access it at a time).<br />
&#8211; Can be used as a holder for the impl object in the pimpl idiom.<br />
&#8211; Can be used in containers thanks to move semantics. But it&#8217;s not very flexible.<br />
&#8211; Can be used for the similar purposes as `boost::scoped_ptr`.</p>
<p>The `shared_ptr`:<br />
&#8211; Shared ownership. I usually prefer single ownership though.<br />
&#8211; Safely store pointers in a container. More flexible than `unique_ptr` in this regard.<br />
&#8211; parent-child relations can be modeled using `shared_ptr` and `weak_ptr`.<br />
&#8211; Accepts a `free`-function as a second constructor argument.<br />
&#8211; It generates a &#8216;free&#8217;-function based on the type provided in the constructor. So `shared_ptr ptr(new SubClass());` is safe even if `Base` does not have a virtual destructor.</p>
<p>Concerning `make_shared`:<br />
&#8211; Safe alternative to unnamed `shared_ptr` temporaries (see [documentation of boost::shared_ptr](<a href="http://www.boost.org/doc/libs/1_48_0/libs/smart_ptr/shared_ptr.htm#BestPractices" rel="nofollow">http://www.boost.org/doc/libs/1_48_0/libs/smart_ptr/shared_ptr.htm#BestPractices</a>) ).<br />
&#8211; It&#8217;s a nicer and compacter syntax.</p>
<p>Concerning `auto_ptr`:<br />
&#8211; Has similar use as `unique_ptr` (ownership transfer, passing between threads) or `boost::scoped_ptr`.<br />
&#8211; Not safe to use in containers.<br />
&#8211; Dangerous to use for member variables in classes do not have a user-defined copy constructor and assignment operator. Even though the class obeys the rule-of-three, it is not safe to copy because it leaves the original invalidated.</p>
<p>With `auto_ptr` it&#8217;s easy to shoot yourself in the foot by passing it to a function and then still try to use it:</p>
<p>    std::auto_ptr r = foo();<br />
    bar(r); // This looks like a regular function call.<br />
    std::cout &lt;value(); // Ouch! I forgot the object is no longer accessible!</p>
<p>With `unique_ptr` you must explicitly move the pointer by calling `std::move`. This makes me less likely to forget that I can no longer access it:</p>
<p>    std::unique_ptr ptr = foo();<br />
    bar(std::move(ptr)); // alerts me that the object is no longer accessible</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Xeo				</title>
				<link>https://herbsutter.com/2012/01/20/gotw-103-smart-pointers-part-1-difficulty-310/#comment-4691</link>
		<dc:creator><![CDATA[Xeo]]></dc:creator>
		<pubDate>Fri, 20 Jan 2012 21:16:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1346#comment-4691</guid>
					<description><![CDATA[1) &lt;a href=&quot;http://stackoverflow.com/q/8706192/500104&quot; rel=&quot;nofollow&quot;&gt;StackOverflow: Which kind of pointer do I use when?&lt;/a&gt; :)

2) Not always. &lt;em&gt;make_shared&lt;/em&gt; doesn&#039;t allow to specify your own deleter. However, if there is no need for one, then there are indeed good reasons to use it. For one, &lt;em&gt;make_shared&lt;/em&gt; compresses the allocations into a single one, where a &lt;em&gt;shared_ptr&#060;X&#038;rt; p(new X);&lt;/em&gt; would need two allocations: one for the &lt;em&gt;X&lt;/em&gt; object, one for the reference-count block used by the &lt;em&gt;shared_ptr&lt;/em&gt;.

3) &lt;em&gt;auto_ptr&lt;/em&gt; has broken copy semantics. The copies actually &lt;em&gt;moves&lt;/em&gt; the &lt;em&gt;auto_ptr&lt;/em&gt;, meaning it transfers the ownership on copy. As such, it&#039;s unusable in standard containers and even deprecated by the C++11 standard.]]></description>
		<content:encoded><![CDATA[<p>1) <a href="http://stackoverflow.com/q/8706192/500104" rel="nofollow">StackOverflow: Which kind of pointer do I use when?</a> :)</p>
<p>2) Not always. <em>make_shared</em> doesn&#8217;t allow to specify your own deleter. However, if there is no need for one, then there are indeed good reasons to use it. For one, <em>make_shared</em> compresses the allocations into a single one, where a <em>shared_ptr&lt;X&amp;rt; p(new X);</em> would need two allocations: one for the <em>X</em> object, one for the reference-count block used by the <em>shared_ptr</em>.</p>
<p>3) <em>auto_ptr</em> has broken copy semantics. The copies actually <em>moves</em> the <em>auto_ptr</em>, meaning it transfers the ownership on copy. As such, it&#8217;s unusable in standard containers and even deprecated by the C++11 standard.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
