<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: We want await! A C# talk that&#8217;s applicable to C++	</title>
	<atom:link href="https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: petke				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5200</link>
		<dc:creator><![CDATA[petke]]></dc:creator>
		<pubDate>Thu, 12 Apr 2012 22:40:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5200</guid>
					<description><![CDATA[@MichaelTK The next C++ is not in expected in eight years but in five. C++17. Before that we will get library changes as TR&#039;s whenever they are ready.]]></description>
		<content:encoded><![CDATA[<p>@MichaelTK The next C++ is not in expected in eight years but in five. C++17. Before that we will get library changes as TR&#8217;s whenever they are ready.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: robdesbois				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5188</link>
		<dc:creator><![CDATA[robdesbois]]></dc:creator>
		<pubDate>Wed, 11 Apr 2012 12:02:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5188</guid>
					<description><![CDATA[@Jon It&#039;s non-standard of course, but boost::any provides a variant type, and type inference is supported in C++11 through the new semantics of the &#039;auto&#039; keyword.]]></description>
		<content:encoded><![CDATA[<p>@Jon It&#8217;s non-standard of course, but boost::any provides a variant type, and type inference is supported in C++11 through the new semantics of the &#8216;auto&#8217; keyword.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MichaelTK				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5180</link>
		<dc:creator><![CDATA[MichaelTK]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 19:00:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5180</guid>
					<description><![CDATA[&#062;  C++ a dead-declared language? By self-appointed gurus, I assume.

Well if you don&#039;t think C++03 is a dead declared language, then you will probably standing there alone with a small fraction of developers... A language is not kept alive by existing codebases. Just because people use it, this doesn&#039;t necessarily mean a language is alive, unless you declare it to be ;). C++11 was a great step forward, but I think it was way too late... And the outlooks for the next iteration of the standard do not seem to be anywhere near that revolutionary. If you now take into account that a new standard needs at least 5 years to spread around... The iteration cycle is too long and except for C++11 far too conservative, period. I know the committee is voluntary but unfortunately this cannot be taken into account when judging about the language itself. The next iterations must be at least as impressive as C++11 and hopefully with a shorter cycle than 8 years. 8 years, common, this is like a life-time in todays pace of the digital evolution (which is only getting exponentially faster). I even doubt that the voluntary standard committee will be able to act fast enough to accompany for the fast growing nature of software development. Some companies like Google/Apple/Microsoft who each work on good compilers, should work together and actually invest money in the standard and not only in compilers...

&#062; The GoingNative conference was great and the talks were all fantastic. C++11 is similarly great and full of great features.

Yes it is... Would have been better if we could call it C++06...]]></description>
		<content:encoded><![CDATA[<p>&gt;  C++ a dead-declared language? By self-appointed gurus, I assume.</p>
<p>Well if you don&#8217;t think C++03 is a dead declared language, then you will probably standing there alone with a small fraction of developers&#8230; A language is not kept alive by existing codebases. Just because people use it, this doesn&#8217;t necessarily mean a language is alive, unless you declare it to be ;). C++11 was a great step forward, but I think it was way too late&#8230; And the outlooks for the next iteration of the standard do not seem to be anywhere near that revolutionary. If you now take into account that a new standard needs at least 5 years to spread around&#8230; The iteration cycle is too long and except for C++11 far too conservative, period. I know the committee is voluntary but unfortunately this cannot be taken into account when judging about the language itself. The next iterations must be at least as impressive as C++11 and hopefully with a shorter cycle than 8 years. 8 years, common, this is like a life-time in todays pace of the digital evolution (which is only getting exponentially faster). I even doubt that the voluntary standard committee will be able to act fast enough to accompany for the fast growing nature of software development. Some companies like Google/Apple/Microsoft who each work on good compilers, should work together and actually invest money in the standard and not only in compilers&#8230;</p>
<p>&gt; The GoingNative conference was great and the talks were all fantastic. C++11 is similarly great and full of great features.</p>
<p>Yes it is&#8230; Would have been better if we could call it C++06&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Pikkonen				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5173</link>
		<dc:creator><![CDATA[Pikkonen]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 13:59:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5173</guid>
					<description><![CDATA[@MichealTK

XP is old. XP is crap. I wish XP were dead. But it isn&#039;t. That&#039;s the unfortunate truth.

What it comes down to is the blatant fact that Microsoft has yet to convince us that removing XP support was purely a technical decision. As seen from the workarounds available at http://tedwvc.wordpress.com, VS11 binaries *can* run on XP, albeit in a rather hacky/ugly manner. From the looks of it, it feels as if the entire decision was made by folks high up in the food chain just for the sake of dumping XP.

On one hand, Microsoft is actively pushing the C++. The GoingNative conference was great and the talks were all fantastic. C++11 is similarly great and full of great features.

On the other hand, Microsoft is pushing C++11 far into the future for many of us developers. We would love to use the ranged based for loop, atomics, improved lambdas, and all that, but we can&#039;t dump 30% of our customers. It is just not realistic.

In addition, it is simply wrong for Microsoft to put such a burden on 3rd party developers. Had Microsoft started with Office, Windows Live, etc. (yes, I&#039;m aware that IE9 doesn&#039;t run on XP), we wouldn&#039;t need to be having this discussion at all.

Microsoft, do the Right Thing.]]></description>
		<content:encoded><![CDATA[<p>@MichealTK</p>
<p>XP is old. XP is crap. I wish XP were dead. But it isn&#8217;t. That&#8217;s the unfortunate truth.</p>
<p>What it comes down to is the blatant fact that Microsoft has yet to convince us that removing XP support was purely a technical decision. As seen from the workarounds available at <a href="http://tedwvc.wordpress.com" rel="nofollow">http://tedwvc.wordpress.com</a>, VS11 binaries *can* run on XP, albeit in a rather hacky/ugly manner. From the looks of it, it feels as if the entire decision was made by folks high up in the food chain just for the sake of dumping XP.</p>
<p>On one hand, Microsoft is actively pushing the C++. The GoingNative conference was great and the talks were all fantastic. C++11 is similarly great and full of great features.</p>
<p>On the other hand, Microsoft is pushing C++11 far into the future for many of us developers. We would love to use the ranged based for loop, atomics, improved lambdas, and all that, but we can&#8217;t dump 30% of our customers. It is just not realistic.</p>
<p>In addition, it is simply wrong for Microsoft to put such a burden on 3rd party developers. Had Microsoft started with Office, Windows Live, etc. (yes, I&#8217;m aware that IE9 doesn&#8217;t run on XP), we wouldn&#8217;t need to be having this discussion at all.</p>
<p>Microsoft, do the Right Thing.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: henrikvallgren				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5172</link>
		<dc:creator><![CDATA[henrikvallgren]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 13:47:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5172</guid>
					<description><![CDATA[@ MichaelTK: C++ a dead-declared language? By self-appointed gurus, I assume.

Personally, I care more about portability that standard this or that. Boost or OpenMP works on many platforms, as do OpenGL.

As a result, I&#039;ve always stayed away from DirectX, but it&#039;s interoperability with C++ AMP makes it very interesting. I&#039;m eagerly considering rewriting the graphics part to take advantage of that combination.]]></description>
		<content:encoded><![CDATA[<p>@ MichaelTK: C++ a dead-declared language? By self-appointed gurus, I assume.</p>
<p>Personally, I care more about portability that standard this or that. Boost or OpenMP works on many platforms, as do OpenGL.</p>
<p>As a result, I&#8217;ve always stayed away from DirectX, but it&#8217;s interoperability with C++ AMP makes it very interesting. I&#8217;m eagerly considering rewriting the graphics part to take advantage of that combination.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MichaelTK				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5171</link>
		<dc:creator><![CDATA[MichaelTK]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 12:32:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5171</guid>
					<description><![CDATA[What is all this Windows XP begging for? XP is dead. If your customers still use XP, so be it. Then they can&#039;t upgrade to your latest software or you can&#039;t upgrade to latest VS. So what, you were fine all the years before without VS11 what would you need it for just now? Obviously it can&#039;t be new features since they are mostly not XP compatible as well. It can&#039;t be C++11 support, since Intel Compiler 12.1 already does support a lot of it in Visual Studio 2010 (more than even VS11 supports as it is now). See it the other way. If Everyone endlessly supports XP, they it will never die. Backwards compat. is one of the biggest problems in software development and continually holding innovation back; without any obvious reason, all except some lazy people who think that using an 11 year old OS makes them cool ;)... Whenever I tried to use XP (in a Virtual Machine of course), it felt like medieval ages.]]></description>
		<content:encoded><![CDATA[<p>What is all this Windows XP begging for? XP is dead. If your customers still use XP, so be it. Then they can&#8217;t upgrade to your latest software or you can&#8217;t upgrade to latest VS. So what, you were fine all the years before without VS11 what would you need it for just now? Obviously it can&#8217;t be new features since they are mostly not XP compatible as well. It can&#8217;t be C++11 support, since Intel Compiler 12.1 already does support a lot of it in Visual Studio 2010 (more than even VS11 supports as it is now). See it the other way. If Everyone endlessly supports XP, they it will never die. Backwards compat. is one of the biggest problems in software development and continually holding innovation back; without any obvious reason, all except some lazy people who think that using an 11 year old OS makes them cool ;)&#8230; Whenever I tried to use XP (in a Virtual Machine of course), it felt like medieval ages.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Justin				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5170</link>
		<dc:creator><![CDATA[Justin]]></dc:creator>
		<pubDate>Tue, 10 Apr 2012 10:31:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5170</guid>
					<description><![CDATA[Herb, I will love you until the day I die if VS11 RTM will support XP :-)]]></description>
		<content:encoded><![CDATA[<p>Herb, I will love you until the day I die if VS11 RTM will support XP :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5155</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Mon, 09 Apr 2012 08:20:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5155</guid>
					<description><![CDATA[&quot;he has graciously agreed to come to the May 7-9 ISO C++ parallelism study group special meeting to present this to the committee members in detail and answer questions about await’s design and C# users’ experience with it in production code&quot;

C# async has yet to ship, of course. If you want experience reports about production code you might look at F#, which is where C# is getting the feature from and shipped with it in VS2010. Before that, apps with 100k users used the same feature in OCaml (which is where F# got the feature from).

&quot;There are several powerful ideas in other languages that could transfer well to C++, would improve rather than bloat the language, and aren’t in tension with “don’t pay for what you don’t use” performance, just like auto and lambdas and other features.&quot;

You might also consider variant types, pattern matching and type inference.]]></description>
		<content:encoded><![CDATA[<p>&#8220;he has graciously agreed to come to the May 7-9 ISO C++ parallelism study group special meeting to present this to the committee members in detail and answer questions about await’s design and C# users’ experience with it in production code&#8221;</p>
<p>C# async has yet to ship, of course. If you want experience reports about production code you might look at F#, which is where C# is getting the feature from and shipped with it in VS2010. Before that, apps with 100k users used the same feature in OCaml (which is where F# got the feature from).</p>
<p>&#8220;There are several powerful ideas in other languages that could transfer well to C++, would improve rather than bloat the language, and aren’t in tension with “don’t pay for what you don’t use” performance, just like auto and lambdas and other features.&#8221;</p>
<p>You might also consider variant types, pattern matching and type inference.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MichaelTK				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5148</link>
		<dc:creator><![CDATA[MichaelTK]]></dc:creator>
		<pubDate>Sun, 08 Apr 2012 13:56:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5148</guid>
					<description><![CDATA[PS: C++.AMP is a step in the right direction regarding parallel patterns, but unfortunately not in the ISO standard. If I were at the committee I would rather see to get a decent evolution of C++.AMP into the next C++ ISO standard... Herb was also talking about C++.AMP and distribution across clusters and heterogeneous computation environments. This is definitely nice to have but again, it must be done fast to be ahead of other languages and especially it needs to be in the standard.]]></description>
		<content:encoded><![CDATA[<p>PS: C++.AMP is a step in the right direction regarding parallel patterns, but unfortunately not in the ISO standard. If I were at the committee I would rather see to get a decent evolution of C++.AMP into the next C++ ISO standard&#8230; Herb was also talking about C++.AMP and distribution across clusters and heterogeneous computation environments. This is definitely nice to have but again, it must be done fast to be ahead of other languages and especially it needs to be in the standard.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MichaelTK				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5147</link>
		<dc:creator><![CDATA[MichaelTK]]></dc:creator>
		<pubDate>Sun, 08 Apr 2012 13:47:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5147</guid>
					<description><![CDATA[&#062; It would seem many major features that are now being zealously laid out in formal papers are feasible for C++2x at best?

This would be a hazard. I doubt that C++11 can cover for that long, since actually it has been due for 10 years already! C++11 is nothing new, it was the revival of a otherwise dead-declared language... 

What about taking complexity out of the language for making advancements easier while still allowing interaction with existing code. This could be implemented by a &quot;safe&quot; and &quot;unsafe&quot; modifier respectively for methods and classes. If the compiler defaults to &quot;safe&quot; then only &quot;unsafe&quot; is recognized and vice versa. In &quot;safe&quot; function one could only use the shiny new syntax which could also break backwards compatibility and in unsafe code, all C++11 features are available. 

The only reason why people would use C++11 as it is in 10 years is because of existing code bases. So C++ itself is in a good position to die how it has begun. That is, by introducing a new C++ derivative on top of C++, call it &quot;c++#&quot; or whatever, which allows full backward compatibility on demand but by default brings ALL the fancies, that are urgently needed, to the C++ world.

The current C++ focused cluster and high performance revival will fade out rather sooner than later. Embedded devices evolve at incredible pace, and thus I hardly see use for C++ in this segment in the mid/long-term. For clusters, other languages and frameworks like Stanfords PPL or things like &quot;Satin&quot;, already provide great performance while still hiding all the low level complexity behind a compiler. 

So please, don&#039;t bother us with C++2x thoughts. As much as I like C++, if I see all the shiny new languages with their great ideas and concepts, and the complexity parallelism brings on the table, C++ must not evolve, C++ must revolutionize if it wants to survive! 

Raw sequential performance doesn&#039;t cut it, if it is too complicated to efficiently work in a heterogeneous parallel environment (20% more sequential performance but 50% less grid utilization won&#039;t get you that far). What we need is efficient parallel patterns one can apply in a productive way. Only this paired with C++ sequential performance is a benefit in contrast to other languages.]]></description>
		<content:encoded><![CDATA[<p>&gt; It would seem many major features that are now being zealously laid out in formal papers are feasible for C++2x at best?</p>
<p>This would be a hazard. I doubt that C++11 can cover for that long, since actually it has been due for 10 years already! C++11 is nothing new, it was the revival of a otherwise dead-declared language&#8230; </p>
<p>What about taking complexity out of the language for making advancements easier while still allowing interaction with existing code. This could be implemented by a &#8220;safe&#8221; and &#8220;unsafe&#8221; modifier respectively for methods and classes. If the compiler defaults to &#8220;safe&#8221; then only &#8220;unsafe&#8221; is recognized and vice versa. In &#8220;safe&#8221; function one could only use the shiny new syntax which could also break backwards compatibility and in unsafe code, all C++11 features are available. </p>
<p>The only reason why people would use C++11 as it is in 10 years is because of existing code bases. So C++ itself is in a good position to die how it has begun. That is, by introducing a new C++ derivative on top of C++, call it &#8220;c++#&#8221; or whatever, which allows full backward compatibility on demand but by default brings ALL the fancies, that are urgently needed, to the C++ world.</p>
<p>The current C++ focused cluster and high performance revival will fade out rather sooner than later. Embedded devices evolve at incredible pace, and thus I hardly see use for C++ in this segment in the mid/long-term. For clusters, other languages and frameworks like Stanfords PPL or things like &#8220;Satin&#8221;, already provide great performance while still hiding all the low level complexity behind a compiler. </p>
<p>So please, don&#8217;t bother us with C++2x thoughts. As much as I like C++, if I see all the shiny new languages with their great ideas and concepts, and the complexity parallelism brings on the table, C++ must not evolve, C++ must revolutionize if it wants to survive! </p>
<p>Raw sequential performance doesn&#8217;t cut it, if it is too complicated to efficiently work in a heterogeneous parallel environment (20% more sequential performance but 50% less grid utilization won&#8217;t get you that far). What we need is efficient parallel patterns one can apply in a productive way. Only this paired with C++ sequential performance is a benefit in contrast to other languages.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David H. Braun				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5143</link>
		<dc:creator><![CDATA[David H. Braun]]></dc:creator>
		<pubDate>Sun, 08 Apr 2012 09:35:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5143</guid>
					<description><![CDATA[Going over to look at N3327 and N3228, and also seeing the long list of formal proposals (already) for the next standard, I&#039;m reminded of your earlier comment, Herb, that we could only expect one major new feature in the next standard. I would think &quot;await&quot; and related functionality would qualify as a major new feature. You&#039;re pretty gung-ho about it, and with good cause. It would seem many major features that are now being zealously laid out in formal papers are feasible for C++2x at best?  It is an arduous, grinding task you are engaged in on the Committee. :-)]]></description>
		<content:encoded><![CDATA[<p>Going over to look at N3327 and N3228, and also seeing the long list of formal proposals (already) for the next standard, I&#8217;m reminded of your earlier comment, Herb, that we could only expect one major new feature in the next standard. I would think &#8220;await&#8221; and related functionality would qualify as a major new feature. You&#8217;re pretty gung-ho about it, and with good cause. It would seem many major features that are now being zealously laid out in formal papers are feasible for C++2x at best?  It is an arduous, grinding task you are engaged in on the Committee. :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David H. Braun				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5142</link>
		<dc:creator><![CDATA[David H. Braun]]></dc:creator>
		<pubDate>Sun, 08 Apr 2012 09:09:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5142</guid>
					<description><![CDATA[After my last comment, I realized there was a higher resolution video available, besides the illegible default resolution. The higher resolution is legible, although not comfortable to read. Still, legible is legible, meaning the information can be had if one selects the highest resolution and sits close to the screen. I still think the rest of my comment applies and suggests desirable improvements.]]></description>
		<content:encoded><![CDATA[<p>After my last comment, I realized there was a higher resolution video available, besides the illegible default resolution. The higher resolution is legible, although not comfortable to read. Still, legible is legible, meaning the information can be had if one selects the highest resolution and sits close to the screen. I still think the rest of my comment applies and suggests desirable improvements.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David H. Braun				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5141</link>
		<dc:creator><![CDATA[David H. Braun]]></dc:creator>
		<pubDate>Sun, 08 Apr 2012 07:02:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5141</guid>
					<description><![CDATA[The subject of the channel 9 video is interesting, but, unfortunately, the text on the screen is almost completely illegible. All you get from that almost-big-enough-to-read overhead screen is a general &quot;sense&quot; of what the speaker is doing. Everything else has to be gotten through carefully listening to every word the speaker says. Little content would be lost if it was a mere audio broadcast. Unfortunately, he isn&#039;t speaking like he&#039;s on radio, but as though he expects the viewer can see everything he sees, which means crucial information is *lost* in transmission.

It would be a good idea if these broadcasts had two simultaneous views the viewer could toggle between -- or even watch side-by-side -- one a broad view of the speaker, the other a direct transmission of the computer screen he is projecting to his audience. That wouldn&#039;t be significantly any more difficult than what you&#039;re already doing -- it just needs to be set up that way.

Several years ago, I used to watch Sun Microsystems (the late) presentations that were much more sophisticated, having all sorts of related &quot;resources&quot; that could be accessed simultaneously while watching the central presentation. Having something like that would be even better than having two screen views. But, as it is, not even being able to read code that is in plain view -- but not legible -- is frustrating. Instinctively, I find myself squinting, like I need glasses, even though I know it isn&#039;t going to help a bit. :-)]]></description>
		<content:encoded><![CDATA[<p>The subject of the channel 9 video is interesting, but, unfortunately, the text on the screen is almost completely illegible. All you get from that almost-big-enough-to-read overhead screen is a general &#8220;sense&#8221; of what the speaker is doing. Everything else has to be gotten through carefully listening to every word the speaker says. Little content would be lost if it was a mere audio broadcast. Unfortunately, he isn&#8217;t speaking like he&#8217;s on radio, but as though he expects the viewer can see everything he sees, which means crucial information is *lost* in transmission.</p>
<p>It would be a good idea if these broadcasts had two simultaneous views the viewer could toggle between &#8212; or even watch side-by-side &#8212; one a broad view of the speaker, the other a direct transmission of the computer screen he is projecting to his audience. That wouldn&#8217;t be significantly any more difficult than what you&#8217;re already doing &#8212; it just needs to be set up that way.</p>
<p>Several years ago, I used to watch Sun Microsystems (the late) presentations that were much more sophisticated, having all sorts of related &#8220;resources&#8221; that could be accessed simultaneously while watching the central presentation. Having something like that would be even better than having two screen views. But, as it is, not even being able to read code that is in plain view &#8212; but not legible &#8212; is frustrating. Instinctively, I find myself squinting, like I need glasses, even though I know it isn&#8217;t going to help a bit. :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: What we really want				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5139</link>
		<dc:creator><![CDATA[What we really want]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 19:13:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5139</guid>
					<description><![CDATA[What we really want is XP SP3 support in Visual Studio 11. I think it is far more important than await. We can live without await. We (or at least many of us) can&#039;t live without our XP customers.

It is unacceptable that no comment has been made on this so far. And hiding the XP support idea from the UserVoice &quot;Hot&quot; list is just plain sad.

http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2287078-allow-mfc-11-to-run-in-xp-sp3]]></description>
		<content:encoded><![CDATA[<p>What we really want is XP SP3 support in Visual Studio 11. I think it is far more important than await. We can live without await. We (or at least many of us) can&#8217;t live without our XP customers.</p>
<p>It is unacceptable that no comment has been made on this so far. And hiding the XP support idea from the UserVoice &#8220;Hot&#8221; list is just plain sad.</p>
<p><a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2287078-allow-mfc-11-to-run-in-xp-sp3" rel="nofollow">http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2287078-allow-mfc-11-to-run-in-xp-sp3</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: petke				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5138</link>
		<dc:creator><![CDATA[petke]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 17:05:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5138</guid>
					<description><![CDATA[The sounds good. I wish we could get &quot;then&quot; on some fast track so we don&#039;t have to wait years for it. I could use it now.]]></description>
		<content:encoded><![CDATA[<p>The sounds good. I wish we could get &#8220;then&#8221; on some fast track so we don&#8217;t have to wait years for it. I could use it now.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MichaelTK				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5137</link>
		<dc:creator><![CDATA[MichaelTK]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 15:59:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5137</guid>
					<description><![CDATA[@Herb: If we are talking about pulling from other languages... What about the following:

1) Mixin templates from D
2) Transitive const &#038; immutability for data and functions
3) &quot;Pure&quot; modifier for functions
4) GC classes from C++.CLI (that is, a new modifier for struct/class which restricts pointer manipulation without! introducing a new pointer/allocation syntax and in turn allows for safe&#038;generational GC. I know your other post about GCs here but I don&#039;t think shared_ptr is the way to go. Its is very hard to get right&#038;efficient and inherently error prone. So a real safe, reliable GC would do the job for most of the time...)
5) Named parameters
6) Anonymous types like &quot;new { x = &#039;Hello World!&#039;, y = 23 }&quot;
7) Reflection, possibly based on compiler AST like the ones coming with Roslyn
8) Infix methods from Scala
9) Infinitely more ;)]]></description>
		<content:encoded><![CDATA[<p>@Herb: If we are talking about pulling from other languages&#8230; What about the following:</p>
<p>1) Mixin templates from D<br />
2) Transitive const &amp; immutability for data and functions<br />
3) &#8220;Pure&#8221; modifier for functions<br />
4) GC classes from C++.CLI (that is, a new modifier for struct/class which restricts pointer manipulation without! introducing a new pointer/allocation syntax and in turn allows for safe&amp;generational GC. I know your other post about GCs here but I don&#8217;t think shared_ptr is the way to go. Its is very hard to get right&amp;efficient and inherently error prone. So a real safe, reliable GC would do the job for most of the time&#8230;)<br />
5) Named parameters<br />
6) Anonymous types like &#8220;new { x = &#8216;Hello World!&#8217;, y = 23 }&#8221;<br />
7) Reflection, possibly based on compiler AST like the ones coming with Roslyn<br />
8) Infix methods from Scala<br />
9) Infinitely more ;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5134</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 15:44:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5134</guid>
					<description><![CDATA[Yes, it&#039;s N3327 and N3228.

BTW, C# isn&#039;t the only language I&#039;m personally actively trying to get ISO C++ to pull from -- I also solicited a proposal from Andrei and Walter proposing D &quot;static if&quot; for C++ and they too graciously agreed to write it up. There are several powerful ideas in other languages that could transfer well to C++, would improve rather than bloat the language, and aren&#039;t in tension with &quot;don&#039;t pay for what you don&#039;t use&quot; performance, just like auto and lambdas and other features.]]></description>
		<content:encoded><![CDATA[<p>Yes, it&#8217;s N3327 and N3228.</p>
<p>BTW, C# isn&#8217;t the only language I&#8217;m personally actively trying to get ISO C++ to pull from &#8212; I also solicited a proposal from Andrei and Walter proposing D &#8220;static if&#8221; for C++ and they too graciously agreed to write it up. There are several powerful ideas in other languages that could transfer well to C++, would improve rather than bloat the language, and aren&#8217;t in tension with &#8220;don&#8217;t pay for what you don&#8217;t use&#8221; performance, just like auto and lambdas and other features.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Wojciech Cierpucha				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5131</link>
		<dc:creator><![CDATA[Wojciech Cierpucha]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 15:18:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5131</guid>
					<description><![CDATA[Tom: take a look at N3327 and N3328 from http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/ - I&#039;ve only skimmed through those two papers but they both contain .then() on std::future.]]></description>
		<content:encoded><![CDATA[<p>Tom: take a look at N3327 and N3328 from <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/" rel="nofollow">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/</a> &#8211; I&#8217;ve only skimmed through those two papers but they both contain .then() on std::future.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Guest				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5129</link>
		<dc:creator><![CDATA[Guest]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 12:37:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5129</guid>
					<description><![CDATA[Maybe something like this ?
http://research.microsoft.com/apps/pubs/default.aspx?id=158164]]></description>
		<content:encoded><![CDATA[<p>Maybe something like this ?<br />
<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=158164" rel="nofollow">http://research.microsoft.com/apps/pubs/default.aspx?id=158164</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom Kirby-Green				</title>
				<link>https://herbsutter.com/2012/04/06/we-want-await-a-c-talk-thats-applicable-to-c/#comment-5127</link>
		<dc:creator><![CDATA[Tom Kirby-Green]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 10:17:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1450#comment-5127</guid>
					<description><![CDATA[Interesting post Herb, would it be possible to read the actual text of the proposal you made to add &#039;then&#039; to &#039;future&#039; ? 
Kind regards,
Tom]]></description>
		<content:encoded><![CDATA[<p>Interesting post Herb, would it be possible to read the actual text of the proposal you made to add &#8216;then&#8217; to &#8216;future&#8217; ?<br />
Kind regards,<br />
Tom</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
