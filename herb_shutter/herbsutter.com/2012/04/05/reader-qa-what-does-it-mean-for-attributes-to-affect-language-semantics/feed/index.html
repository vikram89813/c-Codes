<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Reader Q&#038;A: What does it mean for [[attributes]] to affect language semantics?	</title>
	<atom:link href="https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Ben Voigt				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5190</link>
		<dc:creator><![CDATA[Ben Voigt]]></dc:creator>
		<pubDate>Wed, 11 Apr 2012 14:50:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5190</guid>
					<description><![CDATA[@jmckesson: You say &quot;What&#039;s undefined behavior on one compiler *is* defined behavior on another.&quot; as if that&#039;s a toxic situation.  But in fact, this is true of MOST undefined behavior.  Because there is no restriction on what a compiler may do when it encounters code which formally has undefined behavior, the compiler may define implementation-specific consistent behavior.  The code is still non-portable, even to new compiler versions, because it evokes undefined behavior, but some compilers act predictably.  In that sense, there&#039;s no difference between [[noreturn]] and say misuse of reinterpret_cast on function pointers.]]></description>
		<content:encoded><![CDATA[<p>@jmckesson: You say &#8220;What&#8217;s undefined behavior on one compiler *is* defined behavior on another.&#8221; as if that&#8217;s a toxic situation.  But in fact, this is true of MOST undefined behavior.  Because there is no restriction on what a compiler may do when it encounters code which formally has undefined behavior, the compiler may define implementation-specific consistent behavior.  The code is still non-portable, even to new compiler versions, because it evokes undefined behavior, but some compilers act predictably.  In that sense, there&#8217;s no difference between [[noreturn]] and say misuse of reinterpret_cast on function pointers.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5135</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 15:51:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5135</guid>
					<description><![CDATA[&quot;If the compiler doesn’t implement [[noreturn]], then cases 3 and 4 are handled like 1 and 2 respectively.&quot; And that&#039;s the problem. What is undefined behavior on one compiler *is* defined behavior on another.

You&#039;re focused on the functionality of [[noreturn]] (which is fine) and not the fact that it isn&#039;t a *keyword* (which is the problem).

Attributes should not affect the *language*. If we had an attribute for dllexport, it would be used for exactly that: exporting functions in DLLs. And while this touches the compiler, it doesn&#039;t touch the C++ part of the compiler; it just modifies how the compiler generates code a bit. The language itself works the same whether the compiler recognizes [[dllexport]] or not.]]></description>
		<content:encoded><![CDATA[<p>&#8220;If the compiler doesn’t implement [[noreturn]], then cases 3 and 4 are handled like 1 and 2 respectively.&#8221; And that&#8217;s the problem. What is undefined behavior on one compiler *is* defined behavior on another.</p>
<p>You&#8217;re focused on the functionality of [[noreturn]] (which is fine) and not the fact that it isn&#8217;t a *keyword* (which is the problem).</p>
<p>Attributes should not affect the *language*. If we had an attribute for dllexport, it would be used for exactly that: exporting functions in DLLs. And while this touches the compiler, it doesn&#8217;t touch the C++ part of the compiler; it just modifies how the compiler generates code a bit. The language itself works the same whether the compiler recognizes [[dllexport]] or not.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Stop arguing and ADAPT! &#171; JRFibonacci&#039;s blog: partnering with reality				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5116</link>
		<dc:creator><![CDATA[Stop arguing and ADAPT! &#171; JRFibonacci&#039;s blog: partnering with reality]]></dc:creator>
		<pubDate>Fri, 06 Apr 2012 18:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5116</guid>
					<description><![CDATA[[...] Reader Q&#038;A: What does it mean for [[attributes]] to affect language semantics? (herbsutter.com) [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Reader Q&amp;A: What does it mean for [[attributes]] to affect language semantics? (herbsutter.com) [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5115</link>
		<dc:creator><![CDATA[Mike]]></dc:creator>
		<pubDate>Fri, 06 Apr 2012 17:57:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5115</guid>
					<description><![CDATA[&quot;There is a reasonable fear that attributes will be used to create language dialects&quot;

Who are we trying to kid here?  In what sense do we not _already_ have C++ dialects?

Are we so indoctrinated that we no longer see all of the #ifdef&#039;s and #define&#039;s required to make &quot;normal&quot; code truly portable (I&#039;m looking at you, __decl_spec(dllexport)!)?  

This entire conversation makes no sense to me.  I thought [[attributes]] was an attempt to normalize these extensions as a syntactic construct so we stop denying the reality that is vendor-specific extensions.  Or am I totally misunderstanding the purpose?]]></description>
		<content:encoded><![CDATA[<p>&#8220;There is a reasonable fear that attributes will be used to create language dialects&#8221;</p>
<p>Who are we trying to kid here?  In what sense do we not _already_ have C++ dialects?</p>
<p>Are we so indoctrinated that we no longer see all of the #ifdef&#8217;s and #define&#8217;s required to make &#8220;normal&#8221; code truly portable (I&#8217;m looking at you, __decl_spec(dllexport)!)?  </p>
<p>This entire conversation makes no sense to me.  I thought [[attributes]] was an attempt to normalize these extensions as a syntactic construct so we stop denying the reality that is vendor-specific extensions.  Or am I totally misunderstanding the purpose?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5111</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 06 Apr 2012 00:53:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5111</guid>
					<description><![CDATA[@JCAB: As I mentioned earlier, I was against having attributes at all. :) But to answer what I might consider legitimate uses of them, things that really are whitespace to the C++ language and C++ compiler -- I wouldn&#039;t be opposed to using them for doc-gen type comments, or other similar annotations that the compiler may pass along for other tools to absorb but that the compiler itself doesn&#039;t make use of.]]></description>
		<content:encoded><![CDATA[<p>@JCAB: As I mentioned earlier, I was against having attributes at all. :) But to answer what I might consider legitimate uses of them, things that really are whitespace to the C++ language and C++ compiler &#8212; I wouldn&#8217;t be opposed to using them for doc-gen type comments, or other similar annotations that the compiler may pass along for other tools to absorb but that the compiler itself doesn&#8217;t make use of.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JCAB				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5109</link>
		<dc:creator><![CDATA[JCAB]]></dc:creator>
		<pubDate>Thu, 05 Apr 2012 22:47:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5109</guid>
					<description><![CDATA[@Herb: So if you had to summarize the core of what you&#039;re saying, would you be able to say that [[noreturn]] is a semantically-meaningful annotation for functions, pretty much in the same way as const is a semantically-meaningful annotation for variables?

I suspect my answer to that is &quot;no&quot;. The reason being that const becomes a tangible element in the language at a functional level. Its presence affects types and overloading, for instance. Whereas [[noreturn]] does no such thing. It only affects the underlying code generation, and the possibility of getting diagnostics (always warnings, not errors) resulting from the availability of more information to the compiler (the programmer said this).

In contrast, final and override can very much acquire real essence in the program, like const does. It can affect correctness. You very much want errors when they are mis-used or mis-introduced.

If you could describe an example of an attribute that you think really should be an attribute, and why, I think it would help me to understand the distinction between &quot;has semantic meaning&quot; and &quot;doesn&#039;t have semantic meaning&quot; as you see it. I can think of candidates...

__restrict: no (same reasons as const) [that&#039;s __restrict in the way VS2010, for instance, supports it -- I don&#039;t think it got into C++11, right?]
dllimport: I&#039;m uncertain. It does seem to change the compiler&#039;s behavior in some ways (different calling method?), affecting optmizations, and that&#039;s your argument with noreturn, but in this case it&#039;s more subtle.
__forceinline: also directly related to optimizations.
__assume: could this be an attribute? In any case, also optimizations.
put_this_variable_in_the_fast_memory_bank: You could think of this sort of target-specific desired behaviors as useful. But there is (some) semantic meaning.
bigendian: Wouldn&#039;t it be nice to get endianness handled, sometimes? (as an Xbox 360 developers, I say yes). But it changes the meaning of the data (say, in the face of reinterpret_cast).

However, in general, it seems to me that, if it doesn&#039;t change the semantic meaning of the code in any way, it&#039;s hard to consider an attribute useful in any way.

On the other hand, I do think that some cases of limited semantic meaning useful. Now we just need to delineate the subgroup of semantic meaning changes that are acceptable to tolerate in something that attributes. For instance, if adding or removing an attribute can make compilation of a correct program (correct as of its intent, not the letter of the standard) fail, that&#039;s probably a nono. But if adding an attribute to an incorrect (but legal) program causes the compiler to issue warnings (or maybe even errors, in some cases, maybe), I don&#039;t think we should discount the usefulness of the attribute.

In the case of [[noreturn]], if we want to be thorough, we have four possible scenarios:

1- The function is meant to return, and doesn&#039;t have [[noreturn]]
2- The function isn&#039;t meant to return, and doesn&#039;t have [[noreturn]]
3- The function is meant to return, and has [[noreturn]]
4- The function isn&#039;t meant to return, and has [[noreturn]]

And we need to describe the behavior of a conforming compiler that either implements or ignores this attribute.

If we can do this satisfactorily, then I&#039;d be fully satisfied with this as an attribute. Let&#039;s see:

1- This is the trivial case.
2- The compiler might or might not have enough information and smarts to display a warning like &quot;unreachable code detected&quot; if the caller does anything after calling the function. Same when compiling the function, it might want to emit a compilation warning if it detects that the function can&#039;t return, to tell the programmer that the annotation should be added.
3- The compiler is free to assume that the function doesn&#039;t return and optimize at the call site, and it&#039;s required to fail compilation or execution of the function. There are some cases that can only be detected at runtime, and it&#039;s appropriate to substitute the return instruction with an exception throw or similar, to catch it at runtime.
4- The compiler is free to assume that the function doesn&#039;t return and optimize at the call site, and the function must compile without errors or warnings. If the compiler can&#039;t determine that the function can&#039;t possibly return, it must substitute the return instruction with an exception throw or similar, to catch any leftover programming errors at runtime.

If the compiler doesn&#039;t implement [[noreturn]], then cases 3 and 4 are handled like 1 and 2 respectively.

This is all a bit of off-the-hip shooting, but I can&#039;t help to feel that there&#039;s a perfectly reasonable and tight definition for [[noreturn]] that works reasonably well with some equally reasonable definition of how a compiler must deal with unknown attributes. And the key here is _that_ definition of what an attribute is and how it can be ignored. &quot;has no semantic meaning and can be ignored&quot; is way too restrictive, and I do suspect is next to useless. &quot;has _limited_ semantic meaning and can be ignored&quot;, with an appropriate definition of &quot;limited&quot; in this context can be very useful in practice.

Note also that there are at least two different &quot;kinds&quot; of annotations that I can think of. General-purpose annotations (ignore is ok, if you must, like [[noreturn]]) and special-purpose annotations (their handling as specified is required, or else the compiler must 

I hope I&#039;m making sense :).]]></description>
		<content:encoded><![CDATA[<p>@Herb: So if you had to summarize the core of what you&#8217;re saying, would you be able to say that [[noreturn]] is a semantically-meaningful annotation for functions, pretty much in the same way as const is a semantically-meaningful annotation for variables?</p>
<p>I suspect my answer to that is &#8220;no&#8221;. The reason being that const becomes a tangible element in the language at a functional level. Its presence affects types and overloading, for instance. Whereas [[noreturn]] does no such thing. It only affects the underlying code generation, and the possibility of getting diagnostics (always warnings, not errors) resulting from the availability of more information to the compiler (the programmer said this).</p>
<p>In contrast, final and override can very much acquire real essence in the program, like const does. It can affect correctness. You very much want errors when they are mis-used or mis-introduced.</p>
<p>If you could describe an example of an attribute that you think really should be an attribute, and why, I think it would help me to understand the distinction between &#8220;has semantic meaning&#8221; and &#8220;doesn&#8217;t have semantic meaning&#8221; as you see it. I can think of candidates&#8230;</p>
<p>__restrict: no (same reasons as const) [that&#8217;s __restrict in the way VS2010, for instance, supports it &#8212; I don&#8217;t think it got into C++11, right?]<br />
dllimport: I&#8217;m uncertain. It does seem to change the compiler&#8217;s behavior in some ways (different calling method?), affecting optmizations, and that&#8217;s your argument with noreturn, but in this case it&#8217;s more subtle.<br />
__forceinline: also directly related to optimizations.<br />
__assume: could this be an attribute? In any case, also optimizations.<br />
put_this_variable_in_the_fast_memory_bank: You could think of this sort of target-specific desired behaviors as useful. But there is (some) semantic meaning.<br />
bigendian: Wouldn&#8217;t it be nice to get endianness handled, sometimes? (as an Xbox 360 developers, I say yes). But it changes the meaning of the data (say, in the face of reinterpret_cast).</p>
<p>However, in general, it seems to me that, if it doesn&#8217;t change the semantic meaning of the code in any way, it&#8217;s hard to consider an attribute useful in any way.</p>
<p>On the other hand, I do think that some cases of limited semantic meaning useful. Now we just need to delineate the subgroup of semantic meaning changes that are acceptable to tolerate in something that attributes. For instance, if adding or removing an attribute can make compilation of a correct program (correct as of its intent, not the letter of the standard) fail, that&#8217;s probably a nono. But if adding an attribute to an incorrect (but legal) program causes the compiler to issue warnings (or maybe even errors, in some cases, maybe), I don&#8217;t think we should discount the usefulness of the attribute.</p>
<p>In the case of [[noreturn]], if we want to be thorough, we have four possible scenarios:</p>
<p>1- The function is meant to return, and doesn&#8217;t have [[noreturn]]<br />
2- The function isn&#8217;t meant to return, and doesn&#8217;t have [[noreturn]]<br />
3- The function is meant to return, and has [[noreturn]]<br />
4- The function isn&#8217;t meant to return, and has [[noreturn]]</p>
<p>And we need to describe the behavior of a conforming compiler that either implements or ignores this attribute.</p>
<p>If we can do this satisfactorily, then I&#8217;d be fully satisfied with this as an attribute. Let&#8217;s see:</p>
<p>1- This is the trivial case.<br />
2- The compiler might or might not have enough information and smarts to display a warning like &#8220;unreachable code detected&#8221; if the caller does anything after calling the function. Same when compiling the function, it might want to emit a compilation warning if it detects that the function can&#8217;t return, to tell the programmer that the annotation should be added.<br />
3- The compiler is free to assume that the function doesn&#8217;t return and optimize at the call site, and it&#8217;s required to fail compilation or execution of the function. There are some cases that can only be detected at runtime, and it&#8217;s appropriate to substitute the return instruction with an exception throw or similar, to catch it at runtime.<br />
4- The compiler is free to assume that the function doesn&#8217;t return and optimize at the call site, and the function must compile without errors or warnings. If the compiler can&#8217;t determine that the function can&#8217;t possibly return, it must substitute the return instruction with an exception throw or similar, to catch any leftover programming errors at runtime.</p>
<p>If the compiler doesn&#8217;t implement [[noreturn]], then cases 3 and 4 are handled like 1 and 2 respectively.</p>
<p>This is all a bit of off-the-hip shooting, but I can&#8217;t help to feel that there&#8217;s a perfectly reasonable and tight definition for [[noreturn]] that works reasonably well with some equally reasonable definition of how a compiler must deal with unknown attributes. And the key here is _that_ definition of what an attribute is and how it can be ignored. &#8220;has no semantic meaning and can be ignored&#8221; is way too restrictive, and I do suspect is next to useless. &#8220;has _limited_ semantic meaning and can be ignored&#8221;, with an appropriate definition of &#8220;limited&#8221; in this context can be very useful in practice.</p>
<p>Note also that there are at least two different &#8220;kinds&#8221; of annotations that I can think of. General-purpose annotations (ignore is ok, if you must, like [[noreturn]]) and special-purpose annotations (their handling as specified is required, or else the compiler must </p>
<p>I hope I&#8217;m making sense :).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5108</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Thu, 05 Apr 2012 21:59:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5108</guid>
					<description><![CDATA[&quot;I don’t think that [[noreturn]] meets the bar set by the weak view, because it does more than just cause programs to fail to compile.&quot;

What&#039;s interesting about this is that the [[carries_dependency]] part of the spec carries this notation: The carries_dependency attribute does not change the meaning of the program, but may result in
generation of more efficient code.&quot; Conspicuously, [[noreturn]] *does not* have that note.

This is an interesting argument. It explains why `alignas` is a keyword and not an attribute (besides the fact that it needs an argument, which I don&#039;t think attribute syntax allows). Because a compiler should not be allowed to silently ignore it. If it doesn&#039;t support the specified alignment (or even user-defined alignment), then compilation *must* fail.

After all, you didn&#039;t write that `alignas` statement for your health; you did t because you wrote some code that will *fail* without that statement. If the compiler cannot execute the `alignas` directive, then the compiler *cannot* compile your code.

I&#039;m much more inclined to the use of context-specific keywords than stuff like attributes in these cases.]]></description>
		<content:encoded><![CDATA[<p>&#8220;I don’t think that [[noreturn]] meets the bar set by the weak view, because it does more than just cause programs to fail to compile.&#8221;</p>
<p>What&#8217;s interesting about this is that the [[carries_dependency]] part of the spec carries this notation: The carries_dependency attribute does not change the meaning of the program, but may result in<br />
generation of more efficient code.&#8221; Conspicuously, [[noreturn]] *does not* have that note.</p>
<p>This is an interesting argument. It explains why `alignas` is a keyword and not an attribute (besides the fact that it needs an argument, which I don&#8217;t think attribute syntax allows). Because a compiler should not be allowed to silently ignore it. If it doesn&#8217;t support the specified alignment (or even user-defined alignment), then compilation *must* fail.</p>
<p>After all, you didn&#8217;t write that `alignas` statement for your health; you did t because you wrote some code that will *fail* without that statement. If the compiler cannot execute the `alignas` directive, then the compiler *cannot* compile your code.</p>
<p>I&#8217;m much more inclined to the use of context-specific keywords than stuff like attributes in these cases.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5107</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 05 Apr 2012 21:01:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5107</guid>
					<description><![CDATA[@Olaf: See above -- because what I&#039;m calling the &quot;weak&quot; view prevailed, and people felt it fit the weak view, and those of us who disagreed decided not to be disagreeable and just live with it because it&#039;ll be so rarely used. I&#039;m speaking up about it, not to try to fix it, but to try to discourage doing any more of the same. :)]]></description>
		<content:encoded><![CDATA[<p>@Olaf: See above &#8212; because what I&#8217;m calling the &#8220;weak&#8221; view prevailed, and people felt it fit the weak view, and those of us who disagreed decided not to be disagreeable and just live with it because it&#8217;ll be so rarely used. I&#8217;m speaking up about it, not to try to fix it, but to try to discourage doing any more of the same. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2012/04/05/reader-qa-what-does-it-mean-for-attributes-to-affect-language-semantics/#comment-5105</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Thu, 05 Apr 2012 20:56:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1442#comment-5105</guid>
					<description><![CDATA[So why wasn&#039;t noreturn changed to a keyword? What were the arguments against it?]]></description>
		<content:encoded><![CDATA[<p>So why wasn&#8217;t noreturn changed to a keyword? What were the arguments against it?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
