<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Reader Q&#038;A: auto and expression templates	</title>
	<atom:link href="https://herbsutter.com/2012/04/03/reader-qa/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2012/04/03/reader-qa/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Radics Péter				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-12036</link>
		<dc:creator><![CDATA[Radics Péter]]></dc:creator>
		<pubDate>Tue, 23 Jul 2013 08:28:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-12036</guid>
					<description><![CDATA[I think it would be better to have something like &#039;using auto = my_preferred_auto_type;&#039; instead of &#039;my_preferred_auto_type operator auto();&#039; to avoid code duplication and to keep all the conversion operators look the same (as in, no return type specified). Although my first idea was also operator auto when I first encountered this problem, so from the discoverability point of view it is probably better :)]]></description>
		<content:encoded><![CDATA[<p>I think it would be better to have something like &#8216;using auto = my_preferred_auto_type;&#8217; instead of &#8216;my_preferred_auto_type operator auto();&#8217; to avoid code duplication and to keep all the conversion operators look the same (as in, no return type specified). Although my first idea was also operator auto when I first encountered this problem, so from the discoverability point of view it is probably better :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chip				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5392</link>
		<dc:creator><![CDATA[Chip]]></dc:creator>
		<pubDate>Mon, 30 Apr 2012 16:36:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5392</guid>
					<description><![CDATA[@Ivan has a good question.  Why make the only cycle ten years long?]]></description>
		<content:encoded><![CDATA[<p>@Ivan has a good question.  Why make the only cycle ten years long?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Winter				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5164</link>
		<dc:creator><![CDATA[Michael Winter]]></dc:creator>
		<pubDate>Mon, 09 Apr 2012 18:37:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5164</guid>
					<description><![CDATA[Is there any reason why changing the definition of &quot;operator string() const&quot; to &quot;operator string() &#038;&#038;&quot;, would not work? Since that doesn&#039;t seem to have been brought up, I&#039;m guessing it&#039;s for an obvious reason that I&#039;ve just missed, aside from &quot;most current compilers don&#039;t support &#039;rvalue references to *this&#039; &quot;.

It breaks type-deduction, which is unfortunate, but it seemingly prevents accidental undefined behavior, which is nice.

Also, clang complains about &quot;operator string() const &#038;&#038;&quot; if the type of the object isn&#039;t itself const, is that a defect in clang (or at least the random snapshot I happen to have)?]]></description>
		<content:encoded><![CDATA[<p>Is there any reason why changing the definition of &#8220;operator string() const&#8221; to &#8220;operator string() &amp;&amp;&#8221;, would not work? Since that doesn&#8217;t seem to have been brought up, I&#8217;m guessing it&#8217;s for an obvious reason that I&#8217;ve just missed, aside from &#8220;most current compilers don&#8217;t support &#8216;rvalue references to *this&#8217; &#8220;.</p>
<p>It breaks type-deduction, which is unfortunate, but it seemingly prevents accidental undefined behavior, which is nice.</p>
<p>Also, clang complains about &#8220;operator string() const &amp;&amp;&#8221; if the type of the object isn&#8217;t itself const, is that a defect in clang (or at least the random snapshot I happen to have)?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Motti Lanzkron				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5140</link>
		<dc:creator><![CDATA[Motti Lanzkron]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 20:11:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5140</guid>
					<description><![CDATA[@Nicol Perhaps I gave the wrong impression when I said &quot;opt out&quot;, obviously you need a type for &quot;auto&quot; to deduce, my suggestion (as described in the post linked to above) was to have operator auto have a return type.

e.g. 

    string operator auto() const 
    {
        return stringify();
    }]]></description>
		<content:encoded><![CDATA[<p>@Nicol Perhaps I gave the wrong impression when I said &#8220;opt out&#8221;, obviously you need a type for &#8220;auto&#8221; to deduce, my suggestion (as described in the post linked to above) was to have operator auto have a return type.</p>
<p>e.g. </p>
<p>    string operator auto() const<br />
    {<br />
        return stringify();<br />
    }</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Nicol Bolas				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5136</link>
		<dc:creator><![CDATA[Nicol Bolas]]></dc:creator>
		<pubDate>Sat, 07 Apr 2012 15:53:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5136</guid>
					<description><![CDATA[@Motti: There is a difference between &quot;opt-out of type inference&quot; and &quot;*change* the type inferred.&quot; You asked for the former, and what I suggested was the latter.

An `operator auto()` cannot return a type, since types in C++ are not things you can &quot;compute&quot; without template metaprogramming. If you want to change what type is inferred, then you need to have some kind of construct that resolves to an actual type.]]></description>
		<content:encoded><![CDATA[<p>@Motti: There is a difference between &#8220;opt-out of type inference&#8221; and &#8220;*change* the type inferred.&#8221; You asked for the former, and what I suggested was the latter.</p>
<p>An `operator auto()` cannot return a type, since types in C++ are not things you can &#8220;compute&#8221; without template metaprogramming. If you want to change what type is inferred, then you need to have some kind of construct that resolves to an actual type.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5098</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Thu, 05 Apr 2012 12:56:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5098</guid>
					<description><![CDATA[Why cant we gat those small things before 2017? I mean I know it is an ISO and all that, but tbh I dont get why you  cant you just standardize &quot;quickfixes&quot; like every  2 y or something.]]></description>
		<content:encoded><![CDATA[<p>Why cant we gat those small things before 2017? I mean I know it is an ISO and all that, but tbh I dont get why you  cant you just standardize &#8220;quickfixes&#8221; like every  2 y or something.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Motti Lanzkron				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5089</link>
		<dc:creator><![CDATA[Motti Lanzkron]]></dc:creator>
		<pubDate>Wed, 04 Apr 2012 19:10:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5089</guid>
					<description><![CDATA[@jmckesson that would not be *better*, it would be exactly what I suggested.]]></description>
		<content:encoded><![CDATA[<p>@jmckesson that would not be *better*, it would be exactly what I suggested.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ld				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5069</link>
		<dc:creator><![CDATA[Ld]]></dc:creator>
		<pubDate>Wed, 04 Apr 2012 03:24:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5069</guid>
					<description><![CDATA[auto can (and will) indeed break C++03 expression templates, but with perfect-forwarding it&#039;s now possible to write expression templates that properly &#039;swallow&#039; temporaries such that they&#039;re safe in the face of auto. I.e. in auto tree = a + std::string { &quot;foo&quot; } + c; the tree object would hold a reference to a, an std::string object with value &quot;foo&quot;, and a reference to c. This does mean that with something like auto more_tree = (std::string { &quot;foo&quot; } + a) + &quot;bar&quot;; there are moves (from the object with value &quot;foo&quot; in the temporary tree on the lhs of the last operator+ to the new object with value &quot;foo&quot; inside more_tree) where previously there were just some more references being created, which could be costly for a type where moves are effectively copies. But that&#039;s somewhat premature, and the C++03 really was unsafe to begin with (the private type could already be accessed, and thus unsafely stored, through function template template).]]></description>
		<content:encoded><![CDATA[<p>auto can (and will) indeed break C++03 expression templates, but with perfect-forwarding it&#8217;s now possible to write expression templates that properly &#8216;swallow&#8217; temporaries such that they&#8217;re safe in the face of auto. I.e. in auto tree = a + std::string { &#8220;foo&#8221; } + c; the tree object would hold a reference to a, an std::string object with value &#8220;foo&#8221;, and a reference to c. This does mean that with something like auto more_tree = (std::string { &#8220;foo&#8221; } + a) + &#8220;bar&#8221;; there are moves (from the object with value &#8220;foo&#8221; in the temporary tree on the lhs of the last operator+ to the new object with value &#8220;foo&#8221; inside more_tree) where previously there were just some more references being created, which could be costly for a type where moves are effectively copies. But that&#8217;s somewhat premature, and the C++03 really was unsafe to begin with (the private type could already be accessed, and thus unsafely stored, through function template template).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Soledad Alborno				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5068</link>
		<dc:creator><![CDATA[Soledad Alborno]]></dc:creator>
		<pubDate>Wed, 04 Apr 2012 03:13:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5068</guid>
					<description><![CDATA[I personally think that using auto too often will reduce readability in the code. I would take it carefully.]]></description>
		<content:encoded><![CDATA[<p>I personally think that using auto too often will reduce readability in the code. I would take it carefully.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2012/04/03/reader-qa/#comment-5064</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Wed, 04 Apr 2012 00:05:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1437#comment-5064</guid>
					<description><![CDATA[I think that it would be better to have a mechanism where a class states what type should be deduced if *it* is auto-deduced. So if I have some string type that uses expression templates, I can force `auto str = string_type(...) + &quot;foo&quot;;` to be interpreted as `string_type str = string_type(...) + &quot;foo&quot;;`]]></description>
		<content:encoded><![CDATA[<p>I think that it would be better to have a mechanism where a class states what type should be deduced if *it* is auto-deduced. So if I have some string type that uses expression templates, I can force `auto str = string_type(&#8230;) + &#8220;foo&#8221;;` to be interpreted as `string_type str = string_type(&#8230;) + &#8220;foo&#8221;;`</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
