<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Distinguishing between maybe-null vs never-null is the important thing	</title>
	<atom:link href="https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: paveld500				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39789</link>
		<dc:creator><![CDATA[paveld500]]></dc:creator>
		<pubDate>Tue, 08 Aug 2017 16:18:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39789</guid>
					<description><![CDATA[I mean, how they work, where I should use them and how?]]></description>
		<content:encoded><![CDATA[<p>I mean, how they work, where I should use them and how?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Pavel				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39788</link>
		<dc:creator><![CDATA[Pavel]]></dc:creator>
		<pubDate>Tue, 08 Aug 2017 16:17:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39788</guid>
					<description><![CDATA[I&#039;m sorry, but can somebody offer a deeper explanation on what not_null and maybe_null templates are?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m sorry, but can somebody offer a deeper explanation on what not_null and maybe_null templates are?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mordachaiwolf				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39572</link>
		<dc:creator><![CDATA[mordachaiwolf]]></dc:creator>
		<pubDate>Tue, 21 Mar 2017 17:34:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39572</guid>
					<description><![CDATA[Love this response!  YES - T* is implicitly, by default, NULLABLE!!!!
Breaking that is INSANE.
Having a better type-system where you can say not_null is a step forward, without the foolish baggage of changing everything and sundry.]]></description>
		<content:encoded><![CDATA[<p>Love this response!  YES &#8211; T* is implicitly, by default, NULLABLE!!!!<br />
Breaking that is INSANE.<br />
Having a better type-system where you can say not_null is a step forward, without the foolish baggage of changing everything and sundry.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daniele				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39569</link>
		<dc:creator><![CDATA[Daniele]]></dc:creator>
		<pubDate>Fri, 17 Mar 2017 08:05:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39569</guid>
					<description><![CDATA[Let&#039;s hope to see it in C++20 then!]]></description>
		<content:encoded><![CDATA[<p>Let&#8217;s hope to see it in C++20 then!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39568</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Fri, 17 Mar 2017 01:33:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39568</guid>
					<description><![CDATA[Lots of people want it, but it has taken time to get it right, just like concepts, ranges, modules.]]></description>
		<content:encoded><![CDATA[<p>Lots of people want it, but it has taken time to get it right, just like concepts, ranges, modules.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daniele				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39565</link>
		<dc:creator><![CDATA[Daniele]]></dc:creator>
		<pubDate>Thu, 16 Mar 2017 10:31:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39565</guid>
					<description><![CDATA[Thank you for your quick replies guys. I am really curious to read the trip report. 

C++17 new features seem really awesome. I would have liked to see enum iteration included as well, but it seems I&#039;ll have to wait. Apparently it looks as not so many people require this feature, but I think that, when available, it will enable many new powerful idioms.]]></description>
		<content:encoded><![CDATA[<p>Thank you for your quick replies guys. I am really curious to read the trip report. </p>
<p>C++17 new features seem really awesome. I would have liked to see enum iteration included as well, but it seems I&#8217;ll have to wait. Apparently it looks as not so many people require this feature, but I think that, when available, it will enable many new powerful idioms.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39564</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 16 Mar 2017 04:29:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39564</guid>
					<description><![CDATA[@Daniele: Yes, compile-time reflection will enable that, and I&#039;ll have a paper related to that this June as well for the next meeting.

@GregM: Right you are. As soon as I get caught up I&#039;ll write that trip report (I may wait until the mailing is posted so I can link to papers, or maybe I&#039;ll get it done sooner...).]]></description>
		<content:encoded><![CDATA[<p>@Daniele: Yes, compile-time reflection will enable that, and I&#8217;ll have a paper related to that this June as well for the next meeting.</p>
<p>@GregM: Right you are. As soon as I get caught up I&#8217;ll write that trip report (I may wait until the mailing is posted so I can link to papers, or maybe I&#8217;ll get it done sooner&#8230;).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39563</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Thu, 16 Mar 2017 03:29:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39563</guid>
					<description><![CDATA[Daniele, compile time reflection allows that.

Nov 2016 status from this blog:
the Reflection study group reviewed the latest merged static reflection proposal and found it ready to enter the main Evolution groups at our next meeting to start considering the unified static reflection proposal for a TS or for the next standard.

There was another meeting two weeks ago, but I haven&#039;t seen any trip reports yet.]]></description>
		<content:encoded><![CDATA[<p>Daniele, compile time reflection allows that.</p>
<p>Nov 2016 status from this blog:<br />
the Reflection study group reviewed the latest merged static reflection proposal and found it ready to enter the main Evolution groups at our next meeting to start considering the unified static reflection proposal for a TS or for the next standard.</p>
<p>There was another meeting two weeks ago, but I haven&#8217;t seen any trip reports yet.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daniele				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39562</link>
		<dc:creator><![CDATA[Daniele]]></dc:creator>
		<pubDate>Wed, 15 Mar 2017 17:48:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39562</guid>
					<description><![CDATA[Ps I forgot to say that I am speaking about compile time iteration]]></description>
		<content:encoded><![CDATA[<p>Ps I forgot to say that I am speaking about compile time iteration</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daniele				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39561</link>
		<dc:creator><![CDATA[Daniele]]></dc:creator>
		<pubDate>Wed, 15 Mar 2017 17:19:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39561</guid>
					<description><![CDATA[Hi there,

this is totally offtopic, so apologies but I didn&#039;t know how to ask you this question.
Do you know why even in C++14 you guys have not foreseen a way to iterate over enum classes? is there any hope to see it in C++17?

It is certainly possible to iterate over them if the enum are contiguous, but if they are not and you do not want to manually write (error prone because of repetition) code or use macros, it is (as far as I know) practically impossible to do it. This is because of the standard: converting from an int to an out of range enum value results in undefined behavior.

By the way, what you&#039;re guys doing with the core guidelines rocks!

Thank you,
Daniele]]></description>
		<content:encoded><![CDATA[<p>Hi there,</p>
<p>this is totally offtopic, so apologies but I didn&#8217;t know how to ask you this question.<br />
Do you know why even in C++14 you guys have not foreseen a way to iterate over enum classes? is there any hope to see it in C++17?</p>
<p>It is certainly possible to iterate over them if the enum are contiguous, but if they are not and you do not want to manually write (error prone because of repetition) code or use macros, it is (as far as I know) practically impossible to do it. This is because of the standard: converting from an int to an out of range enum value results in undefined behavior.</p>
<p>By the way, what you&#8217;re guys doing with the core guidelines rocks!</p>
<p>Thank you,<br />
Daniele</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39548</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Thu, 16 Feb 2017 10:04:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39548</guid>
					<description><![CDATA[valid_ptr is better name because dereferencable_ptr is too long. Same for assigned_ptr. value_ptr, is unclear IMAO. If you have better name I am all ears. Note that Code Complete advises against using negation in variable names, I think same holds for types.]]></description>
		<content:encoded><![CDATA[<p>valid_ptr is better name because dereferencable_ptr is too long. Same for assigned_ptr. value_ptr, is unclear IMAO. If you have better name I am all ears. Note that Code Complete advises against using negation in variable names, I think same holds for types.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Collier				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39547</link>
		<dc:creator><![CDATA[David Collier]]></dc:creator>
		<pubDate>Thu, 16 Feb 2017 09:37:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39547</guid>
					<description><![CDATA[Non-null types would be great, but the problem is that in the current language, they can only be partly supported. You can implement a non-null raw pointer, but not a non-null unique_ptr. A non-null unique_ptr is the type you want to return from make_unique, but it&#039;s useless if you can&#039;t move from it. To make this work properly we need proper (&quot;destructive&quot;) move semantics which don&#039;t require a moved-from object to be left in a valid state.]]></description>
		<content:encoded><![CDATA[<p>Non-null types would be great, but the problem is that in the current language, they can only be partly supported. You can implement a non-null raw pointer, but not a non-null unique_ptr. A non-null unique_ptr is the type you want to return from make_unique, but it&#8217;s useless if you can&#8217;t move from it. To make this work properly we need proper (&#8220;destructive&#8221;) move semantics which don&#8217;t require a moved-from object to be left in a valid state.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Distinguishing between maybe-null vs never-null is the important thing &#124; Ace Infoway				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39546</link>
		<dc:creator><![CDATA[Distinguishing between maybe-null vs never-null is the important thing &#124; Ace Infoway]]></dc:creator>
		<pubDate>Thu, 16 Feb 2017 05:26:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39546</guid>
					<description><![CDATA[[&#8230;] vs never-null is the important thing&#013; {$excerpt:n}&#013; submitted by  /u/grauenwolf  [link] [comments]&#013; Source: [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] vs never-null is the important thing&#013; {$excerpt:n}&#013; submitted by  /u/grauenwolf  [link] [comments]&#013; Source: [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Vishal Oza				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39544</link>
		<dc:creator><![CDATA[Vishal Oza]]></dc:creator>
		<pubDate>Wed, 15 Feb 2017 23:16:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39544</guid>
					<description><![CDATA[I agree with this post I think nullptr is a necessary evil and the default should be nullable for all pointers. not_null should only when you know that be that the object the pointer points to has been created. This is one of the reasons I hate the [code]this[/code] keyword I think that [code]this[/code] should return a reference and not a pointer. I also think checking against nullptr is way to get optional augments rather std::optional]]></description>
		<content:encoded><![CDATA[<p>I agree with this post I think nullptr is a necessary evil and the default should be nullable for all pointers. not_null should only when you know that be that the object the pointer points to has been created. This is one of the reasons I hate the </p>
<pre class="brush: plain; title: ; notranslate">this</pre>
<p> keyword I think that </p>
<pre class="brush: plain; title: ; notranslate">this</pre>
<p> should return a reference and not a pointer. I also think checking against nullptr is way to get optional augments rather std::optional</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: paercebal				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39543</link>
		<dc:creator><![CDATA[paercebal]]></dc:creator>
		<pubDate>Wed, 15 Feb 2017 21:51:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39543</guid>
					<description><![CDATA[@Ivan: &quot;not_null&quot; is so clear it shines (despite the negation), whereas valid_ptr is confusing. For example:

void foo()
{
   T * p0 = nullptr ;
   T * p1 ;
}

In the code above, p0 is a valid pointer, that points to null. You can&#039;t dereference it, but you know it (because it&#039;s null).

Whereas p1&#039;s value is... undetermined. This means you have garbage, that could point or not to something. If you&#039;re lucky. That pointer is invalid.

This works the same way for iterators. Consider a vector of integers:

void foo(std::vector v)
{
   assert(! v.empty()) ;
   auto itBegin = v.begin() ;
   auto itEnd = v.end() ;

   v.resize(v.capacity() + 10) ;
   //
}

Before the resize, itBegin and itEnd are both valid iterators. The first is dereferencable (you can retrieved the &quot;pointed&quot; value), while the second is not.

After the resize, we KNOW both itBegin and itEnd are now invalid (because the vector reallocated the underlying memory). If you try to dereference any of them, you&#039;ll get an undefined behavior... exactly like the non-null non-initialized pointer p1 above.

Truth is, you have two notions:
- the pointer is valid (null or valid pointed object) or invalid (undeterminate)
- the pointed object is valid (i.e. the pointer is non-null and points to a valid pointed object).

Now, we could used valid_pointed (which is quite ugly)... but what does that mean in the following case?

void foo(valid_pointed p)
{
   // I can&#039;t dereference p, so the valid_pointed is a bit strange...
   // and what about pointers that have been reinterpret_cast-ed?
}

The fact your address points to something valid doesn&#039;t mean that the current type of the pointer is the right one to use that memory.

This is why valid_ptr (or even valid_pointed) is unclear, IMHO.]]></description>
		<content:encoded><![CDATA[<p>@Ivan: &#8220;not_null&#8221; is so clear it shines (despite the negation), whereas valid_ptr is confusing. For example:</p>
<p>void foo()<br />
{<br />
   T * p0 = nullptr ;<br />
   T * p1 ;<br />
}</p>
<p>In the code above, p0 is a valid pointer, that points to null. You can&#8217;t dereference it, but you know it (because it&#8217;s null).</p>
<p>Whereas p1&#8217;s value is&#8230; undetermined. This means you have garbage, that could point or not to something. If you&#8217;re lucky. That pointer is invalid.</p>
<p>This works the same way for iterators. Consider a vector of integers:</p>
<p>void foo(std::vector v)<br />
{<br />
   assert(! v.empty()) ;<br />
   auto itBegin = v.begin() ;<br />
   auto itEnd = v.end() ;</p>
<p>   v.resize(v.capacity() + 10) ;<br />
   //<br />
}</p>
<p>Before the resize, itBegin and itEnd are both valid iterators. The first is dereferencable (you can retrieved the &#8220;pointed&#8221; value), while the second is not.</p>
<p>After the resize, we KNOW both itBegin and itEnd are now invalid (because the vector reallocated the underlying memory). If you try to dereference any of them, you&#8217;ll get an undefined behavior&#8230; exactly like the non-null non-initialized pointer p1 above.</p>
<p>Truth is, you have two notions:<br />
&#8211; the pointer is valid (null or valid pointed object) or invalid (undeterminate)<br />
&#8211; the pointed object is valid (i.e. the pointer is non-null and points to a valid pointed object).</p>
<p>Now, we could used valid_pointed (which is quite ugly)&#8230; but what does that mean in the following case?</p>
<p>void foo(valid_pointed p)<br />
{<br />
   // I can&#8217;t dereference p, so the valid_pointed is a bit strange&#8230;<br />
   // and what about pointers that have been reinterpret_cast-ed?<br />
}</p>
<p>The fact your address points to something valid doesn&#8217;t mean that the current type of the pointer is the right one to use that memory.</p>
<p>This is why valid_ptr (or even valid_pointed) is unclear, IMHO.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Iama Hummingbird				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39540</link>
		<dc:creator><![CDATA[Iama Hummingbird]]></dc:creator>
		<pubDate>Wed, 15 Feb 2017 18:32:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39540</guid>
					<description><![CDATA[WOW!!! SO I DON&#039;T HAVE TO BUY ANOTHER BOOK MADE FOR A HIGH SCHOOL KID!!!]]></description>
		<content:encoded><![CDATA[<p>WOW!!! SO I DON&#8217;T HAVE TO BUY ANOTHER BOOK MADE FOR A HIGH SCHOOL KID!!!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Yuriy Grishin				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39539</link>
		<dc:creator><![CDATA[Yuriy Grishin]]></dc:creator>
		<pubDate>Wed, 15 Feb 2017 18:06:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39539</guid>
					<description><![CDATA[valid_ptr is worse, valid how exactly? Why nullptr is invalid? It is valid from some perspective. not_null is good enough I think.

If you&#039;re asking for a special thing to do, it very well might be ugly. Same story with casts here I guess.]]></description>
		<content:encoded><![CDATA[<p>valid_ptr is worse, valid how exactly? Why nullptr is invalid? It is valid from some perspective. not_null is good enough I think.</p>
<p>If you&#8217;re asking for a special thing to do, it very well might be ugly. Same story with casts here I guess.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ivan				</title>
				<link>https://herbsutter.com/2017/02/15/distinguishing-between-maybe-null-vs-never-null-is-the-important-thing/#comment-39538</link>
		<dc:creator><![CDATA[Ivan]]></dc:creator>
		<pubDate>Wed, 15 Feb 2017 17:45:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2971#comment-39538</guid>
					<description><![CDATA[wrt naming... not_null is ugly as hell, 
I would prefer valid_ptr or something like that...]]></description>
		<content:encoded><![CDATA[<p>wrt naming&#8230; not_null is ugly as hell,<br />
I would prefer valid_ptr or something like that&#8230;</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
