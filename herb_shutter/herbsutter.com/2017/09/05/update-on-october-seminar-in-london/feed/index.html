<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Update on October seminar in London	</title>
	<atom:link href="https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: aachrisg				</title>
				<link>https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/#comment-39915</link>
		<dc:creator><![CDATA[aachrisg]]></dc:creator>
		<pubDate>Sun, 01 Oct 2017 02:57:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3325#comment-39915</guid>
					<description><![CDATA[Are you aware of this portability issue with visual c++ and c++11 threads? 
https://chrisgreendevelopmentblog.wordpress.com/2017/08/29/thread-pools-and-windows-processor-groups/

It basically breaks the promise of being able to write high performance threaded code portably in c++ on high end xeon systems. The most trivial parallelism implementation written using std::thread, when run under linux on the same box will use all cores, but compilation with visual c++ will result in an executable which uses a fraction of the available processing power.

I think not addressing it is a mistake. Sure, it was easy to work out a (non-portable) fix, but I never would have been aware of the problem were I not coding on such a machine. Large amounts of commercial and open source-software will be written without knowledge of this, resulting in apps that cannot take full advantage of parallelism on such boxes. It needs to be addressed in the STL implementation IMHO.

It&#039;s easy to address, and a fix will not change the current behavior in any way, except when running on systems with really large numbers of cores.

I thought about writing a program to hook thread creation in compiled executables, but I don&#039;t believe it would work well, because apps still won&#039;t know how many threads to create, since std::thread::hardware_concurrency() will still return a result less than the number of cores/HT threads.]]></description>
		<content:encoded><![CDATA[<p>Are you aware of this portability issue with visual c++ and c++11 threads?<br />
<a href="https://chrisgreendevelopmentblog.wordpress.com/2017/08/29/thread-pools-and-windows-processor-groups/" rel="nofollow">https://chrisgreendevelopmentblog.wordpress.com/2017/08/29/thread-pools-and-windows-processor-groups/</a></p>
<p>It basically breaks the promise of being able to write high performance threaded code portably in c++ on high end xeon systems. The most trivial parallelism implementation written using std::thread, when run under linux on the same box will use all cores, but compilation with visual c++ will result in an executable which uses a fraction of the available processing power.</p>
<p>I think not addressing it is a mistake. Sure, it was easy to work out a (non-portable) fix, but I never would have been aware of the problem were I not coding on such a machine. Large amounts of commercial and open source-software will be written without knowledge of this, resulting in apps that cannot take full advantage of parallelism on such boxes. It needs to be addressed in the STL implementation IMHO.</p>
<p>It&#8217;s easy to address, and a fix will not change the current behavior in any way, except when running on systems with really large numbers of cores.</p>
<p>I thought about writing a program to hook thread creation in compiled executables, but I don&#8217;t believe it would work well, because apps still won&#8217;t know how many threads to create, since std::thread::hardware_concurrency() will still return a result less than the number of cores/HT threads.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Onorato				</title>
				<link>https://herbsutter.com/2017/09/05/update-on-october-seminar-in-london/#comment-39872</link>
		<dc:creator><![CDATA[Onorato]]></dc:creator>
		<pubDate>Sat, 09 Sep 2017 13:39:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3325#comment-39872</guid>
					<description><![CDATA[That&#039;s a fantastic news!!]]></description>
		<content:encoded><![CDATA[<p>That&#8217;s a fantastic news!!</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
