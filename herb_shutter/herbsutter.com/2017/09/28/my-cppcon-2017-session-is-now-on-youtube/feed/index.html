<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: My CppCon 2017 session is now on YouTube	</title>
	<atom:link href="https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: sigmabody				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40083</link>
		<dc:creator><![CDATA[sigmabody]]></dc:creator>
		<pubDate>Sun, 03 Dec 2017 19:56:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40083</guid>
					<description><![CDATA[Wanted to add my voice on one point, having watched the [excellent] talk:

I&#039;d really like to see, as a syntax note, the meta class specifier be added as an addendum to &quot;class&quot;, rather than as an alternative name. So for example:
[code]value class Point { ... };[/code]

Rationale:
- Lowers to cognitive burden for readers who are not as familiar (ie: if I know what a &quot;class&quot; is, I can sorta read over a &quot;value&quot; prefix, whereas if that&#039;s the magic keyword, I have to know what that is/means)
- It makes composition easier, outside of creating other new metaclass types, and more explicit in intent
- (similar to above) It makes composition more potentially iterative, in both directions]]></description>
		<content:encoded><![CDATA[<p>Wanted to add my voice on one point, having watched the [excellent] talk:</p>
<p>I&#8217;d really like to see, as a syntax note, the meta class specifier be added as an addendum to &#8220;class&#8221;, rather than as an alternative name. So for example:</p>
<pre class="brush: plain; title: ; notranslate">value class Point { ... };</pre>
<p>Rationale:<br />
&#8211; Lowers to cognitive burden for readers who are not as familiar (ie: if I know what a &#8220;class&#8221; is, I can sorta read over a &#8220;value&#8221; prefix, whereas if that&#8217;s the magic keyword, I have to know what that is/means)<br />
&#8211; It makes composition easier, outside of creating other new metaclass types, and more explicit in intent<br />
&#8211; (similar to above) It makes composition more potentially iterative, in both directions</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40052</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Wed, 15 Nov 2017 14:50:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40052</guid>
					<description><![CDATA[@paultopping:

&#062; Since solving the “CRTP problem” is given as a major motivation for a metaclass mechanism, I just wanted to point out that there may be a simpler solution. And, of course, all things being equal, simpler is better. Perhaps all that is needed are more non-CRTP examples demonstrating how metaclasses will be a good thing.

I think there needs to be a distinction between &quot;things that the CRTP could do too&quot; and &quot;how metaclasses subsumes CRTP&quot;.

The CRTP is, at its core, an attempt to get mixins into the language. But like Boost.Lambda, the CRTP comes with a bunch of limitations. The CRTP base class _cannot_ access the class it is mapped into generally; it can only do so in very specific circumstances.

The simple solution to the CRTP problem is to do what we did with lambdas: add direct support for mixins into the language. And once you get past the reflection introspection and code generation, that is *all* metaclasses are.

That is, reflective introspection and code generation are ultimately orthogonal to metaclasses as functionality. You can have one without the other. While they make metaclasses *really* powerful, C++ right now could still benefit from metaclasses without them, as they give us language support for mixins.

Or to put it another way, my equation would better be stated as: reflective introspection + code injection + mixins = the full metaclasses proposal. Herb&#039;s proposal talks about all of them, but the reflection and code injection stuff is proceeding orthogonality to it (as I understand it). The ability to define metaclasses and how they interact with the class that uses them is pure mixin. So there&#039;s no reason we *have* to wait for reflection/code injection before we get mixins.]]></description>
		<content:encoded><![CDATA[<p>@paultopping:</p>
<p>&gt; Since solving the “CRTP problem” is given as a major motivation for a metaclass mechanism, I just wanted to point out that there may be a simpler solution. And, of course, all things being equal, simpler is better. Perhaps all that is needed are more non-CRTP examples demonstrating how metaclasses will be a good thing.</p>
<p>I think there needs to be a distinction between &#8220;things that the CRTP could do too&#8221; and &#8220;how metaclasses subsumes CRTP&#8221;.</p>
<p>The CRTP is, at its core, an attempt to get mixins into the language. But like Boost.Lambda, the CRTP comes with a bunch of limitations. The CRTP base class _cannot_ access the class it is mapped into generally; it can only do so in very specific circumstances.</p>
<p>The simple solution to the CRTP problem is to do what we did with lambdas: add direct support for mixins into the language. And once you get past the reflection introspection and code generation, that is *all* metaclasses are.</p>
<p>That is, reflective introspection and code generation are ultimately orthogonal to metaclasses as functionality. You can have one without the other. While they make metaclasses *really* powerful, C++ right now could still benefit from metaclasses without them, as they give us language support for mixins.</p>
<p>Or to put it another way, my equation would better be stated as: reflective introspection + code injection + mixins = the full metaclasses proposal. Herb&#8217;s proposal talks about all of them, but the reflection and code injection stuff is proceeding orthogonality to it (as I understand it). The ability to define metaclasses and how they interact with the class that uses them is pure mixin. So there&#8217;s no reason we *have* to wait for reflection/code injection before we get mixins.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt C				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40051</link>
		<dc:creator><![CDATA[Matt C]]></dc:creator>
		<pubDate>Wed, 15 Nov 2017 08:25:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40051</guid>
					<description><![CDATA[Angle brackets got eaten :(]]></description>
		<content:encoded><![CDATA[<p>Angle brackets got eaten :(</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew Chaplain				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40050</link>
		<dc:creator><![CDATA[Matthew Chaplain]]></dc:creator>
		<pubDate>Wed, 15 Nov 2017 08:24:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40050</guid>
					<description><![CDATA[Composability summary: currently either &quot;serializable interface class&quot; or &quot;class&quot; (or &quot;struct&quot;, I assume).  I&#039;m ... actually ok with either of those.  A slight lean to the former.  As you say, similarity to ref class and enum class.]]></description>
		<content:encoded><![CDATA[<p>Composability summary: currently either &#8220;serializable interface class&#8221; or &#8220;class&#8221; (or &#8220;struct&#8221;, I assume).  I&#8217;m &#8230; actually ok with either of those.  A slight lean to the former.  As you say, similarity to ref class and enum class.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40046</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 14 Nov 2017 21:23:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40046</guid>
					<description><![CDATA[Meta (pun intended): I&#039;m sorely behind on answering blog comments related to P0707, esp. on the July blog post. This is part of a first pass to catch up...

@Alexey: I have not tried open multi-methods. Re external data, the metaclasses proposal builds on the compile-time programming proposal, so the question is really whether that allows file I/O (which has been suggested).

@Matthew, several others: Yes, they are composable. See section 6 in the current paper for possible directions on applying multiple metaclasses at once without creating a named metaclass for that combination.

@Nenad: No, I did not consider a meta-union... because I believe metaclasses are powerful enough to express that so that a special case for union is unnecessary. See the safe_union metaclass in the paper for an example.

Re CRTP: I was trying to summarize that there are a lot of drawbacks to CTRP, and that one thing we discovered is that metaclasses appear to cover the use cases of CRTP as well, which helps to expose what CRTP was trying to approximate. However...

@paultopping: ... no, &quot;solving the CRTP problem&quot; is not a major motivation, it&#039;s something &quot;that it happens to do too&quot; that was discovered along the way. CRTP is not yet even mentioned in the paper -- adding that is on my to-do list.]]></description>
		<content:encoded><![CDATA[<p>Meta (pun intended): I&#8217;m sorely behind on answering blog comments related to P0707, esp. on the July blog post. This is part of a first pass to catch up&#8230;</p>
<p>@Alexey: I have not tried open multi-methods. Re external data, the metaclasses proposal builds on the compile-time programming proposal, so the question is really whether that allows file I/O (which has been suggested).</p>
<p>@Matthew, several others: Yes, they are composable. See section 6 in the current paper for possible directions on applying multiple metaclasses at once without creating a named metaclass for that combination.</p>
<p>@Nenad: No, I did not consider a meta-union&#8230; because I believe metaclasses are powerful enough to express that so that a special case for union is unnecessary. See the safe_union metaclass in the paper for an example.</p>
<p>Re CRTP: I was trying to summarize that there are a lot of drawbacks to CTRP, and that one thing we discovered is that metaclasses appear to cover the use cases of CRTP as well, which helps to expose what CRTP was trying to approximate. However&#8230;</p>
<p>@paultopping: &#8230; no, &#8220;solving the CRTP problem&#8221; is not a major motivation, it&#8217;s something &#8220;that it happens to do too&#8221; that was discovered along the way. CRTP is not yet even mentioned in the paper &#8212; adding that is on my to-do list.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xABBAAA				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40037</link>
		<dc:creator><![CDATA[xABBAAA]]></dc:creator>
		<pubDate>Mon, 13 Nov 2017 18:04:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40037</guid>
					<description><![CDATA[So!
Instead of providing programmers with more power, flexibility etc... 

Why do we need the destructor. It would be logical to use it if we don&#039;t need the object any more. Who get tha idej that programmer don&#039;t understand when we need it removed from our memory...]]></description>
		<content:encoded><![CDATA[<p>So!<br />
Instead of providing programmers with more power, flexibility etc&#8230; </p>
<p>Why do we need the destructor. It would be logical to use it if we don&#8217;t need the object any more. Who get tha idej that programmer don&#8217;t understand when we need it removed from our memory&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: paultopping				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40035</link>
		<dc:creator><![CDATA[paultopping]]></dc:creator>
		<pubDate>Mon, 13 Nov 2017 15:49:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40035</guid>
					<description><![CDATA[I didn&#039;t have any problems with Herb&#039;s proposal per se. However, your comment causes me to sharpen my point. Since solving the &quot;CRTP problem&quot; is given as a major motivation for a metaclass mechanism, I just wanted to point out that there may be a simpler solution. And, of course, all things being equal, simpler is better. Perhaps all that is needed are more non-CRTP examples demonstrating how metaclasses will be a good thing. Perhaps these exist already. I will admit to not having read everything.]]></description>
		<content:encoded><![CDATA[<p>I didn&#8217;t have any problems with Herb&#8217;s proposal per se. However, your comment causes me to sharpen my point. Since solving the &#8220;CRTP problem&#8221; is given as a major motivation for a metaclass mechanism, I just wanted to point out that there may be a simpler solution. And, of course, all things being equal, simpler is better. Perhaps all that is needed are more non-CRTP examples demonstrating how metaclasses will be a good thing. Perhaps these exist already. I will admit to not having read everything.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40031</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Sun, 12 Nov 2017 22:59:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40031</guid>
					<description><![CDATA[&#062; While metaclasses would obviously be a powerful mechanism, perhaps CRTP could be replaced by something simpler.

I see no need for that.

From Herb&#039;s proposal, the basic structure of metaclasses doesn&#039;t actually *require* any of the reflection stuff. That is, reading members and so forth. Any non-injection declarations a metaclass makes go *directly* into the class that uses the metaclass. In that way, it works exactly like the CRTP, only without all of the stupid bits.

Basically, pure metaclases are C++ mixins. Metaclasses + reflection + injection are what Herb&#039;s talking about.

The only real downside is that Herb&#039;s current syntax for using a metaclass only lets you use a single metaclass. So if you need to apply multiple metaclasses, you have to make a new metaclass that inherits from them. But that could easily be fixed as follows:

[code]
class(metaclass1, metaclass2) Typename {...};
[/code]

Which will behave as if you had done:

[code]
$class some_unnamed_metaclass_name : metaclass1, metaclass2 {};
some_unnamed_metaclass_name Typename {...};
[/code]]]></description>
		<content:encoded><![CDATA[<p>&gt; While metaclasses would obviously be a powerful mechanism, perhaps CRTP could be replaced by something simpler.</p>
<p>I see no need for that.</p>
<p>From Herb&#8217;s proposal, the basic structure of metaclasses doesn&#8217;t actually *require* any of the reflection stuff. That is, reading members and so forth. Any non-injection declarations a metaclass makes go *directly* into the class that uses the metaclass. In that way, it works exactly like the CRTP, only without all of the stupid bits.</p>
<p>Basically, pure metaclases are C++ mixins. Metaclasses + reflection + injection are what Herb&#8217;s talking about.</p>
<p>The only real downside is that Herb&#8217;s current syntax for using a metaclass only lets you use a single metaclass. So if you need to apply multiple metaclasses, you have to make a new metaclass that inherits from them. But that could easily be fixed as follows:</p>
<pre class="brush: plain; title: ; notranslate">
class(metaclass1, metaclass2) Typename {...};
</pre>
<p>Which will behave as if you had done:</p>
<pre class="brush: plain; title: ; notranslate">
$class some_unnamed_metaclass_name : metaclass1, metaclass2 {};
some_unnamed_metaclass_name Typename {...};
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: paultopping				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40023</link>
		<dc:creator><![CDATA[paultopping]]></dc:creator>
		<pubDate>Sat, 11 Nov 2017 18:52:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40023</guid>
					<description><![CDATA[I agree. While metaclasses would obviously be a powerful mechanism, perhaps CRTP could be replaced by something simpler. Whenever I&#039;ve used CRTP, the difficulty is in dealing with two classes instead of one. Of course, it is only one at a time. What is desired is multiple classes derived from a single base where the definitions within both are merged into a single class. Or, saying it another way, a different kind of derivation from the base is needed where the base&#039;s definitions are merged into the derived class. Perhaps not as elegant as metaclasses and I am only hand-waving here.]]></description>
		<content:encoded><![CDATA[<p>I agree. While metaclasses would obviously be a powerful mechanism, perhaps CRTP could be replaced by something simpler. Whenever I&#8217;ve used CRTP, the difficulty is in dealing with two classes instead of one. Of course, it is only one at a time. What is desired is multiple classes derived from a single base where the definitions within both are merged into a single class. Or, saying it another way, a different kind of derivation from the base is needed where the base&#8217;s definitions are merged into the derived class. Perhaps not as elegant as metaclasses and I am only hand-waving here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40022</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Sat, 11 Nov 2017 18:39:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40022</guid>
					<description><![CDATA[I think I can answer that last question better than Herb did. Herb was trying to get at this point, but I don&#039;t think it came out in full.

The single biggest annoyance with the CRTP (for me and my uses) is the fact that the derived class does not exist during the instantiation of the CRTP class. While the bodies of member functions of the CRTP class can access members of the derived class, anything else cannot.

Think about some of the boilerplate that C++ containers require in terms of typedefs. You have &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, etc. But really, the only one that the implementer needs to define is &lt;code&gt;value_type&lt;/code&gt;; unless they&#039;re doing something special, &lt;code&gt;using reference = value_type&#038;;&lt;/code&gt; and &lt;code&gt;using pointer = value_type*;&lt;/code&gt; work. So that&#039;s an obvious thing to put into a CRTP base class.

But that doesn&#039;t work. Or at least, not directly. You cannot write &lt;code&gt;using pointer = Derived::value_type*;&lt;/code&gt;, because &lt;code&gt;Derived&lt;/code&gt; is an incomplete type at that point in C++&#039;s template instantiation model. So what you have to do is have some traits class which you specialize for your container type, and that class has &lt;code&gt;value_type&lt;/code&gt;. So the CRTP does &lt;code&gt;using pointer = typename trait::value_type*;&lt;/code&gt;.

Which means that when I go to write the container that uses this CRTP base class, I have to go through a lot of pain. I have to close my namespace, open up the namespace where the traits class specialization needs to go, specialize it, close that namespace and reopen my namespace, and then finally declare my class. And that&#039;s for a very simple case.

So while CRTP + reflection + injection can probably get some of the low-hanging metaclasses fruit, it will never be as good as full-frontal metaclasses.﻿]]></description>
		<content:encoded><![CDATA[<p>I think I can answer that last question better than Herb did. Herb was trying to get at this point, but I don&#8217;t think it came out in full.</p>
<p>The single biggest annoyance with the CRTP (for me and my uses) is the fact that the derived class does not exist during the instantiation of the CRTP class. While the bodies of member functions of the CRTP class can access members of the derived class, anything else cannot.</p>
<p>Think about some of the boilerplate that C++ containers require in terms of typedefs. You have <code>value_type</code>, <code>reference</code>, <code>pointer</code>, etc. But really, the only one that the implementer needs to define is <code>value_type</code>; unless they&#8217;re doing something special, <code>using reference = value_type&amp;;</code> and <code>using pointer = value_type*;</code> work. So that&#8217;s an obvious thing to put into a CRTP base class.</p>
<p>But that doesn&#8217;t work. Or at least, not directly. You cannot write <code>using pointer = Derived::value_type*;</code>, because <code>Derived</code> is an incomplete type at that point in C++&#8217;s template instantiation model. So what you have to do is have some traits class which you specialize for your container type, and that class has <code>value_type</code>. So the CRTP does <code>using pointer = typename trait::value_type*;</code>.</p>
<p>Which means that when I go to write the container that uses this CRTP base class, I have to go through a lot of pain. I have to close my namespace, open up the namespace where the traits class specialization needs to go, specialize it, close that namespace and reopen my namespace, and then finally declare my class. And that&#8217;s for a very simple case.</p>
<p>So while CRTP + reflection + injection can probably get some of the low-hanging metaclasses fruit, it will never be as good as full-frontal metaclasses.﻿</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Greg Marr				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40017</link>
		<dc:creator><![CDATA[Greg Marr]]></dc:creator>
		<pubDate>Sat, 04 Nov 2017 00:30:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40017</guid>
					<description><![CDATA[When you got to the portion of the talk about injecting code from the constexpr block into the regular code, I immediately thought that it would make sense to say that this was an `export` operation.  Seems like that could be a good keyword for it, and you could save `-&#062;` for something else.]]></description>
		<content:encoded><![CDATA[<p>When you got to the portion of the talk about injecting code from the constexpr block into the regular code, I immediately thought that it would make sense to say that this was an `export` operation.  Seems like that could be a good keyword for it, and you could save `-&gt;` for something else.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Nenad Miksa				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-40002</link>
		<dc:creator><![CDATA[Nenad Miksa]]></dc:creator>
		<pubDate>Sun, 29 Oct 2017 16:59:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-40002</guid>
					<description><![CDATA[Great idea and great feature! I was really hoping to see that in C++20, but I guess we&#039;ll have to wait until at least c++2023 and then until 2025 for MSVC to properly implement it.

However, what are your thoughts about unions? Did you consider adding [code]$union[/code] keyword for supporting meta-unions, or do you see unions as a special type of metaclass (just like class and struct), but with specific storage rules?

Too bad no one asked that question in the video.]]></description>
		<content:encoded><![CDATA[<p>Great idea and great feature! I was really hoping to see that in C++20, but I guess we&#8217;ll have to wait until at least c++2023 and then until 2025 for MSVC to properly implement it.</p>
<p>However, what are your thoughts about unions? Did you consider adding </p>
<pre class="brush: plain; title: ; notranslate">$union</pre>
<p> keyword for supporting meta-unions, or do you see unions as a special type of metaclass (just like class and struct), but with specific storage rules?</p>
<p>Too bad no one asked that question in the video.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: My Qt World Summit keynote video is now online &#124; Sutter’s Mill				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39976</link>
		<dc:creator><![CDATA[My Qt World Summit keynote video is now online &#124; Sutter’s Mill]]></dc:creator>
		<pubDate>Wed, 25 Oct 2017 18:31:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39976</guid>
					<description><![CDATA[[&#8230;] Summit videos were just posted, including my talk which was a condensed (40-minute) version of my CppCon 2017 metaclasses talk with some small tweaks for a Qt-specific [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Summit videos were just posted, including my talk which was a condensed (40-minute) version of my CppCon 2017 metaclasses talk with some small tweaks for a Qt-specific [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marcin Kaźmierczak				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39959</link>
		<dc:creator><![CDATA[Marcin Kaźmierczak]]></dc:creator>
		<pubDate>Mon, 16 Oct 2017 15:52:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39959</guid>
					<description><![CDATA[I like the idea of metaclasses. The proposal contains examples with Qt&#039;s moc substitution.

Lately you presented us with defer_ptr type. 
I would love to see whether implementation of GarbageCollected type is possible through metaclasses.
I find this a challenging task. Please consider subclassing, visiting members, etc. in potential solution.]]></description>
		<content:encoded><![CDATA[<p>I like the idea of metaclasses. The proposal contains examples with Qt&#8217;s moc substitution.</p>
<p>Lately you presented us with defer_ptr type.<br />
I would love to see whether implementation of GarbageCollected type is possible through metaclasses.<br />
I find this a challenging task. Please consider subclassing, visiting members, etc. in potential solution.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xABBAAA				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39958</link>
		<dc:creator><![CDATA[xABBAAA]]></dc:creator>
		<pubDate>Mon, 16 Oct 2017 06:18:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39958</guid>
					<description><![CDATA[So!
What is the purpose for that word final, any way...]]></description>
		<content:encoded><![CDATA[<p>So!<br />
What is the purpose for that word final, any way&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul Baxter				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39956</link>
		<dc:creator><![CDATA[Paul Baxter]]></dc:creator>
		<pubDate>Sun, 15 Oct 2017 20:11:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39956</guid>
					<description><![CDATA[Ironically, I&#039;d suggest creating a preprocessor program to generate the classes etc (cfront++ :) ) from metadata descriptions so as to gain experience with the meta language and make its use with different compilers easier.

It would also allow much earlier adoption rather than waiting for C++ 2023]]></description>
		<content:encoded><![CDATA[<p>Ironically, I&#8217;d suggest creating a preprocessor program to generate the classes etc (cfront++ :) ) from metadata descriptions so as to gain experience with the meta language and make its use with different compilers easier.</p>
<p>It would also allow much earlier adoption rather than waiting for C++ 2023</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Riccardo Marcangelo				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39955</link>
		<dc:creator><![CDATA[Riccardo Marcangelo]]></dc:creator>
		<pubDate>Sun, 15 Oct 2017 16:17:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39955</guid>
					<description><![CDATA[Herb, thank you for taking the time to write the metaclasses proposal. I think it is an excellent proposal.. I have thought about the addition of &#039;interface&#039; and &#039;abstract&#039; contextual  keywords similarly to how we use the final keyword now. For example: [code]class Foo interface[/code] [code]class Foo abstract[/code]  [code]class Foo final[/code]. Your proposal is superior as it is extensible. We save having to write &#039;class&#039; each time too! If it won&#039;t be ready in time for C++20 I hope it makes it to a TS so we can start using metaclasses sooner rather than later.]]></description>
		<content:encoded><![CDATA[<p>Herb, thank you for taking the time to write the metaclasses proposal. I think it is an excellent proposal.. I have thought about the addition of &#8216;interface&#8217; and &#8216;abstract&#8217; contextual  keywords similarly to how we use the final keyword now. For example: </p>
<pre class="brush: plain; title: ; notranslate">class Foo interface</pre>
<pre class="brush: plain; title: ; notranslate">class Foo abstract</pre>
<pre class="brush: plain; title: ; notranslate">class Foo final</pre>
<p>. Your proposal is superior as it is extensible. We save having to write &#8216;class&#8217; each time too! If it won&#8217;t be ready in time for C++20 I hope it makes it to a TS so we can start using metaclasses sooner rather than later.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gheorghe MarincaGhita				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39927</link>
		<dc:creator><![CDATA[Gheorghe MarincaGhita]]></dc:creator>
		<pubDate>Wed, 04 Oct 2017 07:44:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39927</guid>
					<description><![CDATA[A quick question. Regarding &quot;Effective Concurrency&quot; which is due on amazoon books, any updates ?]]></description>
		<content:encoded><![CDATA[<p>A quick question. Regarding &#8220;Effective Concurrency&#8221; which is due on amazoon books, any updates ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xABBAAA				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39926</link>
		<dc:creator><![CDATA[xABBAAA]]></dc:creator>
		<pubDate>Wed, 04 Oct 2017 06:11:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39926</guid>
					<description><![CDATA[Okay...
Let&#039;s see. Well, the class is bit different than that template and I will need to have history to make it more clear what is the ground we are now.

In the start we had some jumbo computers and no body cares about that... then we had some stuff like Commodore, Spectrum and Atari ...
and now we have std with algorithms and we have templates... does that matter too? 

I don&#039;t know. But, where is multi threading as it should be, not as it is?

Why we don&#039;t build  more on that concept of objects and make it more like relationships of the objects that will represent real life even more.
The templates don&#039;t care about type of the variable and ...]]></description>
		<content:encoded><![CDATA[<p>Okay&#8230;<br />
Let&#8217;s see. Well, the class is bit different than that template and I will need to have history to make it more clear what is the ground we are now.</p>
<p>In the start we had some jumbo computers and no body cares about that&#8230; then we had some stuff like Commodore, Spectrum and Atari &#8230;<br />
and now we have std with algorithms and we have templates&#8230; does that matter too? </p>
<p>I don&#8217;t know. But, where is multi threading as it should be, not as it is?</p>
<p>Why we don&#8217;t build  more on that concept of objects and make it more like relationships of the objects that will represent real life even more.<br />
The templates don&#8217;t care about type of the variable and &#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: hoffmale				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39925</link>
		<dc:creator><![CDATA[hoffmale]]></dc:creator>
		<pubDate>Tue, 03 Oct 2017 22:39:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39925</guid>
					<description><![CDATA[I like the general idea of meta classes: writing code that transforms/verifies other code according to some criteria.

However, I feel there are some problems with the approach, too: It has all the same problems &quot;normal&quot; inheritance already has, plus in some cases it might be too constraining.

As mentioned beforehand, composability of metaclasses, as far as i understand, is restricted to creating a new metaclass inheriting from all metaclasses whose behavior is desired and using that to declare the final type. Not only does this somewhat reproduce the dreaded inheritance-diamond-problem, it also clutters the code base with possibly single-use metaclasses.

Of course, this could be handled by introducing utility metaclasses, maybe like this:
[code]template&#060;$class... T&#062;
$class class_combinator : T... {};[/code]
But somehow, this doesn&#039;t feel as elegant or concise.

In normal OOP, the guideline is usually &quot;favor composition over inheritance&quot;. This usually makes sense, especially if the referred classes address orthogonal concepts, as many of the metaclass examples in your presentation do.
Sadly, I can&#039;t seem to think of a way of expressing this relation in the proposed metaclass implementation.

One possible solution I can think of would be leveraging some of the metaclasses into class attributes/annotations (whatever you prefer). For example, let&#039;s say I want a Qt widget that is &lt;code&gt;counted&lt;/code&gt; and &lt;code&gt;ordered&lt;/code&gt; (using the examples from your slides). The proposed implementation for that would be something like this:
[code]$class MyWidgetClass : QClass, ordered, counted {};

MyWidgetClass MyWidget { /* implementation */ };[/code]

My thoughts would tend to look more like this (using the Java annotation style):
[code]@ordered
@counted
QClass MyWidget {
  /* implementation */
};
[/code]

This way, the different concerns are still separated, but clearer. Another possible benefit could be that the transformations done by &lt;code&gt;ordered&lt;/code&gt; and &lt;code&gt;counted&lt;/code&gt; might be done before the &lt;code&gt;QClass&lt;/code&gt; metaclass does its transformations and verifications.

This way also prevents an explosion of different metaclasses for all conceivable combinations of the metaclasses for these concerns.

Actually, &lt;code&gt;QClass&lt;/code&gt; could possibly also be rewritten into an attribute/annotation, but since it really does change the fundamental semantics (as compared to &lt;code&gt;ordered&lt;/code&gt; or &lt;code&gt;counted&lt;/code&gt;, which only add some useful functionality), I feel like this would be an appropriate use of a metaclass.

What do you think about these problems, and what are the problems with my off-the-head solutions (as I figure you&#039;ve probably already thought about these)?]]></description>
		<content:encoded><![CDATA[<p>I like the general idea of meta classes: writing code that transforms/verifies other code according to some criteria.</p>
<p>However, I feel there are some problems with the approach, too: It has all the same problems &#8220;normal&#8221; inheritance already has, plus in some cases it might be too constraining.</p>
<p>As mentioned beforehand, composability of metaclasses, as far as i understand, is restricted to creating a new metaclass inheriting from all metaclasses whose behavior is desired and using that to declare the final type. Not only does this somewhat reproduce the dreaded inheritance-diamond-problem, it also clutters the code base with possibly single-use metaclasses.</p>
<p>Of course, this could be handled by introducing utility metaclasses, maybe like this:</p>
<pre class="brush: plain; title: ; notranslate">template&lt;$class... T&gt;
$class class_combinator : T... {};</pre>
<p>But somehow, this doesn&#8217;t feel as elegant or concise.</p>
<p>In normal OOP, the guideline is usually &#8220;favor composition over inheritance&#8221;. This usually makes sense, especially if the referred classes address orthogonal concepts, as many of the metaclass examples in your presentation do.<br />
Sadly, I can&#8217;t seem to think of a way of expressing this relation in the proposed metaclass implementation.</p>
<p>One possible solution I can think of would be leveraging some of the metaclasses into class attributes/annotations (whatever you prefer). For example, let&#8217;s say I want a Qt widget that is <code>counted</code> and <code>ordered</code> (using the examples from your slides). The proposed implementation for that would be something like this:</p>
<pre class="brush: plain; title: ; notranslate">$class MyWidgetClass : QClass, ordered, counted {};

MyWidgetClass MyWidget { /* implementation */ };</pre>
<p>My thoughts would tend to look more like this (using the Java annotation style):</p>
<pre class="brush: plain; title: ; notranslate">@ordered
@counted
QClass MyWidget {
  /* implementation */
};
</pre>
<p>This way, the different concerns are still separated, but clearer. Another possible benefit could be that the transformations done by <code>ordered</code> and <code>counted</code> might be done before the <code>QClass</code> metaclass does its transformations and verifications.</p>
<p>This way also prevents an explosion of different metaclasses for all conceivable combinations of the metaclasses for these concerns.</p>
<p>Actually, <code>QClass</code> could possibly also be rewritten into an attribute/annotation, but since it really does change the fundamental semantics (as compared to <code>ordered</code> or <code>counted</code>, which only add some useful functionality), I feel like this would be an appropriate use of a metaclass.</p>
<p>What do you think about these problems, and what are the problems with my off-the-head solutions (as I figure you&#8217;ve probably already thought about these)?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: gnzlbg				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39924</link>
		<dc:creator><![CDATA[gnzlbg]]></dc:creator>
		<pubDate>Tue, 03 Oct 2017 17:51:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39924</guid>
					<description><![CDATA[How do you apply multiple metaclasses to the same class? (e.g. you showed value_type, pod_type, EqualityComparable, can I compose them?). Or the more general theme, how do you compose metaclasses?]]></description>
		<content:encoded><![CDATA[<p>How do you apply multiple metaclasses to the same class? (e.g. you showed value_type, pod_type, EqualityComparable, can I compose them?). Or the more general theme, how do you compose metaclasses?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew Chaplain				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39920</link>
		<dc:creator><![CDATA[Matthew Chaplain]]></dc:creator>
		<pubDate>Mon, 02 Oct 2017 10:43:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39920</guid>
					<description><![CDATA[I&#039;m curious about how composable metaclasses are/should be.  

For example, if I have metaclass &quot;value&quot;, which generates getters and setters a la the talk, and another metaclass called &quot;reflected&quot; which detects getters and setters (etc.) and generates a function to return some type that allows runtime introspection and activation of those functions.  

Under the current proposal, I would need to create a third metaclass, say &quot;reflected_value&quot;, which inherits both of those metaclasses.  Could there be a simpler syntax to have this mix-in capability?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m curious about how composable metaclasses are/should be.  </p>
<p>For example, if I have metaclass &#8220;value&#8221;, which generates getters and setters a la the talk, and another metaclass called &#8220;reflected&#8221; which detects getters and setters (etc.) and generates a function to return some type that allows runtime introspection and activation of those functions.  </p>
<p>Under the current proposal, I would need to create a third metaclass, say &#8220;reflected_value&#8221;, which inherits both of those metaclasses.  Could there be a simpler syntax to have this mix-in capability?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alexey Baskakov				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39917</link>
		<dc:creator><![CDATA[Alexey Baskakov]]></dc:creator>
		<pubDate>Sun, 01 Oct 2017 08:47:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39917</guid>
					<description><![CDATA[Awesome talk, thank you! Generative programming was always a highly desired paradigm to support in C++.

Two questions:
1) Is it possible to support open multi-methods as a use case? https://github.com/jll63/openmethods.d
2) In Generative Programming you can load some external model as an xml/json data (created in tools by non-programmers) and generate some code. Is it out-of-scope for the proposed approach? (So we won&#039;t be able to use any external data in constexpr {} blocks)]]></description>
		<content:encoded><![CDATA[<p>Awesome talk, thank you! Generative programming was always a highly desired paradigm to support in C++.</p>
<p>Two questions:<br />
1) Is it possible to support open multi-methods as a use case? <a href="https://github.com/jll63/openmethods.d" rel="nofollow">https://github.com/jll63/openmethods.d</a><br />
2) In Generative Programming you can load some external model as an xml/json data (created in tools by non-programmers) and generate some code. Is it out-of-scope for the proposed approach? (So we won&#8217;t be able to use any external data in constexpr {} blocks)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: paultopping				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39914</link>
		<dc:creator><![CDATA[paultopping]]></dc:creator>
		<pubDate>Sat, 30 Sep 2017 17:01:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39914</guid>
					<description><![CDATA[While we don&#039;t want to turn C++ into another language, these metaclasses are intended to replace at least some solutions involving &quot;little languages&quot; that are converted to C++ code by external tools. I would like to see support for such &quot;little languages&quot; addressed directly if only to see what additional facilities would have to be added to C++. It seems the metaclass feature, and especially the tooling that comes with it, gets us part way there. Let&#039;s investigate what it would take to go all the way (whatever that means) and see how it might impact what is being proposed here. At a minimum, it would avoid painting ourselves into a corner and make it easier to revisit the decision to support (or not) little languages in the future.]]></description>
		<content:encoded><![CDATA[<p>While we don&#8217;t want to turn C++ into another language, these metaclasses are intended to replace at least some solutions involving &#8220;little languages&#8221; that are converted to C++ code by external tools. I would like to see support for such &#8220;little languages&#8221; addressed directly if only to see what additional facilities would have to be added to C++. It seems the metaclass feature, and especially the tooling that comes with it, gets us part way there. Let&#8217;s investigate what it would take to go all the way (whatever that means) and see how it might impact what is being proposed here. At a minimum, it would avoid painting ourselves into a corner and make it easier to revisit the decision to support (or not) little languages in the future.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xABBAAA				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39913</link>
		<dc:creator><![CDATA[xABBAAA]]></dc:creator>
		<pubDate>Sat, 30 Sep 2017 05:09:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39913</guid>
					<description><![CDATA[I am big fan of C++, and it was it for me.
I have learned some other stuff, but C/C++ is the most expressive programming language out there. Yeah, I am not comparative scientist, do I have compared it with other ones.
The issue I see with C++, is that:
* multi threading is not done in good way,
* support for AI is, well there is no support unless you add something to your C++,
* creating functions dinamically,
* having good approach to limiting data types and test of it,
...

Yeah, there is a lot of the stuff over there that could be fixed, and true evolution need the genuine interest from the people that are involved. Somehow, I don&#039;t see that to the extent that would make me happy...

So, where does C++ go from here... 

And one big issue for C++ is lack of GUI standard for: Linux, MS, ... like something for simple apps...]]></description>
		<content:encoded><![CDATA[<p>I am big fan of C++, and it was it for me.<br />
I have learned some other stuff, but C/C++ is the most expressive programming language out there. Yeah, I am not comparative scientist, do I have compared it with other ones.<br />
The issue I see with C++, is that:<br />
* multi threading is not done in good way,<br />
* support for AI is, well there is no support unless you add something to your C++,<br />
* creating functions dinamically,<br />
* having good approach to limiting data types and test of it,<br />
&#8230;</p>
<p>Yeah, there is a lot of the stuff over there that could be fixed, and true evolution need the genuine interest from the people that are involved. Somehow, I don&#8217;t see that to the extent that would make me happy&#8230;</p>
<p>So, where does C++ go from here&#8230; </p>
<p>And one big issue for C++ is lack of GUI standard for: Linux, MS, &#8230; like something for simple apps&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jaysistar				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39908</link>
		<dc:creator><![CDATA[jaysistar]]></dc:creator>
		<pubDate>Fri, 29 Sep 2017 16:28:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39908</guid>
					<description><![CDATA[I believe that in your example both errors could be given with what&#039;s proposed.

Remember that it&#039;s opt-in. You can tell the compiler to generate a class, then use that class/struct your code instead, and it should be able to be used. Ideally, you would copy the metaclass and remove the constrants that you don&#039;t want. Also, metaclasses are not only for constraits; properites for Qt, CLR (WPF, Noesis GUI etc.), or other change notification systems could be added with metaclasses, which dramatically removes boilerplate code.]]></description>
		<content:encoded><![CDATA[<p>I believe that in your example both errors could be given with what&#8217;s proposed.</p>
<p>Remember that it&#8217;s opt-in. You can tell the compiler to generate a class, then use that class/struct your code instead, and it should be able to be used. Ideally, you would copy the metaclass and remove the constrants that you don&#8217;t want. Also, metaclasses are not only for constraits; properites for Qt, CLR (WPF, Noesis GUI etc.), or other change notification systems could be added with metaclasses, which dramatically removes boilerplate code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Greg Marr				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39907</link>
		<dc:creator><![CDATA[Greg Marr]]></dc:creator>
		<pubDate>Fri, 29 Sep 2017 15:47:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39907</guid>
					<description><![CDATA[JMS, does it really matter which one is tested first?  I would think it&#039;s actually a good thing that this is not ambiguous, so that we get consistent results from all the compilers/libraries.]]></description>
		<content:encoded><![CDATA[<p>JMS, does it really matter which one is tested first?  I would think it&#8217;s actually a good thing that this is not ambiguous, so that we get consistent results from all the compilers/libraries.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JMS				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39906</link>
		<dc:creator><![CDATA[JMS]]></dc:creator>
		<pubDate>Fri, 29 Sep 2017 04:59:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39906</guid>
					<description><![CDATA[You gave your usual excellent talk.

Code that specifies rules is often both terser and easier to write correctly than is an English equivalent.  However, couldn&#039;t a code specification introduce needless constraints?  For example, say that metaclass &quot;M&quot; bans both private functions and virtual functions.  If a careless author writes a private virtual function in an &quot;M&quot; class, which rule is tested first, the one banning &quot;private&quot; functions  or the one banning &quot;virtual&quot; functions?  A specification in English can leave this detail up to the implementation but a specification in code cannot; it must commit to one order or the other.  This may be a trivial example but I wonder if more consequential examples of over-specification are possible or even unavoidable.  I don&#039;t know enough about metaclasses to know whether this is a risk.

Thank you.]]></description>
		<content:encoded><![CDATA[<p>You gave your usual excellent talk.</p>
<p>Code that specifies rules is often both terser and easier to write correctly than is an English equivalent.  However, couldn&#8217;t a code specification introduce needless constraints?  For example, say that metaclass &#8220;M&#8221; bans both private functions and virtual functions.  If a careless author writes a private virtual function in an &#8220;M&#8221; class, which rule is tested first, the one banning &#8220;private&#8221; functions  or the one banning &#8220;virtual&#8221; functions?  A specification in English can leave this detail up to the implementation but a specification in code cannot; it must commit to one order or the other.  This may be a trivial example but I wonder if more consequential examples of over-specification are possible or even unavoidable.  I don&#8217;t know enough about metaclasses to know whether this is a risk.</p>
<p>Thank you.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jay Sistar				</title>
				<link>https://herbsutter.com/2017/09/28/my-cppcon-2017-session-is-now-on-youtube/#comment-39905</link>
		<dc:creator><![CDATA[Jay Sistar]]></dc:creator>
		<pubDate>Fri, 29 Sep 2017 01:07:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3429#comment-39905</guid>
					<description><![CDATA[I&#039;ve been waiting for more talks on this subject. I&#039;d really like this in MSVC, main-line Clang, and Gcc!]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve been waiting for more talks on this subject. I&#8217;d really like this in MSVC, main-line Clang, and Gcc!</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
