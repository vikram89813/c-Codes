<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Metaclasses: Thoughts on generative C++	</title>
	<atom:link href="https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: The best of C++ is what&#8217;s coming. &#8211; CppDepend Blog				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-40207</link>
		<dc:creator><![CDATA[The best of C++ is what&#8217;s coming. &#8211; CppDepend Blog]]></dc:creator>
		<pubDate>Mon, 09 Apr 2018 12:17:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-40207</guid>
					<description><![CDATA[[&#8230;] C++ a better language, and the last year he proposes the metaclasses feature. here&#8217;s from his post the motivation behind adding [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] C++ a better language, and the last year he proposes the metaclasses feature. here&#8217;s from his post the motivation behind adding [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: frank				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-40106</link>
		<dc:creator><![CDATA[frank]]></dc:creator>
		<pubDate>Thu, 21 Dec 2017 00:19:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-40106</guid>
					<description><![CDATA[This looks great! My only problem is understanding where the capabilities of metaclasses (or maybe even metafunctions) stop. Would all of the features below be possible?
- generating serializer functions automatically (e.g. to_json() or to_protobuf())
- generating wrappers for other languages like python avoid using awful tools like swig
- using different defaults for function arguments (e.g. everything const like in rust)
- solving the nightmare of writing multiple overloads for constructors with string arguments (see Nicolai&#039;s “The Nightmare of Move Semantics for Trivial Classes” cppcon talk) and algorithm interfaces (see David Sankel “Choosing an Abstraction” cppcon talk).]]></description>
		<content:encoded><![CDATA[<p>This looks great! My only problem is understanding where the capabilities of metaclasses (or maybe even metafunctions) stop. Would all of the features below be possible?<br />
&#8211; generating serializer functions automatically (e.g. to_json() or to_protobuf())<br />
&#8211; generating wrappers for other languages like python avoid using awful tools like swig<br />
&#8211; using different defaults for function arguments (e.g. everything const like in rust)<br />
&#8211; solving the nightmare of writing multiple overloads for constructors with string arguments (see Nicolai&#8217;s “The Nightmare of Move Semantics for Trivial Classes” cppcon talk) and algorithm interfaces (see David Sankel “Choosing an Abstraction” cppcon talk).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Shiv Kumar				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-40048</link>
		<dc:creator><![CDATA[Shiv Kumar]]></dc:creator>
		<pubDate>Tue, 14 Nov 2017 22:08:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-40048</guid>
					<description><![CDATA[Thank you Herb for your reply. I see your point, however I still feel we’ll be having conversations like, “is that your interface, my interface or std::interface” :)). The ability to be able to define one’s own keyword (C# vocabulary) is extremely powerful (to say the least) but also a maintenance nightmare, I feel. Further, as regards all of the other things one can do with Meta Classes – for those of us not hardcore C++ programmers a huge learning curve (I feel). Maybe it’s just me.]]></description>
		<content:encoded><![CDATA[<p>Thank you Herb for your reply. I see your point, however I still feel we’ll be having conversations like, “is that your interface, my interface or std::interface” :)). The ability to be able to define one’s own keyword (C# vocabulary) is extremely powerful (to say the least) but also a maintenance nightmare, I feel. Further, as regards all of the other things one can do with Meta Classes – for those of us not hardcore C++ programmers a huge learning curve (I feel). Maybe it’s just me.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-40047</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 14 Nov 2017 21:37:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-40047</guid>
					<description><![CDATA[Sorry for the delay catching up to comments... I think this batch of replies brings me up to date...

@Paul: Right, the prototype compiler is still very incomplete and just does the first handful of examples I linked.

Re removing things: Based on the current feedback at last week&#039;s ISO C++ meeting, we will actually be pursuing a functional style along the lines of the third option in section 5 of the updated paper at https://wg21.link/p0707, where the idea (among other things) is to treat each class as read-only... that is, the source-written class is read-only input, every &quot;metaclass&quot; is defined by a compile-time function that takes a read-only meta::type and builds up a new meta::type which is read-only after it is returned, etc. So think of it as a succession of additions. To remove something, you would copy &quot;everything except that something&quot; into a new meta::type.

Oh, and yes the committee is actively pursuing constexpr vector. However, this proposal does not rely on that.

@Tony: I&#039;m hopeful that compile times will be competitive, and better than expressing the same things more convolutedly using today&#039;s TMP and/or extra compilers.

@moonshadow: Lots of syntax variations are under consideration. I don&#039;t think we&#039;d reuse &quot;$this&quot; in particular beause that would already have a meaning (to reflect on the &#039;this&#039; parameter). But see section 5 of the current paper which mentions an example of where we&#039;d need to say &quot;this_class&quot; or similar.

@Shiv Kumar: Actually &quot;interface&quot; would be just another type, which we already disambiguate using namespaces. The idea is that if we standardized &quot;interface&quot; it would still be a library, not in the language, but put in namespace std:: along with all the other library types, and then if you want the standard one you&#039;d namespace-qualify &quot;std::interface Shape { /*...* };&quot;.

@raen: First, thanks! Specific comments follow...

Re syntax: Agreed, the committee last week gave guidance to steer toward a functional style (see earlier in this reply) which among other things removes much of the need to reflect and therefore to even use the strawman $ notation.

Re &quot;1. the meta function can be a free constexpr function&quot;: Yes, that&#039;s the direction the committee just encouraged.

Re &quot;2. the decorator would simply be applied with C++ attributes, with the possibility of chaining them&quot;: I probably wouldn&#039;t use attributes, but in general yes that&#039;s one of the alternatives -- see the alternatives showsn in the new section 6 of the paper at https://wg21.link/p0707.

Thanks all,

Herb]]></description>
		<content:encoded><![CDATA[<p>Sorry for the delay catching up to comments&#8230; I think this batch of replies brings me up to date&#8230;</p>
<p>@Paul: Right, the prototype compiler is still very incomplete and just does the first handful of examples I linked.</p>
<p>Re removing things: Based on the current feedback at last week&#8217;s ISO C++ meeting, we will actually be pursuing a functional style along the lines of the third option in section 5 of the updated paper at <a href="https://wg21.link/p0707" rel="nofollow">https://wg21.link/p0707</a>, where the idea (among other things) is to treat each class as read-only&#8230; that is, the source-written class is read-only input, every &#8220;metaclass&#8221; is defined by a compile-time function that takes a read-only meta::type and builds up a new meta::type which is read-only after it is returned, etc. So think of it as a succession of additions. To remove something, you would copy &#8220;everything except that something&#8221; into a new meta::type.</p>
<p>Oh, and yes the committee is actively pursuing constexpr vector. However, this proposal does not rely on that.</p>
<p>@Tony: I&#8217;m hopeful that compile times will be competitive, and better than expressing the same things more convolutedly using today&#8217;s TMP and/or extra compilers.</p>
<p>@moonshadow: Lots of syntax variations are under consideration. I don&#8217;t think we&#8217;d reuse &#8220;$this&#8221; in particular beause that would already have a meaning (to reflect on the &#8216;this&#8217; parameter). But see section 5 of the current paper which mentions an example of where we&#8217;d need to say &#8220;this_class&#8221; or similar.</p>
<p>@Shiv Kumar: Actually &#8220;interface&#8221; would be just another type, which we already disambiguate using namespaces. The idea is that if we standardized &#8220;interface&#8221; it would still be a library, not in the language, but put in namespace std:: along with all the other library types, and then if you want the standard one you&#8217;d namespace-qualify &#8220;std::interface Shape { /*&#8230;* };&#8221;.</p>
<p>@raen: First, thanks! Specific comments follow&#8230;</p>
<p>Re syntax: Agreed, the committee last week gave guidance to steer toward a functional style (see earlier in this reply) which among other things removes much of the need to reflect and therefore to even use the strawman $ notation.</p>
<p>Re &#8220;1. the meta function can be a free constexpr function&#8221;: Yes, that&#8217;s the direction the committee just encouraged.</p>
<p>Re &#8220;2. the decorator would simply be applied with C++ attributes, with the possibility of chaining them&#8221;: I probably wouldn&#8217;t use attributes, but in general yes that&#8217;s one of the alternatives &#8212; see the alternatives showsn in the new section 6 of the paper at <a href="https://wg21.link/p0707" rel="nofollow">https://wg21.link/p0707</a>.</p>
<p>Thanks all,</p>
<p>Herb</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: raen				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39952</link>
		<dc:creator><![CDATA[raen]]></dc:creator>
		<pubDate>Fri, 13 Oct 2017 00:55:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39952</guid>
					<description><![CDATA[Hi,

I assisted your Qt Keynote this morning. I like the idea of metaclass a lot, especially in sense that 
it complements very well the notion of templates.

Concerning the syntax, my first impression was apparently the same as the feedback given 
by the cpp committee: it introduces new symbols and 
keywords (somehow instead of ``struct`` we have something else), while at the end what 
we want is to transform a type through a function at compile time. The 
transformed type remains a type, so it would make sense to keep calling it a ``struct`` or 
a ``class``.

It also quite similar in principles to `bind` for functions: we create a new function from an existing one,
but again `bind` returns a new function.  

The committee suggestion to have something like

[code]
meta::type interface(const meta::type source) {
    // … basically same code …
};
[/code]

is quite similar to what I was thinking during your keynote. The primary design I have in mind is the metaclass 
concept from Python, which has been slightly modified for python3 but is quite effective and seems
to now have proven its design:

* a decorator indicates that a class is a metaclass, and the final executed class will be a transformed version
  of it
* the fact that a class is meta indicates the compiler/interpreter to apply the meta function on the initial type to get the final type.
  This is the metaclass protocol.
* the meta function that is called with the reflexion of the class being decorated is an entity that has the same type
  of construct as any other (in python: a class member function, or a free function)
* the meta function is evaluated at compile time (in python: when the interpreter sees the declaration of the class)

For the C++ counterpart of that, I believe not introducing any new notion or constructs (`$class`, `constexp{}`)
would have a better chance to convey the idea of metaclass in a proper way.

I would suggest this:

1. the meta function can be a free constexpr function, or a function object with a `static constexpr operator()`. 
  Calling this function, or the member function, with the right parameters, is the first step of the meta protocol 
  between the type being transformed and the transformation function.
  The advantage would be 
  to compose the meta function from eg. a template and member constexpr variables in an easier way for a developer

  [code]
  meta::type metaFunc1(const meta::type source) {
  };

  // here we could imagine meta2 behaving **exactly** as any struct, but with a 
  // required interface to be applied by the compiler
  template &#060;class T&#062;
  struct metaStruct2 {

    constexpr auto operator()(const meta::type source) {
      // here the returned type is a new type that is defined nowhere in 
      // the source code, auto make sense
      auto modified_source = source.add_member_function(); // each of your &#034;compiler&#034; command returns a new type or a compile time test
      auto modified_source2 = modified_source.delete_member(&#034;x&#034;);
      return modified_source2;
    }
  };
  [/code]
  
2. the decorator would simply be applied with C++ attributes, with the possibility of chaining them. Then they would be applied in order
  Something like
  [code]
  class [[meta(metaFunc1, metaStruct2&#060;4&#062;)]] 
  some_class_before_transformation{};
  [/code]

  In this case, we would apply first metaFunc1, then metaStruct2, etc

  Another possible syntax would be (since attributes can be ignored or are considered as language extensions) 
  to reveal the fact that we are applying a function transforming a type that is being declared:

  [code]
  class metaStruct2&#060;4&#062;(metaFunc1(some_class_before_transformation)) 
  {};
  [/code]

  which seems to me clearer and less ambiguous on the orders. It also reveals the fact that we are transforming a type that 
  has not yet been fully parsed. This does not really clash with the notion of `final` that you mention in your paper:
  `final` would be an attribute of a returned type, that would prevent its &quot;compiler casting&quot; to ``meta::type`` and stop
  the evaluation of the meta functions.

3. it would be possible to use type alias (w/wo template) with the meta functions:

  [code]
  using my_augmented_type = metaStruct2&#060;4&#062;(metaFunc1(some_class_before_transformation));

  template &#060;int Value&#062;
  using my_augmented_type2 = metaStruct2&#060;Value&#062;(some_class_before_transformation);
  [/code]

  One of the possibilities would be to enable or not eg. &quot;some checks&quot; depending on a boolean

  [code]
  template &#060;bool B = false&#062;
  struct metaStruct3 {
      constexpr auto operator()(const meta::type source) {
        return source; // defaults to identity
      }
  };

  template &#060;&#062;
  struct metaStruct3&#060;true&#062; {
      constexpr auto operator()(const meta::type source) {
        // instruments source
        return modified_source;
      }
  };  
  [/code]

Let me know if any of this makes sense :)

Best,

(apologies if I posted twice)]]></description>
		<content:encoded><![CDATA[<p>Hi,</p>
<p>I assisted your Qt Keynote this morning. I like the idea of metaclass a lot, especially in sense that<br />
it complements very well the notion of templates.</p>
<p>Concerning the syntax, my first impression was apparently the same as the feedback given<br />
by the cpp committee: it introduces new symbols and<br />
keywords (somehow instead of &#8220;struct&#8220; we have something else), while at the end what<br />
we want is to transform a type through a function at compile time. The<br />
transformed type remains a type, so it would make sense to keep calling it a &#8220;struct&#8220; or<br />
a &#8220;class&#8220;.</p>
<p>It also quite similar in principles to `bind` for functions: we create a new function from an existing one,<br />
but again `bind` returns a new function.  </p>
<p>The committee suggestion to have something like</p>
<pre class="brush: plain; title: ; notranslate">
meta::type interface(const meta::type source) {
    // … basically same code …
};
</pre>
<p>is quite similar to what I was thinking during your keynote. The primary design I have in mind is the metaclass<br />
concept from Python, which has been slightly modified for python3 but is quite effective and seems<br />
to now have proven its design:</p>
<p>* a decorator indicates that a class is a metaclass, and the final executed class will be a transformed version<br />
  of it<br />
* the fact that a class is meta indicates the compiler/interpreter to apply the meta function on the initial type to get the final type.<br />
  This is the metaclass protocol.<br />
* the meta function that is called with the reflexion of the class being decorated is an entity that has the same type<br />
  of construct as any other (in python: a class member function, or a free function)<br />
* the meta function is evaluated at compile time (in python: when the interpreter sees the declaration of the class)</p>
<p>For the C++ counterpart of that, I believe not introducing any new notion or constructs (`$class`, `constexp{}`)<br />
would have a better chance to convey the idea of metaclass in a proper way.</p>
<p>I would suggest this:</p>
<p>1. the meta function can be a free constexpr function, or a function object with a `static constexpr operator()`.<br />
  Calling this function, or the member function, with the right parameters, is the first step of the meta protocol<br />
  between the type being transformed and the transformation function.<br />
  The advantage would be<br />
  to compose the meta function from eg. a template and member constexpr variables in an easier way for a developer</p>
<pre class="brush: plain; title: ; notranslate">
  meta::type metaFunc1(const meta::type source) {
  };

  // here we could imagine meta2 behaving **exactly** as any struct, but with a 
  // required interface to be applied by the compiler
  template &lt;class T&gt;
  struct metaStruct2 {

    constexpr auto operator()(const meta::type source) {
      // here the returned type is a new type that is defined nowhere in 
      // the source code, auto make sense
      auto modified_source = source.add_member_function(); // each of your &quot;compiler&quot; command returns a new type or a compile time test
      auto modified_source2 = modified_source.delete_member(&quot;x&quot;);
      return modified_source2;
    }
  };
  </pre>
<p>2. the decorator would simply be applied with C++ attributes, with the possibility of chaining them. Then they would be applied in order<br />
  Something like</p>
<pre class="brush: plain; title: ; notranslate">
  class [[meta(metaFunc1, metaStruct2&lt;4&gt;)]] 
  some_class_before_transformation{};
  </pre>
<p>  In this case, we would apply first metaFunc1, then metaStruct2, etc</p>
<p>  Another possible syntax would be (since attributes can be ignored or are considered as language extensions)<br />
  to reveal the fact that we are applying a function transforming a type that is being declared:</p>
<pre class="brush: plain; title: ; notranslate">
  class metaStruct2&lt;4&gt;(metaFunc1(some_class_before_transformation)) 
  {};
  </pre>
<p>  which seems to me clearer and less ambiguous on the orders. It also reveals the fact that we are transforming a type that<br />
  has not yet been fully parsed. This does not really clash with the notion of `final` that you mention in your paper:<br />
  `final` would be an attribute of a returned type, that would prevent its &#8220;compiler casting&#8221; to &#8220;meta::type&#8220; and stop<br />
  the evaluation of the meta functions.</p>
<p>3. it would be possible to use type alias (w/wo template) with the meta functions:</p>
<pre class="brush: plain; title: ; notranslate">
  using my_augmented_type = metaStruct2&lt;4&gt;(metaFunc1(some_class_before_transformation));

  template &lt;int Value&gt;
  using my_augmented_type2 = metaStruct2&lt;Value&gt;(some_class_before_transformation);
  </pre>
<p>  One of the possibilities would be to enable or not eg. &#8220;some checks&#8221; depending on a boolean</p>
<pre class="brush: plain; title: ; notranslate">
  template &lt;bool B = false&gt;
  struct metaStruct3 {
      constexpr auto operator()(const meta::type source) {
        return source; // defaults to identity
      }
  };

  template &lt;&gt;
  struct metaStruct3&lt;true&gt; {
      constexpr auto operator()(const meta::type source) {
        // instruments source
        return modified_source;
      }
  };  
  </pre>
<p>Let me know if any of this makes sense :)</p>
<p>Best,</p>
<p>(apologies if I posted twice)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Shriram V				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39912</link>
		<dc:creator><![CDATA[Shriram V]]></dc:creator>
		<pubDate>Sat, 30 Sep 2017 04:45:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39912</guid>
					<description><![CDATA[One idea to mitigate that could be: Apart from namespaces that can be used to scope them, all meta class names in any user library can be made to require to start with an _ (e.g _interface), except those that are part of the standard library. Much like string literals.]]></description>
		<content:encoded><![CDATA[<p>One idea to mitigate that could be: Apart from namespaces that can be used to scope them, all meta class names in any user library can be made to require to start with an _ (e.g _interface), except those that are part of the standard library. Much like string literals.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Shiv Kumar				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39909</link>
		<dc:creator><![CDATA[Shiv Kumar]]></dc:creator>
		<pubDate>Fri, 29 Sep 2017 20:18:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39909</guid>
					<description><![CDATA[Hey Herb, I thoroughly enjoy your talks (in video format on YouTube). I&#039;m a full time C# programmer and a part time C++ programmer (mainly embedded systems), watching your C++ talks has essentially pushed me to explore C++ fairly recently...

On the face of it, I like Meta Classes, but the thought that the word &quot;interface&quot; could mean many things for folks is not really a good thing it is? I addressed this in your talk, but I&#039;m not convinced your argument is valid. Having a standardized meaning of interface has a real value for the language. Giving me to ability to doing other things with MetaClasses is great, but something&#039;s should be addressed by the language as a spec BEFORE we have a clutter of the meaning of &quot;interfaces&quot;. 

So in the case of interface you&#039;re saying this metaclass will be in the language. Ok, but I can have an interface metaclass in a different header file, include that header instead of the standard and now my entire program changes or has compile errors? Can I define my own metaclass for &quot;class&quot;? In C# I don&#039;t use extension methods for similar reasons. 
1. The meaning could change from file to file or project to project
2. When I switch projects or jobs, what I understand an interface will likely not have the same meaning
3. When I see &quot;interface&quot; on stack overflow I wouldn&#039;t know what that really means.

If standardization takes time then well, maybe it needs to be speeded up? :).]]></description>
		<content:encoded><![CDATA[<p>Hey Herb, I thoroughly enjoy your talks (in video format on YouTube). I&#8217;m a full time C# programmer and a part time C++ programmer (mainly embedded systems), watching your C++ talks has essentially pushed me to explore C++ fairly recently&#8230;</p>
<p>On the face of it, I like Meta Classes, but the thought that the word &#8220;interface&#8221; could mean many things for folks is not really a good thing it is? I addressed this in your talk, but I&#8217;m not convinced your argument is valid. Having a standardized meaning of interface has a real value for the language. Giving me to ability to doing other things with MetaClasses is great, but something&#8217;s should be addressed by the language as a spec BEFORE we have a clutter of the meaning of &#8220;interfaces&#8221;. </p>
<p>So in the case of interface you&#8217;re saying this metaclass will be in the language. Ok, but I can have an interface metaclass in a different header file, include that header instead of the standard and now my entire program changes or has compile errors? Can I define my own metaclass for &#8220;class&#8221;? In C# I don&#8217;t use extension methods for similar reasons.<br />
1. The meaning could change from file to file or project to project<br />
2. When I switch projects or jobs, what I understand an interface will likely not have the same meaning<br />
3. When I see &#8220;interface&#8221; on stack overflow I wouldn&#8217;t know what that really means.</p>
<p>If standardization takes time then well, maybe it needs to be speeded up? :).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: My CppCon 2017 session is now on YouTube &#124; Sutter’s Mill				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39904</link>
		<dc:creator><![CDATA[My CppCon 2017 session is now on YouTube &#124; Sutter’s Mill]]></dc:creator>
		<pubDate>Fri, 29 Sep 2017 00:17:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39904</guid>
					<description><![CDATA[[&#8230;] CppCon talk yesterday is now on YouTube. You can read more about in my July blog post on &#8220;Metaclasses: Thoughts on generative C++&#8221; which contains links to the current paper and some examples that work so far on the live prototype [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] CppCon talk yesterday is now on YouTube. You can read more about in my July blog post on &#8220;Metaclasses: Thoughts on generative C++&#8221; which contains links to the current paper and some examples that work so far on the live prototype [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: moonshadow				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39901</link>
		<dc:creator><![CDATA[moonshadow]]></dc:creator>
		<pubDate>Mon, 25 Sep 2017 16:18:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39901</guid>
					<description><![CDATA[How about using ``$this`` instead of the name of metaclass
or like this:
```
constexpr class interface {
    constexpr {
        compiler.require($this.variables().empty(), &quot;interfaces may not contain data&quot;);
   }
   interface(const decltype(this)&#038; that) = default;
};
```
Where the type of ``this`` (if its used from ``constexpr`` block or metaclass) be the type of the class which inherits it.
Wouldn&#039;t this simplify things?]]></description>
		<content:encoded><![CDATA[<p>How about using &#8220;$this&#8220; instead of the name of metaclass<br />
or like this:<br />
&#8220;`<br />
constexpr class interface {<br />
    constexpr {<br />
        compiler.require($this.variables().empty(), &#8220;interfaces may not contain data&#8221;);<br />
   }<br />
   interface(const decltype(this)&amp; that) = default;<br />
};<br />
&#8220;`<br />
Where the type of &#8220;this&#8220; (if its used from &#8220;constexpr&#8220; block or metaclass) be the type of the class which inherits it.<br />
Wouldn&#8217;t this simplify things?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jen				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39894</link>
		<dc:creator><![CDATA[Jen]]></dc:creator>
		<pubDate>Mon, 18 Sep 2017 19:49:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39894</guid>
					<description><![CDATA[I absolutely love this proposal.  When I was done reading it, I was left thinking that the only thing it needs is to be paired with a niladic function proposal like N1611 (Implicitly-Callable Functions).  The combination would allow for properties like in other languages, by generating a niladic function from a metaclass that returns a proxy object that provides any appropriate function overloads.  It also turns all the difficult questions about property semantics into user-defined code, rather than trying to normalize specific semantics in the core language.]]></description>
		<content:encoded><![CDATA[<p>I absolutely love this proposal.  When I was done reading it, I was left thinking that the only thing it needs is to be paired with a niladic function proposal like N1611 (Implicitly-Callable Functions).  The combination would allow for properties like in other languages, by generating a niladic function from a metaclass that returns a proxy object that provides any appropriate function overloads.  It also turns all the difficult questions about property semantics into user-defined code, rather than trying to normalize specific semantics in the core language.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tony Rivière				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39832</link>
		<dc:creator><![CDATA[Tony Rivière]]></dc:creator>
		<pubDate>Fri, 01 Sep 2017 15:18:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39832</guid>
					<description><![CDATA[I&#039;ve watched your presentation just yesterday, without any knowledge of what it would be about.
Beside my eyes shined even more at each new slide, it&#039;s just like you&#039;ve answered all C++ issues with this killer feature. I&#039;m C++ developers for 10 years now, and metaclasses bring to life all features I could dream of for C++.

For the examples you mentioned in your presentation, my only feedback is: yes we wanted that because they were missing features that are present on other languages. The good point is that we will be able to make our own semantic by ourselves. Taking the property example, there are plenty ways to design a property like object with more or less features. And instead of waiting several years for the committee to validate a proposition, we will have the tools to implement it directly.

Here are few &quot;issues&quot; that could be solve using metaclasses:
- dot operator dilemma, for any forward wrapper like reference_wrapper, one of the main issue using dot operator is: does it grant you access to the wrapper functions? the T functions? or both? With a reference_wrapper metaclass we don&#039;t care anymore since we will have the choice to implement it like we want. In this case: for all functions of T, add a function inside reference_wrapper which just forward the parameters to the T function. But for another kind of forward wrapper, we can imagine different rules.
- in the same idea: we could wrap a type T to be always contained inside shared_ptr transparently.
- automatically generate wrappers to another language.
- automatically generate boilerplate code (factory, etc...)
- override default historical choices of the C++ like everything is mutable and you have to explicitly apply const whenever it&#039;s needed, compared to Rust where everything is const by default.

To answer people saying that it will increase the complexity and readibility of a code because it introduce potentially an infinite number of class behavior aside &quot;class&quot; and &quot;struct&quot;, I would say it&#039;s already what templates do except that metaprogramming using templates can become really hard to read and maintain if you&#039;re not an expert. I hope metaclasses will allow us to do more metaprogramming, more easily, more readable / smoother syntax, with less painful error messages than templates.

Regarding the syntax $class vs a function call: I really prefer the $class syntax because it looks more like a declarative thing. To me, a function is made for executing something (whatever it&#039;s done at compile time or runtime). But here, the metaclass is something that we declare, not something that we compute.

@Herb
I got few more questions:
- Do you expect metaclasses to compile (far more) faster than templates? I guess yes.
- I don&#039;t know if there are proposals for generalized attributes like C# attributes (inside []) that can be used to flag any class, function or data member - but can we imagine that we could some C#-like attributes to have even better control over what can be generated by metaclasses? For example: tell which members have to be serialized or not.

Anyway, I definitely cannot wait to gets my hand on. I have many ideas I would like to implement that would benefit the simplicity of metaclasses compared to templates.

And please, make it available through Visual Studio soon enough :)

Thanks for this brilliant and revolutionary idea.  Looking forward for any updates.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve watched your presentation just yesterday, without any knowledge of what it would be about.<br />
Beside my eyes shined even more at each new slide, it&#8217;s just like you&#8217;ve answered all C++ issues with this killer feature. I&#8217;m C++ developers for 10 years now, and metaclasses bring to life all features I could dream of for C++.</p>
<p>For the examples you mentioned in your presentation, my only feedback is: yes we wanted that because they were missing features that are present on other languages. The good point is that we will be able to make our own semantic by ourselves. Taking the property example, there are plenty ways to design a property like object with more or less features. And instead of waiting several years for the committee to validate a proposition, we will have the tools to implement it directly.</p>
<p>Here are few &#8220;issues&#8221; that could be solve using metaclasses:<br />
&#8211; dot operator dilemma, for any forward wrapper like reference_wrapper, one of the main issue using dot operator is: does it grant you access to the wrapper functions? the T functions? or both? With a reference_wrapper metaclass we don&#8217;t care anymore since we will have the choice to implement it like we want. In this case: for all functions of T, add a function inside reference_wrapper which just forward the parameters to the T function. But for another kind of forward wrapper, we can imagine different rules.<br />
&#8211; in the same idea: we could wrap a type T to be always contained inside shared_ptr transparently.<br />
&#8211; automatically generate wrappers to another language.<br />
&#8211; automatically generate boilerplate code (factory, etc&#8230;)<br />
&#8211; override default historical choices of the C++ like everything is mutable and you have to explicitly apply const whenever it&#8217;s needed, compared to Rust where everything is const by default.</p>
<p>To answer people saying that it will increase the complexity and readibility of a code because it introduce potentially an infinite number of class behavior aside &#8220;class&#8221; and &#8220;struct&#8221;, I would say it&#8217;s already what templates do except that metaprogramming using templates can become really hard to read and maintain if you&#8217;re not an expert. I hope metaclasses will allow us to do more metaprogramming, more easily, more readable / smoother syntax, with less painful error messages than templates.</p>
<p>Regarding the syntax $class vs a function call: I really prefer the $class syntax because it looks more like a declarative thing. To me, a function is made for executing something (whatever it&#8217;s done at compile time or runtime). But here, the metaclass is something that we declare, not something that we compute.</p>
<p>@Herb<br />
I got few more questions:<br />
&#8211; Do you expect metaclasses to compile (far more) faster than templates? I guess yes.<br />
&#8211; I don&#8217;t know if there are proposals for generalized attributes like C# attributes (inside []) that can be used to flag any class, function or data member &#8211; but can we imagine that we could some C#-like attributes to have even better control over what can be generated by metaclasses? For example: tell which members have to be serialized or not.</p>
<p>Anyway, I definitely cannot wait to gets my hand on. I have many ideas I would like to implement that would benefit the simplicity of metaclasses compared to templates.</p>
<p>And please, make it available through Visual Studio soon enough :)</p>
<p>Thanks for this brilliant and revolutionary idea.  Looking forward for any updates.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ Annotated: Apr – Aug 2017 &#124; CLion Blog				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39829</link>
		<dc:creator><![CDATA[C++ Annotated: Apr – Aug 2017 &#124; CLion Blog]]></dc:creator>
		<pubDate>Tue, 29 Aug 2017 12:51:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39829</guid>
					<description><![CDATA[[&#8230;] full collection of links for further reading can be found in this blog post by Herb Sutter. And if you are looking for a short technical summary of Herb’s proposal, check the blog post by [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] full collection of links for further reading can be found in this blog post by Herb Sutter. And if you are looking for a short technical summary of Herb’s proposal, check the blog post by [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ Annotated: Apr – Aug 2017 - ReSharper C++ BlogReSharper C++ Blog				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39828</link>
		<dc:creator><![CDATA[C++ Annotated: Apr – Aug 2017 - ReSharper C++ BlogReSharper C++ Blog]]></dc:creator>
		<pubDate>Tue, 29 Aug 2017 10:34:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39828</guid>
					<description><![CDATA[[&#8230;] full collection of links for further reading can be found in this blog post by Herb Sutter. And if you are looking for a short technical summary of Herb’s proposal, check the blog post by [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] full collection of links for further reading can be found in this blog post by Herb Sutter. And if you are looking for a short technical summary of Herb’s proposal, check the blog post by [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39827</link>
		<dc:creator><![CDATA[Paul]]></dc:creator>
		<pubDate>Mon, 28 Aug 2017 21:43:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39827</guid>
					<description><![CDATA[I am wondering though, how is clear implemented? Would this require a &quot;constexpr vector&quot; implementation? If so, how is the &quot;constexpr vector&quot; implemented?]]></description>
		<content:encoded><![CDATA[<p>I am wondering though, how is clear implemented? Would this require a &#8220;constexpr vector&#8221; implementation? If so, how is the &#8220;constexpr vector&#8221; implemented?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39826</link>
		<dc:creator><![CDATA[Paul]]></dc:creator>
		<pubDate>Mon, 28 Aug 2017 20:41:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39826</guid>
					<description><![CDATA[Hey, I would like ask a few things about how this proposal and how it will progress in the future.

I am currently checking out the cppx-compiler and it seems that with the current state of libcppx, it doesn&#039;t provide all features which are needed to eg. imlement the safe_union metaclass.

The interesting thing here is that members can be removed, injected and iterated through. I guess this isn&#039;t implemented yet? Or has there been changes in this regards?

I am also wondering though, if you plan to expand the &quot;removal behavior&quot; to more &quot;iterable reflections&quot;, something like removing all base classes with &quot;$metaclass.bases().clear()&quot;.]]></description>
		<content:encoded><![CDATA[<p>Hey, I would like ask a few things about how this proposal and how it will progress in the future.</p>
<p>I am currently checking out the cppx-compiler and it seems that with the current state of libcppx, it doesn&#8217;t provide all features which are needed to eg. imlement the safe_union metaclass.</p>
<p>The interesting thing here is that members can be removed, injected and iterated through. I guess this isn&#8217;t implemented yet? Or has there been changes in this regards?</p>
<p>I am also wondering though, if you plan to expand the &#8220;removal behavior&#8221; to more &#8220;iterable reflections&#8221;, something like removing all base classes with &#8220;$metaclass.bases().clear()&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: amirshrestha				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39803</link>
		<dc:creator><![CDATA[amirshrestha]]></dc:creator>
		<pubDate>Tue, 15 Aug 2017 20:53:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39803</guid>
					<description><![CDATA[This proposal is definitely on my reading lists. I hope I could attend your CppCon 2017 talk this September!]]></description>
		<content:encoded><![CDATA[<p>This proposal is definitely on my reading lists. I hope I could attend your CppCon 2017 talk this September!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39801</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 13 Aug 2017 23:24:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39801</guid>
					<description><![CDATA[@soulformachine Consider that a metaclass can compute anything that is reflectable and constexpr-computable, (although the prototype currently only supports a small subset of that) and all the rules you&#039;d like to express are computable at compile time using reflection... and see also the paper&#039;s safe_union example for a type that completely replaces the declared implementation.

@Christian The non-virtual interface idiom (NVI) is a recurring and useful idiom, especially for classes that also have implementation, not a do-always rule. Pure public interfaces are a perfectly valid pattern -- it&#039;s just until now they have been written entirely by convention without any guard rails where the compiler can help enforce we followed the intent and that it stays that way under maintenance.]]></description>
		<content:encoded><![CDATA[<p>@soulformachine Consider that a metaclass can compute anything that is reflectable and constexpr-computable, (although the prototype currently only supports a small subset of that) and all the rules you&#8217;d like to express are computable at compile time using reflection&#8230; and see also the paper&#8217;s safe_union example for a type that completely replaces the declared implementation.</p>
<p>@Christian The non-virtual interface idiom (NVI) is a recurring and useful idiom, especially for classes that also have implementation, not a do-always rule. Pure public interfaces are a perfectly valid pattern &#8212; it&#8217;s just until now they have been written entirely by convention without any guard rails where the compiler can help enforce we followed the intent and that it stays that way under maintenance.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Christian Hackl				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39799</link>
		<dc:creator><![CDATA[Christian Hackl]]></dc:creator>
		<pubDate>Fri, 11 Aug 2017 15:49:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39799</guid>
					<description><![CDATA[Isn&#039;t the interface example which appears in the proposal and which is being discussed here a blatant violation of your own guidelines regarding the &quot;non-virtual interface idiom&quot; (http://www.gotw.ca/publications/mill18.htm), according to which virtual functions in C++ should usually be private and public functions should usually be non-virtual?]]></description>
		<content:encoded><![CDATA[<p>Isn&#8217;t the interface example which appears in the proposal and which is being discussed here a blatant violation of your own guidelines regarding the &#8220;non-virtual interface idiom&#8221; (<a href="http://www.gotw.ca/publications/mill18.htm" rel="nofollow">http://www.gotw.ca/publications/mill18.htm</a>), according to which virtual functions in C++ should usually be private and public functions should usually be non-virtual?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: soulformachine				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39798</link>
		<dc:creator><![CDATA[soulformachine]]></dc:creator>
		<pubDate>Fri, 11 Aug 2017 07:33:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39798</guid>
					<description><![CDATA[@HerbSutter: I guess that would work, I like the fact that the details would be hidden away behind $class interface and say $class implementation, but what worries me is that this is just a way of providing a nicer syntax for the existing system and not a tool which can change the system so that for example in this case a solution can be produced which is more efficient than virtual inheritance (if there is one). Also it would not be possible to provide interface behavior such as in C# which can provide interface function implementation through a base class which is unrelated to interface but has a function with the same signature:

[code]
interface IA
{
    void foo();
}
    
class B
{
    public void foo() { }
}
    
class A : B, IA
{
        
}
    
public class Program
{
    public static void Main(string[] args)
    {
        IA a = new A();
        a.foo();
    }
}
[/code]

Also, it would still be possible to derive a class from an interface, which would produce different behavior, unless there is a possibility to say &quot;this $class is final unless the deriving $class is implementation&quot;.]]></description>
		<content:encoded><![CDATA[<p>@HerbSutter: I guess that would work, I like the fact that the details would be hidden away behind $class interface and say $class implementation, but what worries me is that this is just a way of providing a nicer syntax for the existing system and not a tool which can change the system so that for example in this case a solution can be produced which is more efficient than virtual inheritance (if there is one). Also it would not be possible to provide interface behavior such as in C# which can provide interface function implementation through a base class which is unrelated to interface but has a function with the same signature:</p>
<pre class="brush: plain; title: ; notranslate">
interface IA
{
    void foo();
}
    
class B
{
    public void foo() { }
}
    
class A : B, IA
{
        
}
    
public class Program
{
    public static void Main(string[] args)
    {
        IA a = new A();
        a.foo();
    }
}
</pre>
<p>Also, it would still be possible to derive a class from an interface, which would produce different behavior, unless there is a possibility to say &#8220;this $class is final unless the deriving $class is implementation&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39795</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 10 Aug 2017 01:16:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39795</guid>
					<description><![CDATA[@soulformachine: If you want such a system, you can use a metaclass for your derived classes that recognizes interfaces and inherits from them virtually by default. Would that address your concern?]]></description>
		<content:encoded><![CDATA[<p>@soulformachine: If you want such a system, you can use a metaclass for your derived classes that recognizes interfaces and inherits from them virtually by default. Would that address your concern?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39794</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 10 Aug 2017 01:04:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39794</guid>
					<description><![CDATA[@Alex:

You wrote: &quot;I don’t like resulting property metaclass because we express similar things (property attributes like type, name, getter, setter, scriptable etc) using very different C++ constructs (like type name, tag types, return type or names of data members).&quot;

Sure, that&#039;s a reasonable point for the example I gave. The actual Qt property will be more elegant than my initial strawman, which was mostly to demonstrate capability. The flexibility we have gives lots of ways to design a property metaclass... for example, if we changed the requirements to (this again is just a strawman that approximates the published Qt rules, see http://doc.qt.io/qt-5/properties.html):

•	We recognize as a “get” any function that is const and returns T or T const&#038;.
•	We recognize as a “set” any function that is non-const and takes exactly one parameter of type T, T&#038;, or T const&#038;.
•	We recognize as a “notify” any function declaration that is a signal function in the same class.

then you could write this in your example:

[code]
property&#060;bool&#062; focus : scriptable, revision(3) {
    bool hasFocus() const { return ::HasFocus(m_widgetHandle); /* ??? */ }
    void focusChanged();
};
[/code]

or, since we can also reflect over attributes:

[code]
property&#060;bool&#062; focus [[scriptable, revision(3)]] {
    bool hasFocus() const { return ::HasFocus(m_widgetHandle); /* ??? */ }
    void focusChanged();
};
[/code]

or many other variations.

The major point here is that you can match Qt rules pretty much exactly, or WinRT rules, etc. plus have strong expressive power to express an opinion on what your users&#039; code would best look like -- but never straying far from the C++ grammar, since it has to match the C++ grammar, so we couple great flexibility with constraints that help ensure the result still &quot;looks like C++&quot; even though it is expressing things C++ could never express before. As with any (meta)class design, taste comes into play, and the (meta)class author has the flexibility to express their taste as well as express their core requirements and functionality. -- Just as with classes, metaclasses offer flexible expressive power to let the (meta)class designer express what they want and make their (meta)class usable in the way that they want. And so I fully expect that we&#039;ll get &quot;Effective C++ Metaclass Design&quot; design guidance just as we have &quot;Effective C++ Class Desigh&quot; guidance (i.e., &quot;just because you can doesn&#039;t mean you should&quot;); we are just now learning those style rules for metaclasses, just as we did with classes in the late 80s and early 90s.

And regarding the use of m_widgetHandle in the property getter definition, the short answer is &quot;yes that should work&quot; and the hint as to why is &quot;same as in-class member function definitions and non-static data member initializers.&quot;  [*]

Does that help to address some of your concerns, even if it may not yet address all of them completely?



    [*] Far too briefly, but enough that you&#039;ll get the idea if you&#039;re familiar with compilers: In-class member function definitions and member initializers already effectively require two-pass compilation of the class definition -- it&#039;s the only place in C++ that requires two-pass today, so that you can refer to something that is not declared until later in the source file. Actual compilers like GCC and Clang implement this by effectively storing up the tokens of the function definition (doing just brace matching) or default initializer (looking for the ;) and then not actually even parsing the contents of those things (never mind doing semantic analysis, name lookup, etc.) until after the class is fully defined. -- And that same rule should apply here, so that the function body above would be parsed after the enclosing class is fully defined, which is after its metaclass has run and moved the functions there so they&#039;re in a scope where they can refer to each other naturally. -- Two things to note about this: (a) it&#039;s just the same rule C++ already has today for in-class function definitions, and (b) it just does what the user expects in other languages where properties are nested scopes so I don&#039;t expect this to be surprising. Having said that, we absolutely won&#039;t know until we validate the above by implementing it in real compilers and then testing it with real users. That&#039;s real work and design risk, and I&#039;m not minimizing it, just saying why technically we think it&#039;s sound at this point.]]></description>
		<content:encoded><![CDATA[<p>@Alex:</p>
<p>You wrote: &#8220;I don’t like resulting property metaclass because we express similar things (property attributes like type, name, getter, setter, scriptable etc) using very different C++ constructs (like type name, tag types, return type or names of data members).&#8221;</p>
<p>Sure, that&#8217;s a reasonable point for the example I gave. The actual Qt property will be more elegant than my initial strawman, which was mostly to demonstrate capability. The flexibility we have gives lots of ways to design a property metaclass&#8230; for example, if we changed the requirements to (this again is just a strawman that approximates the published Qt rules, see <a href="http://doc.qt.io/qt-5/properties.html" rel="nofollow">http://doc.qt.io/qt-5/properties.html</a>):</p>
<p>•	We recognize as a “get” any function that is const and returns T or T const&amp;.<br />
•	We recognize as a “set” any function that is non-const and takes exactly one parameter of type T, T&amp;, or T const&amp;.<br />
•	We recognize as a “notify” any function declaration that is a signal function in the same class.</p>
<p>then you could write this in your example:</p>
<pre class="brush: plain; title: ; notranslate">
property&lt;bool&gt; focus : scriptable, revision(3) {
    bool hasFocus() const { return ::HasFocus(m_widgetHandle); /* ??? */ }
    void focusChanged();
};
</pre>
<p>or, since we can also reflect over attributes:</p>
<pre class="brush: plain; title: ; notranslate">
property&lt;bool&gt; focus [[scriptable, revision(3)]] {
    bool hasFocus() const { return ::HasFocus(m_widgetHandle); /* ??? */ }
    void focusChanged();
};
</pre>
<p>or many other variations.</p>
<p>The major point here is that you can match Qt rules pretty much exactly, or WinRT rules, etc. plus have strong expressive power to express an opinion on what your users&#8217; code would best look like &#8212; but never straying far from the C++ grammar, since it has to match the C++ grammar, so we couple great flexibility with constraints that help ensure the result still &#8220;looks like C++&#8221; even though it is expressing things C++ could never express before. As with any (meta)class design, taste comes into play, and the (meta)class author has the flexibility to express their taste as well as express their core requirements and functionality. &#8212; Just as with classes, metaclasses offer flexible expressive power to let the (meta)class designer express what they want and make their (meta)class usable in the way that they want. And so I fully expect that we&#8217;ll get &#8220;Effective C++ Metaclass Design&#8221; design guidance just as we have &#8220;Effective C++ Class Desigh&#8221; guidance (i.e., &#8220;just because you can doesn&#8217;t mean you should&#8221;); we are just now learning those style rules for metaclasses, just as we did with classes in the late 80s and early 90s.</p>
<p>And regarding the use of m_widgetHandle in the property getter definition, the short answer is &#8220;yes that should work&#8221; and the hint as to why is &#8220;same as in-class member function definitions and non-static data member initializers.&#8221;  [*]</p>
<p>Does that help to address some of your concerns, even if it may not yet address all of them completely?</p>
<p>    [*] Far too briefly, but enough that you&#8217;ll get the idea if you&#8217;re familiar with compilers: In-class member function definitions and member initializers already effectively require two-pass compilation of the class definition &#8212; it&#8217;s the only place in C++ that requires two-pass today, so that you can refer to something that is not declared until later in the source file. Actual compilers like GCC and Clang implement this by effectively storing up the tokens of the function definition (doing just brace matching) or default initializer (looking for the ;) and then not actually even parsing the contents of those things (never mind doing semantic analysis, name lookup, etc.) until after the class is fully defined. &#8212; And that same rule should apply here, so that the function body above would be parsed after the enclosing class is fully defined, which is after its metaclass has run and moved the functions there so they&#8217;re in a scope where they can refer to each other naturally. &#8212; Two things to note about this: (a) it&#8217;s just the same rule C++ already has today for in-class function definitions, and (b) it just does what the user expects in other languages where properties are nested scopes so I don&#8217;t expect this to be surprising. Having said that, we absolutely won&#8217;t know until we validate the above by implementing it in real compilers and then testing it with real users. That&#8217;s real work and design risk, and I&#8217;m not minimizing it, just saying why technically we think it&#8217;s sound at this point.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jay Sistar				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39791</link>
		<dc:creator><![CDATA[Jay Sistar]]></dc:creator>
		<pubDate>Wed, 09 Aug 2017 16:12:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39791</guid>
					<description><![CDATA[I know that it has been said that these features will not make it into C++20, but we do have a Clang version that implements some of it. When could we expect Visual C++ to have it?]]></description>
		<content:encoded><![CDATA[<p>I know that it has been said that these features will not make it into C++20, but we do have a Clang version that implements some of it. When could we expect Visual C++ to have it?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: soulformachine				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39786</link>
		<dc:creator><![CDATA[soulformachine]]></dc:creator>
		<pubDate>Tue, 08 Aug 2017 05:08:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39786</guid>
					<description><![CDATA[Consider this case with a hierarchy of interfaces and implementation classes:

[code]
interface IA {
    void foo();
};

interface IB : IA {
    void bar();
};


class A : public IA {
public:
    void foo() override {}
};

class B : public A, public IB {
public:
    void bar() override {}

    // but now we have to also provide foo override introduced by IB,
    // even though IA has been implemented by base class A
    void foo() override { A::foo(); }
};
[/code]

Interfaces would still not act as in other languages, not without an ability to do virtual table fixup, or enforce virtual inheritance with that meta code.]]></description>
		<content:encoded><![CDATA[<p>Consider this case with a hierarchy of interfaces and implementation classes:</p>
<pre class="brush: plain; title: ; notranslate">
interface IA {
    void foo();
};

interface IB : IA {
    void bar();
};


class A : public IA {
public:
    void foo() override {}
};

class B : public A, public IB {
public:
    void bar() override {}

    // but now we have to also provide foo override introduced by IB,
    // even though IA has been implemented by base class A
    void foo() override { A::foo(); }
};
</pre>
<p>Interfaces would still not act as in other languages, not without an ability to do virtual table fixup, or enforce virtual inheritance with that meta code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: RiaD				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39785</link>
		<dc:creator><![CDATA[RiaD]]></dc:creator>
		<pubDate>Sun, 06 Aug 2017 21:43:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39785</guid>
					<description><![CDATA[You didn’t say anything about namespacing, it probably better be smth like std::interface etc which looks less nice]]></description>
		<content:encoded><![CDATA[<p>You didn’t say anything about namespacing, it probably better be smth like std::interface etc which looks less nice</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: RiaD				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39784</link>
		<dc:creator><![CDATA[RiaD]]></dc:creator>
		<pubDate>Sun, 06 Aug 2017 21:43:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39784</guid>
					<description><![CDATA[Note, that it’s hard to get the difference between creating a class and creating a member (it’s actually specific to the previous definitions)

vector x{}
vs
property y{}]]></description>
		<content:encoded><![CDATA[<p>Note, that it’s hard to get the difference between creating a class and creating a member (it’s actually specific to the previous definitions)</p>
<p>vector x{}<br />
vs<br />
property y{}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xaizek (@xaizek)				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39781</link>
		<dc:creator><![CDATA[xaizek (@xaizek)]]></dc:creator>
		<pubDate>Sun, 06 Aug 2017 12:56:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39781</guid>
					<description><![CDATA[While this might reduce amount of macros/boilerplate used to generate some classes, my overall impression of defining &quot;interface&quot; and alike is basically this:
[code]
#define BEGIN {
#define END }
[/code]]]></description>
		<content:encoded><![CDATA[<p>While this might reduce amount of macros/boilerplate used to generate some classes, my overall impression of defining &#8220;interface&#8221; and alike is basically this:</p>
<pre class="brush: plain; title: ; notranslate">
#define BEGIN {
#define END }
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Shriram V				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39779</link>
		<dc:creator><![CDATA[Shriram V]]></dc:creator>
		<pubDate>Thu, 03 Aug 2017 14:43:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39779</guid>
					<description><![CDATA[Herb, it&#039;s a really cool proposal! We can then create DSLs as we like, implemented as a standard c++ library!!

Would it be possible to implement features like memory safety, thread safety equivalent to how Rust provides?]]></description>
		<content:encoded><![CDATA[<p>Herb, it&#8217;s a really cool proposal! We can then create DSLs as we like, implemented as a standard c++ library!!</p>
<p>Would it be possible to implement features like memory safety, thread safety equivalent to how Rust provides?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alex Zhondin				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39775</link>
		<dc:creator><![CDATA[Alex Zhondin]]></dc:creator>
		<pubDate>Wed, 02 Aug 2017 09:03:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39775</guid>
					<description><![CDATA[I&#039;m seeing your example of properties.
Some notes:

1. You wrote:
	This metaclass implements the following requirements and defaults:
	• Each function’s name must begin with “get” or “set.”
	• T must be copyable.
	• Apply any other Qt property rules
	
It&#039;s not true. Getters/Setters may have arbitrary names. We could have read-only property with const ref return type, so it could be non-copyable.

2. Anyway, I&#039;m just trying to build up more compete example of the property metaclass.
Using your idea of signal/slot as helper types I came to the following:

Qt property declaration:
    Q_PROPERTY(bool focus READ hasFocus NOTIFY focusChanged SCRIPTABLE true REVISION 3)
	
C++ property declaration:
	property focus {
		getter hasFocus() const { return ::HasFocus(m_widgetHandle); /* ??? */ }
		notifier focusChanged();
		bool scriptable = true;
		int revision = 3;
	};
	
Where getter/setter/notifier are helper types to mark or distinguish property attributes (READ/WRITE/NOTIFY etc.)

Note that line with /* ??? */ is lexically not correct because uses m_widgetHandle from outer class.
Is this (using outer class members or similar &quot;incorrect&quot; code) will be forbidden?

I don&#039;t like resulting property metaclass because we express similar things (property attributes like type, name, getter, setter, scriptable etc) using very different C++ constructs (like type name, tag types, return type or names of data members).
And more over we use redundant words (like &quot;int&quot; for revision) just because of C++ syntax requirement.

I consider metaclasses as attempt to introduce &quot;programmable&quot; declaration statements into C++.
And you want to limit it by existing C++ declaration facilities like class/subclass declarations, data and function members.
It works in simple cases like $interface where you introduce just replacement for &quot;class&quot; keyword.
But more complex and useful declarative statements looks unnatural at my opinion.

I&#039;m programming C++ quite a long time (&#062;10 years) and noticed that C++ is too imperative (and thus more verbose) in some cases. We had to invent DSLs (Domain Specific Language) to eliminate writing a lot of required but &quot;stupid&quot; code. Just like interfaces and value classes do in your proposal. You could see as example my project https://github.com/lexxmark/QtnProperty.

So I wonder at some time metaclasses will replace all these DSLs (I&#039;m consigering Qt classes and WinRT as DSL too). But I think C++ declarative facilities not enough to cover all cases. We need more unified and powerful declarative syntax like JSON or QML.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m seeing your example of properties.<br />
Some notes:</p>
<p>1. You wrote:<br />
	This metaclass implements the following requirements and defaults:<br />
	• Each function’s name must begin with “get” or “set.”<br />
	• T must be copyable.<br />
	• Apply any other Qt property rules</p>
<p>It&#8217;s not true. Getters/Setters may have arbitrary names. We could have read-only property with const ref return type, so it could be non-copyable.</p>
<p>2. Anyway, I&#8217;m just trying to build up more compete example of the property metaclass.<br />
Using your idea of signal/slot as helper types I came to the following:</p>
<p>Qt property declaration:<br />
    Q_PROPERTY(bool focus READ hasFocus NOTIFY focusChanged SCRIPTABLE true REVISION 3)</p>
<p>C++ property declaration:<br />
	property focus {<br />
		getter hasFocus() const { return ::HasFocus(m_widgetHandle); /* ??? */ }<br />
		notifier focusChanged();<br />
		bool scriptable = true;<br />
		int revision = 3;<br />
	};</p>
<p>Where getter/setter/notifier are helper types to mark or distinguish property attributes (READ/WRITE/NOTIFY etc.)</p>
<p>Note that line with /* ??? */ is lexically not correct because uses m_widgetHandle from outer class.<br />
Is this (using outer class members or similar &#8220;incorrect&#8221; code) will be forbidden?</p>
<p>I don&#8217;t like resulting property metaclass because we express similar things (property attributes like type, name, getter, setter, scriptable etc) using very different C++ constructs (like type name, tag types, return type or names of data members).<br />
And more over we use redundant words (like &#8220;int&#8221; for revision) just because of C++ syntax requirement.</p>
<p>I consider metaclasses as attempt to introduce &#8220;programmable&#8221; declaration statements into C++.<br />
And you want to limit it by existing C++ declaration facilities like class/subclass declarations, data and function members.<br />
It works in simple cases like $interface where you introduce just replacement for &#8220;class&#8221; keyword.<br />
But more complex and useful declarative statements looks unnatural at my opinion.</p>
<p>I&#8217;m programming C++ quite a long time (&gt;10 years) and noticed that C++ is too imperative (and thus more verbose) in some cases. We had to invent DSLs (Domain Specific Language) to eliminate writing a lot of required but &#8220;stupid&#8221; code. Just like interfaces and value classes do in your proposal. You could see as example my project <a href="https://github.com/lexxmark/QtnProperty" rel="nofollow">https://github.com/lexxmark/QtnProperty</a>.</p>
<p>So I wonder at some time metaclasses will replace all these DSLs (I&#8217;m consigering Qt classes and WinRT as DSL too). But I think C++ declarative facilities not enough to cover all cases. We need more unified and powerful declarative syntax like JSON or QML.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Robert Andrzejuk				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39774</link>
		<dc:creator><![CDATA[Robert Andrzejuk]]></dc:creator>
		<pubDate>Wed, 02 Aug 2017 09:00:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39774</guid>
					<description><![CDATA[Here&#039;s an idea, define a meta-class:
&quot;fake&quot;: all functions from inherited classes /return default values/are erased(compile time error when called)/.../
&quot;mock&quot;: /.../
&quot;test-fixture&quot;: /.../
&quot;tests&quot;: /.../

Wonder if/how that will work? :-)
O my ... 6 years to wait for this feature ...
(I wonder if meta-functions are plausible?)]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s an idea, define a meta-class:<br />
&#8220;fake&#8221;: all functions from inherited classes /return default values/are erased(compile time error when called)/&#8230;/<br />
&#8220;mock&#8221;: /&#8230;/<br />
&#8220;test-fixture&#8221;: /&#8230;/<br />
&#8220;tests&#8221;: /&#8230;/</p>
<p>Wonder if/how that will work? :-)<br />
O my &#8230; 6 years to wait for this feature &#8230;<br />
(I wonder if meta-functions are plausible?)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39772</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 01 Aug 2017 14:24:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39772</guid>
					<description><![CDATA[@kpfleming: The original intention when that code was written before constexpr blocks was that they be visible, yes. However now those variables should be injected into the class, or the constexpr block extended, if they are going to be used. I will update the examples for the next revision.

@Eric: This isn&#039;t instead of concepts. See Figure 1 -- Metaclasses complement (and rely on) concepts and reflection, which are about querying capabilities – based on “does this expression compile” and “does this member/signature exist,” respectively. Metaclasses are about defining types – participating in interpreting the meaning of source code to generate the class definition. Also see section 2.7.

@Gregory: It gives you the &quot;usual&quot; property syntax modulo writing (). Metaclasses can generate what the language already lets you write, and dropping the () would be an additional language extension (orthogonal to metaclasses).

@Adam: I think it&#039;s consistent -- this to_string is not print all the possible values of the enum, it&#039;s printing all the enumerators.

And yes, I do need to add a note/discussion that one way to think of this is that it should replace all uses of CRTP, which basically was an early approximation. Curious how this technique is recurring, huh? :)

@Roland: I didn&#039;t write out the property code but described what it does in the prose. See some of the other examples in the paper for generating functions, such as safe_union.

@Andreas: Yup, that&#039;s a good summary of benefits of the function style syntax.]]></description>
		<content:encoded><![CDATA[<p>@kpfleming: The original intention when that code was written before constexpr blocks was that they be visible, yes. However now those variables should be injected into the class, or the constexpr block extended, if they are going to be used. I will update the examples for the next revision.</p>
<p>@Eric: This isn&#8217;t instead of concepts. See Figure 1 &#8212; Metaclasses complement (and rely on) concepts and reflection, which are about querying capabilities – based on “does this expression compile” and “does this member/signature exist,” respectively. Metaclasses are about defining types – participating in interpreting the meaning of source code to generate the class definition. Also see section 2.7.</p>
<p>@Gregory: It gives you the &#8220;usual&#8221; property syntax modulo writing (). Metaclasses can generate what the language already lets you write, and dropping the () would be an additional language extension (orthogonal to metaclasses).</p>
<p>@Adam: I think it&#8217;s consistent &#8212; this to_string is not print all the possible values of the enum, it&#8217;s printing all the enumerators.</p>
<p>And yes, I do need to add a note/discussion that one way to think of this is that it should replace all uses of CRTP, which basically was an early approximation. Curious how this technique is recurring, huh? :)</p>
<p>@Roland: I didn&#8217;t write out the property code but described what it does in the prose. See some of the other examples in the paper for generating functions, such as safe_union.</p>
<p>@Andreas: Yup, that&#8217;s a good summary of benefits of the function style syntax.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sci/Math/Prog summary: July 2017 &#124; Abacus Noir Form				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39771</link>
		<dc:creator><![CDATA[Sci/Math/Prog summary: July 2017 &#124; Abacus Noir Form]]></dc:creator>
		<pubDate>Tue, 01 Aug 2017 05:43:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39771</guid>
					<description><![CDATA[[&#8230;] Sutter put out a real teaser about upcoming metaprogramming abilities in [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter put out a real teaser about upcoming metaprogramming abilities in [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jason Heblack				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39769</link>
		<dc:creator><![CDATA[Jason Heblack]]></dc:creator>
		<pubDate>Mon, 31 Jul 2017 17:27:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39769</guid>
					<description><![CDATA[Commenting on &quot;C++ Core Guidelines&quot; where it says: &quot;Note Capitalize the names of your user-defined types to distinguish them from standards-library types.&quot; - You guys are &#039;hypocrites&#039;!!! You recommend something that you DON&#039;T do! Why are standards-library types lower-case? Because nobody likes hitting the shift key. No One&#039;s gonna follow that. They&#039;ll just do everything lower-case. I&#039;m commenting on this because I was following the Google Style Guide for C++ but I DON&#039;T like it because of all the shift key usage. So, I&#039;m refactoring my code to be all lower case so it&#039;s easier to type. Also, I switched around the underscore key so I DON&#039;T have to hit shift to get the underscore. THAT IS LAME]]></description>
		<content:encoded><![CDATA[<p>Commenting on &#8220;C++ Core Guidelines&#8221; where it says: &#8220;Note Capitalize the names of your user-defined types to distinguish them from standards-library types.&#8221; &#8211; You guys are &#8216;hypocrites&#8217;!!! You recommend something that you DON&#8217;T do! Why are standards-library types lower-case? Because nobody likes hitting the shift key. No One&#8217;s gonna follow that. They&#8217;ll just do everything lower-case. I&#8217;m commenting on this because I was following the Google Style Guide for C++ but I DON&#8217;T like it because of all the shift key usage. So, I&#8217;m refactoring my code to be all lower case so it&#8217;s easier to type. Also, I switched around the underscore key so I DON&#8217;T have to hit shift to get the underscore. THAT IS LAME</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andreas Mattes				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39767</link>
		<dc:creator><![CDATA[Andreas Mattes]]></dc:creator>
		<pubDate>Mon, 31 Jul 2017 13:17:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39767</guid>
					<description><![CDATA[While I like the direction this is going, I think that that there is a bit of a mix-up between concepts and transformations in here. This can be seen in the definition of .is which assumes that the result of a metaclass transformation is a kind of concept and a second application of the same transformation is a No-op. But that is not the case for examples like the one that adds a new overload of each function with an additional int parameter.

The function syntax for metaclasses embraces that more. And why stop there? If the transformation is a function, then .as can be seen as a constexpr function call and maybe should have the function call syntax with types as parameters? It could then also have additional type or non-type parameters (like flags or similar) and transformations could call other transformations without special syntax that has an implicit call order.
And finally maybe concepts should be the same syntax, functions returning bool for concepts and functions returning meta::type for transformations.
If metaclass transformations result in a type that conforms to a concept, the function could return the name of that concept instead of meta::type (although the question is when the concept check should be done, some kind of cast maybe?).]]></description>
		<content:encoded><![CDATA[<p>While I like the direction this is going, I think that that there is a bit of a mix-up between concepts and transformations in here. This can be seen in the definition of .is which assumes that the result of a metaclass transformation is a kind of concept and a second application of the same transformation is a No-op. But that is not the case for examples like the one that adds a new overload of each function with an additional int parameter.</p>
<p>The function syntax for metaclasses embraces that more. And why stop there? If the transformation is a function, then .as can be seen as a constexpr function call and maybe should have the function call syntax with types as parameters? It could then also have additional type or non-type parameters (like flags or similar) and transformations could call other transformations without special syntax that has an implicit call order.<br />
And finally maybe concepts should be the same syntax, functions returning bool for concepts and functions returning meta::type for transformations.<br />
If metaclass transformations result in a type that conforms to a concept, the function could return the name of that concept instead of meta::type (although the question is when the concept check should be done, some kind of cast maybe?).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roland Bock				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39766</link>
		<dc:creator><![CDATA[Roland Bock]]></dc:creator>
		<pubDate>Sun, 30 Jul 2017 06:52:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39766</guid>
					<description><![CDATA[I missed the code that defines property. In particular, I would be interested in the part that creates 

[code]
 T get_xxx() { return value; }
[/code]

Is that code available somewhere? It requires constructing names out of thin air. Does the prototype by Andrew Sutton already support that?

Afaict, this could mean that we could finally get variadic composition.]]></description>
		<content:encoded><![CDATA[<p>I missed the code that defines property. In particular, I would be interested in the part that creates </p>
<pre class="brush: plain; title: ; notranslate">
 T get_xxx() { return value; }
</pre>
<p>Is that code available somewhere? It requires constructing names out of thin air. Does the prototype by Andrew Sutton already support that?</p>
<p>Afaict, this could mean that we could finally get variadic composition.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adam Harter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39765</link>
		<dc:creator><![CDATA[Adam Harter]]></dc:creator>
		<pubDate>Sun, 30 Jul 2017 01:08:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39765</guid>
					<description><![CDATA[A question regarding the basic_enum to_string example:
I&#039;m assuming that a flag_enum instance (class?) would match the function - since a flag_enum can have values that aren&#039;t part of the enum itself, does this mean that a flag_enum isn&#039;t a basic_enum?  This could be fixed easily enough with a more constrained to_string function, but it feels kind of weird that the more general function doesn&#039;t work.  Of course the to_string of the original could be (inefficiently) rewritten to work but that, again, doesn&#039;t feel right.
Am I missing something basic or reasoning about this incorrectly?

That aside, this a really exciting feature (and CRTP wouldn&#039;t be needed anymore!)]]></description>
		<content:encoded><![CDATA[<p>A question regarding the basic_enum to_string example:<br />
I&#8217;m assuming that a flag_enum instance (class?) would match the function &#8211; since a flag_enum can have values that aren&#8217;t part of the enum itself, does this mean that a flag_enum isn&#8217;t a basic_enum?  This could be fixed easily enough with a more constrained to_string function, but it feels kind of weird that the more general function doesn&#8217;t work.  Of course the to_string of the original could be (inefficiently) rewritten to work but that, again, doesn&#8217;t feel right.<br />
Am I missing something basic or reasoning about this incorrectly?</p>
<p>That aside, this a really exciting feature (and CRTP wouldn&#8217;t be needed anymore!)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gregory				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39763</link>
		<dc:creator><![CDATA[Gregory]]></dc:creator>
		<pubDate>Sat, 29 Jul 2017 17:44:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39763</guid>
					<description><![CDATA[About properties. While metaclasses can generate ordinary methods from property declarations, what about caller side? Does user of the class have to use generated methods instead of property name to get or set property? If so, why bother to implement properties at all?]]></description>
		<content:encoded><![CDATA[<p>About properties. While metaclasses can generate ordinary methods from property declarations, what about caller side? Does user of the class have to use generated methods instead of property name to get or set property? If so, why bother to implement properties at all?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Eric Duhon				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39762</link>
		<dc:creator><![CDATA[Eric Duhon]]></dc:creator>
		<pubDate>Sat, 29 Jul 2017 16:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39762</guid>
					<description><![CDATA[void foo(interface arg)]]></description>
		<content:encoded><![CDATA[<p>void foo(interface arg)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Eric Duhon				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39761</link>
		<dc:creator><![CDATA[Eric Duhon]]></dc:creator>
		<pubDate>Sat, 29 Jul 2017 16:20:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39761</guid>
					<description><![CDATA[This almost seems like it could be used instead of concepts. At first I was thinking of it as concepts specify requirements on a type, and a metaclass modifies a type to make it adhere to a concept. Was thinking it would probably be common to have concepts and a matching metaclass in pairs. How is the name collision between concepts and meta classes? Does it cause problems to have a concept named ForwardIterator and a metaclass called ForwardIterator as well? Since metaclasses have requirement clauses, could a metclass implicitly create a concept as well so you don&#039;t have to create a separate matching one? Then you can get the terse concept syntax with your metaclass for free. void foo(observer_ptr arg);]]></description>
		<content:encoded><![CDATA[<p>This almost seems like it could be used instead of concepts. At first I was thinking of it as concepts specify requirements on a type, and a metaclass modifies a type to make it adhere to a concept. Was thinking it would probably be common to have concepts and a matching metaclass in pairs. How is the name collision between concepts and meta classes? Does it cause problems to have a concept named ForwardIterator and a metaclass called ForwardIterator as well? Since metaclasses have requirement clauses, could a metclass implicitly create a concept as well so you don&#8217;t have to create a separate matching one? Then you can get the terse concept syntax with your metaclass for free. void foo(observer_ptr arg);</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kamil Koczurek				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39759</link>
		<dc:creator><![CDATA[Kamil Koczurek]]></dc:creator>
		<pubDate>Sat, 29 Jul 2017 10:45:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39759</guid>
					<description><![CDATA[Amazing. I hope it will get to c++23, it would be so nice to use with concepts. And I&#039;ll finally be able to compute semi–complex stuff without workarounds in those [code]constexpr[/code] blocks. &#060;3]]></description>
		<content:encoded><![CDATA[<p>Amazing. I hope it will get to c++23, it would be so nice to use with concepts. And I&#8217;ll finally be able to compute semi–complex stuff without workarounds in those </p>
<pre class="brush: plain; title: ; notranslate">constexpr</pre>
<p> blocks. &lt;3</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: kpfleming				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39757</link>
		<dc:creator><![CDATA[kpfleming]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 21:23:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39757</guid>
					<description><![CDATA[Question: throughout the example implementations, there are variables defined to do calculations during the constexpr code evaluation (compute the number of objects, etc.) Some of these variables, although not all, are then referenced in the code *outside* the class-level constexpr block (for example, in the bitfield example). Is it your intention that these will be visible to code outside the constexpr block, but not injected into the protoclass (as they would have been if they were declared outside the constexpr block)?]]></description>
		<content:encoded><![CDATA[<p>Question: throughout the example implementations, there are variables defined to do calculations during the constexpr code evaluation (compute the number of objects, etc.) Some of these variables, although not all, are then referenced in the code *outside* the class-level constexpr block (for example, in the bitfield example). Is it your intention that these will be visible to code outside the constexpr block, but not injected into the protoclass (as they would have been if they were declared outside the constexpr block)?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39756</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 20:31:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39756</guid>
					<description><![CDATA[@Martin: Yes, that&#039;s the direction we&#039;re exploring. The current paper doesn&#039;t mention it but the current design and compiler already allows constexpr { } compile-time code blocks in regular classes too.

@Jonathan: Good news, it is actually not too early to tell -- there is zero chance of this being in C++20. :) Besides that this needs further development and trying out at increasing scales in more domains, the door for C++20 features closes in two years and this depends on two other features (reflection and compile-time programming) of which only one (reflection) is even yet in progress toward becoming a draft TS itself.

@Paul: Yes, since it&#039;s &quot;just code&quot; you can put it in namespaces, libraries, etc. just like any code -- including putting common ones in namespace std.

And yes, reducing reliance on the preprocessor (and template metaprogramming) is a primary goal. TMP is &quot;meta&quot; too but templates are &quot;accidentally&quot; meta :) whereas the point here is to design and leverage first-class compile-time programming.]]></description>
		<content:encoded><![CDATA[<p>@Martin: Yes, that&#8217;s the direction we&#8217;re exploring. The current paper doesn&#8217;t mention it but the current design and compiler already allows constexpr { } compile-time code blocks in regular classes too.</p>
<p>@Jonathan: Good news, it is actually not too early to tell &#8212; there is zero chance of this being in C++20. :) Besides that this needs further development and trying out at increasing scales in more domains, the door for C++20 features closes in two years and this depends on two other features (reflection and compile-time programming) of which only one (reflection) is even yet in progress toward becoming a draft TS itself.</p>
<p>@Paul: Yes, since it&#8217;s &#8220;just code&#8221; you can put it in namespaces, libraries, etc. just like any code &#8212; including putting common ones in namespace std.</p>
<p>And yes, reducing reliance on the preprocessor (and template metaprogramming) is a primary goal. TMP is &#8220;meta&#8221; too but templates are &#8220;accidentally&#8221; meta :) whereas the point here is to design and leverage first-class compile-time programming.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andreas				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39755</link>
		<dc:creator><![CDATA[Andreas]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 19:19:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39755</guid>
					<description><![CDATA[Great work! There is definetly no reason not to push as hard as possible to make this go into c++20
Is there a timeplan when this might become an TS?]]></description>
		<content:encoded><![CDATA[<p>Great work! There is definetly no reason not to push as hard as possible to make this go into c++20<br />
Is there a timeplan when this might become an TS?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin Kosicky				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39754</link>
		<dc:creator><![CDATA[Martin Kosicky]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 17:59:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39754</guid>
					<description><![CDATA[Also in java you can chain these code generations ... therefore i wouldnt put it into a new block  ut rather have it ordinarry code that gets chained...]]></description>
		<content:encoded><![CDATA[<p>Also in java you can chain these code generations &#8230; therefore i wouldnt put it into a new block  ut rather have it ordinarry code that gets chained&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jaysistar				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39753</link>
		<dc:creator><![CDATA[jaysistar]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 17:58:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39753</guid>
					<description><![CDATA[I know that C++ is sometimes considered an &quot;expert&#039;s language&quot;, and that this feature renforces that consideration, but it also opens the door for expert senior programmers to give themselves and their juniors a construct with rules that they not only define, bht can change if something seems illogical later, and also have code, not English, for any user of their metaclass to check to see if an assumption is true.]]></description>
		<content:encoded><![CDATA[<p>I know that C++ is sometimes considered an &#8220;expert&#8217;s language&#8221;, and that this feature renforces that consideration, but it also opens the door for expert senior programmers to give themselves and their juniors a construct with rules that they not only define, bht can change if something seems illogical later, and also have code, not English, for any user of their metaclass to check to see if an assumption is true.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin Kosicky				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39752</link>
		<dc:creator><![CDATA[Martin Kosicky]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 17:48:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39752</guid>
					<description><![CDATA[To be more constructive. I would be happier if you didnt introduce new syntax. Why cant we have a special code block costexpr and inside regular c++. The reflection can be stored in some well known variable with name access with regular methods. Injecting members not with an arrow but rather a method... AddFunc... etc. Java has simmiliar mechanism when generating code based on annotations.]]></description>
		<content:encoded><![CDATA[<p>To be more constructive. I would be happier if you didnt introduce new syntax. Why cant we have a special code block costexpr and inside regular c++. The reflection can be stored in some well known variable with name access with regular methods. Injecting members not with an arrow but rather a method&#8230; AddFunc&#8230; etc. Java has simmiliar mechanism when generating code based on annotations.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chawathe, Vipul S.				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39751</link>
		<dc:creator><![CDATA[Chawathe, Vipul S.]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 16:38:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39751</guid>
					<description><![CDATA[$ operator syntax overlaps sigil from PERL for strings. As this can improvise WRL like COM dialects radically, when using /std:latest flag VC++ UWP developers must get this ASAP. This must be technical specification at least, as some dependencies will hold up until C++ 20.]]></description>
		<content:encoded><![CDATA[<p>$ operator syntax overlaps sigil from PERL for strings. As this can improvise WRL like COM dialects radically, when using /std:latest flag VC++ UWP developers must get this ASAP. This must be technical specification at least, as some dependencies will hold up until C++ 20.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jonathan O'Connor				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39750</link>
		<dc:creator><![CDATA[Jonathan O'Connor]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 14:35:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39750</guid>
					<description><![CDATA[I appreciate that it is probably too early to tell, but what chance do you think that some form of metaclasses will be in C++20?]]></description>
		<content:encoded><![CDATA[<p>I appreciate that it is probably too early to tell, but what chance do you think that some form of metaclasses will be in C++20?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Laurent Lessieux				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39749</link>
		<dc:creator><![CDATA[Laurent Lessieux]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 14:11:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39749</guid>
					<description><![CDATA[There has been quite a lot of C++ proposal where I have been wondering where I could apply them.
Concepts, ok it will help but not sure how often. Modules yes I can see how that would help too.
But this one is the first one where I could see how to solve problems that have been creeping in our applications and framework over the years by making the code cleaner, a lot simpler AND safer.

Just one request, can you make a prototype version in Visual Studio 2017 ;)]]></description>
		<content:encoded><![CDATA[<p>There has been quite a lot of C++ proposal where I have been wondering where I could apply them.<br />
Concepts, ok it will help but not sure how often. Modules yes I can see how that would help too.<br />
But this one is the first one where I could see how to solve problems that have been creeping in our applications and framework over the years by making the code cleaner, a lot simpler AND safer.</p>
<p>Just one request, can you make a prototype version in Visual Studio 2017 ;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39748</link>
		<dc:creator><![CDATA[Paul]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 13:23:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39748</guid>
					<description><![CDATA[Very interesting way to extend the &#039;language&#039;. It could encourage better implementations, but the flip side is you would&#039;ve given people a bigger shotgun to shoot themselves in the foot.

Would you expect there to be some &#039;standard&#039; meta classes defined for things like interface, value, raii_value etc.

My main concern is the difficulty in managing user defined abstractions which materially can affect code written elsewhere. e.g. updating the definition of meta::type flintstone would propagate to all class barney, class wilma etc.

Probably no worse than base class dependencies, but another place for bugs, subtle interface issues and surprises to hide.

That said, seems to elegantly extend in some areas of C++ weakness and may reduce reliance on the pre-processor.]]></description>
		<content:encoded><![CDATA[<p>Very interesting way to extend the &#8216;language&#8217;. It could encourage better implementations, but the flip side is you would&#8217;ve given people a bigger shotgun to shoot themselves in the foot.</p>
<p>Would you expect there to be some &#8216;standard&#8217; meta classes defined for things like interface, value, raii_value etc.</p>
<p>My main concern is the difficulty in managing user defined abstractions which materially can affect code written elsewhere. e.g. updating the definition of meta::type flintstone would propagate to all class barney, class wilma etc.</p>
<p>Probably no worse than base class dependencies, but another place for bugs, subtle interface issues and surprises to hide.</p>
<p>That said, seems to elegantly extend in some areas of C++ weakness and may reduce reliance on the pre-processor.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Guy				</title>
				<link>https://herbsutter.com/2017/07/26/metaclasses-thoughts-on-generative-c/#comment-39747</link>
		<dc:creator><![CDATA[Guy]]></dc:creator>
		<pubDate>Fri, 28 Jul 2017 11:34:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3292#comment-39747</guid>
					<description><![CDATA[I&#039;ve found the metaclasses (and surrounding compile time programming) talks very interesting. I think this feature will likely be overused tremendously to start with and eventually we will settle down as a community to a few common uses (apart from cutting edge library authors who will think if amazing uses).
I would like to see if you could use metaclasses to write compile time html or similar technologies in a very natural way that could then be converted into C++ types.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve found the metaclasses (and surrounding compile time programming) talks very interesting. I think this feature will likely be overused tremendously to start with and eventually we will settle down as a community to a few common uses (apart from cutting edge library authors who will think if amazing uses).<br />
I would like to see if you could use metaclasses to write compile time html or similar technologies in a very natural way that could then be converted into C++ types.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
