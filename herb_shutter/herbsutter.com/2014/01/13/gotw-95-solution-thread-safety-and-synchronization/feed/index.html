<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #95 Solution: Thread Safety and Synchronization	</title>
	<atom:link href="https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Kornner Studios (@KornnerStudios)				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-15006</link>
		<dc:creator><![CDATA[Kornner Studios (@KornnerStudios)]]></dc:creator>
		<pubDate>Thu, 13 Feb 2014 01:05:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-15006</guid>
					<description><![CDATA[On the subject of C# and &#039;const&#039; methods, there is the Code Contracts PureAttribute: http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.pureattribute%28v=vs.110%29.aspx

It&#039;s a required attribute for any method/type that is to be used in other Code Contract facilities, where the programmer claims &quot;no visible state changes are performed by the executed systems&quot;. &quot;Claims&quot; because such non-state-changing behavior isn&#039;t enforced or verified by any current tools (assuming you even have a Code Contracts provider installed), I figured it&#039;s an interesting foot note at least, since the subject was touched on]]></description>
		<content:encoded><![CDATA[<p>On the subject of C# and &#8216;const&#8217; methods, there is the Code Contracts PureAttribute: <a href="http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.pureattribute%28v=vs.110%29.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/system.diagnostics.contracts.pureattribute%28v=vs.110%29.aspx</a></p>
<p>It&#8217;s a required attribute for any method/type that is to be used in other Code Contract facilities, where the programmer claims &#8220;no visible state changes are performed by the executed systems&#8221;. &#8220;Claims&#8221; because such non-state-changing behavior isn&#8217;t enforced or verified by any current tools (assuming you even have a Code Contracts provider installed), I figured it&#8217;s an interesting foot note at least, since the subject was touched on</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dan				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14200</link>
		<dc:creator><![CDATA[Dan]]></dc:creator>
		<pubDate>Sat, 25 Jan 2014 02:34:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14200</guid>
					<description><![CDATA[can anyone give a reproducible code example for int getting trashed in race, if all threads use this variable as int type?]]></description>
		<content:encoded><![CDATA[<p>can anyone give a reproducible code example for int getting trashed in race, if all threads use this variable as int type?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14175</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Tue, 21 Jan 2014 19:15:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14175</guid>
					<description><![CDATA[@xingzou: It&#039;s very unfortunate that Java and C++ gave the word volatile completely different meanings. In Java, volatile would indeed protect you from a race, in C++ it would do no such thing. Think of Java volatile == C++ atomic. Think of C++ volatile as a way of accessing memory mapped IO.]]></description>
		<content:encoded><![CDATA[<p>@xingzou: It&#8217;s very unfortunate that Java and C++ gave the word volatile completely different meanings. In Java, volatile would indeed protect you from a race, in C++ it would do no such thing. Think of Java volatile == C++ atomic. Think of C++ volatile as a way of accessing memory mapped IO.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xiongzou				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14171</link>
		<dc:creator><![CDATA[xiongzou]]></dc:creator>
		<pubDate>Tue, 21 Jan 2014 03:01:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14171</guid>
					<description><![CDATA[Thanks a lot for your clarifications. It does help a lot! 

To go further on the question, if we declare the int volatile, will a &quot;volatile int&quot; free from race condition? Assume the compiler and CPU supports volatile. 

Thanks &#038; regards]]></description>
		<content:encoded><![CDATA[<p>Thanks a lot for your clarifications. It does help a lot! </p>
<p>To go further on the question, if we declare the int volatile, will a &#8220;volatile int&#8221; free from race condition? Assume the compiler and CPU supports volatile. </p>
<p>Thanks &amp; regards</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter GotW95: Thread Safety and Synchronisation &#124; musingstudio				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14168</link>
		<dc:creator><![CDATA[Herb Sutter GotW95: Thread Safety and Synchronisation &#124; musingstudio]]></dc:creator>
		<pubDate>Mon, 20 Jan 2014 19:19:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14168</guid>
					<description><![CDATA[[&#8230;] article on thread safety and synchronisation from Herb [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] article on thread safety and synchronisation from Herb [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14167</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Mon, 20 Jan 2014 18:28:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14167</guid>
					<description><![CDATA[@xiongzou: Atomic operations also guarantee ordering: all threads see changes to atomic variables in the same order (it&#039;s called sequential consistency and is only guaranteed for strong atomics). A simple example of a race is when a thread modifies one shared variable &quot;x&quot; and then sets a shared flag &quot;done.&quot; You want other threads to see those writes in the same order, because if they see &quot;done&quot; before the modification to &quot;x&quot;, they will work with stale data. This is *not* guaranteed if the flag is not atomic. The compiler is free to reorder writes to different variables, and the processor is free to hold some writes in local buffers before committing them to global memory. So atomic variables are not only about atomicity but also about visibility.]]></description>
		<content:encoded><![CDATA[<p>@xiongzou: Atomic operations also guarantee ordering: all threads see changes to atomic variables in the same order (it&#8217;s called sequential consistency and is only guaranteed for strong atomics). A simple example of a race is when a thread modifies one shared variable &#8220;x&#8221; and then sets a shared flag &#8220;done.&#8221; You want other threads to see those writes in the same order, because if they see &#8220;done&#8221; before the modification to &#8220;x&#8221;, they will work with stale data. This is *not* guaranteed if the flag is not atomic. The compiler is free to reorder writes to different variables, and the processor is free to hold some writes in local buffers before committing them to global memory. So atomic variables are not only about atomicity but also about visibility.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14166</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 Jan 2014 18:05:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14166</guid>
					<description><![CDATA[@xiongzou: No, ints (and even chars) can get trashed in a race. Synchronization is not only about atomicity, it’s also about ordering and disabling some optimizations. If you want a standalone mutable shared int that is safe to use concurrently from multiple threads, it must be at least an atomic or part of data protected by a mutex. Otherwise, in a data race even an int can get trashed, such as by an optimizer that thinks only its thread is using the int and performs normal legal single-threaded optimizations, such as injecting speculative writes which in a race could cause other threads to see &quot;impossible&quot; values.]]></description>
		<content:encoded><![CDATA[<p>@xiongzou: No, ints (and even chars) can get trashed in a race. Synchronization is not only about atomicity, it’s also about ordering and disabling some optimizations. If you want a standalone mutable shared int that is safe to use concurrently from multiple threads, it must be at least an atomic or part of data protected by a mutex. Otherwise, in a data race even an int can get trashed, such as by an optimizer that thinks only its thread is using the int and performs normal legal single-threaded optimizations, such as injecting speculative writes which in a race could cause other threads to see &#8220;impossible&#8221; values.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xiongzou				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14162</link>
		<dc:creator><![CDATA[xiongzou]]></dc:creator>
		<pubDate>Mon, 20 Jan 2014 06:11:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14162</guid>
					<description><![CDATA[I am a bit confused, in most modern CPUs, atomic operation is guranteed on a word size memory with read and write operations. int is a word size in most operating systems, which should be safe from race condition in your example, right? Not sure I mis-understand anything here? Thanks]]></description>
		<content:encoded><![CDATA[<p>I am a bit confused, in most modern CPUs, atomic operation is guranteed on a word size memory with read and write operations. int is a word size in most operating systems, which should be safe from race condition in your example, right? Not sure I mis-understand anything here? Thanks</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul Groke				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14148</link>
		<dc:creator><![CDATA[Paul Groke]]></dc:creator>
		<pubDate>Fri, 17 Jan 2014 17:15:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14148</guid>
					<description><![CDATA[Hi Herb, what do you mean by &quot;concurrent const operations that are just reading from the same variable x must be safe&quot;? That all const operations that are logically a clean &quot;read&quot; must be safe? I&#039;m not sure that that&#039;s a good definition.
On the one hand, it&#039;s more complicated than it has to be. After all, what kind of const operations can (or should) be there that are not logically a clean &quot;read&quot;? So wouldn&#039;t it be better to just say all const operations?
On the other hand it forbids stuff like lazy evaluation.
So for me this is somewhere in between &quot;restrictive, but so simple that anyone can understand it and apply it correctly without having to think too much&quot; and &quot;a little complicated but allows us to do cool stuff that we otherwise couldn&#039;t&quot;.
So maybe the best thing would be to just document which methods are thread-safe and which are not.]]></description>
		<content:encoded><![CDATA[<p>Hi Herb, what do you mean by &#8220;concurrent const operations that are just reading from the same variable x must be safe&#8221;? That all const operations that are logically a clean &#8220;read&#8221; must be safe? I&#8217;m not sure that that&#8217;s a good definition.<br />
On the one hand, it&#8217;s more complicated than it has to be. After all, what kind of const operations can (or should) be there that are not logically a clean &#8220;read&#8221;? So wouldn&#8217;t it be better to just say all const operations?<br />
On the other hand it forbids stuff like lazy evaluation.<br />
So for me this is somewhere in between &#8220;restrictive, but so simple that anyone can understand it and apply it correctly without having to think too much&#8221; and &#8220;a little complicated but allows us to do cool stuff that we otherwise couldn&#8217;t&#8221;.<br />
So maybe the best thing would be to just document which methods are thread-safe and which are not.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14143</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 16 Jan 2014 17:27:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14143</guid>
					<description><![CDATA[@ixache: Aha, s/to so/to do/. Fixed, thanks.]]></description>
		<content:encoded><![CDATA[<p>@ixache: Aha, s/to so/to do/. Fixed, thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ixache				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14142</link>
		<dc:creator><![CDATA[ixache]]></dc:creator>
		<pubDate>Thu, 16 Jan 2014 15:04:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14142</guid>
					<description><![CDATA[Herb, you wrote: &quot;To make it possible for the code that uses a shared variable to so the above, two basic things must be true.&quot;

Is&#039;nt there a lacking somewhere in that sentence ?]]></description>
		<content:encoded><![CDATA[<p>Herb, you wrote: &#8220;To make it possible for the code that uses a shared variable to so the above, two basic things must be true.&#8221;</p>
<p>Is&#8217;nt there a lacking somewhere in that sentence ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14139</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 16 Jan 2014 01:43:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14139</guid>
					<description><![CDATA[@mcmcc: I see where you&#039;re coming from. In this case I did them in this order because &quot;problem, then solution&quot; seems to work better in general. In this case, it seemed like presenting &quot;reduce sharing&quot; would lead to incomplete answers (or &quot;why?&quot; questions) without being able to refer back to &quot;data races and how bad they are&quot; so I presented that first so I could refer to it. I&#039;ll think about this and see if reversing the order makes sense for when these appear in book form.]]></description>
		<content:encoded><![CDATA[<p>@mcmcc: I see where you&#8217;re coming from. In this case I did them in this order because &#8220;problem, then solution&#8221; seems to work better in general. In this case, it seemed like presenting &#8220;reduce sharing&#8221; would lead to incomplete answers (or &#8220;why?&#8221; questions) without being able to refer back to &#8220;data races and how bad they are&#8221; so I presented that first so I could refer to it. I&#8217;ll think about this and see if reversing the order makes sense for when these appear in book form.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marcel Wid				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14134</link>
		<dc:creator><![CDATA[Marcel Wid]]></dc:creator>
		<pubDate>Wed, 15 Jan 2014 12:19:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14134</guid>
					<description><![CDATA[@Herb: You added the word &quot;concurrently&quot; to the definition of race condition (aka data race). I&#039;m afraid, but as the definition now stands, it is as wrong as it was before. &quot;Concurrent access&quot; doesn&#039;t necessarily introduce a data race (at least if you use the term &quot;concurrent access&quot; as in the spec). Here is a quote from §20.7.2.5/1:

&quot;Concurrent access to a shared_ptr object from multiple threads does not introduce a data race if the access is done exclusively via the functions in this section and the instance is passed as their first argument.&quot;

I know that it is almost impossible to give a definition of &quot;data race&quot; in one line. Here is a suggestion:

&quot;A race condition occurs when two different threads access the same shared variable and at least one of them is a store (write) and they may be executed at the same time (they may interleave).&quot;]]></description>
		<content:encoded><![CDATA[<p>@Herb: You added the word &#8220;concurrently&#8221; to the definition of race condition (aka data race). I&#8217;m afraid, but as the definition now stands, it is as wrong as it was before. &#8220;Concurrent access&#8221; doesn&#8217;t necessarily introduce a data race (at least if you use the term &#8220;concurrent access&#8221; as in the spec). Here is a quote from §20.7.2.5/1:</p>
<p>&#8220;Concurrent access to a shared_ptr object from multiple threads does not introduce a data race if the access is done exclusively via the functions in this section and the instance is passed as their first argument.&#8221;</p>
<p>I know that it is almost impossible to give a definition of &#8220;data race&#8221; in one line. Here is a suggestion:</p>
<p>&#8220;A race condition occurs when two different threads access the same shared variable and at least one of them is a store (write) and they may be executed at the same time (they may interleave).&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14129</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 23:30:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14129</guid>
					<description><![CDATA[I think I&#039;m confused because ownership may have specific meaning in the context of concurrency. People came up with ownership schemes to describe synchronization. I studied these things when we were designing D (here&#039;s a blog I wrote back then: http://bartoszmilewski.com/2009/06/02/race-free-multithreading-ownership/ ). The &quot;owner&quot; in these schemes is the object responsible for locking. When you are talking about objects that might be connected under the covers, that would be a violation of ownership (and an invitation to deadlock). I think I would stick to &quot;uses&quot; or &quot;has access to&quot; rather than &quot;owns&quot; when talking about code.]]></description>
		<content:encoded><![CDATA[<p>I think I&#8217;m confused because ownership may have specific meaning in the context of concurrency. People came up with ownership schemes to describe synchronization. I studied these things when we were designing D (here&#8217;s a blog I wrote back then: <a href="http://bartoszmilewski.com/2009/06/02/race-free-multithreading-ownership/" rel="nofollow">http://bartoszmilewski.com/2009/06/02/race-free-multithreading-ownership/</a> ). The &#8220;owner&#8221; in these schemes is the object responsible for locking. When you are talking about objects that might be connected under the covers, that would be a violation of ownership (and an invitation to deadlock). I think I would stick to &#8220;uses&#8221; or &#8220;has access to&#8221; rather than &#8220;owns&#8221; when talking about code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mcmcc				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14123</link>
		<dc:creator><![CDATA[mcmcc]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 20:55:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14123</guid>
					<description><![CDATA[&#062; @mcmcc: Yes, but that’s beyond the scope of this particular GotW. Wait for it… :)

Perhaps what I&#039;m noting here is that the GotW&#039;s are coming the wrong order.  The &quot;Oversharing&quot; GotW should come first because that (I presume ;) suggests the ideal solution.   This GotW starts with &quot;Well, here you are sharing stuff - how do you avoid problems&quot; without discussing how/why you ended up in that situation in the first place.]]></description>
		<content:encoded><![CDATA[<p>&gt; @mcmcc: Yes, but that’s beyond the scope of this particular GotW. Wait for it… :)</p>
<p>Perhaps what I&#8217;m noting here is that the GotW&#8217;s are coming the wrong order.  The &#8220;Oversharing&#8221; GotW should come first because that (I presume ;) suggests the ideal solution.   This GotW starts with &#8220;Well, here you are sharing stuff &#8211; how do you avoid problems&#8221; without discussing how/why you ended up in that situation in the first place.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marcel Wid				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14119</link>
		<dc:creator><![CDATA[Marcel Wid]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 19:19:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14119</guid>
					<description><![CDATA[&quot;A race condition occurs when two threads access the same shared variable, and at least one is a non-const operation (writer).&quot;
&quot;If a race condition occurs, your program has undefined behavior.&quot;

I interpret these two statements that you mean the term &quot;data race&quot; in the terminology of the standard.

If this definition were right, then it would be impossible to write a data race free program. Because by your definition a properly synchronized access to a shared variable would also result in a data race and hence in undefined behavior. I think, the definition from the standard is quite readable:

&quot;Two expression evaluations conflict if one of them modifies a memory location and the other one accesses or modifies the same memory location.&quot;
&quot;The execution of a program contains a data race if it contains two conflicting actions in different threads,
at least one of which is not atomic, and neither happens before the other.&quot;]]></description>
		<content:encoded><![CDATA[<p>&#8220;A race condition occurs when two threads access the same shared variable, and at least one is a non-const operation (writer).&#8221;<br />
&#8220;If a race condition occurs, your program has undefined behavior.&#8221;</p>
<p>I interpret these two statements that you mean the term &#8220;data race&#8221; in the terminology of the standard.</p>
<p>If this definition were right, then it would be impossible to write a data race free program. Because by your definition a properly synchronized access to a shared variable would also result in a data race and hence in undefined behavior. I think, the definition from the standard is quite readable:</p>
<p>&#8220;Two expression evaluations conflict if one of them modifies a memory location and the other one accesses or modifies the same memory location.&#8221;<br />
&#8220;The execution of a program contains a data race if it contains two conflicting actions in different threads,<br />
at least one of which is not atomic, and neither happens before the other.&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Guru of the Week 95 : Thread Safety and Synchronization &#124; C++, Qt, OpenGL, CUDA				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14116</link>
		<dc:creator><![CDATA[Guru of the Week 95 : Thread Safety and Synchronization &#124; C++, Qt, OpenGL, CUDA]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 17:24:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14116</guid>
					<description><![CDATA[[&#8230;] GotW #95 Solution: Thread Safety and Synchronization. [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] GotW #95 Solution: Thread Safety and Synchronization. [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14114</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 16:48:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14114</guid>
					<description><![CDATA[@Bartosz: I often said &quot;owns or uses&quot; to try to make it clear we&#039;re talking about the code that creates/manipulates/manages/destroys the variable. If &quot;owns&quot; and &quot;uses/owns&quot; are unclear I&#039;d be happy to consider suggestions -- what would be better?

@mcmcc: Yes, but that&#039;s beyond the scope of this particular GotW. Wait for it... :)]]></description>
		<content:encoded><![CDATA[<p>@Bartosz: I often said &#8220;owns or uses&#8221; to try to make it clear we&#8217;re talking about the code that creates/manipulates/manages/destroys the variable. If &#8220;owns&#8221; and &#8220;uses/owns&#8221; are unclear I&#8217;d be happy to consider suggestions &#8212; what would be better?</p>
<p>@mcmcc: Yes, but that&#8217;s beyond the scope of this particular GotW. Wait for it&#8230; :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alb				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14111</link>
		<dc:creator><![CDATA[Alb]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 11:01:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14111</guid>
					<description><![CDATA[Even just reading a const variable can raise a race condition in the particular case when you access a controler register. Even if the variable is (both volatile and) const qualified.


I am wondering if I did not more often face race condition in the &#039;extended&#039; sense (interleaves problems) rather than the reader/writer concurrent scheme. The race condition has just been so much explained that most of time I see code with variable access protected (even with a &#039;disable/enable-all-interrupts&#039; hammer) but without analysis of the entire design ands its hidden &#039;logical&#039; dependency.
Nevertheless using the appropriate synchronisation construct is not trivial and thanks for giving us such wise and discerning advice.]]></description>
		<content:encoded><![CDATA[<p>Even just reading a const variable can raise a race condition in the particular case when you access a controler register. Even if the variable is (both volatile and) const qualified.</p>
<p>I am wondering if I did not more often face race condition in the &#8216;extended&#8217; sense (interleaves problems) rather than the reader/writer concurrent scheme. The race condition has just been so much explained that most of time I see code with variable access protected (even with a &#8216;disable/enable-all-interrupts&#8217; hammer) but without analysis of the entire design ands its hidden &#8216;logical&#8217; dependency.<br />
Nevertheless using the appropriate synchronisation construct is not trivial and thanks for giving us such wise and discerning advice.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mcmcc				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14109</link>
		<dc:creator><![CDATA[mcmcc]]></dc:creator>
		<pubDate>Mon, 13 Jan 2014 22:15:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14109</guid>
					<description><![CDATA[Guideline #0:  Prefer to not share data at all.  

Its surprising how often this idea fails to occur to people...]]></description>
		<content:encoded><![CDATA[<p>Guideline #0:  Prefer to not share data at all.  </p>
<p>Its surprising how often this idea fails to occur to people&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14108</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Mon, 13 Jan 2014 21:58:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14108</guid>
					<description><![CDATA[Herb, you keep using the word &quot;own&quot; without explaining it. When dealing with resource management, owning means being responsible for final disposal, and that&#039;s not what you mean here, do you?]]></description>
		<content:encoded><![CDATA[<p>Herb, you keep using the word &#8220;own&#8221; without explaining it. When dealing with resource management, owning means being responsible for final disposal, and that&#8217;s not what you mean here, do you?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14107</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 13 Jan 2014 20:18:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14107</guid>
					<description><![CDATA[@Daniel: I&#039;ve added the words &quot;with each other&quot; -- better?

@Casey: Good eyes, second &quot;not&quot; removed, thanks!]]></description>
		<content:encoded><![CDATA[<p>@Daniel: I&#8217;ve added the words &#8220;with each other&#8221; &#8212; better?</p>
<p>@Casey: Good eyes, second &#8220;not&#8221; removed, thanks!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Casey				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14106</link>
		<dc:creator><![CDATA[Casey]]></dc:creator>
		<pubDate>Mon, 13 Jan 2014 19:26:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14106</guid>
					<description><![CDATA[&quot;So it’s not like shared_ptr is not a fully internally synchronized type&quot; Yes, it is exactly &quot;like shared_ptr is not a fully internally synchronized type.&quot; I think you doubled up on &quot;not&quot; in this clause.]]></description>
		<content:encoded><![CDATA[<p>&#8220;So it’s not like shared_ptr is not a fully internally synchronized type&#8221; Yes, it is exactly &#8220;like shared_ptr is not a fully internally synchronized type.&#8221; I think you doubled up on &#8220;not&#8221; in this clause.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daniel Hardman				</title>
				<link>https://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/#comment-14105</link>
		<dc:creator><![CDATA[Daniel Hardman]]></dc:creator>
		<pubDate>Mon, 13 Jan 2014 19:23:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2411#comment-14105</guid>
					<description><![CDATA[I am uncomfortable with the wording of your first guideline, because it&#039;s stated without a caveat. Reads (const operations) are safe IFF no writes are happening concurrently--but you state it as if reads can always be considered safe, without condition. This is also a reason why I don&#039;t like the summary you gave about the meaning of &quot;const&quot; and &quot;mutable&quot; in one of your recent talks.

It seems to me that a clearer way to explain it would be: reads do not, in and of themselves, introduce any threading problems. Therefore, if reads are the only operations happening, you have thread safety. However, if writes are also happening, then the reads (not just the writes) also become unsafe. *Thread safety is not a characteristic of an individual operation; it is a characteristic of an overall usage pattern.* Thus, &quot;read&quot; or &quot;const&quot; does not mean &quot;thread-safe&quot;--it means &quot;introducing no threading problems, but still vulnerable to vicitimization by them&quot;.]]></description>
		<content:encoded><![CDATA[<p>I am uncomfortable with the wording of your first guideline, because it&#8217;s stated without a caveat. Reads (const operations) are safe IFF no writes are happening concurrently&#8211;but you state it as if reads can always be considered safe, without condition. This is also a reason why I don&#8217;t like the summary you gave about the meaning of &#8220;const&#8221; and &#8220;mutable&#8221; in one of your recent talks.</p>
<p>It seems to me that a clearer way to explain it would be: reads do not, in and of themselves, introduce any threading problems. Therefore, if reads are the only operations happening, you have thread safety. However, if writes are also happening, then the reads (not just the writes) also become unsafe. *Thread safety is not a characteristic of an individual operation; it is a characteristic of an overall usage pattern.* Thus, &#8220;read&#8221; or &#8220;const&#8221; does not mean &#8220;thread-safe&#8221;&#8211;it means &#8220;introducing no threading problems, but still vulnerable to vicitimization by them&#8221;.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
