<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: A quick poll about order of evaluation&#8230;	</title>
	<atom:link href="https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Sergey				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-39334</link>
		<dc:creator><![CDATA[Sergey]]></dc:creator>
		<pubDate>Tue, 12 Jul 2016 11:40:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-39334</guid>
					<description><![CDATA[it&#039;s undefined behaviour.
there are two statements in one expression.]]></description>
		<content:encoded><![CDATA[<p>it&#8217;s undefined behaviour.<br />
there are two statements in one expression.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-38027</link>
		<dc:creator><![CDATA[Peter]]></dc:creator>
		<pubDate>Mon, 07 Dec 2015 08:15:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-38027</guid>
					<description><![CDATA[What is wrong with You people? How it could possibly be 01? that would mean i++ evaluates to 1 two consecutive times! This better not happen regardless the order of evaluation! 
:D
Consider v[i++] = v[i++] = i++; // &#060;-- how this should evaluate?]]></description>
		<content:encoded><![CDATA[<p>What is wrong with You people? How it could possibly be 01? that would mean i++ evaluates to 1 two consecutive times! This better not happen regardless the order of evaluation!<br />
:D<br />
Consider v[i++] = v[i++] = i++; // &lt;&#8211; how this should evaluate?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: somedude				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-37803</link>
		<dc:creator><![CDATA[somedude]]></dc:creator>
		<pubDate>Sat, 26 Sep 2015 22:33:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-37803</guid>
					<description><![CDATA[I hope the result of the voting isn&#039;t undefined.]]></description>
		<content:encoded><![CDATA[<p>I hope the result of the voting isn&#8217;t undefined.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Aaron				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-37644</link>
		<dc:creator><![CDATA[Aaron]]></dc:creator>
		<pubDate>Thu, 13 Aug 2015 21:57:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-37644</guid>
					<description><![CDATA[If I didn&#039;t know any better, I would assume the following based off of the OOO.

v[i++] = i++;	// Just evaluating this expression.

v[i++]	// place address of v[0] on the stack, increment i (i == 1);
i++		// load i (i == 1) on the stack, increment i (i == 2);
=		// pop the value 1 from the stack, pop address of v[0] from the
		// stack, assign v[0] the value of 1;

I would expect an output of 10.]]></description>
		<content:encoded><![CDATA[<p>If I didn&#8217;t know any better, I would assume the following based off of the OOO.</p>
<p>v[i++] = i++;	// Just evaluating this expression.</p>
<p>v[i++]	// place address of v[0] on the stack, increment i (i == 1);<br />
i++		// load i (i == 1) on the stack, increment i (i == 2);<br />
=		// pop the value 1 from the stack, pop address of v[0] from the<br />
		// stack, assign v[0] the value of 1;</p>
<p>I would expect an output of 10.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gareth				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-37015</link>
		<dc:creator><![CDATA[Gareth]]></dc:creator>
		<pubDate>Sat, 25 Apr 2015 14:09:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-37015</guid>
					<description><![CDATA[I was only thinking yesterday that everyone knows what multiple uses of [code]i++[/code] should do so why don&#039;t that define it properly in the standard? I figured maybe compilers have better opportunity to optimize code where multiple increments are not used or something like that. After seeing this survey I realize that people&#039;s ideas of what it should do vary quite a lot. I went for [code]10[/code] on the basis that i is incremented after it is used each time. Now I see that is not as obvious as I thought it would be.]]></description>
		<content:encoded><![CDATA[<p>I was only thinking yesterday that everyone knows what multiple uses of </p>
<pre class="brush: plain; title: ; notranslate">i++</pre>
<p> should do so why don&#8217;t that define it properly in the standard? I figured maybe compilers have better opportunity to optimize code where multiple increments are not used or something like that. After seeing this survey I realize that people&#8217;s ideas of what it should do vary quite a lot. I went for </p>
<pre class="brush: plain; title: ; notranslate">10</pre>
<p> on the basis that i is incremented after it is used each time. Now I see that is not as obvious as I thought it would be.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: DowntownDave				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-36697</link>
		<dc:creator><![CDATA[DowntownDave]]></dc:creator>
		<pubDate>Fri, 20 Mar 2015 18:42:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-36697</guid>
					<description><![CDATA[Herb I&#039;m ready for a new blog post now... :)]]></description>
		<content:encoded><![CDATA[<p>Herb I&#8217;m ready for a new blog post now&#8230; :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chor Lit				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-36353</link>
		<dc:creator><![CDATA[Chor Lit]]></dc:creator>
		<pubDate>Sun, 15 Feb 2015 05:29:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-36353</guid>
					<description><![CDATA[It seems that some form of extra control for postincrement/postdecrement is needed in the expression.I propose using redundant parentheses around expression whenever we want the accumulated increment/decrement side-effect to take immediate effect at the point of use of redundant parentheses. The syntaxes are 

   (expr);   

   (expr)++;

   (expr)--;

E.g.

int f(int, int, int){  return i; }

int i=0, V[3] = {}; //initial condition

V[i++] = i++;                                             =&#062; V[0]=0, V[1]=0, V[2]=0; Final value of i is 2; no ambiguity now 

V[(i)] = i--;                                               =&#062;  V[0]=0, V[1]=2, V[2]=0; Final value of i is 1   

i=2;    //re-init

V[(i)++] = V[(i)++] = V[i--] = i--;                 =&#062; V[0]=2, V[1]=2, V[2]=2; Final value of i is 2.                                                                                                  

i=f(i=0, i++, (i)++);                                    =&#062; f(0,0,1) and returns 1; But final value of i is 2;

i=f(i=0, i++, i++);                                      =&#062; f(0,0,0)  and returns 0; But final value of i is 2


If expr itself needs redundant parentheses, then an extra redundant parentheses can be added and so on. E.g.

  (expr ? (expr1) : (expr2))++


which is different from
 
  (expr ? expr1 : expr2)++

, the latter of which is a normal postincrement/postdecrement


If there is no accumulated increments/decrements at the point where forced postincrement/postdecrement is used, then the redundant parentheses is redundant. E.g.

  (i)++;  //similar to i++

  (i)++ + (i)++;  //the left redundant-parentheses is redundant, but the right redundant-parentheses is not 
  

I also propose operands be evaluated according to their associativity, and postfix-expression be evaluated left-to-right, as proposed in N4228, and forced/unforced postincrement/postdecrement both yield lvalue.

  --expr++;   //ok now
  
  ++expr--;  //ok now]]></description>
		<content:encoded><![CDATA[<p>It seems that some form of extra control for postincrement/postdecrement is needed in the expression.I propose using redundant parentheses around expression whenever we want the accumulated increment/decrement side-effect to take immediate effect at the point of use of redundant parentheses. The syntaxes are </p>
<p>   (expr);   </p>
<p>   (expr)++;</p>
<p>   (expr)&#8211;;</p>
<p>E.g.</p>
<p>int f(int, int, int){  return i; }</p>
<p>int i=0, V[3] = {}; //initial condition</p>
<p>V[i++] = i++;                                             =&gt; V[0]=0, V[1]=0, V[2]=0; Final value of i is 2; no ambiguity now </p>
<p>V[(i)] = i&#8211;;                                               =&gt;  V[0]=0, V[1]=2, V[2]=0; Final value of i is 1   </p>
<p>i=2;    //re-init</p>
<p>V[(i)++] = V[(i)++] = V[i&#8211;] = i&#8211;;                 =&gt; V[0]=2, V[1]=2, V[2]=2; Final value of i is 2.                                                                                                  </p>
<p>i=f(i=0, i++, (i)++);                                    =&gt; f(0,0,1) and returns 1; But final value of i is 2;</p>
<p>i=f(i=0, i++, i++);                                      =&gt; f(0,0,0)  and returns 0; But final value of i is 2</p>
<p>If expr itself needs redundant parentheses, then an extra redundant parentheses can be added and so on. E.g.</p>
<p>  (expr ? (expr1) : (expr2))++</p>
<p>which is different from</p>
<p>  (expr ? expr1 : expr2)++</p>
<p>, the latter of which is a normal postincrement/postdecrement</p>
<p>If there is no accumulated increments/decrements at the point where forced postincrement/postdecrement is used, then the redundant parentheses is redundant. E.g.</p>
<p>  (i)++;  //similar to i++</p>
<p>  (i)++ + (i)++;  //the left redundant-parentheses is redundant, but the right redundant-parentheses is not </p>
<p>I also propose operands be evaluated according to their associativity, and postfix-expression be evaluated left-to-right, as proposed in N4228, and forced/unforced postincrement/postdecrement both yield lvalue.</p>
<p>  &#8211;expr++;   //ok now</p>
<p>  ++expr&#8211;;  //ok now</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bittermanandy				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-36341</link>
		<dc:creator><![CDATA[bittermanandy]]></dc:creator>
		<pubDate>Sat, 14 Feb 2015 19:54:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-36341</guid>
					<description><![CDATA[Raptor attack. http://xkcd.com/292/

Just don&#039;t.]]></description>
		<content:encoded><![CDATA[<p>Raptor attack. <a href="http://xkcd.com/292/" rel="nofollow">http://xkcd.com/292/</a></p>
<p>Just don&#8217;t.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Onur				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-36309</link>
		<dc:creator><![CDATA[Onur]]></dc:creator>
		<pubDate>Thu, 12 Feb 2015 21:08:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-36309</guid>
					<description><![CDATA[i think output should be 02 .Because :
[code]
std::vector&#060;int&#062; v = { 0, 0 };
int i = 0;
v[i++]// i is 1 now.
 = i++ ; //i is 2 now.
std::cout &#060;&#060; 
v[0] //0,because v[0] was 0 and its value hasn&#039;t changed
&#060;&#060; v[1]// 2,because it became 2.
 &#060;&#060; endl;
[/code]
i think that&#039;s the answer.Thanks]]></description>
		<content:encoded><![CDATA[<p>i think output should be 02 .Because :</p>
<pre class="brush: plain; title: ; notranslate">
std::vector&lt;int&gt; v = { 0, 0 };
int i = 0;
v[i++]// i is 1 now.
 = i++ ; //i is 2 now.
std::cout &lt;&lt; 
v[0] //0,because v[0] was 0 and its value hasn't changed
&lt;&lt; v[1]// 2,because it became 2.
 &lt;&lt; endl;
</pre>
<p>i think that&#8217;s the answer.Thanks</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bruys				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-35858</link>
		<dc:creator><![CDATA[Bruys]]></dc:creator>
		<pubDate>Sun, 25 Jan 2015 06:54:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-35858</guid>
					<description><![CDATA[(In the following, = is used for assignment, and == for equality.)

If we were to evaluate left to right:
before             =&#062; v[0] == 0,  v[1] == 0, i == 0
v[i++] = RHS    =&#062; v[0] = RHS, i == 1
v[0] = i++        =&#062; v[0] = 1, i == 2
after              =&#062; v[0] == 1, v[1] == 0, i == 2

If we were to evaluate right to left:
before         =&#062; v[0] == 0, v[1] == 0, i == 0
LHS = i++    =&#062; RHS == 0, i == 1
v[i++] = 0     =&#062; v[1] = 0, i == 2
after            =&#062; v[0] == 0, v[1] == 0, i == 2

If there were an order, left to right would be more natural, but I could cope with either. If there is a reason for not specifying an order (I can&#039;t see any particular use for this syntax), then give me a compilation error. My only preference would be: don&#039;t give me &#039;unspecified&#039;.]]></description>
		<content:encoded><![CDATA[<p>(In the following, = is used for assignment, and == for equality.)</p>
<p>If we were to evaluate left to right:<br />
before             =&gt; v[0] == 0,  v[1] == 0, i == 0<br />
v[i++] = RHS    =&gt; v[0] = RHS, i == 1<br />
v[0] = i++        =&gt; v[0] = 1, i == 2<br />
after              =&gt; v[0] == 1, v[1] == 0, i == 2</p>
<p>If we were to evaluate right to left:<br />
before         =&gt; v[0] == 0, v[1] == 0, i == 0<br />
LHS = i++    =&gt; RHS == 0, i == 1<br />
v[i++] = 0     =&gt; v[1] = 0, i == 2<br />
after            =&gt; v[0] == 0, v[1] == 0, i == 2</p>
<p>If there were an order, left to right would be more natural, but I could cope with either. If there is a reason for not specifying an order (I can&#8217;t see any particular use for this syntax), then give me a compilation error. My only preference would be: don&#8217;t give me &#8216;unspecified&#8217;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: dorianmuthig				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-35367</link>
		<dc:creator><![CDATA[dorianmuthig]]></dc:creator>
		<pubDate>Wed, 14 Jan 2015 08:14:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-35367</guid>
					<description><![CDATA[Scratch that, was thinking of ++i, should print 00, it&#039;s messed up anyhow, who would do that? Why count it twice?]]></description>
		<content:encoded><![CDATA[<p>Scratch that, was thinking of ++i, should print 00, it&#8217;s messed up anyhow, who would do that? Why count it twice?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: dorianmuthig				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-35366</link>
		<dc:creator><![CDATA[dorianmuthig]]></dc:creator>
		<pubDate>Wed, 14 Jan 2015 08:07:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-35366</guid>
					<description><![CDATA[But after line three has been evaluated, i would be 2, a curiosity this poll question does not touch on.]]></description>
		<content:encoded><![CDATA[<p>But after line three has been evaluated, i would be 2, a curiosity this poll question does not touch on.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: dorianmuthig				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-35365</link>
		<dc:creator><![CDATA[dorianmuthig]]></dc:creator>
		<pubDate>Wed, 14 Jan 2015 08:03:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-35365</guid>
					<description><![CDATA[Code should be evaluated left to right when piped (multiple times), reduced on both sides before assigned from the right side and evaluated one line after the other in order. Therefore the correct behavior should be:
[code]std::vector v = { 0, 0 };
int i = 0;[/code]

There is nothing suspicious here, yet.
[code]v[i++] = i++;[/code]

This should make 
[code]v[1] = 1;[/code]

or 
[code]v = { 0, 1 };[/code]

And then 
[code]std::cout &#060;&#060; v[0] &#060;&#060; v[1] &#060;&#060; endl;[/code]

would print [quote]01[/quote] to the console.]]></description>
		<content:encoded><![CDATA[<p>Code should be evaluated left to right when piped (multiple times), reduced on both sides before assigned from the right side and evaluated one line after the other in order. Therefore the correct behavior should be:</p>
<pre class="brush: plain; title: ; notranslate">std::vector v = { 0, 0 };
int i = 0;</pre>
<p>There is nothing suspicious here, yet.</p>
<pre class="brush: plain; title: ; notranslate">v[i++] = i++;</pre>
<p>This should make </p>
<pre class="brush: plain; title: ; notranslate">v[1] = 1;</pre>
<p>or </p>
<pre class="brush: plain; title: ; notranslate">v = { 0, 1 };</pre>
<p>And then </p>
<pre class="brush: plain; title: ; notranslate">std::cout &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;</pre>
<p>would print [quote]01[/quote] to the console.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bill Lynch				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-35354</link>
		<dc:creator><![CDATA[Bill Lynch]]></dc:creator>
		<pubDate>Wed, 14 Jan 2015 03:23:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-35354</guid>
					<description><![CDATA[There&#039;s also the question if `i == 2` at the end of that expression.]]></description>
		<content:encoded><![CDATA[<p>There&#8217;s also the question if `i == 2` at the end of that expression.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Thornley				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-35110</link>
		<dc:creator><![CDATA[David Thornley]]></dc:creator>
		<pubDate>Fri, 09 Jan 2015 23:57:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-35110</guid>
					<description><![CDATA[Suppose we were doing this with a user-defined type, so instead of 
[code]
v[i++]=i++;
[/code]
we had
[code]
v.operator[](i.operator++())..operator=(i.operator++());
[/code]
In this case, we have unspecified behavior (feel free to correct me if I&#039;m wrong) because the order of function calls isn&#039;t completely specified.  There&#039;s advice to make UDTs that do arithmetic work like ints, so it seems reasonable to me to make the ints work like UDTs here.  That&#039;s why I voted for &quot;unspecified&quot;.

I don&#039;t want to specify a behavior here, because that&#039;s more stuff I&#039;d have to learn to read the code.  Ideally, I&#039;d like code that requires complicated rules to understand, and can easily be written less ambiguously, to be a genuine error.  C++ has enough readability problems, for a variety of reasons.

I&#039;ve become less fond of undefined behavior since gcc started optimizing it out so aggressively.  In cases like accessing outside the bounds of an array, I think it appropriate, since the likely outcomes (exception, wrong answer) are sufficiently different from one another.  In this case, we&#039;re going to get some reasonably valid result under any reasonable interpretation of what the computer is likely to do, so unspecified.]]></description>
		<content:encoded><![CDATA[<p>Suppose we were doing this with a user-defined type, so instead of </p>
<pre class="brush: plain; title: ; notranslate">
v[i++]=i++;
</pre>
<p>we had</p>
<pre class="brush: plain; title: ; notranslate">
v.operator[](i.operator++())..operator=(i.operator++());
</pre>
<p>In this case, we have unspecified behavior (feel free to correct me if I&#8217;m wrong) because the order of function calls isn&#8217;t completely specified.  There&#8217;s advice to make UDTs that do arithmetic work like ints, so it seems reasonable to me to make the ints work like UDTs here.  That&#8217;s why I voted for &#8220;unspecified&#8221;.</p>
<p>I don&#8217;t want to specify a behavior here, because that&#8217;s more stuff I&#8217;d have to learn to read the code.  Ideally, I&#8217;d like code that requires complicated rules to understand, and can easily be written less ambiguously, to be a genuine error.  C++ has enough readability problems, for a variety of reasons.</p>
<p>I&#8217;ve become less fond of undefined behavior since gcc started optimizing it out so aggressively.  In cases like accessing outside the bounds of an array, I think it appropriate, since the likely outcomes (exception, wrong answer) are sufficiently different from one another.  In this case, we&#8217;re going to get some reasonably valid result under any reasonable interpretation of what the computer is likely to do, so unspecified.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fax				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-34989</link>
		<dc:creator><![CDATA[Fax]]></dc:creator>
		<pubDate>Wed, 07 Jan 2015 15:08:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-34989</guid>
					<description><![CDATA[Preferably a compile time error stating that post-increment is illegal syntax.]]></description>
		<content:encoded><![CDATA[<p>Preferably a compile time error stating that post-increment is illegal syntax.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dilip Ranganathan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-34865</link>
		<dc:creator><![CDATA[Dilip Ranganathan]]></dc:creator>
		<pubDate>Mon, 05 Jan 2015 21:16:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-34865</guid>
					<description><![CDATA[What is going to become of this poll anyway? Will it sound the death knell for N4228?]]></description>
		<content:encoded><![CDATA[<p>What is going to become of this poll anyway? Will it sound the death knell for N4228?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Doubleday				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-34801</link>
		<dc:creator><![CDATA[Peter Doubleday]]></dc:creator>
		<pubDate>Sun, 04 Jan 2015 16:38:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-34801</guid>
					<description><![CDATA[I&#039;m a UB man (it&#039;ll learn people not to write this stuff!) followed by a 0 1 man, because I expect an RHS expression to be calculated before the LHS storage location is calculated.  I particularly expect this with right-to-left associativity.
Which raises the question of what I would expect in a similar code-snippet using the equality operator (left-to-right associativity).  I should expect the LHS post-increment to be evaluated before the RHS post-increment, I suppose, but you know what? I&#039;ve just consulted my C++ back-brain, and I don&#039;t.
And please don&#039;t hurt my brain by mutating the question to, say, the comma operator.  I don&#039;t even know whether this is defined behaviour or not.
I guess what I&#039;m saying is that, if this monstrosity has to be allowed for some reason, then it should be an exceptionally clear and well-defined reason.  If it&#039;s strictly based on operator associativity, I could learn to live with that.
(Luckily, the scope resolution operator doesn&#039;t come into play here!)]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m a UB man (it&#8217;ll learn people not to write this stuff!) followed by a 0 1 man, because I expect an RHS expression to be calculated before the LHS storage location is calculated.  I particularly expect this with right-to-left associativity.<br />
Which raises the question of what I would expect in a similar code-snippet using the equality operator (left-to-right associativity).  I should expect the LHS post-increment to be evaluated before the RHS post-increment, I suppose, but you know what? I&#8217;ve just consulted my C++ back-brain, and I don&#8217;t.<br />
And please don&#8217;t hurt my brain by mutating the question to, say, the comma operator.  I don&#8217;t even know whether this is defined behaviour or not.<br />
I guess what I&#8217;m saying is that, if this monstrosity has to be allowed for some reason, then it should be an exceptionally clear and well-defined reason.  If it&#8217;s strictly based on operator associativity, I could learn to live with that.<br />
(Luckily, the scope resolution operator doesn&#8217;t come into play here!)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ricardo Costa				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-34609</link>
		<dc:creator><![CDATA[Ricardo Costa]]></dc:creator>
		<pubDate>Wed, 31 Dec 2014 20:55:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-34609</guid>
					<description><![CDATA[I voted for 10 because I think the left-hand expression should be evaluated first. The command a = b translates in my mind to a.operator=(b), and it&#039;s more natural to know the type of &quot;a&quot; (and the operators it contains) before we actually evaluate and pass arguments to the call.

However, there is also this case:

a = b = c = d

Which is currently interpreted as a = (b = (c = d)). That means the right-hand side is evaluated first. So, in a second thought, C/C++ programmers might be more used to right-hand evaluation happening before left-hand.]]></description>
		<content:encoded><![CDATA[<p>I voted for 10 because I think the left-hand expression should be evaluated first. The command a = b translates in my mind to a.operator=(b), and it&#8217;s more natural to know the type of &#8220;a&#8221; (and the operators it contains) before we actually evaluate and pass arguments to the call.</p>
<p>However, there is also this case:</p>
<p>a = b = c = d</p>
<p>Which is currently interpreted as a = (b = (c = d)). That means the right-hand side is evaluated first. So, in a second thought, C/C++ programmers might be more used to right-hand evaluation happening before left-hand.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Marcos				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-34585</link>
		<dc:creator><![CDATA[Fernando Marcos]]></dc:creator>
		<pubDate>Wed, 31 Dec 2014 11:48:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-34585</guid>
					<description><![CDATA[My vote goes for the 00 result.

I haven&#039;t tested current results, but &quot;in my mind&quot; that is an &quot;assignment&quot; and that involves two different expressions. As I would do if I faced a blackboard with &quot;a = b + 1&quot; I would first focus on the right side of the assignment (&quot;b + 1&quot;) so I would solve that first FULLY as the first expression (as if it were a function call). Then I&#039;d assign that value to the left expression (whatever it is).

Adding post-increments to the equation, I &quot;would&quot; define their behavior to be applied AFTER the computation has been performed and BEFORE the computed value is used, in a left to right manner (or, again in my mind &quot;expression context&quot;)

[CODE]
int a = 4;
int b = (a++ + a++);
[/CODE]

I would expect &quot;9&quot; as a result (4+5), leaving variable &quot;a&quot; as 6 before assigning the result to &quot;b&quot;.

In case of several successive expressions, like in:

[CODE]
int a = 4;
int b = func(a++ + a++, a++);
[/CODE]

I would expect the two expressions being evaluated left to right and the function invoked with arguments &quot;9,6&quot;.

Turning back to the original example:

[CODE]
std::vector v = { 0, 0 };
int i = 0;
v[i++] = i++;
std::cout &#060;&#060; v[0] &#060;&#060; v[1] &#060;&#060; endl;
[/CODE]

I&#039;d expect the right hand expression to yield value &#034;0&#034;, be post-incremented before the variable is again used in the left hand expression so

[CODE]
int i = 0;
const auto result = i;
i = i + 1;
v[i] = result;
i = i + 1;
[/CODE]

Having said that, an issue arises... it would not be the same
[CODE]
v[i++] = i++;
[/CODE]

than

[CODE]
void assignFunc(int&#038; a,int &#038;b)
{
  a = b;
}
assignFunc(v[i++],i++);
[/CODE]

In any case, such an obvious &#034;double post increment&#034; scenario a compiler warning/error could be nice - I understand that performing alias detection could be a real nightmare.

Just my two cents!]]></description>
		<content:encoded><![CDATA[<p>My vote goes for the 00 result.</p>
<p>I haven&#8217;t tested current results, but &#8220;in my mind&#8221; that is an &#8220;assignment&#8221; and that involves two different expressions. As I would do if I faced a blackboard with &#8220;a = b + 1&#8221; I would first focus on the right side of the assignment (&#8220;b + 1&#8221;) so I would solve that first FULLY as the first expression (as if it were a function call). Then I&#8217;d assign that value to the left expression (whatever it is).</p>
<p>Adding post-increments to the equation, I &#8220;would&#8221; define their behavior to be applied AFTER the computation has been performed and BEFORE the computed value is used, in a left to right manner (or, again in my mind &#8220;expression context&#8221;)</p>
<p>[CODE]<br />
int a = 4;<br />
int b = (a++ + a++);<br />
[/CODE]</p>
<p>I would expect &#8220;9&#8221; as a result (4+5), leaving variable &#8220;a&#8221; as 6 before assigning the result to &#8220;b&#8221;.</p>
<p>In case of several successive expressions, like in:</p>
<p>[CODE]<br />
int a = 4;<br />
int b = func(a++ + a++, a++);<br />
[/CODE]</p>
<p>I would expect the two expressions being evaluated left to right and the function invoked with arguments &#8220;9,6&#8221;.</p>
<p>Turning back to the original example:</p>
<p>[CODE]<br />
std::vector v = { 0, 0 };<br />
int i = 0;<br />
v[i++] = i++;<br />
std::cout &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;<br />
[/CODE]</p>
<p>I&#039;d expect the right hand expression to yield value &quot;0&quot;, be post-incremented before the variable is again used in the left hand expression so</p>
<p>[CODE]<br />
int i = 0;<br />
const auto result = i;<br />
i = i + 1;<br />
v[i] = result;<br />
i = i + 1;<br />
[/CODE]</p>
<p>Having said that, an issue arises&#8230; it would not be the same<br />
[CODE]<br />
v[i++] = i++;<br />
[/CODE]</p>
<p>than</p>
<p>[CODE]<br />
void assignFunc(int&amp; a,int &amp;b)<br />
{<br />
  a = b;<br />
}<br />
assignFunc(v[i++],i++);<br />
[/CODE]</p>
<p>In any case, such an obvious &quot;double post increment&quot; scenario a compiler warning/error could be nice &#8211; I understand that performing alias detection could be a real nightmare.</p>
<p>Just my two cents!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marc Espie				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-34352</link>
		<dc:creator><![CDATA[Marc Espie]]></dc:creator>
		<pubDate>Fri, 26 Dec 2014 15:51:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-34352</guid>
					<description><![CDATA[I&#039;m still voting for compiler diagnostic. In that specific case (i++ twice) this is obvious.

For more devious constructs where the compiler can&#039;t conclude (i++ vs j++ with names so defined that there could be an alias, like because of templates for instance, or thru pointers with no restrict in effect so that we don&#039;t know it&#039;s the same pointer), I would still vote for a diagnostic.

If that code is so convoluted that the compiler can&#039;t figure out it&#039;s safe, it doesn&#039;t belong in a valid program.  We&#039;re not talking normal Turing machine rules. We&#039;re talking a specific case where it&#039;s perfectly okay to answer &quot;this is safe&quot; or &quot;I don&#039;t know, so disallow it&quot;.

In the worst case, you end up splitting the instruction and adding a ;. That&#039;s much better than hard-to-diagnose bugs.

Forcing an order of evaluation is wrong. It puts more constraints on the compiler itself, which already has a hard time doing a good job on modern architectures.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m still voting for compiler diagnostic. In that specific case (i++ twice) this is obvious.</p>
<p>For more devious constructs where the compiler can&#8217;t conclude (i++ vs j++ with names so defined that there could be an alias, like because of templates for instance, or thru pointers with no restrict in effect so that we don&#8217;t know it&#8217;s the same pointer), I would still vote for a diagnostic.</p>
<p>If that code is so convoluted that the compiler can&#8217;t figure out it&#8217;s safe, it doesn&#8217;t belong in a valid program.  We&#8217;re not talking normal Turing machine rules. We&#8217;re talking a specific case where it&#8217;s perfectly okay to answer &#8220;this is safe&#8221; or &#8220;I don&#8217;t know, so disallow it&#8221;.</p>
<p>In the worst case, you end up splitting the instruction and adding a ;. That&#8217;s much better than hard-to-diagnose bugs.</p>
<p>Forcing an order of evaluation is wrong. It puts more constraints on the compiler itself, which already has a hard time doing a good job on modern architectures.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marc Espie				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33857</link>
		<dc:creator><![CDATA[Marc Espie]]></dc:creator>
		<pubDate>Wed, 17 Dec 2014 10:29:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33857</guid>
					<description><![CDATA[This should definitely be a compile error. Not even a warning, but a hard error. This code is undefined behavior, and every compiler we know of is able to analyse local code and figure out double i++ in one single instruction.]]></description>
		<content:encoded><![CDATA[<p>This should definitely be a compile error. Not even a warning, but a hard error. This code is undefined behavior, and every compiler we know of is able to analyse local code and figure out double i++ in one single instruction.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mohammad Skafi				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33852</link>
		<dc:creator><![CDATA[Mohammad Skafi]]></dc:creator>
		<pubDate>Wed, 17 Dec 2014 08:06:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33852</guid>
					<description><![CDATA[Taking into consideration the following:
&lt;code&gt;u[i++] = v[i++] = i++;&lt;/code&gt;
and the fact that operator++ could be user defined, and the fact that operator= associates right-to-left, it makes sense to expand it as:
[code]
tmp = i
i = i+1

v[i] = tmp
i = i+1

u[i] = v[i]
i = i+1
[/code]]]></description>
		<content:encoded><![CDATA[<p>Taking into consideration the following:<br />
<code>u[i++] = v[i++] = i++;</code><br />
and the fact that operator++ could be user defined, and the fact that operator= associates right-to-left, it makes sense to expand it as:</p>
<pre class="brush: plain; title: ; notranslate">
tmp = i
i = i+1

v[i] = tmp
i = i+1

u[i] = v[i]
i = i+1
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tyrone T. Berhane				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33713</link>
		<dc:creator><![CDATA[Tyrone T. Berhane]]></dc:creator>
		<pubDate>Mon, 15 Dec 2014 00:34:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33713</guid>
					<description><![CDATA[int i = 0;
 v[i++] = i++;

Herb, by the way, after looking a bit closer, the postfix looks correct by logic, because the vector being an internal system based feature is close to the language itself, a distance away from something coming into a database, externally, by way of string or integer.  Anything assigned to it , by prefix would make sense, by standard. Features, ususally being closerr to the first things on the compilers list, after the common data types and such, looks like it would shovel the similar for the postfix, being lower on the compilers list, by structural logic. makes some sense, yet it is&#039; a complexity based implementation. An old saying followed this. &quot;When approchment to a problem set needs a work around.&quot;  That&#039;s where I&#039;ve seen this kind of code, in my own.  But if the rest of the program&#039;s code doesn&#039;t reflect this level of complexity, then you could probably have someone make the whole program easier, by way of resource management.]]></description>
		<content:encoded><![CDATA[<p>int i = 0;<br />
 v[i++] = i++;</p>
<p>Herb, by the way, after looking a bit closer, the postfix looks correct by logic, because the vector being an internal system based feature is close to the language itself, a distance away from something coming into a database, externally, by way of string or integer.  Anything assigned to it , by prefix would make sense, by standard. Features, ususally being closerr to the first things on the compilers list, after the common data types and such, looks like it would shovel the similar for the postfix, being lower on the compilers list, by structural logic. makes some sense, yet it is&#8217; a complexity based implementation. An old saying followed this. &#8220;When approchment to a problem set needs a work around.&#8221;  That&#8217;s where I&#8217;ve seen this kind of code, in my own.  But if the rest of the program&#8217;s code doesn&#8217;t reflect this level of complexity, then you could probably have someone make the whole program easier, by way of resource management.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tyrone T. Berhane				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33712</link>
		<dc:creator><![CDATA[Tyrone T. Berhane]]></dc:creator>
		<pubDate>Mon, 15 Dec 2014 00:20:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33712</guid>
					<description><![CDATA[int i = 0;
v[i++] = i++;


There&#039;s nothing here that seems much afoul here.  One would just be dealing with two logic layers of abstraction.  Usually if you see code like that in a file, the person has the potential to max out the programs capabilities at a different open points.

Code like that, read on a daily code review basis, requires a set of desk glasses.

I wrote code like that in school projects where I exceeded the level of abstraction common to the programming exercises by complexity of 2.

I guess the level of abstraction were common, we&#039;d be done with part of the main scientific problem sets of the past 40 years or so, only if expertise becomes a rational thing in the areas of the senior sciences, rather than complementary research and result handling.]]></description>
		<content:encoded><![CDATA[<p>int i = 0;<br />
v[i++] = i++;</p>
<p>There&#8217;s nothing here that seems much afoul here.  One would just be dealing with two logic layers of abstraction.  Usually if you see code like that in a file, the person has the potential to max out the programs capabilities at a different open points.</p>
<p>Code like that, read on a daily code review basis, requires a set of desk glasses.</p>
<p>I wrote code like that in school projects where I exceeded the level of abstraction common to the programming exercises by complexity of 2.</p>
<p>I guess the level of abstraction were common, we&#8217;d be done with part of the main scientific problem sets of the past 40 years or so, only if expertise becomes a rational thing in the areas of the senior sciences, rather than complementary research and result handling.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33432</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Mon, 08 Dec 2014 21:26:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33432</guid>
					<description><![CDATA[I&#039;d like this being (in standard&#039;s terms) &quot;ill formed (no diagnostics required)&quot;. That&#039;s almost status quo (as far as I can tell it&#039;s answer 5).

You cannot do any real justice among the &quot;good&quot; answers, only force one of them, or keep the status quo of UB. And I don&#039;t even care here if it&#039;s the launching-missiles or just the you-can-get-any-answer kind of UB, both of them is equally wrong. (BTW, I would rather call the later &quot;implementation specified&quot; than &quot;unspecified&quot; behavior, keep the UB term for potential missile launches.)

The whole &quot;v[i++] = i++;&quot; thing is over-engineered anyway, programmers should write easily understandable code, not this; it is in no way worse to write &quot;v[i] = i; i+=2;&quot; instead (or whatever version you actually wanted). It&#039;s also better from teachability POW: One shouldn&#039;t have to waste time to teach/learn stuff that is not supposed to write anyway.

Make expressions with ambiguous sequence point ordering an error, that will enforce better code and straightforward to teach. I added the &quot;no diagnostics required&quot; part so that current compilers are immediately conformant with the language change, but to still encourage future compiler versions to emit an error (or warning; some of them already do).]]></description>
		<content:encoded><![CDATA[<p>I&#8217;d like this being (in standard&#8217;s terms) &#8220;ill formed (no diagnostics required)&#8221;. That&#8217;s almost status quo (as far as I can tell it&#8217;s answer 5).</p>
<p>You cannot do any real justice among the &#8220;good&#8221; answers, only force one of them, or keep the status quo of UB. And I don&#8217;t even care here if it&#8217;s the launching-missiles or just the you-can-get-any-answer kind of UB, both of them is equally wrong. (BTW, I would rather call the later &#8220;implementation specified&#8221; than &#8220;unspecified&#8221; behavior, keep the UB term for potential missile launches.)</p>
<p>The whole &#8220;v[i++] = i++;&#8221; thing is over-engineered anyway, programmers should write easily understandable code, not this; it is in no way worse to write &#8220;v[i] = i; i+=2;&#8221; instead (or whatever version you actually wanted). It&#8217;s also better from teachability POW: One shouldn&#8217;t have to waste time to teach/learn stuff that is not supposed to write anyway.</p>
<p>Make expressions with ambiguous sequence point ordering an error, that will enforce better code and straightforward to teach. I added the &#8220;no diagnostics required&#8221; part so that current compilers are immediately conformant with the language change, but to still encourage future compiler versions to emit an error (or warning; some of them already do).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: V				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33340</link>
		<dc:creator><![CDATA[V]]></dc:creator>
		<pubDate>Sat, 06 Dec 2014 23:17:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33340</guid>
					<description><![CDATA[10 (if my in-mind compiler served me right), i.e left to right. This really boils down to &quot;what is easier to teach to a beginner&quot; - in which case it seems pretty obvious to me. C++ is read by people left to right, then I would believe that that is also likely going to be what people expect is going to happen. &quot;But this part here is placed BEFORE that, then why isn&#039;t it running in that order?&quot;

I also think that Sean Parent&#039;s point about what other languages do is a very valid one.]]></description>
		<content:encoded><![CDATA[<p>10 (if my in-mind compiler served me right), i.e left to right. This really boils down to &#8220;what is easier to teach to a beginner&#8221; &#8211; in which case it seems pretty obvious to me. C++ is read by people left to right, then I would believe that that is also likely going to be what people expect is going to happen. &#8220;But this part here is placed BEFORE that, then why isn&#8217;t it running in that order?&#8221;</p>
<p>I also think that Sean Parent&#8217;s point about what other languages do is a very valid one.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Georg Legato				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33339</link>
		<dc:creator><![CDATA[Georg Legato]]></dc:creator>
		<pubDate>Sat, 06 Dec 2014 22:12:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33339</guid>
					<description><![CDATA[&quot;12&quot; should be the answer.
Think about Ms. Liskov:

[code]
/* following the Liskov idea of substitution... */

#include &#060;vector&#062;
#include &#060;iostream&#062;
using namespace std;

int pincr (int&#038; x, const char &#038; who)
{
    cout &#060;&#060; &#034;   f: &#034; &#060;&#060; x &#060;&#060; &#034; who: &#034; &#060;&#060; &#038;who &#060;&#060; endl;    
    return ++x;
}

struct IntBox {
    IntBox () : i(0) {}
    int i;
    int operator++(int x) {++i; return i;}
};

int main()
{
    vector&#060;int&#062; v = { 0, 0 };
    int i = 0;

    v[i++] = i++;
    cout &#060;&#060; &#034;herb´s: &#034; &#060;&#060; v[0] &#060;&#060; v[1] &#060;&#060; endl;

    i = 0;
    v[pincr(i,*&#034;LHS&#034;)] = pincr(i,*&#034;RHS&#034;) ;
    cout &#060;&#060; &#034;funcIncr:&#034; &#060;&#060; v[0] &#060;&#060; v[1] &#060;&#060; endl;

    IntBox I;
    v[I++] = I++;
    cout &#060;&#060; &#034;operator++: &#034; &#060;&#060; v[0] &#060;&#060; v[1] &#060;&#060; endl;
    
    i = 0;
    auto lam = [&#038;](){return i++;};
    v[lam()] = lam();
    cout &#060;&#060; &#034;two lambdas: &#034; &#060;&#060; v[0] &#060;&#060; v[1] &#060;&#060; endl;

}

[/code]]]></description>
		<content:encoded><![CDATA[<p>&#8220;12&#8221; should be the answer.<br />
Think about Ms. Liskov:</p>
<pre class="brush: plain; title: ; notranslate">
/* following the Liskov idea of substitution... */

#include &lt;vector&gt;
#include &lt;iostream&gt;
using namespace std;

int pincr (int&amp; x, const char &amp; who)
{
    cout &lt;&lt; &quot;   f: &quot; &lt;&lt; x &lt;&lt; &quot; who: &quot; &lt;&lt; &amp;who &lt;&lt; endl;    
    return ++x;
}

struct IntBox {
    IntBox () : i(0) {}
    int i;
    int operator++(int x) {++i; return i;}
};

int main()
{
    vector&lt;int&gt; v = { 0, 0 };
    int i = 0;

    v[i++] = i++;
    cout &lt;&lt; &quot;herb´s: &quot; &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;

    i = 0;
    v[pincr(i,*&quot;LHS&quot;)] = pincr(i,*&quot;RHS&quot;) ;
    cout &lt;&lt; &quot;funcIncr:&quot; &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;

    IntBox I;
    v[I++] = I++;
    cout &lt;&lt; &quot;operator++: &quot; &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;
    
    i = 0;
    auto lam = [&amp;](){return i++;};
    v[lam()] = lam();
    cout &lt;&lt; &quot;two lambdas: &quot; &lt;&lt; v[0] &lt;&lt; v[1] &lt;&lt; endl;

}

</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: hyrosen				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33264</link>
		<dc:creator><![CDATA[hyrosen]]></dc:creator>
		<pubDate>Fri, 05 Dec 2014 15:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33264</guid>
					<description><![CDATA[@Michael (Post-)incrementing as the last operation of the full expression would, among other things, break existing code, since as things stand now, side effects of arguments to a function must be complete before the function is called.]]></description>
		<content:encoded><![CDATA[<p>@Michael (Post-)incrementing as the last operation of the full expression would, among other things, break existing code, since as things stand now, side effects of arguments to a function must be complete before the function is called.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33252</link>
		<dc:creator><![CDATA[Michael]]></dc:creator>
		<pubDate>Fri, 05 Dec 2014 10:03:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33252</guid>
					<description><![CDATA[Do we have something like f(g(i++),i++); here? I like 00 because it can be phrased as a simple rule - if several sub-expressions of single statement contain post increments than incrementing is to be performed as the very last operation.

10 or 01 would require hard to memorize rules...]]></description>
		<content:encoded><![CDATA[<p>Do we have something like f(g(i++),i++); here? I like 00 because it can be phrased as a simple rule &#8211; if several sub-expressions of single statement contain post increments than incrementing is to be performed as the very last operation.</p>
<p>10 or 01 would require hard to memorize rules&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jason Kikel				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33206</link>
		<dc:creator><![CDATA[Jason Kikel]]></dc:creator>
		<pubDate>Thu, 04 Dec 2014 17:37:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33206</guid>
					<description><![CDATA[Can anyone explain why this doesn&#039;t invoke the fill constructor?]]></description>
		<content:encoded><![CDATA[<p>Can anyone explain why this doesn&#8217;t invoke the fill constructor?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ophir				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33187</link>
		<dc:creator><![CDATA[Ophir]]></dc:creator>
		<pubDate>Thu, 04 Dec 2014 10:18:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33187</guid>
					<description><![CDATA[I vote for 10 as I prefer left-to-right evaluation, which goes the same way that a human reads the code. But if this can cause compilers to miss optimization opportunities, I would go with unspecified. The pole is somewhat misleading is 00 represent two different behaviors - i[0]=0 and i[1]=0. In addition, I can&#039;t understand how the result 01 got so many votes, why would anybody expect that?]]></description>
		<content:encoded><![CDATA[<p>I vote for 10 as I prefer left-to-right evaluation, which goes the same way that a human reads the code. But if this can cause compilers to miss optimization opportunities, I would go with unspecified. The pole is somewhat misleading is 00 represent two different behaviors &#8211; i[0]=0 and i[1]=0. In addition, I can&#8217;t understand how the result 01 got so many votes, why would anybody expect that?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Karl Hansson				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33153</link>
		<dc:creator><![CDATA[Karl Hansson]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 21:40:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33153</guid>
					<description><![CDATA[Is there a value in letting different compilers deal with things like this their own ways rather than to standardize a particular behavior?  Personally I prefer things things to be standardized as much as possible.]]></description>
		<content:encoded><![CDATA[<p>Is there a value in letting different compilers deal with things like this their own ways rather than to standardize a particular behavior?  Personally I prefer things things to be standardized as much as possible.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dilip Ranganathan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33147</link>
		<dc:creator><![CDATA[Dilip Ranganathan]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 20:17:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33147</guid>
					<description><![CDATA[So does C#. Its not like Herb doesn&#039;t know this already. As always with C++ if we don&#039;t make things at least a wee bit complicated, we&#039;d get withdrawal symptoms.]]></description>
		<content:encoded><![CDATA[<p>So does C#. Its not like Herb doesn&#8217;t know this already. As always with C++ if we don&#8217;t make things at least a wee bit complicated, we&#8217;d get withdrawal symptoms.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dilip Ranganathan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33146</link>
		<dc:creator><![CDATA[Dilip Ranganathan]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 20:16:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33146</guid>
					<description><![CDATA[Finally! a voice of reason!]]></description>
		<content:encoded><![CDATA[<p>Finally! a voice of reason!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sean Parent				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33140</link>
		<dc:creator><![CDATA[Sean Parent]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 18:11:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33140</guid>
					<description><![CDATA[(really? - strips links without allowing me to edit?) Search stackoverflow for &quot;What are the rules for evaluation order in Java?&quot;]]></description>
		<content:encoded><![CDATA[<p>(really? &#8211; strips links without allowing me to edit?) Search stackoverflow for &#8220;What are the rules for evaluation order in Java?&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sean Parent				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33139</link>
		<dc:creator><![CDATA[Sean Parent]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 18:09:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33139</guid>
					<description><![CDATA[Commenting on own post - Initially I read 00 to imply no writes - as noted by others it can imply r to l evaluation. Remainder of my comment stands. I don&#039;t have an issue with getting rid of undefined behavior, but it should be done with an argument from data. I have no data in support of either side, and in this case I think speculating about what the compiler might (or might not) do is just that. As for what the evaluation order should be, I&#039;d look at other languages before creating a new set of rules - it sounds like people are trying to apply precedence rules to subexpression evaluation ordering - see the answer here .]]></description>
		<content:encoded><![CDATA[<p>Commenting on own post &#8211; Initially I read 00 to imply no writes &#8211; as noted by others it can imply r to l evaluation. Remainder of my comment stands. I don&#8217;t have an issue with getting rid of undefined behavior, but it should be done with an argument from data. I have no data in support of either side, and in this case I think speculating about what the compiler might (or might not) do is just that. As for what the evaluation order should be, I&#8217;d look at other languages before creating a new set of rules &#8211; it sounds like people are trying to apply precedence rules to subexpression evaluation ordering &#8211; see the answer here .</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: hyrosen				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33133</link>
		<dc:creator><![CDATA[hyrosen]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 16:29:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33133</guid>
					<description><![CDATA[This is why people go off and create their own programming languages.  I know that I&#039;m right, but I have long since given up hope that C/C++ will ever do it - I&#039;ve been arguing about this for years.  Also, not that it will convince anyone here, strict left-to-right is the way it&#039;s done in Java: http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.7]]></description>
		<content:encoded><![CDATA[<p>This is why people go off and create their own programming languages.  I know that I&#8217;m right, but I have long since given up hope that C/C++ will ever do it &#8211; I&#8217;ve been arguing about this for years.  Also, not that it will convince anyone here, strict left-to-right is the way it&#8217;s done in Java: <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.7" rel="nofollow">http://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.7</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Eric				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33131</link>
		<dc:creator><![CDATA[Eric]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 16:21:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33131</guid>
					<description><![CDATA[@Matt C, the compiler won&#039;t know in general which of f_1(i) or f_2(i) will be more complicated to evaluate, especially since this can change depending on conditionals and run time state.

I would consider it far more important to achieve consistent behavior, rather than to reach for possibly better performance in some cases at the cost of potentially inconsistent behavior.

In particular, I would not want it to be the case that the behavior changes if I choose to first create an explicit named reference to the destination location of an assignment.

[code]
int &#038; foo = expression, e.g. involving v[f_1()]
foo = f_2();
// potentially more operations involving foo
[/code]

The only way to ensure consistency of behavior with or without a named reference is to evaluate the LHS of the assignment first, just as you first posed.  Otherwise, seemingly equivalent code could behave differently.]]></description>
		<content:encoded><![CDATA[<p>@Matt C, the compiler won&#8217;t know in general which of f_1(i) or f_2(i) will be more complicated to evaluate, especially since this can change depending on conditionals and run time state.</p>
<p>I would consider it far more important to achieve consistent behavior, rather than to reach for possibly better performance in some cases at the cost of potentially inconsistent behavior.</p>
<p>In particular, I would not want it to be the case that the behavior changes if I choose to first create an explicit named reference to the destination location of an assignment.</p>
<pre class="brush: plain; title: ; notranslate">
int &amp; foo = expression, e.g. involving v[f_1()]
foo = f_2();
// potentially more operations involving foo
</pre>
<p>The only way to ensure consistency of behavior with or without a named reference is to evaluate the LHS of the assignment first, just as you first posed.  Otherwise, seemingly equivalent code could behave differently.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt C				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33129</link>
		<dc:creator><![CDATA[Matt C]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 15:58:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33129</guid>
					<description><![CDATA[So when I looked at the question, I immediately thought, &quot;I would expect this to execute left-to-right&quot;.

[code]v[i++] =&#062; lhs = v[0], i = 1.
i++ =&#062; rhs = 1, i = 2.
lhs = rhs =&#062; v[0] = 1.[/code]

So that gives the &quot;10&quot; result.

But, that means that the reference to v[0] has to be held somewhere.  Either in a register, or (possibly expensively) pushed onto the stack.  Now, the right hand side of an expression is usually *far* more complicated than the left, and putting that register out of use could be detrimental to performance.  

And so I&#039;d rather leave it unspecified so that the compiler can do whatever it works out to be fastest, because whatever rule takes place here doesn&#039;t *just* affect aliasing problems, but all assignments.  Consider also:

[code]
void complicated_1(int &#038;);
void complicated_2(int &#038;);

v[complicated_1(i)] = complicated_2(i);
[/code]]]></description>
		<content:encoded><![CDATA[<p>So when I looked at the question, I immediately thought, &#8220;I would expect this to execute left-to-right&#8221;.</p>
<pre class="brush: plain; title: ; notranslate">v[i++] =&gt; lhs = v[0], i = 1.
i++ =&gt; rhs = 1, i = 2.
lhs = rhs =&gt; v[0] = 1.</pre>
<p>So that gives the &#8220;10&#8221; result.</p>
<p>But, that means that the reference to v[0] has to be held somewhere.  Either in a register, or (possibly expensively) pushed onto the stack.  Now, the right hand side of an expression is usually *far* more complicated than the left, and putting that register out of use could be detrimental to performance.  </p>
<p>And so I&#8217;d rather leave it unspecified so that the compiler can do whatever it works out to be fastest, because whatever rule takes place here doesn&#8217;t *just* affect aliasing problems, but all assignments.  Consider also:</p>
<pre class="brush: plain; title: ; notranslate">
void complicated_1(int &amp;);
void complicated_2(int &amp;);

v[complicated_1(i)] = complicated_2(i);
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dilip Ranganathan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33124</link>
		<dc:creator><![CDATA[Dilip Ranganathan]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 15:04:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33124</guid>
					<description><![CDATA[@Joseph Mansfield: I don&#039;t understand the C++ community&#039;s infatuation with leaving things unspecified _even_ when given an opportunity to specify a particular outcome. In this particular case, I would like to ask you (and just about every commenter watching this thread and maybe Herb himself), what would be technical argument against specifying a strict left-to-right order of evaluation? (leaving aside the question of programmer expectations for the moment)]]></description>
		<content:encoded><![CDATA[<p>@Joseph Mansfield: I don&#8217;t understand the C++ community&#8217;s infatuation with leaving things unspecified _even_ when given an opportunity to specify a particular outcome. In this particular case, I would like to ask you (and just about every commenter watching this thread and maybe Herb himself), what would be technical argument against specifying a strict left-to-right order of evaluation? (leaving aside the question of programmer expectations for the moment)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dilip Ranganathan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33123</link>
		<dc:creator><![CDATA[Dilip Ranganathan]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 15:01:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33123</guid>
					<description><![CDATA[@Evan -- are you serious? I can&#039;t tell.]]></description>
		<content:encoded><![CDATA[<p>@Evan &#8212; are you serious? I can&#8217;t tell.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: arnecls				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33121</link>
		<dc:creator><![CDATA[arnecls]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 13:30:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33121</guid>
					<description><![CDATA[From a first look I would expect it to write 0 to v[1], so {0,0}.

Why?
- Right side is executed first (the value has to be generated before you can assign it).
- i++ returns 0, i is now 1
- After this the array is accessed i++ returns 1, i is now 2
- So basically it should be v[1] = 0;

But ....
If you rewrite it to use more than one line there are multiple possibilities.

[code]
int value = i++;
int&#038; target = v[i++];
target = value;
[/code]

[code]
int&#038; target = v[i++];
int value = i++;
target = value;
[/code]

As of this I guess undefined is the correct way to go to be &quot;consistent&quot; with different implementation variants.]]></description>
		<content:encoded><![CDATA[<p>From a first look I would expect it to write 0 to v[1], so {0,0}.</p>
<p>Why?<br />
&#8211; Right side is executed first (the value has to be generated before you can assign it).<br />
&#8211; i++ returns 0, i is now 1<br />
&#8211; After this the array is accessed i++ returns 1, i is now 2<br />
&#8211; So basically it should be v[1] = 0;</p>
<p>But &#8230;.<br />
If you rewrite it to use more than one line there are multiple possibilities.</p>
<pre class="brush: plain; title: ; notranslate">
int value = i++;
int&amp; target = v[i++];
target = value;
</pre>
<pre class="brush: plain; title: ; notranslate">
int&amp; target = v[i++];
int value = i++;
target = value;
</pre>
<p>As of this I guess undefined is the correct way to go to be &#8220;consistent&#8221; with different implementation variants.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: arnecls				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33120</link>
		<dc:creator><![CDATA[arnecls]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 13:28:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33120</guid>
					<description><![CDATA[I would expect it to write 0 to v[1], so {0,0}.

Why?
- Right side is executed first (the value has to be generated before you can assign it).
- i++ returns 0, i is now 1
- After this the array is accessed i++ returns 1, i is now 2
- So basically it should be v[1] = 0;

But ....
If you rewrite it to use more than one line there are multiple possibilities.

int value = i++;
int&#038; target = v[i++];
target = value;

int&#038; target = v[i++];
int value = i++;
target = value;

As of this I guess undefined is the correct way to go to be &quot;consistent&quot;.]]></description>
		<content:encoded><![CDATA[<p>I would expect it to write 0 to v[1], so {0,0}.</p>
<p>Why?<br />
&#8211; Right side is executed first (the value has to be generated before you can assign it).<br />
&#8211; i++ returns 0, i is now 1<br />
&#8211; After this the array is accessed i++ returns 1, i is now 2<br />
&#8211; So basically it should be v[1] = 0;</p>
<p>But &#8230;.<br />
If you rewrite it to use more than one line there are multiple possibilities.</p>
<p>int value = i++;<br />
int&amp; target = v[i++];<br />
target = value;</p>
<p>int&amp; target = v[i++];<br />
int value = i++;<br />
target = value;</p>
<p>As of this I guess undefined is the correct way to go to be &#8220;consistent&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joseph Mansfield (@sftrabbit)				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33105</link>
		<dc:creator><![CDATA[Joseph Mansfield (@sftrabbit)]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 09:23:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33105</guid>
					<description><![CDATA[I voted for unspecified for two reasons:

1. I do not like the idea of enforcing further sequencing rules on expressions. The current sequenced-before rules are intuitive and map nicely to the syntax tree.

2. It is clear that there really is some known set of side effects that might arise from this expression. I can&#039;t see any reason for a compiler to manipulate this in anyway that would result in some outcome that is not expected. An execution path with multiple known outcomes is &quot;unspecified behaviour&quot;. Undefined behaviour is just too loose.]]></description>
		<content:encoded><![CDATA[<p>I voted for unspecified for two reasons:</p>
<p>1. I do not like the idea of enforcing further sequencing rules on expressions. The current sequenced-before rules are intuitive and map nicely to the syntax tree.</p>
<p>2. It is clear that there really is some known set of side effects that might arise from this expression. I can&#8217;t see any reason for a compiler to manipulate this in anyway that would result in some outcome that is not expected. An execution path with multiple known outcomes is &#8220;unspecified behaviour&#8221;. Undefined behaviour is just too loose.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Hyman Rosen				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33082</link>
		<dc:creator><![CDATA[Hyman Rosen]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 02:29:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33082</guid>
					<description><![CDATA[@Evan I&#039;m utterly baffled why you would want a statement in a programming language, which is written for no other purpose than asking a computer to produce a desired result, to have an ambiguous interpretation.  It&#039;s all fun and games until someone loses an eye.]]></description>
		<content:encoded><![CDATA[<p>@Evan I&#8217;m utterly baffled why you would want a statement in a programming language, which is written for no other purpose than asking a computer to produce a desired result, to have an ambiguous interpretation.  It&#8217;s all fun and games until someone loses an eye.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bdsoftware				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33071</link>
		<dc:creator><![CDATA[bdsoftware]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 01:07:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33071</guid>
					<description><![CDATA[@Evan, thanks for that explanation! Much appreciated.]]></description>
		<content:encoded><![CDATA[<p>@Evan, thanks for that explanation! Much appreciated.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Evan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33061</link>
		<dc:creator><![CDATA[Evan]]></dc:creator>
		<pubDate>Tue, 02 Dec 2014 21:51:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33061</guid>
					<description><![CDATA[@Ben Craig

&#062; I would prefer: “Unspecified (one of the first three options, but could be different on different compilers, or even different runs of the same compiler)”.

I would want something even looser: the compiler is not required to pick the same evaluation for different occurrences of the same construct even in the same run, or for the same occurrences in different contexts (in the case of different template instantiations or different copies of an inlined function).]]></description>
		<content:encoded><![CDATA[<p>@Ben Craig</p>
<p>&gt; I would prefer: “Unspecified (one of the first three options, but could be different on different compilers, or even different runs of the same compiler)”.</p>
<p>I would want something even looser: the compiler is not required to pick the same evaluation for different occurrences of the same construct even in the same run, or for the same occurrences in different contexts (in the case of different template instantiations or different copies of an inlined function).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Evan				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33060</link>
		<dc:creator><![CDATA[Evan]]></dc:creator>
		<pubDate>Tue, 02 Dec 2014 21:43:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33060</guid>
					<description><![CDATA[@bdsoftware:

&#062; Thus, the only two possible outputs would be 00 and 10. i don’t see how 01 could ever happen.

That&#039;s because you&#039;re not thinking creatively enough. Consider just &lt;code&gt;x = y++&lt;/code&gt;. One way of implementing this is morally equivalent to
[code]y += 1
x = y - 1[/code]
Now, I&#039;m not sure why a compiler would do this, but I can imagine that one would in certain weird situations. (Now, that&#039;s not true of just a source transformation with no knowledge of the implementation because there are overflow issues, but that doesn&#039;t apply to code generators, which know the behavior under overflow.)

Similarly, one way of compiling &lt;code&gt;v[j++] = i++&lt;/code&gt; is the following:
[code]i += 1
j += 1
v[j-1] = i-1[/code]

If &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are the same, you have
[code]i += 2
v[i - 1] = i - 1   //v[1]=1[/code]]]></description>
		<content:encoded><![CDATA[<p>@bdsoftware:</p>
<p>&gt; Thus, the only two possible outputs would be 00 and 10. i don’t see how 01 could ever happen.</p>
<p>That&#8217;s because you&#8217;re not thinking creatively enough. Consider just <code>x = y++</code>. One way of implementing this is morally equivalent to</p>
<pre class="brush: plain; title: ; notranslate">y += 1
x = y - 1</pre>
<p>Now, I&#8217;m not sure why a compiler would do this, but I can imagine that one would in certain weird situations. (Now, that&#8217;s not true of just a source transformation with no knowledge of the implementation because there are overflow issues, but that doesn&#8217;t apply to code generators, which know the behavior under overflow.)</p>
<p>Similarly, one way of compiling <code>v[j++] = i++</code> is the following:</p>
<pre class="brush: plain; title: ; notranslate">i += 1
j += 1
v[j-1] = i-1</pre>
<p>If <code>i</code> and <code>j</code> are the same, you have</p>
<pre class="brush: plain; title: ; notranslate">i += 2
v[i - 1] = i - 1   //v[1]=1</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin				</title>
				<link>https://herbsutter.com/2014/12/01/a-quick-poll-about-order-of-evaluation/#comment-33058</link>
		<dc:creator><![CDATA[Martin]]></dc:creator>
		<pubDate>Tue, 02 Dec 2014 21:21:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2547#comment-33058</guid>
					<description><![CDATA[it seems simplest to have the above work similar to the way &lt;code&gt;*pDest++=*pSrc++;&lt;/code&gt; works]]></description>
		<content:encoded><![CDATA[<p>it seems simplest to have the above work similar to the way <code>*pDest++=*pSrc++;</code> works</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
