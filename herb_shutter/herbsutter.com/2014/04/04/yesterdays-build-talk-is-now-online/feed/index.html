<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Yesterdayâ€™s Build talk is now online	</title>
	<atom:link href="https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-19067</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 19:56:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-19067</guid>
					<description><![CDATA[@Dennis: See his article for details. No, they&#039;re concrete types.]]></description>
		<content:encoded><![CDATA[<p>@Dennis: See his article for details. No, they&#8217;re concrete types.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: dennis luehring				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-19064</link>
		<dc:creator><![CDATA[dennis luehring]]></dc:creator>
		<pubDate>Sat, 26 Apr 2014 16:52:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-19064</guid>
					<description><![CDATA[isn&#039;t your performance tip at minute 42:00 a little bit lame

AIComponent, PhysicsComponen, RenderComponents seems to be
interfaces - or else it makes less sense to put pointers to them into
vectors

so normaly the objects will be accessed usinge the interface AND
they can have different sizes - like AIComponentVersion1, AIComponentVersion2

this way is not possible to used contiguous space vectors - so whats the point?]]></description>
		<content:encoded><![CDATA[<p>isn&#8217;t your performance tip at minute 42:00 a little bit lame</p>
<p>AIComponent, PhysicsComponen, RenderComponents seems to be<br />
interfaces &#8211; or else it makes less sense to put pointers to them into<br />
vectors</p>
<p>so normaly the objects will be accessed usinge the interface AND<br />
they can have different sizes &#8211; like AIComponentVersion1, AIComponentVersion2</p>
<p>this way is not possible to used contiguous space vectors &#8211; so whats the point?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: anonymous				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18246</link>
		<dc:creator><![CDATA[anonymous]]></dc:creator>
		<pubDate>Mon, 07 Apr 2014 13:30:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18246</guid>
					<description><![CDATA[@Malte Skarupke

Inserting into a sorted vector is O(n), not O(n^2). 
Inserting into a set is O(log(n)), not O(n log(n)).]]></description>
		<content:encoded><![CDATA[<p>@Malte Skarupke</p>
<p>Inserting into a sorted vector is O(n), not O(n^2).<br />
Inserting into a set is O(log(n)), not O(n log(n)).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: George				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18179</link>
		<dc:creator><![CDATA[George]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 15:11:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18179</guid>
					<description><![CDATA[Are there any plans to go more in depth on doing cross platform mobile dev in c++, using native ui &#038; language for the interface on each platform? I know xamarin is an option to do this but I&#039;d really like to learn more about doing this with a c++ code base. Are there any talks or presentations about this?]]></description>
		<content:encoded><![CDATA[<p>Are there any plans to go more in depth on doing cross platform mobile dev in c++, using native ui &amp; language for the interface on each platform? I know xamarin is an option to do this but I&#8217;d really like to learn more about doing this with a c++ code base. Are there any talks or presentations about this?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Malte Skarupke				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18167</link>
		<dc:creator><![CDATA[Malte Skarupke]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 06:51:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18167</guid>
					<description><![CDATA[Hi,
loved the talk but a few comments about the list vs vector comparison. One slide (at 49 minutes in) states &quot;Vector beats list massively for insertion and deletion.&quot; This is not strictly true, because in your benchmark vector beats list for search, not insertion. Insertion and deletion will almost always be faster in list, as long as you know where you want to insert an element. In your benchmark you have to search for the insertion point though, and the faster search through vector outweighs the faster insertion in list. So I am not refuting your benchmark, just the explanation.

As for your benchmark of map vs sorted vector: I can not reproduce your results. I used a std::set (which uses a tree like std::map) and that is much faster at inserting random numbers. Inserting n random numbers into a sorted vector should be O(n^2) whereas inserting them into a set should be O(n log(n)) and that is exactly what I see in my benchmarks. For me a sorted vector is only faster if you have less than 1000 elements.

What&#039;s a good way to post my benchmark code here? I don&#039;t know how tot link to another website from the comments, and I&#039;m not sure if I should just dump 50 lines of C++ code in the comments here.]]></description>
		<content:encoded><![CDATA[<p>Hi,<br />
loved the talk but a few comments about the list vs vector comparison. One slide (at 49 minutes in) states &#8220;Vector beats list massively for insertion and deletion.&#8221; This is not strictly true, because in your benchmark vector beats list for search, not insertion. Insertion and deletion will almost always be faster in list, as long as you know where you want to insert an element. In your benchmark you have to search for the insertion point though, and the faster search through vector outweighs the faster insertion in list. So I am not refuting your benchmark, just the explanation.</p>
<p>As for your benchmark of map vs sorted vector: I can not reproduce your results. I used a std::set (which uses a tree like std::map) and that is much faster at inserting random numbers. Inserting n random numbers into a sorted vector should be O(n^2) whereas inserting them into a set should be O(n log(n)) and that is exactly what I see in my benchmarks. For me a sorted vector is only faster if you have less than 1000 elements.</p>
<p>What&#8217;s a good way to post my benchmark code here? I don&#8217;t know how tot link to another website from the comments, and I&#8217;m not sure if I should just dump 50 lines of C++ code in the comments here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18166</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 05:54:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18166</guid>
					<description><![CDATA[Herb I maybe misheard you or misunderstood you, but you talking about constant factors being very low... 
it sounded like you are claiming desired operation on list and vector have diff complexity but they have the same one. O(n). If you had iterator to place you want to insert to it would be O(1) for list but you dont have...
All what this example says is that reading is not 123x slower than writing, aka the fact you must read on avg n/2 elems for list and write one and for vec you need to write n/2 doesnt hurt vector because writing is not orders of magnitude slower than read. 
disclaimer: could be wrong, please reply and not just downvote(im ok with TD, i just need to know why)]]></description>
		<content:encoded><![CDATA[<p>Herb I maybe misheard you or misunderstood you, but you talking about constant factors being very low&#8230;<br />
it sounded like you are claiming desired operation on list and vector have diff complexity but they have the same one. O(n). If you had iterator to place you want to insert to it would be O(1) for list but you dont have&#8230;<br />
All what this example says is that reading is not 123x slower than writing, aka the fact you must read on avg n/2 elems for list and write one and for vec you need to write n/2 doesnt hurt vector because writing is not orders of magnitude slower than read.<br />
disclaimer: could be wrong, please reply and not just downvote(im ok with TD, i just need to know why)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Magnus Tyme				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18163</link>
		<dc:creator><![CDATA[Magnus Tyme]]></dc:creator>
		<pubDate>Sat, 05 Apr 2014 03:01:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18163</guid>
					<description><![CDATA[wrt gotw-54, based on your current talk and the proliferation of advanced processor behaviours since the gotw was written, will you be rethinking &quot;In Most Cases, Prefer Using deque&quot; to include some kind of size constraint?

Also can you please place the code you used to generate the graph on to github or some such, I know it&#039;s trivial code and can be easily written, but it&#039;d be nice to see your version.]]></description>
		<content:encoded><![CDATA[<p>wrt gotw-54, based on your current talk and the proliferation of advanced processor behaviours since the gotw was written, will you be rethinking &#8220;In Most Cases, Prefer Using deque&#8221; to include some kind of size constraint?</p>
<p>Also can you please place the code you used to generate the graph on to github or some such, I know it&#8217;s trivial code and can be easily written, but it&#8217;d be nice to see your version.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: anonymous				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18157</link>
		<dc:creator><![CDATA[anonymous]]></dc:creator>
		<pubDate>Fri, 04 Apr 2014 23:28:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18157</guid>
					<description><![CDATA[Hi Herb!

Great talk! Really important topics. 

I have two minor remarks.

- First, I think you should have mentioned that you can enable vectors with SBO using a stack_allocator (e.g. Howard Hinnant&#039;s one), so you can really use the same interface for heap and stack allocated vectors and remove all allocations! This is a bit of a drawback between array and vector, they do not share the same interface (which is IMO a huge advantage of Haskell Sequence containers, they all share the same &quot;list-like&quot; interface, so they are drop-in replacements).

- Second, your slide 43 recommends map and unordered_map for dictionary lookup. I think one should recommend boost::flat_set/flat_multi_set/flat_map/flat_multi_map first, since they are _contiguous_ and are just so much faster. They can be slower if you are inserting a lot, but in that case they give you the vector, you push_back at the end, sort it, and give it back to them. Perfect performance.

IMO a point worth remarking is that there is also a huge Array culture in C++ for the reasons you mention. Not only for matrix types, but for trees, and geometry. Want an array-based octree for a particle system? Want sorted vectors (like flat_set)? Unboxed vectors (i.e. vectors that perform AOS to SOA transformations)? Jagged vectors (flat vectors of vectors)? C++ has all of these. There is a large culture and a really nice ecosystem of array-based data-structures in C++ because they are really hardware friendly (as opposed to paper/blackboard friendly). They are fast.]]></description>
		<content:encoded><![CDATA[<p>Hi Herb!</p>
<p>Great talk! Really important topics. </p>
<p>I have two minor remarks.</p>
<p>&#8211; First, I think you should have mentioned that you can enable vectors with SBO using a stack_allocator (e.g. Howard Hinnant&#8217;s one), so you can really use the same interface for heap and stack allocated vectors and remove all allocations! This is a bit of a drawback between array and vector, they do not share the same interface (which is IMO a huge advantage of Haskell Sequence containers, they all share the same &#8220;list-like&#8221; interface, so they are drop-in replacements).</p>
<p>&#8211; Second, your slide 43 recommends map and unordered_map for dictionary lookup. I think one should recommend boost::flat_set/flat_multi_set/flat_map/flat_multi_map first, since they are _contiguous_ and are just so much faster. They can be slower if you are inserting a lot, but in that case they give you the vector, you push_back at the end, sort it, and give it back to them. Perfect performance.</p>
<p>IMO a point worth remarking is that there is also a huge Array culture in C++ for the reasons you mention. Not only for matrix types, but for trees, and geometry. Want an array-based octree for a particle system? Want sorted vectors (like flat_set)? Unboxed vectors (i.e. vectors that perform AOS to SOA transformations)? Jagged vectors (flat vectors of vectors)? C++ has all of these. There is a large culture and a really nice ecosystem of array-based data-structures in C++ because they are really hardware friendly (as opposed to paper/blackboard friendly). They are fast.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jesse Good				</title>
				<link>https://herbsutter.com/2014/04/04/yesterdays-build-talk-is-now-online/#comment-18148</link>
		<dc:creator><![CDATA[Jesse Good]]></dc:creator>
		<pubDate>Fri, 04 Apr 2014 21:08:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2474#comment-18148</guid>
					<description><![CDATA[Recently I read &quot;C# for Systems Programming&quot; on Joe Duffy&#039;s Blog and then &quot;.NET native&quot; was announced. It will be interesting to see how C++ holds up.]]></description>
		<content:encoded><![CDATA[<p>Recently I read &#8220;C# for Systems Programming&#8221; on Joe Duffy&#8217;s Blog and then &#8220;.NET native&#8221; was announced. It will be interesting to see how C++ holds up.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
