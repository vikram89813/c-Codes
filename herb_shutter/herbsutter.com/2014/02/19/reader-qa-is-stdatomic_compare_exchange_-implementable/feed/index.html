<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Reader Q&#038;A: Is std::atomic_compare_exchange_* implementable?	</title>
	<atom:link href="https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: cpp tutorials				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-34980</link>
		<dc:creator><![CDATA[cpp tutorials]]></dc:creator>
		<pubDate>Wed, 07 Jan 2015 11:34:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-34980</guid>
					<description><![CDATA[Smart pointers implementation has been explained well here. Thank you for posting the useful information and please keep sharing in future. You can also find more information on smart pointers here in the below link.

&lt;a href=&quot;http://www.cpptutorials.com/2014/11/smart-pointers-implementation-in-c-with.html&quot; rel=&quot;nofollow&quot;&gt; Smart pointers implementation in  Cpp with examples &lt;/a&gt;]]></description>
		<content:encoded><![CDATA[<p>Smart pointers implementation has been explained well here. Thank you for posting the useful information and please keep sharing in future. You can also find more information on smart pointers here in the below link.</p>
<p><a href="http://www.cpptutorials.com/2014/11/smart-pointers-implementation-in-c-with.html" rel="nofollow"> Smart pointers implementation in  Cpp with examples </a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anthony Williams				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-25407</link>
		<dc:creator><![CDATA[Anthony Williams]]></dc:creator>
		<pubDate>Thu, 28 Aug 2014 07:56:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-25407</guid>
					<description><![CDATA[No, I haven&#039;t reported a bug in ICC --- I haven&#039;t checked their generated code, as I don&#039;t use ICC regularly.]]></description>
		<content:encoded><![CDATA[<p>No, I haven&#8217;t reported a bug in ICC &#8212; I haven&#8217;t checked their generated code, as I don&#8217;t use ICC regularly.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ricardo Costa				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-25396</link>
		<dc:creator><![CDATA[Ricardo Costa]]></dc:creator>
		<pubDate>Thu, 28 Aug 2014 05:50:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-25396</guid>
					<description><![CDATA[@Anthony Williams have you also reported the bug to ICC? Didn&#039;t see that being mentioned.]]></description>
		<content:encoded><![CDATA[<p>@Anthony Williams have you also reported the bug to ICC? Didn&#8217;t see that being mentioned.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-25295</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 26 Aug 2014 19:23:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-25295</guid>
					<description><![CDATA[Update: Duncan and Anthony are quite correct, and now that I understand the issue I&#039;ve discovered this affects code I&#039;ve already written. So thank you again, Duncan!

This post: Updated.

Implementations: Fixed or being fixed. I believe the GCC libstd++, Clang libc++, and VC++ implementations already have fixed this in their current or next releases. (The good news is that I think the problem implementations inject a potential race but only in a &lt;em&gt;very&lt;/em&gt; tiny window, so hopefully actual code won&#039;t notice it while we get the fixes out, except that heavy stress does expose windows this small.)

The standard: Being fixed. This will also be reviewed for the standard in WG21, possibly as soon as our SG1 meeting next week, and I believe everyone agrees we need to tighten the wording in the standard.

Thanks again.]]></description>
		<content:encoded><![CDATA[<p>Update: Duncan and Anthony are quite correct, and now that I understand the issue I&#8217;ve discovered this affects code I&#8217;ve already written. So thank you again, Duncan!</p>
<p>This post: Updated.</p>
<p>Implementations: Fixed or being fixed. I believe the GCC libstd++, Clang libc++, and VC++ implementations already have fixed this in their current or next releases. (The good news is that I think the problem implementations inject a potential race but only in a <em>very</em> tiny window, so hopefully actual code won&#8217;t notice it while we get the fixes out, except that heavy stress does expose windows this small.)</p>
<p>The standard: Being fixed. This will also be reviewed for the standard in WG21, possibly as soon as our SG1 meeting next week, and I believe everyone agrees we need to tighten the wording in the standard.</p>
<p>Thanks again.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15914</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Wed, 26 Feb 2014 23:41:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15914</guid>
					<description><![CDATA[He was free to raise his concerns during development of C11 and C++11. so I suggest skipping his rants.]]></description>
		<content:encoded><![CDATA[<p>He was free to raise his concerns during development of C11 and C++11. so I suggest skipping his rants.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jan Ringoš				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15774</link>
		<dc:creator><![CDATA[Jan Ringoš]]></dc:creator>
		<pubDate>Mon, 24 Feb 2014 09:19:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15774</guid>
					<description><![CDATA[You might also want to check the thread on GCC mailing list where Linus is raising hell about atomics wording in C11 (and all the things around).]]></description>
		<content:encoded><![CDATA[<p>You might also want to check the thread on GCC mailing list where Linus is raising hell about atomics wording in C11 (and all the things around).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bames				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15614</link>
		<dc:creator><![CDATA[bames]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 21:50:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15614</guid>
					<description><![CDATA[Herb,

Has a defect report been filed on this (or do you know of one in the works)? The actual language of the spec does seem to imply much stronger guarantees than you are suggesting here. (In fact the actual language of the spec appears to guarantee behavior even stronger than Anthony&#039;s library provides.)]]></description>
		<content:encoded><![CDATA[<p>Herb,</p>
<p>Has a defect report been filed on this (or do you know of one in the works)? The actual language of the spec does seem to imply much stronger guarantees than you are suggesting here. (In fact the actual language of the spec appears to guarantee behavior even stronger than Anthony&#8217;s library provides.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15607</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 18:25:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15607</guid>
					<description><![CDATA[BTW, I&#039;ve started an email thread with the designers of the feature and Duncan and Anthony.

Short update: I still think my answer is correct, but we&#039;re checking on the intent of the feature and the standardese probably needs improving in any event.

Longer update:

I understood that the design of having compare_exchange_* take the &quot;expected&quot; value by reference, and update &quot;expected&quot; on failure to expose the old value, was only intended for convenience to simplify the calling loops which would otherwise always have to write an extra &quot;reload&quot; line of code.

Now that &quot;expected&quot; is an lvalue, folks like Duncan are trying to use the success of compare_exchange_* to hand off ownership **of &quot;expected&quot; itself** to another thread. For that to be safe, if the compare_exchange_* succeeds then the thread that performed it must no longer read or write from &quot;expected&quot; else his technique contains a race.

I don&#039;t think this usage was ever intended to be supported, but I could be wrong (waiting to hear back from the feature&#039;s designer), even if it wasn&#039;t we may want to extend and add support for it now, and in any event I think we need to improve the standardese wording which is apparently unclear today.]]></description>
		<content:encoded><![CDATA[<p>BTW, I&#8217;ve started an email thread with the designers of the feature and Duncan and Anthony.</p>
<p>Short update: I still think my answer is correct, but we&#8217;re checking on the intent of the feature and the standardese probably needs improving in any event.</p>
<p>Longer update:</p>
<p>I understood that the design of having compare_exchange_* take the &#8220;expected&#8221; value by reference, and update &#8220;expected&#8221; on failure to expose the old value, was only intended for convenience to simplify the calling loops which would otherwise always have to write an extra &#8220;reload&#8221; line of code.</p>
<p>Now that &#8220;expected&#8221; is an lvalue, folks like Duncan are trying to use the success of compare_exchange_* to hand off ownership **of &#8220;expected&#8221; itself** to another thread. For that to be safe, if the compare_exchange_* succeeds then the thread that performed it must no longer read or write from &#8220;expected&#8221; else his technique contains a race.</p>
<p>I don&#8217;t think this usage was ever intended to be supported, but I could be wrong (waiting to hear back from the feature&#8217;s designer), even if it wasn&#8217;t we may want to extend and add support for it now, and in any event I think we need to improve the standardese wording which is apparently unclear today.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anthony Williams				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15605</link>
		<dc:creator><![CDATA[Anthony Williams]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 17:12:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15605</guid>
					<description><![CDATA[The write to expected does not need to be atomic. It should only be written to on failure, so if the compare-exchange succeeds, then other threads can touch the value passed as the &quot;expected&quot; parameter, because the compare-exchange will not do so (in a correct implementation).

This is important when doing things like lock-free data structures, where the &quot;expected&quot; value may often be part of a node being added to the data structure by the compare-exchange. If the compare-exchange fails then the node is still not part of the data structure, so modifying expected is not a problem. If the compare-exchange succeeds then the node is now part of the data structure and may be accessed by other threads.]]></description>
		<content:encoded><![CDATA[<p>The write to expected does not need to be atomic. It should only be written to on failure, so if the compare-exchange succeeds, then other threads can touch the value passed as the &#8220;expected&#8221; parameter, because the compare-exchange will not do so (in a correct implementation).</p>
<p>This is important when doing things like lock-free data structures, where the &#8220;expected&#8221; value may often be part of a node being added to the data structure by the compare-exchange. If the compare-exchange fails then the node is still not part of the data structure, so modifying expected is not a problem. If the compare-exchange succeeds then the node is now part of the data structure and may be accessed by other threads.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Noob Learner				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15601</link>
		<dc:creator><![CDATA[Noob Learner]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 16:28:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15601</guid>
					<description><![CDATA[My opinion on the issue is that the problem is not about race/unconditional write but more of sharing the &#039;expected&#039; variable across thread. I would say there was never a guarantee in atomic write to &#039;expected&#039;. Thus I think trying to assume atomicity for &#039;expected&#039; isn&#039;t an appropriate thing. If there was never a guarantee to atomic write for &#039;expected&#039; then we should not attempt to pass a variable to &#039;expected&#039; which spans multiple thread.

Think of it as a simple function:
void foo(int* arg);

In the above case, passing a variable to the function &#039;arg&#039; which is shared across multiple thread is just asking for trouble.

Whether function foo write arg unconditionally or does anything to it is beside the point. It doesn&#039;t change the problem that passing in a variable used by multiple thread into arg is creating a problem of attempting atomicity/synchronisation on a variable/type not meant to do that.]]></description>
		<content:encoded><![CDATA[<p>My opinion on the issue is that the problem is not about race/unconditional write but more of sharing the &#8216;expected&#8217; variable across thread. I would say there was never a guarantee in atomic write to &#8216;expected&#8217;. Thus I think trying to assume atomicity for &#8216;expected&#8217; isn&#8217;t an appropriate thing. If there was never a guarantee to atomic write for &#8216;expected&#8217; then we should not attempt to pass a variable to &#8216;expected&#8217; which spans multiple thread.</p>
<p>Think of it as a simple function:<br />
void foo(int* arg);</p>
<p>In the above case, passing a variable to the function &#8216;arg&#8217; which is shared across multiple thread is just asking for trouble.</p>
<p>Whether function foo write arg unconditionally or does anything to it is beside the point. It doesn&#8217;t change the problem that passing in a variable used by multiple thread into arg is creating a problem of attempting atomicity/synchronisation on a variable/type not meant to do that.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bames				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15600</link>
		<dc:creator><![CDATA[bames]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 15:50:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15600</guid>
					<description><![CDATA[I don&#039;t think the issue is that implementations are failing to make the assignment to expected atomic with the compare/exchange. The problem is that the spec guarantees that, if the exchange occurs, then expected is _not_ written to. Thus if the exchange occurs then another thread which was waiting on the exchange can go ahead and access expected, knowing that the compare_exchange will not write to it and there will therefore be no race.

But since actual implementations write to expected unconditionally real implementations introduce a race.]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t think the issue is that implementations are failing to make the assignment to expected atomic with the compare/exchange. The problem is that the spec guarantees that, if the exchange occurs, then expected is _not_ written to. Thus if the exchange occurs then another thread which was waiting on the exchange can go ahead and access expected, knowing that the compare_exchange will not write to it and there will therefore be no race.</p>
<p>But since actual implementations write to expected unconditionally real implementations introduce a race.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Noob Learner				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15569</link>
		<dc:creator><![CDATA[Noob Learner]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 03:29:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15569</guid>
					<description><![CDATA[In fact, I think Ducan is stretching the guarantee of atomicity to its function parameter which I don&#039;t think was intended.]]></description>
		<content:encoded><![CDATA[<p>In fact, I think Ducan is stretching the guarantee of atomicity to its function parameter which I don&#8217;t think was intended.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Noob Learner				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15568</link>
		<dc:creator><![CDATA[Noob Learner]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 03:25:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15568</guid>
					<description><![CDATA[After reading both the SO as well as the above post. My initial reaction was that indeed Duncan and Anthony are both correct.

However on second thoughts, I think Herb is also right. In this case for compare_exchange, I would rather say the atomicity was for the head node not for the node-next. Think of it this way suppose we have the following code which store the new value into the atomic_var and put the original value in the old_value.

template 
void SuperStore(std::atomic&#038; atmoic_var, const Ty1* new_value, Ty1* old_value); 

Obviously from the function signature, we safely say the the store to the atomic_var would be atomically safe, but to assume the write to old_value is safe would be a big no no. If it was atomic, old_value should have been std::atomic* old_value.

I think to make the whole issue of compare_exchange better, &#039;expected&#039; should have been an atomic variable.

Or maybe the standard committee was referring to the atomicity of the calling object of compare_exchange_weak, rather than the atomicity of the compare_exchange_weak function parameters. It is just a guess and maybe I am wrong.]]></description>
		<content:encoded><![CDATA[<p>After reading both the SO as well as the above post. My initial reaction was that indeed Duncan and Anthony are both correct.</p>
<p>However on second thoughts, I think Herb is also right. In this case for compare_exchange, I would rather say the atomicity was for the head node not for the node-next. Think of it this way suppose we have the following code which store the new value into the atomic_var and put the original value in the old_value.</p>
<p>template<br />
void SuperStore(std::atomic&amp; atmoic_var, const Ty1* new_value, Ty1* old_value); </p>
<p>Obviously from the function signature, we safely say the the store to the atomic_var would be atomically safe, but to assume the write to old_value is safe would be a big no no. If it was atomic, old_value should have been std::atomic* old_value.</p>
<p>I think to make the whole issue of compare_exchange better, &#8216;expected&#8217; should have been an atomic variable.</p>
<p>Or maybe the standard committee was referring to the atomicity of the calling object of compare_exchange_weak, rather than the atomicity of the compare_exchange_weak function parameters. It is just a guess and maybe I am wrong.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew Elvey Price				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15562</link>
		<dc:creator><![CDATA[Matthew Elvey Price]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 00:09:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15562</guid>
					<description><![CDATA[Or rather... you guarantee it will NOT unexpectedly modified/invalidated. Whoops.]]></description>
		<content:encoded><![CDATA[<p>Or rather&#8230; you guarantee it will NOT unexpectedly modified/invalidated. Whoops.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew Elvey Price				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15561</link>
		<dc:creator><![CDATA[Matthew Elvey Price]]></dc:creator>
		<pubDate>Fri, 21 Feb 2014 00:06:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15561</guid>
					<description><![CDATA[My reading of the standard is:

part of 29.6.5/2:
In the following operation definitions:
— an A refers to one of the atomic types.
— a C refers to its corresponding non-atomic type. (...)

An example function definition from just before 29.6.5/20:
[code]bool atomic_compare_exchange_weak(A* object,C* expected,C desired) noexcept[/code]

Expected is type C so is NOT atomic.

If we assume what I&#039;ve said above, the specific issue in your code is that by passing in a non-atomic variable (expected), you guarantee it will unexpectedly modified or invalidated during that call. Then you break that guarantee by deleting or modifying it in another thread. Ben&#039;s code appears to account for this correctly. 

The compiler bugs listed only cover storing to expected in the success case where it would store the same value anyway.]]></description>
		<content:encoded><![CDATA[<p>My reading of the standard is:</p>
<p>part of 29.6.5/2:<br />
In the following operation definitions:<br />
— an A refers to one of the atomic types.<br />
— a C refers to its corresponding non-atomic type. (&#8230;)</p>
<p>An example function definition from just before 29.6.5/20:</p>
<pre class="brush: plain; title: ; notranslate">bool atomic_compare_exchange_weak(A* object,C* expected,C desired) noexcept</pre>
<p>Expected is type C so is NOT atomic.</p>
<p>If we assume what I&#8217;ve said above, the specific issue in your code is that by passing in a non-atomic variable (expected), you guarantee it will unexpectedly modified or invalidated during that call. Then you break that guarantee by deleting or modifying it in another thread. Ben&#8217;s code appears to account for this correctly. </p>
<p>The compiler bugs listed only cover storing to expected in the success case where it would store the same value anyway.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseeta;				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15556</link>
		<dc:creator><![CDATA[nosenseeta;]]></dc:creator>
		<pubDate>Thu, 20 Feb 2014 22:42:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15556</guid>
					<description><![CDATA[btw my apology, I thought it was just an another example of somebody not understanding some brainf**k atomic code, but it turns out to be about a serious bug. :D But since Herb said it is not I was like meh, boring...]]></description>
		<content:encoded><![CDATA[<p>btw my apology, I thought it was just an another example of somebody not understanding some brainf**k atomic code, but it turns out to be about a serious bug. :D But since Herb said it is not I was like meh, boring&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anthony Williams				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15554</link>
		<dc:creator><![CDATA[Anthony Williams]]></dc:creator>
		<pubDate>Thu, 20 Feb 2014 22:11:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15554</guid>
					<description><![CDATA[@nosenseetal It&#039;s an implementation bug]]></description>
		<content:encoded><![CDATA[<p>@nosenseetal It&#8217;s an implementation bug</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15548</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Thu, 20 Feb 2014 19:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15548</guid>
					<description><![CDATA[@Anthony Williams
is it a implementation or ISO bug?]]></description>
		<content:encoded><![CDATA[<p>@Anthony Williams<br />
is it a implementation or ISO bug?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anthony Williams				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15506</link>
		<dc:creator><![CDATA[Anthony Williams]]></dc:creator>
		<pubDate>Thu, 20 Feb 2014 09:56:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15506</guid>
					<description><![CDATA[Duncan is unfortunately correct: there are bugs in at least gcc 4.8, clang 3.4 and Visual Studio 2013, all of which do an unconditional store to the &quot;expected&quot; parameter, even on successful exchanges, which can cause a race.

The bugs have now been reported:

MSVC: https://connect.microsoft.com/VisualStudio/feedback/details/819819/std-atomic-compare-exchange-weak-has-spurious-write-which-can-cause-race-conditions

GCC: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272

Clang: http://llvm.org/bugs/show_bug.cgi?id=18899]]></description>
		<content:encoded><![CDATA[<p>Duncan is unfortunately correct: there are bugs in at least gcc 4.8, clang 3.4 and Visual Studio 2013, all of which do an unconditional store to the &#8220;expected&#8221; parameter, even on successful exchanges, which can cause a race.</p>
<p>The bugs have now been reported:</p>
<p>MSVC: <a href="https://connect.microsoft.com/VisualStudio/feedback/details/819819/std-atomic-compare-exchange-weak-has-spurious-write-which-can-cause-race-conditions" rel="nofollow">https://connect.microsoft.com/VisualStudio/feedback/details/819819/std-atomic-compare-exchange-weak-has-spurious-write-which-can-cause-race-conditions</a></p>
<p>GCC: <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272" rel="nofollow">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=60272</a></p>
<p>Clang: <a href="http://llvm.org/bugs/show_bug.cgi?id=18899" rel="nofollow">http://llvm.org/bugs/show_bug.cgi?id=18899</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Duncan Forster				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15476</link>
		<dc:creator><![CDATA[Duncan Forster]]></dc:creator>
		<pubDate>Thu, 20 Feb 2014 00:11:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15476</guid>
					<description><![CDATA[I think you have misunderstood my example. The example function atomic_bool_compare_and_swap is not real code but used to illustrate how CAS works in hardware. So the block with comment &#039;Here be atomic&#039; above for this example should be considered atomic. This serves the discussion well, except I made a mistake. In fact CMPXCHG does return success/failure in the ZF flag (on x86, thanks Anthony for correcting me). I overlooked this because every time I have used CMPXCHG (or seen it used) the result has always been calculated by another compare. This seems innocuous but is racy.

I&#039;m not talking about an issue in theory, this has caused serious production issues. So to recap the C++ interface (it turns) out is implementable with CMPXCHG (on x86) and in some cases is rather nice. Wait a second the interface is correct, CAS is correct, this doesn&#039;t compute in regards to my real-world issue. I have a test case, I can prove this doesn&#039;t work. Ah, the penny drops, this is actually a bug in the implementation (in my case GCC 4.8).

Take this simple example:

    #include 
    struct Node { Node* next; };
    void Push(std::atomic head, Node* node)
    {
        node-&#062;next = head.load();
        while(!head.compare_exchange_weak(node-&#062;next, node))
            ;
    }

This is completely correct C++ and should work always in any situation (with the assumption nodes are unique and never re-used).

I like to think of this example as the Push thread creating a private object. The compare_exchange_weak operation is an attempt by the Push thread to relinquish ownership and pass it to another thread. If the operation succeeds the object is no longer owned by the Push thread and it shouldn&#039;t touch the object ever (otherwise you have a race and all bets are off). If the operation fails 
the Push thread still owns the object (still private), thus it may be modified race free.  

As I have discussed with Anthony Williams and also mentioned on SO, no current compiler implements this correctly. The only know correct implementation is the Just::Thread library. I won&#039;t go thru the assembly for all the compilers but I will mention VC++:

   inline int _Compare_exchange_seq_cst_4(volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value)
   {    /* compare and exchange values atomically with
       sequentially consistent memory order */
       int _Res;
       _Uint4_t _Prev = _InterlockedCompareExchange((volatile long
*)_Tgt, _Value, *_Exp);
       if (_Prev == *_Exp) !!!!!!!!!!!!!!!!!!!!!!!
           _Res = 1;
       else
       { /* copy old value */
           _Res = 0;
           *_Exp = _Prev;
       }
       return (_Res);
   }

This is not correct, it has a race condition which means it&#039;s reading a value it shouldn&#039;t after the CAS. Since it&#039;s a race it may calculate the wrong return code. If that happens it will also invent a write when in fact the CAS succeeded. This is very bad when you consider object ownership (from above).]]></description>
		<content:encoded><![CDATA[<p>I think you have misunderstood my example. The example function atomic_bool_compare_and_swap is not real code but used to illustrate how CAS works in hardware. So the block with comment &#8216;Here be atomic&#8217; above for this example should be considered atomic. This serves the discussion well, except I made a mistake. In fact CMPXCHG does return success/failure in the ZF flag (on x86, thanks Anthony for correcting me). I overlooked this because every time I have used CMPXCHG (or seen it used) the result has always been calculated by another compare. This seems innocuous but is racy.</p>
<p>I&#8217;m not talking about an issue in theory, this has caused serious production issues. So to recap the C++ interface (it turns) out is implementable with CMPXCHG (on x86) and in some cases is rather nice. Wait a second the interface is correct, CAS is correct, this doesn&#8217;t compute in regards to my real-world issue. I have a test case, I can prove this doesn&#8217;t work. Ah, the penny drops, this is actually a bug in the implementation (in my case GCC 4.8).</p>
<p>Take this simple example:</p>
<p>    #include<br />
    struct Node { Node* next; };<br />
    void Push(std::atomic head, Node* node)<br />
    {<br />
        node-&gt;next = head.load();<br />
        while(!head.compare_exchange_weak(node-&gt;next, node))<br />
            ;<br />
    }</p>
<p>This is completely correct C++ and should work always in any situation (with the assumption nodes are unique and never re-used).</p>
<p>I like to think of this example as the Push thread creating a private object. The compare_exchange_weak operation is an attempt by the Push thread to relinquish ownership and pass it to another thread. If the operation succeeds the object is no longer owned by the Push thread and it shouldn&#8217;t touch the object ever (otherwise you have a race and all bets are off). If the operation fails<br />
the Push thread still owns the object (still private), thus it may be modified race free.  </p>
<p>As I have discussed with Anthony Williams and also mentioned on SO, no current compiler implements this correctly. The only know correct implementation is the Just::Thread library. I won&#8217;t go thru the assembly for all the compilers but I will mention VC++:</p>
<p>   inline int _Compare_exchange_seq_cst_4(volatile _Uint4_t *_Tgt, _Uint4_t *_Exp, _Uint4_t _Value)<br />
   {    /* compare and exchange values atomically with<br />
       sequentially consistent memory order */<br />
       int _Res;<br />
       _Uint4_t _Prev = _InterlockedCompareExchange((volatile long<br />
*)_Tgt, _Value, *_Exp);<br />
       if (_Prev == *_Exp) !!!!!!!!!!!!!!!!!!!!!!!<br />
           _Res = 1;<br />
       else<br />
       { /* copy old value */<br />
           _Res = 0;<br />
           *_Exp = _Prev;<br />
       }<br />
       return (_Res);<br />
   }</p>
<p>This is not correct, it has a race condition which means it&#8217;s reading a value it shouldn&#8217;t after the CAS. Since it&#8217;s a race it may calculate the wrong return code. If that happens it will also invent a write when in fact the CAS succeeded. This is very bad when you consider object ownership (from above).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Hutchings				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15469</link>
		<dc:creator><![CDATA[Ben Hutchings]]></dc:creator>
		<pubDate>Wed, 19 Feb 2014 22:31:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15469</guid>
					<description><![CDATA[Herb, I think Duncan&#039;s &#039;Here be atomic&#039; comment means that the following block is pseudo-code for the hardware CAS instruction. And I think he&#039;s concerned that the use of the the &#039;expected&#039; variable is not atomic. (Actually, it could be on some architectures.) But you&#039;re right that that isn&#039;t normally required.

Norbert, your code is backwards. You have to set the &#039;next&#039; pointer of the new node before swapping the list head. So you would do something like:
[code]
MyPointer temp = head;
do
    new_node-&#062;next = temp;
while(!atomic_compare_exchange(&#038;head, temp, new_node));
[/code]]]></description>
		<content:encoded><![CDATA[<p>Herb, I think Duncan&#8217;s &#8216;Here be atomic&#8217; comment means that the following block is pseudo-code for the hardware CAS instruction. And I think he&#8217;s concerned that the use of the the &#8216;expected&#8217; variable is not atomic. (Actually, it could be on some architectures.) But you&#8217;re right that that isn&#8217;t normally required.</p>
<p>Norbert, your code is backwards. You have to set the &#8216;next&#8217; pointer of the new node before swapping the list head. So you would do something like:</p>
<pre class="brush: plain; title: ; notranslate">
MyPointer temp = head;
do
    new_node-&gt;next = temp;
while(!atomic_compare_exchange(&amp;head, temp, new_node));
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Norbert Lange				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15463</link>
		<dc:creator><![CDATA[Norbert Lange]]></dc:creator>
		<pubDate>Wed, 19 Feb 2014 20:18:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15463</guid>
					<description><![CDATA[I believe the issue is the while loop:
while(!atomic_bool_compare_and_swap(&#038;head, new_node-&#062;next, new_node)).

First its been noted that 2 threads could try to add the &quot;new_node&quot;, so I expect this to be an existing node and a reachable next pointer, The problem then is that you should never update the existing pointer unless the cmpexchange suceeded.

Instead you would need something like this:
[code]
MyPointer temp = new_node-&#062;next;
while(!atomic_bool_compare_and_swap(&#038;head, temp, new_node))
   ;
new_node-&#062;next = temp;
[/code]
(might use the compare_exchange_*_strong variant instead of a loop).

In short, the expected variable must not be reachable from anywhere except the calling thread.

The rest about CAs and compare_echange is covered already, I will just add that the  boolean return value is bloody necessary when you implement the compare_exchange with loadlinked/storelinked. Look at a implementation with only the old value returned:
[code]    template&#060;typename _T&#062;
    _T atomic_compare_exchange(_T *value, _T expected, _T new_value)
    {
        _T old_value = loadlnked(value);
        if (old_value == expected &#038;&#038; storelinked(value, new_value))
          return new_value;
        else
        {
          return atomic_load(value);
        }
    }[/code]

Lets assume _T=int and the value in question is 5, and wants to change it to 42.

Thread A:
1) _T old_value = loadlnked(value);
2) another Thread interrupts and changes the value (or atleast causes the linked sequence to fail)
3) storelinked fails
4) another thread interrupts and changes the value to 42
5) atomic_load(value) returns 5

The caller of atomic_compare_exchange gets the expected value as return value, and thus would assume he changed the value, when in thruth the value got set from somewhere else. This might not be a problem for some uses, but for example reference-counting would mean the counter got incremented once instead of twice.

So a usefull atomic_compare_exchange needs an indication of the operation failed, the write-back of expected is the only thing that could have been left out.]]></description>
		<content:encoded><![CDATA[<p>I believe the issue is the while loop:<br />
while(!atomic_bool_compare_and_swap(&amp;head, new_node-&gt;next, new_node)).</p>
<p>First its been noted that 2 threads could try to add the &#8220;new_node&#8221;, so I expect this to be an existing node and a reachable next pointer, The problem then is that you should never update the existing pointer unless the cmpexchange suceeded.</p>
<p>Instead you would need something like this:</p>
<pre class="brush: plain; title: ; notranslate">
MyPointer temp = new_node-&gt;next;
while(!atomic_bool_compare_and_swap(&amp;head, temp, new_node))
   ;
new_node-&gt;next = temp;
</pre>
<p>(might use the compare_exchange_*_strong variant instead of a loop).</p>
<p>In short, the expected variable must not be reachable from anywhere except the calling thread.</p>
<p>The rest about CAs and compare_echange is covered already, I will just add that the  boolean return value is bloody necessary when you implement the compare_exchange with loadlinked/storelinked. Look at a implementation with only the old value returned:</p>
<pre class="brush: plain; title: ; notranslate">    template&lt;typename _T&gt;
    _T atomic_compare_exchange(_T *value, _T expected, _T new_value)
    {
        _T old_value = loadlnked(value);
        if (old_value == expected &amp;&amp; storelinked(value, new_value))
          return new_value;
        else
        {
          return atomic_load(value);
        }
    }</pre>
<p>Lets assume _T=int and the value in question is 5, and wants to change it to 42.</p>
<p>Thread A:<br />
1) _T old_value = loadlnked(value);<br />
2) another Thread interrupts and changes the value (or atleast causes the linked sequence to fail)<br />
3) storelinked fails<br />
4) another thread interrupts and changes the value to 42<br />
5) atomic_load(value) returns 5</p>
<p>The caller of atomic_compare_exchange gets the expected value as return value, and thus would assume he changed the value, when in thruth the value got set from somewhere else. This might not be a problem for some uses, but for example reference-counting would mean the counter got incremented once instead of twice.</p>
<p>So a usefull atomic_compare_exchange needs an indication of the operation failed, the write-back of expected is the only thing that could have been left out.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2014/02/19/reader-qa-is-stdatomic_compare_exchange_-implementable/#comment-15460</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Wed, 19 Feb 2014 19:37:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2429#comment-15460</guid>
					<description><![CDATA[this is all cool and interesting, but I wish people would pay attention a bit to the boring stuff also, like serialization(preferably to make class serializable automatically in a sense that it can be serialized automatically if all its members can be serialized automatically... and if you have serialization for all built in ntypes then you have default serialization for any type :D ), for each for enums, to_string for enums...

atomics are for small perchentage of the people, other just need to know here be danger except in simple cases like counter, bool flag...]]></description>
		<content:encoded><![CDATA[<p>this is all cool and interesting, but I wish people would pay attention a bit to the boring stuff also, like serialization(preferably to make class serializable automatically in a sense that it can be serialized automatically if all its members can be serialized automatically&#8230; and if you have serialization for all built in ntypes then you have default serialization for any type :D ), for each for enums, to_string for enums&#8230;</p>
<p>atomics are for small perchentage of the people, other just need to know here be danger except in simple cases like counter, bool flag&#8230;</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
