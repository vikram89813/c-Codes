<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Trip report: Summer ISO C++ standards meeting (Rapperswil)	</title>
	<atom:link href="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: akreuzkamp				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40311</link>
		<dc:creator><![CDATA[akreuzkamp]]></dc:creator>
		<pubDate>Wed, 01 Aug 2018 11:29:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40311</guid>
					<description><![CDATA[(I just realized my comment below got messed up, so I repeat it here)

As a small comment to yaafcd (p1141r0):

It says “We are willing to tolerate this small potential for ambiguity.”
Wouldn’t it make slightly more sense to have constrained type template-parameters have the regular syntax &lt;code&gt;template&#060;Contrain typename T&#062; foo()&lt;/code&gt; or &lt;code&gt;template&#060;Constrain class T&#062; foo()&lt;/code&gt; and then additionally add the relaxation that &lt;code&gt;template&#060;Constrain T&#062; foo()&lt;/code&gt; is allowed? That would make the rules symmetric to &lt;code&gt;Constain auto x&lt;/code&gt; and again allows for a style that has no ambiguities. Therefore it would not need the admission above.

Still I’m really glad to see that there’s finally a good proposal which most people are willing to support. :)

And I’m really excited that range-adaptors could actually make their way into C++20 :)]]></description>
		<content:encoded><![CDATA[<p>(I just realized my comment below got messed up, so I repeat it here)</p>
<p>As a small comment to yaafcd (p1141r0):</p>
<p>It says “We are willing to tolerate this small potential for ambiguity.”<br />
Wouldn’t it make slightly more sense to have constrained type template-parameters have the regular syntax <code>template&lt;Contrain typename T&gt; foo()</code> or <code>template&lt;Constrain class T&gt; foo()</code> and then additionally add the relaxation that <code>template&lt;Constrain T&gt; foo()</code> is allowed? That would make the rules symmetric to <code>Constain auto x</code> and again allows for a style that has no ambiguities. Therefore it would not need the admission above.</p>
<p>Still I’m really glad to see that there’s finally a good proposal which most people are willing to support. :)</p>
<p>And I’m really excited that range-adaptors could actually make their way into C++20 :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Onlynagesha				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40277</link>
		<dc:creator><![CDATA[Onlynagesha]]></dc:creator>
		<pubDate>Mon, 30 Jul 2018 06:26:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40277</guid>
					<description><![CDATA[What about adding bound checking for STL containers like [[expects audit: x &#060; size()]]? I find it a pity that they do not provide an effective way for bound checking without exceptions or wierd .at() idiom.]]></description>
		<content:encoded><![CDATA[<p>What about adding bound checking for STL containers like [[expects audit: x &lt; size()]]? I find it a pity that they do not provide an effective way for bound checking without exceptions or wierd .at() idiom.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40268</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 14 Jul 2018 15:58:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40268</guid>
					<description><![CDATA[Re OOM: These are good questions, and I believe all the ones mentioned so far are acknowledged and addressed in P0709R1 section 4.3 which has several pages of answers and rationale: https://wg21.link/p0709]]></description>
		<content:encoded><![CDATA[<p>Re OOM: These are good questions, and I believe all the ones mentioned so far are acknowledged and addressed in P0709R1 section 4.3 which has several pages of answers and rationale: <a href="https://wg21.link/p0709" rel="nofollow">https://wg21.link/p0709</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: akreuzkamp				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40267</link>
		<dc:creator><![CDATA[akreuzkamp]]></dc:creator>
		<pubDate>Sat, 14 Jul 2018 09:18:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40267</guid>
					<description><![CDATA[As a small comment to yaafcd (p1141r0):

You wrote &quot;We are willing to tolerate this small potential for ambiguity.&quot;
Wouldn&#039;t it make slightly more sense to have constrained type template-parameters have the regular syntax &quot;template  foo()&quot; or &quot;template  foo()&quot; and then additionally add the relaxation that &quot;template foo()&quot; is allowed? That would make the rules symmetric to &quot;Constain auto x&quot; and again allows for a style that has no ambiguities. Therefore it would not need the admission above.

Still I&#039;m really glad to see that there&#039;s finally a good proposal which most people are willing to support. :)

And I&#039;m really excited that range-adaptors could actually make their way into C++20 :)]]></description>
		<content:encoded><![CDATA[<p>As a small comment to yaafcd (p1141r0):</p>
<p>You wrote &#8220;We are willing to tolerate this small potential for ambiguity.&#8221;<br />
Wouldn&#8217;t it make slightly more sense to have constrained type template-parameters have the regular syntax &#8220;template  foo()&#8221; or &#8220;template  foo()&#8221; and then additionally add the relaxation that &#8220;template foo()&#8221; is allowed? That would make the rules symmetric to &#8220;Constain auto x&#8221; and again allows for a style that has no ambiguities. Therefore it would not need the admission above.</p>
<p>Still I&#8217;m really glad to see that there&#8217;s finally a good proposal which most people are willing to support. :)</p>
<p>And I&#8217;m really excited that range-adaptors could actually make their way into C++20 :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dwayne Robinson				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40266</link>
		<dc:creator><![CDATA[Dwayne Robinson]]></dc:creator>
		<pubDate>Sat, 14 Jul 2018 05:56:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40266</guid>
					<description><![CDATA[The terminate-on-OOM mindset really worries me. As an owner of a system component DLL, we can&#039;t just go terminating a whole process because some bad font had a table that was too large, and I certainly do not want my own application being terminated because the user tried to load some huge JPEG (I have some images that are hundreds of MB&#039;s when loaded).]]></description>
		<content:encoded><![CDATA[<p>The terminate-on-OOM mindset really worries me. As an owner of a system component DLL, we can&#8217;t just go terminating a whole process because some bad font had a table that was too large, and I certainly do not want my own application being terminated because the user tried to load some huge JPEG (I have some images that are hundreds of MB&#8217;s when loaded).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: dfa				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40265</link>
		<dc:creator><![CDATA[dfa]]></dc:creator>
		<pubDate>Fri, 13 Jul 2018 10:06:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40265</guid>
					<description><![CDATA[@J

&quot;I think terminating on a OOM makes much more sense than throwing exceptions.&quot;

Terminate what? The whole process or the thread in which it occurred?
If my process can keep running in the face of 1 thread having an OOM, then I would much rather that, than kill the whole thing. 

I&#039;d argue that would make for more reliable software, as an OOM (due to memory pressure or fragmentation) can sometimes be a transitory condition that passes, meaning multi-threaded long-running processes can potentially keep going regardless.]]></description>
		<content:encoded><![CDATA[<p>@J</p>
<p>&#8220;I think terminating on a OOM makes much more sense than throwing exceptions.&#8221;</p>
<p>Terminate what? The whole process or the thread in which it occurred?<br />
If my process can keep running in the face of 1 thread having an OOM, then I would much rather that, than kill the whole thing. </p>
<p>I&#8217;d argue that would make for more reliable software, as an OOM (due to memory pressure or fragmentation) can sometimes be a transitory condition that passes, meaning multi-threaded long-running processes can potentially keep going regardless.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roman				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40264</link>
		<dc:creator><![CDATA[Roman]]></dc:creator>
		<pubDate>Wed, 11 Jul 2018 23:10:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40264</guid>
					<description><![CDATA[Does this mean that with contracts we will finally have [code]T&#038; pop_back() noexcept;[/code] ?]]></description>
		<content:encoded><![CDATA[<p>Does this mean that with contracts we will finally have </p>
<pre class="brush: plain; title: ; notranslate">T&amp; pop_back() noexcept;</pre>
<p> ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Henry Miller				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40263</link>
		<dc:creator><![CDATA[Henry Miller]]></dc:creator>
		<pubDate>Mon, 09 Jul 2018 21:17:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40263</guid>
					<description><![CDATA[@Adrian

I&#039;ve been thinking about fragmentation.  The only reason you cannot defragment C++ memory today is someone might send a pointer to someplace not trackable as a pointer.  I&#039;ve seen two cases of this: you cast it to &quot;an int&quot; and do some math that you latter undo and cast back; or you send the pointer elsewhere (ie the network) and latter get it back (these are probably undefined behavior).  For all pointers they point to nullptr, someplace within the object in question, or one beyond the object. Thus if you ignore those cases it is possible for the compiler to track/find all the pointers, and when compaction is needed move/relocated the objects wherever and change the pointers.

If someone wants to run with this, feel free. I think it can work but there are many tricky things that I can&#039;t possibly think of much less put into a proposal. I do not require credit for my tiny idea.]]></description>
		<content:encoded><![CDATA[<p>@Adrian</p>
<p>I&#8217;ve been thinking about fragmentation.  The only reason you cannot defragment C++ memory today is someone might send a pointer to someplace not trackable as a pointer.  I&#8217;ve seen two cases of this: you cast it to &#8220;an int&#8221; and do some math that you latter undo and cast back; or you send the pointer elsewhere (ie the network) and latter get it back (these are probably undefined behavior).  For all pointers they point to nullptr, someplace within the object in question, or one beyond the object. Thus if you ignore those cases it is possible for the compiler to track/find all the pointers, and when compaction is needed move/relocated the objects wherever and change the pointers.</p>
<p>If someone wants to run with this, feel free. I think it can work but there are many tricky things that I can&#8217;t possibly think of much less put into a proposal. I do not require credit for my tiny idea.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40257</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Fri, 06 Jul 2018 17:54:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40257</guid>
					<description><![CDATA[It always concerns me when people think and talk about OOM (out of memory) when it comes to allocation failure.  An allocation failure does not necessarily mean that you&#039;re out of memory.  In my experience, the most frequent cause of allocation failure is address space fragmentation, not memory exhaustion.  You don&#039;t even need a memory leak for that to happen.

Thinking about all allocation failures as OOM limits the thinking about the causes, solutions, and error reporting strategies that should be used.]]></description>
		<content:encoded><![CDATA[<p>It always concerns me when people think and talk about OOM (out of memory) when it comes to allocation failure.  An allocation failure does not necessarily mean that you&#8217;re out of memory.  In my experience, the most frequent cause of allocation failure is address space fragmentation, not memory exhaustion.  You don&#8217;t even need a memory leak for that to happen.</p>
<p>Thinking about all allocation failures as OOM limits the thinking about the causes, solutions, and error reporting strategies that should be used.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40255</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Thu, 05 Jul 2018 15:03:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40255</guid>
					<description><![CDATA[@Florian Rudolf: &quot;Concerning contracts, are there plans to support overloading with contracts?&quot;

I hope not. Contracts aren&#039;t concepts, and having two functions with two different contracts ought to mean having two different algorithms behind them. And a different algorithm should be spelled with a different name.

That is, if there&#039;s a version of `my_algorithm` that takes a sorted list and one that doesn&#039;t, then these are two separate algorithms and users should pick which one to call based on that data. If you have a vector, then you know that it is sorted, either because you [[requires]] that it was sorted, or some function [[ensures]] that it is sorted. Either way, you the caller of `my_algorithm` is perfectly aware of the sorting status of the vector. So just call the right algorithm.

Overload resolution is complex enough; let&#039;s not give people the ability to add arbitrarily many layers of complexity to them.]]></description>
		<content:encoded><![CDATA[<p>@Florian Rudolf: &#8220;Concerning contracts, are there plans to support overloading with contracts?&#8221;</p>
<p>I hope not. Contracts aren&#8217;t concepts, and having two functions with two different contracts ought to mean having two different algorithms behind them. And a different algorithm should be spelled with a different name.</p>
<p>That is, if there&#8217;s a version of `my_algorithm` that takes a sorted list and one that doesn&#8217;t, then these are two separate algorithms and users should pick which one to call based on that data. If you have a vector, then you know that it is sorted, either because you [[requires]] that it was sorted, or some function [[ensures]] that it is sorted. Either way, you the caller of `my_algorithm` is perfectly aware of the sorting status of the vector. So just call the right algorithm.</p>
<p>Overload resolution is complex enough; let&#8217;s not give people the ability to add arbitrarily many layers of complexity to them.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Florian Rudolf				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40254</link>
		<dc:creator><![CDATA[Florian Rudolf]]></dc:creator>
		<pubDate>Thu, 05 Jul 2018 10:14:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40254</guid>
					<description><![CDATA[Concerning contracts, are there plans to support overloading with contracts? Something like:

[code]
my_algorithm(std::vector&#060;float&#062; const &#038; foo);
my_algorithm(std::vector&#060;float&#062; const &#038; foo) [[expects: is_sorted(foo)]];

std::vector&#060;float&#062; my_sort(std::vector&#060;float&#062; const &#038; foo) [[ensures: is_sorted(result)]];

// somethere else
std::vector&#060;float&#062; tmp = randomVector();

my_algorithm(tmp);  // calls first overload
my_algorithm(my_sort(tmp)); // calls second overload
[/code]]]></description>
		<content:encoded><![CDATA[<p>Concerning contracts, are there plans to support overloading with contracts? Something like:</p>
<pre class="brush: plain; title: ; notranslate">
my_algorithm(std::vector&lt;float&gt; const &amp; foo);
my_algorithm(std::vector&lt;float&gt; const &amp; foo) [[expects: is_sorted(foo)]];

std::vector&lt;float&gt; my_sort(std::vector&lt;float&gt; const &amp; foo) [[ensures: is_sorted(result)]];

// somethere else
std::vector&lt;float&gt; tmp = randomVector();

my_algorithm(tmp);  // calls first overload
my_algorithm(my_sort(tmp)); // calls second overload
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: stan423321				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40252</link>
		<dc:creator><![CDATA[stan423321]]></dc:creator>
		<pubDate>Wed, 04 Jul 2018 16:00:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40252</guid>
					<description><![CDATA[The OOM paradigm switch idea is interesting, but relying in global state for disabling retroactive changes to how it works sounds really concerning. Maybe this could be opted in by using tools in std2 namespace or something? Is std2 becoming a reality anyway?

I sort of disagree with P0709r1 1.1 (2). Consider a program that runs some sort of not really well trusted submodule, for instance an IDE which interprets an in-progress, possibly buggy program, or an X server which runs a session for a possibly buggy client. Bugs in these are &quot;kinda-recoverable&quot;, you can&#039;t recover the module, but it&#039;s likely you can recover the state of whole program. Maybe I don&#039;t know what I&#039;m talking about? The rest of the document appears to be great. Have you considered reporting no error by using a hidden error domain of no error on the ABI side, as much as that must be ludicrous while the code side of error structure is explicitly designed to not indicate success?]]></description>
		<content:encoded><![CDATA[<p>The OOM paradigm switch idea is interesting, but relying in global state for disabling retroactive changes to how it works sounds really concerning. Maybe this could be opted in by using tools in std2 namespace or something? Is std2 becoming a reality anyway?</p>
<p>I sort of disagree with P0709r1 1.1 (2). Consider a program that runs some sort of not really well trusted submodule, for instance an IDE which interprets an in-progress, possibly buggy program, or an X server which runs a session for a possibly buggy client. Bugs in these are &#8220;kinda-recoverable&#8221;, you can&#8217;t recover the module, but it&#8217;s likely you can recover the state of whole program. Maybe I don&#8217;t know what I&#8217;m talking about? The rest of the document appears to be great. Have you considered reporting no error by using a hidden error domain of no error on the ABI side, as much as that must be ludicrous while the code side of error structure is explicitly designed to not indicate success?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dirkco du Plessis				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40251</link>
		<dc:creator><![CDATA[Dirkco du Plessis]]></dc:creator>
		<pubDate>Wed, 04 Jul 2018 10:07:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40251</guid>
					<description><![CDATA[Thank you for the amazing work you all are putting in to make C++ an even more amazing language.]]></description>
		<content:encoded><![CDATA[<p>Thank you for the amazing work you all are putting in to make C++ an even more amazing language.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40248</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 20:52:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40248</guid>
					<description><![CDATA[@avjewe Remember that metaclasses are a multi-year project in early prototyping and that&#039;s also responding to committee feedback. I&#039;ll have more news this summer though, stay tuned...]]></description>
		<content:encoded><![CDATA[<p>@avjewe Remember that metaclasses are a multi-year project in early prototyping and that&#8217;s also responding to committee feedback. I&#8217;ll have more news this summer though, stay tuned&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thomas McLeod				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40247</link>
		<dc:creator><![CDATA[Thomas McLeod]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 15:33:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40247</guid>
					<description><![CDATA[Something about how you scale images makes them barely legible.`]]></description>
		<content:encoded><![CDATA[<p>Something about how you scale images makes them barely legible.`</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: avjewe				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40246</link>
		<dc:creator><![CDATA[avjewe]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 11:21:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40246</guid>
					<description><![CDATA[What more is needed before Meta Classes can be considered?]]></description>
		<content:encoded><![CDATA[<p>What more is needed before Meta Classes can be considered?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: J				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40245</link>
		<dc:creator><![CDATA[J]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 08:50:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40245</guid>
					<description><![CDATA[std::bad_alloc

I think terminating on a OOM makes much more sense than throwing exceptions.

As opposed to C and its heap allocation functions (e.g. realloc() and friends) C++&#039;s new is auto-magically getting memory from the free store. It is much more analogous to an automatic variable getting its memory from the stack. Ideally I think a new failure should trigger UB like a stack overflow. I guess terminate() is the next best thing.

As for the multi language objection, adding an extra API in the foreign language to call std::set_new_handler([]{throw std::bad_alloc();}); cannot be that hard unless I am missing something?

J.]]></description>
		<content:encoded><![CDATA[<p>std::bad_alloc</p>
<p>I think terminating on a OOM makes much more sense than throwing exceptions.</p>
<p>As opposed to C and its heap allocation functions (e.g. realloc() and friends) C++&#8217;s new is auto-magically getting memory from the free store. It is much more analogous to an automatic variable getting its memory from the stack. Ideally I think a new failure should trigger UB like a stack overflow. I guess terminate() is the next best thing.</p>
<p>As for the multi language objection, adding an extra API in the foreign language to call std::set_new_handler([]{throw std::bad_alloc();}); cannot be that hard unless I am missing something?</p>
<p>J.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Felix Petriconi				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40244</link>
		<dc:creator><![CDATA[Felix Petriconi]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 08:36:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40244</guid>
					<description><![CDATA[There is a presentation by Daniel Garcia on contracts from ACCU 2017: https://github.com/ACCUConf/ACCUConf_PDFs/blob/master/2017/j-danie-garcia-contracts.pdf and https://www.youtube.com/watch?v=IBas3S2HtdU]]></description>
		<content:encoded><![CDATA[<p>There is a presentation by Daniel Garcia on contracts from ACCU 2017: <a href="https://github.com/ACCUConf/ACCUConf_PDFs/blob/master/2017/j-danie-garcia-contracts.pdf" rel="nofollow">https://github.com/ACCUConf/ACCUConf_PDFs/blob/master/2017/j-danie-garcia-contracts.pdf</a> and <a href="https://www.youtube.com/watch?v=IBas3S2HtdU" rel="nofollow">https://www.youtube.com/watch?v=IBas3S2HtdU</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sam				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40243</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 06:58:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40243</guid>
					<description><![CDATA[Thanks to all the experts!
Totally agree with Giuseppe about Modules.
Modules has to be the most important of all...
May be, prioritizing Modules over other stuff a bit is required?
Good luck ahead!]]></description>
		<content:encoded><![CDATA[<p>Thanks to all the experts!<br />
Totally agree with Giuseppe about Modules.<br />
Modules has to be the most important of all&#8230;<br />
May be, prioritizing Modules over other stuff a bit is required?<br />
Good luck ahead!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Giuseppe				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40242</link>
		<dc:creator><![CDATA[Giuseppe]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 05:21:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40242</guid>
					<description><![CDATA[Two things... Three taking into account a big thanks for all the committee members.
1- for the backwards compatibility it will be after C++20 so you&#039;re not forced to use later version of the language with battle tested 25years old code.

2- The train model is working good, but, considering the incredible usefulness of the modules would it be incredibile to delay.1 meeting or 2 in order to let modules go into IS?]]></description>
		<content:encoded><![CDATA[<p>Two things&#8230; Three taking into account a big thanks for all the committee members.<br />
1- for the backwards compatibility it will be after C++20 so you&#8217;re not forced to use later version of the language with battle tested 25years old code.</p>
<p>2- The train model is working good, but, considering the incredible usefulness of the modules would it be incredibile to delay.1 meeting or 2 in order to let modules go into IS?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Phil Miller, PhD				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40241</link>
		<dc:creator><![CDATA[Phil Miller, PhD]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 02:08:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40241</guid>
					<description><![CDATA[(Following comments, tried but failed earlier)]]></description>
		<content:encoded><![CDATA[<p>(Following comments, tried but failed earlier)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: N/A				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40240</link>
		<dc:creator><![CDATA[N/A]]></dc:creator>
		<pubDate>Tue, 03 Jul 2018 00:07:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40240</guid>
					<description><![CDATA[&quot;Just add set_new_handler&quot; isn&#039;t a solution for libraries. Today I have libraries written in C++ that are driven by main application written in Swift or ObjectiveC or Java. Code in those languages generally cannot call set_new_handler. The C++ libraries rely on bad_alloc in a few places. If you change the default I&#039;d have to change the code. Not to mention how new and old C++ libraries are supposed to coexist in such world? 
In general, global solutions to local problems are evil. If you want std library not to throw bad_alloc then solve it in the library (this is what allocators are supposed to be for, no?). Don&#039;t change the globals for code you don&#039;t own or control.]]></description>
		<content:encoded><![CDATA[<p>&#8220;Just add set_new_handler&#8221; isn&#8217;t a solution for libraries. Today I have libraries written in C++ that are driven by main application written in Swift or ObjectiveC or Java. Code in those languages generally cannot call set_new_handler. The C++ libraries rely on bad_alloc in a few places. If you change the default I&#8217;d have to change the code. Not to mention how new and old C++ libraries are supposed to coexist in such world?<br />
In general, global solutions to local problems are evil. If you want std library not to throw bad_alloc then solve it in the library (this is what allocators are supposed to be for, no?). Don&#8217;t change the globals for code you don&#8217;t own or control.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Phil Miller				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40239</link>
		<dc:creator><![CDATA[Phil Miller]]></dc:creator>
		<pubDate>Mon, 02 Jul 2018 21:44:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40239</guid>
					<description><![CDATA[More details on the prospective August libraries meeting in/near Chicago? I could likely help out on that.]]></description>
		<content:encoded><![CDATA[<p>More details on the prospective August libraries meeting in/near Chicago? I could likely help out on that.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40238</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Mon, 02 Jul 2018 20:27:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40238</guid>
					<description><![CDATA[&#039;new_handler &#039;

Changing &#039;new_handler from throwing bad_alloc to calling terminate&#039; is messing with backwards compatibility.

We already have the screw up with the removal of auto_ptr to satisfy a zealot attitude, auto_ptr is fine if used correctly in old code. The only change should have been a compiler warning with perhaps a flashing blue light for good measure!

This is not as bad, requiring perhaps just one change to old code to get it to be backward compatible.

Unfortunately the ISO C++ committee  doesn&#039;t appear to appreciate one of the great  features of C and C++ is backwards compatibility with old code - You know the stuff that is 100% battle proven possibly over 25+ years of use and anyone modifying just to comply with a dictated new feature takes on a real risk in terms of messing it up and their job security!

After being (justifiably!) negative above,  very please to see the &#039;Feature test macros&#039; , something that should have been in C++11

Although hard to believe anyone would ask “Why would I do that?”  - Ok perhaps someone on the  C++ISO committee...….]]></description>
		<content:encoded><![CDATA[<p>&#8216;new_handler &#8216;</p>
<p>Changing &#8216;new_handler from throwing bad_alloc to calling terminate&#8217; is messing with backwards compatibility.</p>
<p>We already have the screw up with the removal of auto_ptr to satisfy a zealot attitude, auto_ptr is fine if used correctly in old code. The only change should have been a compiler warning with perhaps a flashing blue light for good measure!</p>
<p>This is not as bad, requiring perhaps just one change to old code to get it to be backward compatible.</p>
<p>Unfortunately the ISO C++ committee  doesn&#8217;t appear to appreciate one of the great  features of C and C++ is backwards compatibility with old code &#8211; You know the stuff that is 100% battle proven possibly over 25+ years of use and anyone modifying just to comply with a dictated new feature takes on a real risk in terms of messing it up and their job security!</p>
<p>After being (justifiably!) negative above,  very please to see the &#8216;Feature test macros&#8217; , something that should have been in C++11</p>
<p>Although hard to believe anyone would ask “Why would I do that?”  &#8211; Ok perhaps someone on the  C++ISO committee&#8230;….</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nisimjoseph				</title>
				<link>https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comment-40237</link>
		<dc:creator><![CDATA[nisimjoseph]]></dc:creator>
		<pubDate>Mon, 02 Jul 2018 19:12:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=3673#comment-40237</guid>
					<description><![CDATA[where can I found an explanation with examples for Contracts in C++20? if you have a lecture or article that can easily be understood it will be great.]]></description>
		<content:encoded><![CDATA[<p>where can I found an explanation with examples for Contracts in C++20? if you have a lecture or article that can easily be understood it will be great.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
