<!doctype html>
<html amp lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
	
<!-- Jetpack Open Graph Tags -->
<meta property="og:type" content="article" />
<meta property="og:title" content="Trip report: Summer ISO C++ standards meeting (Rapperswil)" />
<meta property="og:url" content="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/" />
<meta property="og:description" content="On Saturday June 9, the ISO C++ committee completed its summer meeting in beautiful Rapperswil, Switzerland, hosted with thanks by HSR Rapperswil, Zühlke, Netcetera, Bbv, SNV, Crealogix, Meeting C+…" />
<meta property="article:published_time" content="2018-07-02T18:31:12+00:00" />
<meta property="article:modified_time" content="2018-07-02T18:42:42+00:00" />
<meta property="og:site_name" content="Sutter’s Mill" />
<meta property="og:image" content="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png" />
<meta property="og:image:width" content="1943" />
<meta property="og:image:height" content="1339" />
<meta property="og:locale" content="en_US" />
<meta name="twitter:creator" content="@herbsutter" />
<meta name="twitter:site" content="@herbsutter" />
<meta name="twitter:text:title" content="Trip report: Summer ISO C++ standards meeting (Rapperswil)" />
<meta name="twitter:card" content="summary" />
<meta property="article:publisher" content="https://www.facebook.com/WordPresscom" />

<!-- End Jetpack Open Graph Tags -->
	<title>Trip report: Summer ISO C++ standards meeting (Rapperswil) &#8211; Sutter’s Mill</title>
		<link rel="canonical" href="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/" />
	<script src="https://cdn.ampproject.org/v0.js" async></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic">	<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script type="application/ld+json">{"@context":"http:\/\/schema.org","@type":"BlogPosting","mainEntityOfPage":"https:\/\/herbsutter.com\/2018\/07\/02\/trip-report-summer-iso-c-standards-meeting-rapperswil\/","publisher":{"@type":"Organization","name":"Sutter\u2019s Mill","logo":{"@type":"ImageObject","url":"https:\/\/secure.gravatar.com\/blavatar\/4554b8d24c7f200dc5e2e1b18db1893f?s=60&d=https%3A%2F%2Fs0.wp.com%2Fi%2Ffavicons%2Fapple-touch-icon-60x60.png","width":60,"height":60}},"headline":"Trip report: Summer ISO C++ standards meeting (Rapperswil)","datePublished":"2018-07-02T10:31:12+00:00","dateModified":"2018-07-02T10:42:42+00:00","author":{"@type":"Person","name":"Herb Sutter"},"image":{"@type":"ImageObject","url":"https:\/\/herbsutter.files.wordpress.com\/2018\/06\/wg21-timeline-2018-06.png","width":500,"height":345}}</script>
	<meta name="generator" content="AMP Plugin v0.6.2" />	<style amp-custom>
		/* Generic WP styling */

.alignright {
	float: right;
}

.alignleft {
	float: left;
}

.aligncenter {
	display: block;
	margin-left: auto;
	margin-right: auto;
}

.amp-wp-enforced-sizes {
	/** Our sizes fallback is 100vw, and we have a padding on the container; the max-width here prevents the element from overflowing. **/
	max-width: 100%;
	margin: 0 auto;
}

.amp-wp-unknown-size img {
	/** Worst case scenario when we can't figure out dimensions for an image. **/
	/** Force the image into a box of fixed dimensions and use object-fit to scale. **/
	object-fit: contain;
}

/* Template Styles */

.amp-wp-content,
.amp-wp-title-bar div {
		margin: 0 auto;
	max-width: 500px;
	}

html {
	background: #0a89c0;
}

body {
	background: #fff;
	color: #353535;
	font-family: 'Merriweather', 'Times New Roman', Times, Serif;
	font-weight: 300;
	line-height: 1.75em;
}

p,
ol,
ul,
figure {
	margin: 0 0 1em;
	padding: 0;
}

a,
a:visited {
	color: #0a89c0;
}

a:hover,
a:active,
a:focus {
	color: #353535;
}

/* Quotes */

blockquote {
	color: #353535;
	background: rgba(127,127,127,.125);
	border-left: 2px solid #0a89c0;
	margin: 8px 0 24px 0;
	padding: 16px;
}

blockquote p:last-child {
	margin-bottom: 0;
}

/* UI Fonts */

.amp-wp-meta,
.amp-wp-header div,
.amp-wp-title,
.wp-caption-text,
.amp-wp-tax-category,
.amp-wp-tax-tag,
.amp-wp-comments-link,
.amp-wp-footer p,
.back-to-top {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", sans-serif;
}

/* Header */

.amp-wp-header {
	background-color: #0a89c0;
}

.amp-wp-header div {
	color: #fff;
	font-size: 1em;
	font-weight: 400;
	margin: 0 auto;
	max-width: calc(840px - 32px);
	padding: .875em 16px;
	position: relative;
}

.amp-wp-header a {
	color: #fff;
	text-decoration: none;
}

/* Site Icon */

.amp-wp-header .amp-wp-site-icon {
	/** site icon is 32px **/
	background-color: #fff;
	border: 1px solid #fff;
	border-radius: 50%;
	position: absolute;
	right: 18px;
	top: 10px;
}

/* Article */

.amp-wp-article {
	color: #353535;
	font-weight: 400;
	margin: 1.5em auto;
	max-width: 840px;
	overflow-wrap: break-word;
	word-wrap: break-word;
}

/* Article Header */

.amp-wp-article-header {
	align-items: center;
	align-content: stretch;
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	margin: 1.5em 16px 0;
}

.amp-wp-title {
	color: #353535;
	display: block;
	flex: 1 0 100%;
	font-weight: 900;
	margin: 0 0 .625em;
	width: 100%;
}

/* Article Meta */

.amp-wp-meta {
	color: #696969;
	display: inline-block;
	flex: 2 1 50%;
	font-size: .875em;
	line-height: 1.5em;
	margin: 0 0 1.5em;
	padding: 0;
}

.amp-wp-article-header .amp-wp-meta:last-of-type {
	text-align: right;
}

.amp-wp-article-header .amp-wp-meta:first-of-type {
	text-align: left;
}

.amp-wp-byline amp-img,
.amp-wp-byline .amp-wp-author {
	display: inline-block;
	vertical-align: middle;
}

.amp-wp-byline amp-img {
	border: 1px solid #0a89c0;
	border-radius: 50%;
	position: relative;
	margin-right: 6px;
}

.amp-wp-posted-on {
	text-align: right;
}

/* Featured image */

.amp-wp-article-featured-image {
	margin: 0 0 1em;
}
.amp-wp-article-featured-image amp-img {
	margin: 0 auto;
}
.amp-wp-article-featured-image.wp-caption .wp-caption-text {
	margin: 0 18px;
}

/* Article Content */

.amp-wp-article-content {
	margin: 0 16px;
}

.amp-wp-article-content ul,
.amp-wp-article-content ol {
	margin-left: 1em;
}

.amp-wp-article-content amp-img {
	margin: 0 auto;
}

.amp-wp-article-content amp-img.alignright {
	margin: 0 0 1em 16px;
}

.amp-wp-article-content amp-img.alignleft {
	margin: 0 16px 1em 0;
}

/* Captions */

.wp-caption {
	padding: 0;
}

.wp-caption.alignleft {
	margin-right: 16px;
}

.wp-caption.alignright {
	margin-left: 16px;
}

.wp-caption .wp-caption-text {
	border-bottom: 1px solid #c2c2c2;
	color: #696969;
	font-size: .875em;
	line-height: 1.5em;
	margin: 0;
	padding: .66em 10px .75em;
}

/* AMP Media */

amp-carousel {
	background: #c2c2c2;
	margin: 0 -16px 1.5em;
}
amp-iframe,
amp-youtube,
amp-instagram,
amp-vine {
	background: #c2c2c2;
	margin: 0 -16px 1.5em;
}

.amp-wp-article-content amp-carousel amp-img {
	border: none;
}

amp-carousel > amp-img > img {
	object-fit: contain;
}

.amp-wp-iframe-placeholder {
	background: #c2c2c2 url( https://s2.wp.com/wp-content/plugins/amp/assets/images/placeholder-icon.png ) no-repeat center 40%;
	background-size: 48px 48px;
	min-height: 48px;
}

/* Article Footer Meta */

.amp-wp-article-footer .amp-wp-meta {
	display: block;
}

.amp-wp-tax-category,
.amp-wp-tax-tag {
	color: #696969;
	font-size: .875em;
	line-height: 1.5em;
	margin: 1.5em 16px;
}

.amp-wp-comments-link {
	color: #696969;
	font-size: .875em;
	line-height: 1.5em;
	text-align: center;
	margin: 2.25em 0 1.5em;
}

.amp-wp-comments-link a {
	border-style: solid;
	border-color: #c2c2c2;
	border-width: 1px 1px 2px;
	border-radius: 4px;
	background-color: transparent;
	color: #0a89c0;
	cursor: pointer;
	display: block;
	font-size: 14px;
	font-weight: 600;
	line-height: 18px;
	margin: 0 auto;
	max-width: 200px;
	padding: 11px 16px;
	text-decoration: none;
	width: 50%;
	-webkit-transition: background-color 0.2s ease;
			transition: background-color 0.2s ease;
}

/* AMP Footer */

.amp-wp-footer {
	border-top: 1px solid #c2c2c2;
	margin: calc(1.5em - 1px) 0 0;
}

.amp-wp-footer div {
	margin: 0 auto;
	max-width: calc(840px - 32px);
	padding: 1.25em 16px 1.25em;
	position: relative;
}

.amp-wp-footer h2 {
	font-size: 1em;
	line-height: 1.375em;
	margin: 0 0 .5em;
}

.amp-wp-footer p {
	color: #696969;
	font-size: .8em;
	line-height: 1.5em;
	margin: 0 85px 0 0;
}

.amp-wp-footer a {
	text-decoration: none;
}

.back-to-top {
	bottom: 1.275em;
	font-size: .8em;
	font-weight: 600;
	line-height: 2em;
	position: absolute;
	right: 16px;
}
		/* Inline styles */
.amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a{color:#008000;}.amp-wp-inline-8dff6cec9d7069536b1f8297fd4c1b02{color:#339966;}	</style>
</head>

<body class="">

<header id="top" class="amp-wp-header">
	<div>
		<a href="https://herbsutter.com">
									<span class="amp-site-title">
				Sutter’s Mill			</span>
		</a>
	</div>
</header>

<article class="amp-wp-article">
	<header class="amp-wp-article-header">
		<h1 class="amp-wp-title">Trip report: Summer ISO C++ standards meeting (Rapperswil)</h1>
			<div class="amp-wp-meta amp-wp-byline">
					<amp-img src="https://secure.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=24&#038;d=identicon&#038;r=g" width="24" height="24" layout="fixed"></amp-img>
				<span class="amp-wp-author author vcard">Herb Sutter</span>
	</div>
<div class="amp-wp-meta amp-wp-posted-on">
	<time datetime="2018-07-02T10:31:12+00:00">
		5 months ago	</time>
</div>
	</header>

	
	<div class="amp-wp-article-content">
		<p>On Saturday June 9, the ISO C++ committee completed its summer meeting in beautiful Rapperswil, Switzerland, hosted with thanks by HSR Rapperswil, Zühlke, Netcetera, Bbv, SNV, Crealogix, Meeting C++, and BMW Car IT GmbH. We had some 140 people at the meeting, representing 11 national bodies. As usual, we met for six days Monday through Saturday, this time including all evenings.</p><p>Per our <a href="https://wg21.link/P1000">C++20 schedule</a>, this was the second-last meeting for merging major language features into C++20. So we gave priority to the major proposals that might make C++20 or otherwise could make solid progress, and we deferred other proposals to be considered at a future meeting — not at all as a comment on the proposals, but just for lack of time. We expect to get to these soon once C++20 is well in hand.</p><h1>Top news: Contracts adopted for C++20</h1><p><a href="https://wg21.link/p0542"><strong>Contracts (Gabriel Dos Reis, J. Daniel Garcia, John Lakos, Alisdair Meredith, Nathan Myers, Bjarne Stroustrup)</strong></a> was formally adopted for C++20.</p><p>Contracts allow preconditions, postconditions, and assertions to be expressed in code using a uniform syntax, with options to have different contract levels, custom violation handlers, and more.</p><p>Here are a few quick examples to get the flavor. Let’s start with perhaps the most familiar contract, <strong>assert</strong>:</p><pre>void f() {
    int x = g();
    int y = h();
<span class="amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a"><strong>    [[assert: x+y &gt; 0]]</strong></span>
}</pre><p>“But wait,” someone might say, “C’s <strong>assert</strong> macro was good enough for my grandpappy, so shouldn’t it be good enough for me?” Never fear, you can still <strong>assert(x)</strong>, but if you respell it as <span class="amp-wp-inline-8dff6cec9d7069536b1f8297fd4c1b02"><strong>[[assert:x]]</strong></span> you get some benefits. For example:</p><ul><li>You’re not relying on a macro (unlike C assert). Yes, this matters, because macros are outside the language and routinely cause problems when using language features. For example, this was demonstrated again just a few days ago on Twitter by Nico Josuttis (HT: Alisdair Meredith), who pointed out that <strong>assert(c==std::complex&lt;float&gt;{0,0})</strong> does not compile; the reason is because macros don’t understand language commas, but <span class="amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a"><strong>[[assert: c==std::complex&lt;float&gt;{0,0}]]</strong></span> works just fine without any surprises.</li>
<li>You get to install your own violation handler and ship a release build with the option of turning on enforcement at run time.</li>
<li>You get to express <span class="amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a"><strong>audit</strong></span> to distinguish expensive checks to be run only when explicitly requested.</li>
<li>You get to express <span class="amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a"><strong>axiom</strong></span> contracts that are intended to never generate run-time code but are available to static analysis tools.</li>
<li>Finally, you will likely get better performance, because contracts should enable compilers to perform more optimizations, more easily, than expressing them using assertions.</li>
</ul><p>But there’s more, because of course contracts are not just about assertions. They also include expects preconditions and ensures postconditions, which are part of the function declaration and so are visible at call sites:</p><pre>double sqrt(double x) <span class="amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a"><strong>[[expects: x &gt;= 0]]</strong></span>;

void sort(vector&lt;emp&gt;&amp; v) <span class="amp-wp-inline-40e61f8af7aa709830a69202cb74cc6a"><strong>[[ensures audit: is_sorted(v)]]</strong></span>;
    // could be expensive, check only when audit is requested</pre><p>In addition to similar benefits as for assert, expects preconditions in particular deliver some enforcement benefits that are very desirable and difficult or impossible to get by hand:</p><ul><li>Preconditions are usually enforced at the call site, which is what we want most of the time because a precondition violation always means a programming bug in the calling code.</li>
<li>But preconditions can also be enforced in the callee, which can sometimes be necessary for pragmatic reasons, such as when the function is invoked through an opaque function pointer.</li>
<li>Preconditions and postconditions that are known at the call site also give the optimizer more information to potentially make your code fast.</li>
</ul><p>As a cheeky aside, if you noticed that I mentioned optimization several times, it’s for the usual reason: The simplest way to get C++ programmers to want a feature is to show that it can make their code faster, even if performance isn’t the only motivation or benefit.</p><h1>Why contracts are a big deal, and related Rapperswil progress</h1><p>In my opinion, contracts is the most impactful feature of C++20 so far, and arguably the most impactful feature we have added to C++ since C++11. That statement might surprise you, so let me elaborate why I think so.</p><p><strong>Having first-class contracts support it is the first major “step 1” of reforming error handling in C++</strong> and applying 30 years’ worth of learnings.</p><p><strong>Step 2 is to (gradually) migrate std:: standard library precondition violations in particular from exceptions (or error codes) to contracts.</strong> The programming world now broadly recognizes that programming bugs (e.g., out-of-bounds access, null dereference, and in general all pre/post/assert-condition violations) cause a corrupted state that cannot be recovered from programmatically, and so they should never be reported to the calling code as exceptions or error codes that code could somehow handle. Over the past three meetings (Albuquerque through Rapperswil), the Library Evolution Working Group (LEWG) voted unanimously to pursue <strong><a href="https://wg21.link/p0788r2">P0788R2 (Walter Brown)</a></strong> and relatedly in Rapperswil voted unanimously to pursue section 4.2 of <strong><a href="https://wg21.link/p0709">P0709 (my paper)</a></strong>, which includes pursuing a path of gradually migrating all standard library preconditions from exceptions toward contracts. (Note that in the near term, the idea is for implementations to be allowed, but not required, to use contracts. We are bringing the community forward gently here.)</p><p>Why is step 2 so important? Because it’s not just window dressing: Gradually switching precondition violations from exceptions to contracts promises to eventually remove a majority of all exceptions thrown by the standard library(!). This principle applies across programming languages; for examples, in Java and .NET some 90% of all exceptions are thrown for precondition violations (e.g., <strong>ArgumentNullException</strong>). Being able to eliminate a majority of all exceptions, which eventually enables many more functions to be <strong>noexcept</strong>, is a huge improvement for both correctness and performance:</p><ul><li><strong>Correctness: It eliminates a majority of the invisible control flow paths in our code.</strong> For example, over 20 years ago I wrote GotW #20 [<a href="http://gotw.ca/gotw/020.htm">Sutter 1997</a>] that shows how today a 4-line function has 3 normal execution paths and <em>20 invisible</em> exceptional execution paths; if we can eliminate a majority of the functions that can throw, we immediately remove a majority of the invisible possible execution paths in functions like this one, in all calling code.</li>
<li><strong>Performance: More </strong><strong>noexcept</strong><strong> enables more optimization and faster code.</strong> (You knew that was coming, right?)</li>
</ul><p>Once you change all preconditions (and postconditions and assertions) from exceptions to contracts, eliminating some of the largest categories of exceptions, one specific kind of exception dominates all others: <strong>bad_alloc</strong>. Which brings us to step 3…</p><p><strong>Step 3 is to consider handling heap exhaustion (out-of-memory, OOM) differently from other errors.</strong> If in addition to not throwing on precondition violations we also do not throw on OOM, the vast majority of all C++ standard library functions can be <strong>noexcept</strong>. — Needless to say, this would be a huge change where we need to tread carefully and measure impact and high-fidelity compatibility in major real code bases, and we don’t want people to panic about it or think we’ve lost our minds: We are serious about bringing code forward gently after validating good adoptability and low impact long before this gets near an actual standard.</p><p>Nevertheless, we are also serious about improving this, and the fundamental change is simple and already fully supported in C++ today: In Rapperswil, LEWG also voted unanimously to pursue section 4.3 of <strong><a href="https://wg21.link/p0709">P0709 (my paper)</a></strong> which proposes pursuing a path of gradually migrating all OOM from <strong>bad_alloc</strong> to <strong>new(nothrow)</strong>-like mechanisms. The initial contemplated step, definitely not for C++20, would be to change the default <strong>new_handler</strong> from throwing <strong>bad_alloc</strong> to calling <strong>terminate</strong>. That might sound like a big change, but it’s not, it’s already fully supported in C++ today because you can already change the <strong>new_handler</strong> to terminate today with a single line of code (<strong>std::set_new_handler([]{terminate();});</strong>), and this would just be changing the default and existing code that wants to keep the current behavior could still write simply the reverse single line of code (<strong>std::set_new_handler([]{throw std::bad_alloc();});</strong>) to get exactly the current behavior.</p><p>To repeat, this is a feature that will want a clear high-fidelity zero-breakage migration path, and we’re treating that compatibility seriously, even as we are also treating solving this problem seriously to modernize C++ error handling and move toward a mostly-<strong>noexcept</strong> world.</p><p>You can find a more detailed writeup in my new proposal <a href="https://wg21.link/p0709"><strong>P0709</strong></a>, particularly sections 1.1, 4.2, and 4.3. Again, P0709 is not for C++20, it is to illustrate a direction and potential path. The other parts of P0709 have not yet been reviewed by the full committee, so for now they should not be treated as anything more than a proposal, subject to much discussion and feedback over the coming several years.</p><h1>Other new features approved for C++20</h1><p>We adopted several other new features into the draft standard.</p><p><strong><a href="https://wg21.link/p0941">Feature test macros (Ville Voutilainen, Jonathan Wakely).</a></strong> This enables code to portably test whether a certain new C++ feature exists. “Why would I do that?” someone might ask. The primary and biggest benefit is <strong>they help your team to start to adopt new C++ features even before all your compilers support them</strong>; just write</p><pre>#if /*new feature is present*/ // temporary
<strong>    nice clean modern code!    // &lt;-- keep this long-term</strong>
#else                          // temporary
    do it the old way          // temporary
#endif                         // temporary</pre><p>and eventually drop the #if test and the whole #else block as soon as all your compilers are up to date. This is so much better than today, where one of two things happens: (1) Teams often wait until all their compilers support a given new C++ feature before they start to use it, which slows down adopting the new features and getting their benefits at least on the compilers that do support it. Or, (2) teams roll their own nonstandard nonportable compiler-specific “approximate” feature tests (e.g., write their own macro for “I know this feature is available on version ## of MSVC and version ## of GCC” by hand).</p><p>We all agree we don’t like macros. However, we don’t yet have replacements for all uses of macros, including this one, and these standard macros are better than rolling your own nonstandard ones or, more likely, just not using new C++ features at all for a longer time.</p><p>Some experts still disagree, and we respect their views, but in my view these feature test macros are an important and pragmatic help to improve the speed of adoption of new standard C++ features.</p><p><strong><a href="https://wg21.link/p0898">Standard library concepts (Casey Carter, Eric Niebler).</a></strong> This is the first part of the Ranges TS to be merged into C++20 at an upcoming meeting, and contains the core concepts from the Ranges TS. It is also the first appearance of the concepts language feature in the standard library. Expect more to come for C++20 (see Ranges, below).</p><p><strong><a href="https://wg21.link/p0732">Class Types in Non-Type Template Parameters (Jeff Snyder, Louis Dionne).</a></strong> Yes, you can now have types other than int and char as non-type template parameters. For example, in addition to <strong>template&lt;int Size&gt;</strong>, you can now have things like <strong>template&lt;fixed_string S&gt;</strong> for a suitably defined class type. It turns out that this builds on the <strong>&lt;=&gt;</strong> spaceship comparison operator; and if you’re wondering why, it’s because we know the semantics of a defaulted <strong>&lt;=&gt;</strong> comparison, which is essential because the compiler has to perform comparisons to determine whether two template instantiations are the same.</p><p>Note: I did not have this benefit in mind at all when I proposed <strong>&lt;=&gt;</strong>. I think this is a great example where, when you let programmers express intent explicitly as with <strong>&lt;=&gt;</strong>, and provide useful defaults, you are inherently adding more reliable information to the source code and will reap additional benefits because you can now build on knowledge of that clear programmer intent.</p><p><a href="https://wg21.link/p0892"><strong>explicit(bool) (Barry Revzin).</strong></a> This is conditional <strong>explicit</strong>, along the same lines as conditional <strong>noexcept</strong>. It lets library writers write <strong>explicit</strong> at a finer granularity, to turn off conversions where possible and feasible, without having to write two functions all the time.</p><p><strong><a href="https://wg21.link/p0476">Bit-casting object representations (JF Bastien).</a></strong> Header <strong>&lt;bit&gt;</strong> now lets you <strong>bit_cast.</strong> “But wait,” someone may be thinking, “don’t we already have <strong>reinterpret_cast</strong>?” Yes we do, and this is still a reinterpreting operation, but <strong>bit_cast</strong> has less unsafety and some additional flexibility: it ensures the sizes of the From and To types match, guarantees that they are both actually trivially copyable, and as a bonus makes the operation <strong>constexpr</strong> wherever possible.</p><p>Speaking of constexpr bit_cast, here are some more items in the “constexpr all the things!” department:</p><ul><li><strong><a href="https://wg21.link/p0879">“Constexpr for swap and swap related functions” (Antony Polukhin).</a></strong> Don’t be misled by the title, there are a lot of algorithms mentioned here.</li>
<li><strong><a href="https://wg21.link/p1064">“Allowing Virtual Function Calls in Constant Expressions” (Peter Dimov, Vassil Vassilev).</a></strong> Even if you weren’t surprised that we were thinking of <strong>constexpr new</strong> (we are), you might still be surprised about <strong>constexpr virtual</strong> functions. After all, virtual functions are dynamic, right? Yes they are… except when they run at compile time. So here’s another step to general C++ compile-time code.</li>
</ul><h1>Other progress and decisions</h1><p><strong>Reflection TS is feature-complete</strong>: The Reflection TS was declared feature-complete and is being sent out for its main comment ballot over the summer. Note again that the TS’s current template metaprogramming-based syntax is just a placeholder; the feedback being requested is on the core “guts” of the design, and the committee already knows it intends to replace the surface syntax with a simpler programming model that uses ordinary compile-time code and not <strong>&lt;&gt;</strong>-style metaprogramming.</p><p><strong>Parallelism TS2 is done</strong>: The second Parallelism TS is done! We completed ballot comment resolution, and approved the final TS for publication. This TS includes more execution policies, an <strong>exception_list</strong> type to communicate multiple parallel exceptions, and more parallel algorithms including wavefront, reductions, inductions, parallel for, and more. It also includes <strong>task_block</strong> support to enable writing custom parallel algorithms.</p><p><strong>Graphics (io2d) is deferred</strong>: Many thanks to Michael McLaughlin especially, and to Guy Davidson, Michael Kazakov, and David Ludwig for their assistance with the design, specification, and implementation of this cross-platform library. This is a project that has been worked on for several years, and for the past two years has been primarily responding to committee tweak requests; unfortunately, although the committee requested a series of updates to the proposal that have been applied, at this meeting the committee decided that it does not have interest to pursue further work on graphics in any form at this time after all. However, the io2d project will continue, and be available on package managers (Conan, vcpkg), and we expect a renewed proposal in the medium term; in the meantime, watch <a href="https://hatcat.com">Guy Davidson’s blog</a> for news and updates.</p><p>Also, LEWG adopted <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p0921r2.pdf">P0921r2</a> as a statement of their direction for future C++ standard library evolution compatibility guarantees.</p><h1>Updates on other major proposals</h1><p>Here are other major items in progress. You’ll notice that the first six (6!) of them mention expectations for our next meeting this November in San Diego. Not all of those items will make C++20 in San Diego, but people are going to try. It’s not surprising that San Diego is going to be a busy meeting, though; that was expected, because it’s the last meeting to merge major features into C++20, and deadlines are famously motivational. — Just <strong>do not</strong> expect all of the following to make C++20, and I’m listing them in rough order starting with the most likely to make it in.</p><p><strong>(very likely for C++20) Ranges</strong>: In my previous trip report I mentioned that the core concepts from the Ranges TS were expected to make C++20, but the rest of the Ranges TS would be “C++20 or C++23.” Since then we have made faster than expected progress, and it now looks like Ranges is “likely” to make C++20 in the next meeting or two. For those interested in details, in addition to all of the Ranges TS, also paper P0789 on Range Adaptors and Utilities have now progressed to detailed wording review and are targeting C++20. In sum, to quote Eric Niebler: “If you liked the Ranges TS, you’ll love C++20.”</p><p><strong>(likely for C++20) Concepts: “convenience” notation for constrained templates</strong>: We already added the concepts core feature to C++20, and at this meeting we had further discussions on adding a convenience syntax to write constrained templates without resorting to the low-level “<strong>requires</strong>” keyword. The two major active proposals that received discussion were from Bjarne Stroustrup and from me. The good news is that the Evolution Working Group (EWG) liked both, which means that for the first time we have a proposal based on the TS syntax (Bjarne’s preference) that could get consensus to be approved!</p><p>The key people are continuing to work to come up with a merged proposal that might be adoptable for C++20 in November in San Diego, and I’m pleased to report that as of this post-meeting mailing we for the first time have a unified proposal that lists most of the previous authors of papers in this area as coauthors, you can find it here: <strong><a href="https://wg21.link/P1141">P1141R0: “Yet another approach for constrained declarations.”</a></strong> I’m guardedly optimistic that we may have a winner here; we’ll know in San Diego. (I sometimes delay my trip report until the post-meeting mailing is available so that everyone can see the latest papers, and knowing that this new paper was coming was one reason I delayed this report.)</p><p><strong>(maybe for C++20) Coroutines</strong>: EWG considered an alternative, then decided to go forward with the TS approach. That came up for full committee vote but fell just short and was not adopted for C++20; the proposers will continue to work on improving consensus over the summer by addressing remaining concerns and we expect coroutines to be proposed again for C++20 at our November meeting in San Diego.</p><p><strong>Modules</strong>: For the first time, the committee saw a merged approach that both major proposers said satisfies their requirements; that announcement was met by applause in the room. The merged proposal aims to combine the “best of” the Modules TS and the Atom alternative proposal, and that direction was approved by EWG. EWG did not approve the poll to incorporate a subset of it into C++20 at this meeting; it is not yet clear whether part of the proposal can make C++20 but we are going to have an extra two-day meeting in September to help make progress and we expect it to be proposed again for C++20 at our November meeting in San Diego.</p><p><strong>Executors</strong>: This is still not expected to be part of C++20, but key people have not given up and are trying to make it happen, and one never can tell. We are going to hold an extra two-day meeting in September to help make progress on Executors, and expect to have a lively discussion about options to merge all or parts of it into C++20 in November in San Diego.</p><p><strong>Networking</strong>: This is pretty much ready except that it depends on Executors. Soon after Executors are ready for C++20, Networking is ready to slide in right behind it.</p><p>Clearly San Diego is going to be a busy meeting. But before then we have two extra design meetings on modules and executors to help improve their chances of progress; those will be co-located with <strong><a href="https://cppcon.org/">CppCon in September</a></strong>, to take place near the CppCon site on the days just before the conference begins. On top of that, there will also be an extra library wording issues meeting in the Chicago area in August… all in all, it’ll be a full summer and fall before we even get to San Diego.</p><p>Additionally, <strong>SG12</strong> had productive discussions about undefined behavior (including with participation from our sister ISO working group WG23, Programming Language Vulnerabilities), and <strong>SG15</strong> had a second exploratory evening session focusing on package managers for C++.</p><h1>What’s next</h1><p>Here is a cheat-sheet summary of our current expectations for some of the major pieces of work. Note that, as always, this is an estimate only. The bolded parts are the major changes from last time, including that Ranges as a whole is looking very likely for C++20.</p><p><amp-img class="alignnone size-full wp-image-3675 amp-wp-enforced-sizes" src="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500" alt="wg21-schedule-2018-06" srcset="https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=500 500w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=150 150w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=300 300w, https://herbsutter.files.wordpress.com/2018/06/wg21-schedule-2018-06.png?w=768 768w" sizes="(min-width: 500px) 500px, 100vw" width="500" height="227"></amp-img></p><p>And here is an updated snapshot of where we are on the timeline for C++20 and the TSes that are completed, in flight, or expected to begin:</p><p><amp-img class="alignnone size-full wp-image-3674 amp-wp-enforced-sizes" src="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500" alt="wg21-timeline-2018-06" srcset="https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=500 500w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=1000 1000w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=150 150w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=300 300w, https://herbsutter.files.wordpress.com/2018/06/wg21-timeline-2018-06.png?w=768 768w" sizes="(min-width: 500px) 500px, 100vw" width="500" height="345"></amp-img></p><p>Thank you again to the approximately 140 experts who attended this meeting, and the many more who participate in standardization through their national bodies! Have a good spring… we look forward now to our next “extra” meetings in September (Bellevue, WA, USA) and the next regular WG21 meeting in November (San Diego, CA, USA).</p>	</div>

	<footer class="amp-wp-article-footer">
			<div class="amp-wp-meta amp-wp-tax-category">
		Categories: <a href="https://herbsutter.com/category/c/" rel="category tag">C++</a>	</div>

		<div class="amp-wp-meta amp-wp-comments-link">
		<a href="https://herbsutter.com/2018/07/02/trip-report-summer-iso-c-standards-meeting-rapperswil/#comments">
			View Comments		</a>
	</div>
	</footer>
</article>

<footer class="amp-wp-footer">
	<div>
		<h2>Sutter’s Mill</h2>
		<p>
			<a href="https://wordpress.com/?ref=footer_blog">Blog at WordPress.com.</a>
		</p>
		<a href="#top" class="back-to-top">Back to top</a>
	</div>
</footer>


	<amp-pixel src="https://pixel.wp.com/b.gif?rand=RANDOM&#038;host=herbsutter.com&#038;ref=DOCUMENT_REFERRER&#038;amp=1&#038;blog=3379246&#038;v=wpcom&#038;tz=-8&#038;user_id=0&#038;post=3673&#038;subd=herbsutter"></amp-pixel>
	<amp-pixel src="https://pixel.wp.com/b.gif?rand=RANDOM&#038;v=wpcom-no-pv&#038;crypt=UE40eW5QN0p8M2Y%2FRE1TaVhzUzFMbjdWNHpwZGhTayxPSUFCMGNrd29%2BSmw0TDhnZmRTK0hlRi9QSGh6bi9GXVhBJWIlZlR5U1JMLU8%2FMkNtblkvY1d1TjBELytHc0k%2FMXdHUVQyK2IyUVA5SjU1bj9VX3ExLHYsREFpcnlfNHYtXV1HSUIsLkJrcnp0eS5sLmdfbDgrZG9bWy1RSmZoX0t4ZXpza01NL2lZRnJxazFbLVI4P2VuL0RUWU9iRXpqVHVxWnxUZj1beCtbW1ZKci1SfHdJZ2E3aCtGKzJmP29zN0svQX56aF9UMmJIXz12dndsOQ%3D%3D"></amp-pixel>
	
</body>
</html>
