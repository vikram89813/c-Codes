<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Complex initialization for a const variable	</title>
	<atom:link href="https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: nosila00				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9822</link>
		<dc:creator><![CDATA[nosila00]]></dc:creator>
		<pubDate>Sun, 05 May 2013 02:53:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9822</guid>
					<description><![CDATA[Wouldn&#039;t it be easier to just introduce the &quot;final&quot; C# keyword in C++?]]></description>
		<content:encoded><![CDATA[<p>Wouldn&#8217;t it be easier to just introduce the &#8220;final&#8221; C# keyword in C++?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ukdiveboy				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9649</link>
		<dc:creator><![CDATA[ukdiveboy]]></dc:creator>
		<pubDate>Fri, 26 Apr 2013 18:39:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9649</guid>
					<description><![CDATA[Yes, as sdeetee pointed out, this is very similar to a construct used in Javascript to create an object, immediately call it and use the return value from it.  in javascript it is often used as a constructor, or factory pattern, but this is also another neat way to use it.]]></description>
		<content:encoded><![CDATA[<p>Yes, as sdeetee pointed out, this is very similar to a construct used in Javascript to create an object, immediately call it and use the return value from it.  in javascript it is often used as a constructor, or factory pattern, but this is also another neat way to use it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Garciat				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9405</link>
		<dc:creator><![CDATA[Garciat]]></dc:creator>
		<pubDate>Sat, 20 Apr 2013 19:26:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9405</guid>
					<description><![CDATA[C++11 lambdas give one the opportunity to think more JavaScript-y. Now, it&#039;s up to you whether that&#039;s actually good or bad.]]></description>
		<content:encoded><![CDATA[<p>C++11 lambdas give one the opportunity to think more JavaScript-y. Now, it&#8217;s up to you whether that&#8217;s actually good or bad.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter &#8211; complex initialisation for a const variable &#124; musingstudio				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9169</link>
		<dc:creator><![CDATA[Herb Sutter &#8211; complex initialisation for a const variable &#124; musingstudio]]></dc:creator>
		<pubDate>Fri, 12 Apr 2013 12:26:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9169</guid>
					<description><![CDATA[[...] Sutter provided this handy use of lambdas to initialise a const variable that needs some [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter provided this handy use of lambdas to initialise a const variable that needs some [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Steven Harris				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9146</link>
		<dc:creator><![CDATA[Steven Harris]]></dc:creator>
		<pubDate>Thu, 11 Apr 2013 18:06:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9146</guid>
					<description><![CDATA[As you mentioned Scala, I was going to point out in my original post that Java also accommodates this (which may be what makes it possible for Scala&#039;s compiler back end) with its &quot;final&quot; keyword. Qualifying a variable as final—like using &quot;val&quot; rather than &quot;var&quot; in Scala—means that the variable must be assigned exactly once before use, not that it needs to be bound at its point of declaration.

Given that, one can write:

final String host;
final int port;
if (something) {
  host = “alpha”;
  port = 119;
} else {
  host = “omega”;
  port = 563;
}]]></description>
		<content:encoded><![CDATA[<p>As you mentioned Scala, I was going to point out in my original post that Java also accommodates this (which may be what makes it possible for Scala&#8217;s compiler back end) with its &#8220;final&#8221; keyword. Qualifying a variable as final—like using &#8220;val&#8221; rather than &#8220;var&#8221; in Scala—means that the variable must be assigned exactly once before use, not that it needs to be bound at its point of declaration.</p>
<p>Given that, one can write:</p>
<p>final String host;<br />
final int port;<br />
if (something) {<br />
  host = “alpha”;<br />
  port = 119;<br />
} else {<br />
  host = “omega”;<br />
  port = 563;<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9145</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 11 Apr 2013 18:06:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9145</guid>
					<description><![CDATA[@Kaylyn: Hmm, which reminds me that you can always use a tuple:

const tuple xy = [&#038;]{ /* initialize and return a tuple */ }();

or a struct:

const struct xy_ { int x; std::string y; } xy = [&#038;]{ /* initialize and return an xy_ */ }();

Hmm... one argument in favor of these options is that if those local variables are so related that they&#039;re initialized together, they probably ought to benefit from being grouped together anyway.

In fact, in the case of host and port, the answer seems clear that the normal term we use for &quot;initialize multiple variables that should be initialized together and probably share an invariants&quot; is &quot;constructor.&quot; In the host+port example above, I sense that there&#039;s a class or struct abstraction missing anyway to group these together, and once you have that you&#039;re back in the simple single-variable case.]]></description>
		<content:encoded><![CDATA[<p>@Kaylyn: Hmm, which reminds me that you can always use a tuple:</p>
<p>const tuple xy = [&amp;]{ /* initialize and return a tuple */ }();</p>
<p>or a struct:</p>
<p>const struct xy_ { int x; std::string y; } xy = [&amp;]{ /* initialize and return an xy_ */ }();</p>
<p>Hmm&#8230; one argument in favor of these options is that if those local variables are so related that they&#8217;re initialized together, they probably ought to benefit from being grouped together anyway.</p>
<p>In fact, in the case of host and port, the answer seems clear that the normal term we use for &#8220;initialize multiple variables that should be initialized together and probably share an invariants&#8221; is &#8220;constructor.&#8221; In the host+port example above, I sense that there&#8217;s a class or struct abstraction missing anyway to group these together, and once you have that you&#8217;re back in the simple single-variable case.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kaylyn Bogle				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9143</link>
		<dc:creator><![CDATA[Kaylyn Bogle]]></dc:creator>
		<pubDate>Thu, 11 Apr 2013 17:33:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9143</guid>
					<description><![CDATA[@Steven Harris:

If they don&#039;t have to be const you can unpack using std::tie:

int x;
std::string y;

std::tie(x, y) = SomeFunction(); // That returns std::tuple

I don&#039;t think it&#039;s possible in C++, without some sort of profound language change wrt variable definition, to easily unpack and initialize multiple consts from a function :(

Scala handles situations like this really well:

val (a, b) = if (someConditionIstrue) {
    // Do calculations here
    (calculatedValue, someOtherCalculation)
} else (5, 5)  // Some default values

This creates two constants `a`, and `b`, unpacked from the tuple returned by `if`]]></description>
		<content:encoded><![CDATA[<p>@Steven Harris:</p>
<p>If they don&#8217;t have to be const you can unpack using std::tie:</p>
<p>int x;<br />
std::string y;</p>
<p>std::tie(x, y) = SomeFunction(); // That returns std::tuple</p>
<p>I don&#8217;t think it&#8217;s possible in C++, without some sort of profound language change wrt variable definition, to easily unpack and initialize multiple consts from a function :(</p>
<p>Scala handles situations like this really well:</p>
<p>val (a, b) = if (someConditionIstrue) {<br />
    // Do calculations here<br />
    (calculatedValue, someOtherCalculation)<br />
} else (5, 5)  // Some default values</p>
<p>This creates two constants `a`, and `b`, unpacked from the tuple returned by `if`</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Some Future Concurrency in C++14 &#124; Art &#38; Logic Blog				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9139</link>
		<dc:creator><![CDATA[Some Future Concurrency in C++14 &#124; Art &#38; Logic Blog]]></dc:creator>
		<pubDate>Thu, 11 Apr 2013 16:38:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9139</guid>
					<description><![CDATA[[...] over adding keywords. Herb Sutter has described C++14 as an incremental update to C++11 as &#8220;the delta from 11 is pretty small but with a number of convenient fit-and-finish tidy-ups&#038;#82..., so maybe that indicates sweeping changes like this won&#8217;t get far in [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] over adding keywords. Herb Sutter has described C++14 as an incremental update to C++11 as &#8220;the delta from 11 is pretty small but with a number of convenient fit-and-finish tidy-ups&amp;#82&#8230;, so maybe that indicates sweeping changes like this won&#8217;t get far in [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9096</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Wed, 10 Apr 2013 18:02:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9096</guid>
					<description><![CDATA[@Herb I don&#039;t want to change anything, just was wondering about the line in your code:

the_instance = call_once( create, /* initialization, most conveniently with a lambda */ );]]></description>
		<content:encoded><![CDATA[<p>@Herb I don&#8217;t want to change anything, just was wondering about the line in your code:</p>
<p>the_instance = call_once( create, /* initialization, most conveniently with a lambda */ );</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9095</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 10 Apr 2013 18:01:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9095</guid>
					<description><![CDATA[PS - I never understood the comments that asked for a terser notation. It&#039;s seven (7) characters: [&#038;]{ followed by }() .]]></description>
		<content:encoded><![CDATA[<p>PS &#8211; I never understood the comments that asked for a terser notation. It&#8217;s seven (7) characters: [&amp;]{ followed by }() .</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9093</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 10 Apr 2013 17:57:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9093</guid>
					<description><![CDATA[@Arne: What would you like to change? That signature accepts call_once( flag, []{ ...my lambda... } ); right? std::async is the same.

@Jon: It can be made fast. Certainly you can do DCL, which is an atomic load (generally cheap). And before thread-safe init for function local statics was adopted, Google showed the committee a cool algorithm to do it cheaply on the fast path and promised to make the algorithm freely available for this purpose, which is what convinced the committee to adopt it as I recall. I can hunt it up in the papers but don&#039;t have a link offhand.]]></description>
		<content:encoded><![CDATA[<p>@Arne: What would you like to change? That signature accepts call_once( flag, []{ &#8230;my lambda&#8230; } ); right? std::async is the same.</p>
<p>@Jon: It can be made fast. Certainly you can do DCL, which is an atomic load (generally cheap). And before thread-safe init for function local statics was adopted, Google showed the committee a cool algorithm to do it cheaply on the fast path and promised to make the algorithm freely available for this purpose, which is what convinced the committee to adopt it as I recall. I can hunt it up in the papers but don&#8217;t have a link offhand.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9071</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Wed, 10 Apr 2013 01:53:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9071</guid>
					<description><![CDATA[@Herb, Does the first singleton example you posted imply a memory barrier? If instance() is performance-critical for subsequent calls, would an alternative be to ensure the calculation is done at startup instead of on-demand?]]></description>
		<content:encoded><![CDATA[<p>@Herb, Does the first singleton example you posted imply a memory barrier? If instance() is performance-critical for subsequent calls, would an alternative be to ensure the calculation is done at startup instead of on-demand?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9066</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Tue, 09 Apr 2013 16:28:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9066</guid>
					<description><![CDATA[Thanks for the enlightenment about thread safety - one question to the call_once, though: As far as I can see in N3337, there is only void call_once(once_flag&#038;, Callable, Args&#038;&#038;...) - is that going to change?]]></description>
		<content:encoded><![CDATA[<p>Thanks for the enlightenment about thread safety &#8211; one question to the call_once, though: As far as I can see in N3337, there is only void call_once(once_flag&amp;, Callable, Args&amp;&amp;&#8230;) &#8211; is that going to change?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9042</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 18:39:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9042</guid>
					<description><![CDATA[@Arne: No, that doesn&#039;t work. You only get automatically thread-safe initialization for *function local* statics, not for all statics because that would incur expense on a lot of code that doesn&#039;t need it. This is described in 3.6.2/2 for those following along in the standard. The standard way to write thread-safe initialization of statics or lazy initialization, if you&#039;re not using function local statics, is to use once_flag and call_once.

So for example you can do a singleton as:

// preferred unless you need fanciness like a phoenix singleton
singleton&#038; singleton::instance() {
    static singleton the_instance = /* arbitrarily complex init, most conveniently in a lambda */;
    return the_instance;
}

or as:

// good but usually a verbose way to accomplish the same as the above
singleton { static once_flag create; static instance* the_instance; ... };
singleton&#038; singleton::instance() {
    the_instance = call_once( create, /* initialization, most conveniently with a lambda */ );
    return *the_instance;
}

or using Double-Checked Locking using a mutex and an atomic but that&#039;s sort of the old-school way once_flag and call_once are designed to replace.

Or another way but those are the three common variants.

Herb]]></description>
		<content:encoded><![CDATA[<p>@Arne: No, that doesn&#8217;t work. You only get automatically thread-safe initialization for *function local* statics, not for all statics because that would incur expense on a lot of code that doesn&#8217;t need it. This is described in 3.6.2/2 for those following along in the standard. The standard way to write thread-safe initialization of statics or lazy initialization, if you&#8217;re not using function local statics, is to use once_flag and call_once.</p>
<p>So for example you can do a singleton as:</p>
<p>// preferred unless you need fanciness like a phoenix singleton<br />
singleton&amp; singleton::instance() {<br />
    static singleton the_instance = /* arbitrarily complex init, most conveniently in a lambda */;<br />
    return the_instance;<br />
}</p>
<p>or as:</p>
<p>// good but usually a verbose way to accomplish the same as the above<br />
singleton { static once_flag create; static instance* the_instance; &#8230; };<br />
singleton&amp; singleton::instance() {<br />
    the_instance = call_once( create, /* initialization, most conveniently with a lambda */ );<br />
    return *the_instance;<br />
}</p>
<p>or using Double-Checked Locking using a mutex and an atomic but that&#8217;s sort of the old-school way once_flag and call_once are designed to replace.</p>
<p>Or another way but those are the three common variants.</p>
<p>Herb</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Umar Nizamani				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9039</link>
		<dc:creator><![CDATA[Umar Nizamani]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 13:22:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9039</guid>
					<description><![CDATA[What i tend to do to avoid such problems is keep such values of i under limited scope.. so basically:

{
  int i; 
  if(someConditionIstrue) 
  { 
    Do some operations and calculate the value of i; 
    i = some calculated value; 
  } 

  // Do what ever you want to do with i
} // Close scope, and forget about i

Obviously not the ideal solution, but helps keep code clean, and variables managed..]]></description>
		<content:encoded><![CDATA[<p>What i tend to do to avoid such problems is keep such values of i under limited scope.. so basically:</p>
<p>{<br />
  int i;<br />
  if(someConditionIstrue)<br />
  {<br />
    Do some operations and calculate the value of i;<br />
    i = some calculated value;<br />
  } </p>
<p>  // Do what ever you want to do with i<br />
} // Close scope, and forget about i</p>
<p>Obviously not the ideal solution, but helps keep code clean, and variables managed..</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon A Watts				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9035</link>
		<dc:creator><![CDATA[Simon A Watts]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 10:57:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9035</guid>
					<description><![CDATA[This expensive-lazy-initialisation is quite frequent in the legacy code bases I&#039;ve dealt with (a slight improvement over repeated-initialisation - obviously there to absorb excess processing capacity).

Where the thing to be initialised is a global computed constant, as opposed, say, a constant for an object instance, I usually extract it to a static with an initialising function, such as:

namespace { // anonymous
    int once_calculate_i_ () { /* ... */ }
} 

void foo ()
{
    static const int i= once_calculate_i_ ();
    // ...
}


I don&#039;t see an advantage in using a lambda here (and we&#039;re unlikely to see C++11 compilers adopted for 10 years if past record is maintained - there are reasons for this in my domain).

I would still want to see the intent of the calculation documented, which is better handled when it is expressed as a separate function.  Without documentation of intent, we have to infer intent from the implementation, which is not necessarily the same thing... Poor documentation is a bane of maintaining long-term code bases, and I prefer to leave my future incarnates something more manageable.]]></description>
		<content:encoded><![CDATA[<p>This expensive-lazy-initialisation is quite frequent in the legacy code bases I&#8217;ve dealt with (a slight improvement over repeated-initialisation &#8211; obviously there to absorb excess processing capacity).</p>
<p>Where the thing to be initialised is a global computed constant, as opposed, say, a constant for an object instance, I usually extract it to a static with an initialising function, such as:</p>
<p>namespace { // anonymous<br />
    int once_calculate_i_ () { /* &#8230; */ }<br />
} </p>
<p>void foo ()<br />
{<br />
    static const int i= once_calculate_i_ ();<br />
    // &#8230;<br />
}</p>
<p>I don&#8217;t see an advantage in using a lambda here (and we&#8217;re unlikely to see C++11 compilers adopted for 10 years if past record is maintained &#8211; there are reasons for this in my domain).</p>
<p>I would still want to see the intent of the calculation documented, which is better handled when it is expressed as a separate function.  Without documentation of intent, we have to infer intent from the implementation, which is not necessarily the same thing&#8230; Poor documentation is a bane of maintaining long-term code bases, and I prefer to leave my future incarnates something more manageable.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Philip				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9034</link>
		<dc:creator><![CDATA[Philip]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 08:58:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9034</guid>
					<description><![CDATA[I love it!]]></description>
		<content:encoded><![CDATA[<p>I love it!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9032</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 07:22:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9032</guid>
					<description><![CDATA[@Lachlan: I should clarify that a single instance of LazyInitialize may be shared by zero or many clients of the object. expensive_calculation() should only be called when the first client needs it.]]></description>
		<content:encoded><![CDATA[<p>@Lachlan: I should clarify that a single instance of LazyInitialize may be shared by zero or many clients of the object. expensive_calculation() should only be called when the first client needs it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lachlan Brad Easton				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9031</link>
		<dc:creator><![CDATA[Lachlan Brad Easton]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 07:16:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9031</guid>
					<description><![CDATA[@Jon: In cases where it doesn&#039;t make sense for value to be static then you could call expensive_calculation in LazyInitialize&#039;s constructor.]]></description>
		<content:encoded><![CDATA[<p>@Jon: In cases where it doesn&#8217;t make sense for value to be static then you could call expensive_calculation in LazyInitialize&#8217;s constructor.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9024</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Mon, 08 Apr 2013 01:38:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9024</guid>
					<description><![CDATA[How can we solve something like this?

class LazyInitialize
{
public:
	int get_value() {if (value not calculated yet) {value = expensive_calculation();} return value;}
private:
	const_once int value;
};]]></description>
		<content:encoded><![CDATA[<p>How can we solve something like this?</p>
<p>class LazyInitialize<br />
{<br />
public:<br />
	int get_value() {if (value not calculated yet) {value = expensive_calculation();} return value;}<br />
private:<br />
	const_once int value;<br />
};</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Инициализация константных переменных &#124; System Development				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9016</link>
		<dc:creator><![CDATA[Инициализация константных переменных &#124; System Development]]></dc:creator>
		<pubDate>Sun, 07 Apr 2013 14:39:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9016</guid>
					<description><![CDATA[[...] P.S. подсмотренно у Саттера. [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] P.S. подсмотренно у Саттера. [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9015</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Sun, 07 Apr 2013 14:26:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9015</guid>
					<description><![CDATA[The lambda solution seems appropriate for some situations, but it&#039;s not clear that it addresses the original question.

The original question didn&#039;t have a default value and only conditionally initializes the variable.  The lambda solution doesn&#039;t do the same thing, since it always initializes the variable regardless of the condition.

When I first read the question, I wondered if the intent was that i was actually a member variable (or at least persistent beyond the scope suggested), and the intent was to initialize it the first time SomeCondition was true and then never to change it again after that.  In that case, the idea of &quot;const once&quot; seems useful.

For example, if i was a function static, the intent might be to initialize i the first time the function is called and the condition is true, and never to change i again after that.  (And also to let i remain uninitialized until that first call with the condition being true.)

Otherwise, you could just write:

const int i = (someCondition) ? calc() : default_value;

This is going to be recognized by all C and C++ programmers, even those not versed in lambdas.]]></description>
		<content:encoded><![CDATA[<p>The lambda solution seems appropriate for some situations, but it&#8217;s not clear that it addresses the original question.</p>
<p>The original question didn&#8217;t have a default value and only conditionally initializes the variable.  The lambda solution doesn&#8217;t do the same thing, since it always initializes the variable regardless of the condition.</p>
<p>When I first read the question, I wondered if the intent was that i was actually a member variable (or at least persistent beyond the scope suggested), and the intent was to initialize it the first time SomeCondition was true and then never to change it again after that.  In that case, the idea of &#8220;const once&#8221; seems useful.</p>
<p>For example, if i was a function static, the intent might be to initialize i the first time the function is called and the condition is true, and never to change i again after that.  (And also to let i remain uninitialized until that first call with the condition being true.)</p>
<p>Otherwise, you could just write:</p>
<p>const int i = (someCondition) ? calc() : default_value;</p>
<p>This is going to be recognized by all C and C++ programmers, even those not versed in lambdas.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9009</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Sun, 07 Apr 2013 09:20:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9009</guid>
					<description><![CDATA[@Herb: I think what Bruno means with statics is something like this: 
//header
struct C {
  static int i;  
};
//source
int C::i = [](){ return (std::time(nullptr) % 2) ? 42 : 4711; }();]]></description>
		<content:encoded><![CDATA[<p>@Herb: I think what Bruno means with statics is something like this:<br />
//header<br />
struct C {<br />
  static int i;<br />
};<br />
//source<br />
int C::i = [](){ return (std::time(nullptr) % 2) ? 42 : 4711; }();</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: petke				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9007</link>
		<dc:creator><![CDATA[petke]]></dc:creator>
		<pubDate>Sun, 07 Apr 2013 07:48:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9007</guid>
					<description><![CDATA[I known about it, but don&#039;t end up using it. Its still too verbose.]]></description>
		<content:encoded><![CDATA[<p>I known about it, but don&#8217;t end up using it. Its still too verbose.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Visto nel Web &#8211; 73 &#124; Ok, panico				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9006</link>
		<dc:creator><![CDATA[Visto nel Web &#8211; 73 &#124; Ok, panico]]></dc:creator>
		<pubDate>Sun, 07 Apr 2013 07:08:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9006</guid>
					<description><![CDATA[[...] Complex initialization for a const variable ::: Sutter&#8217;s Mill [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Complex initialization for a const variable ::: Sutter&#8217;s Mill [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-9000</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 07 Apr 2013 00:32:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-9000</guid>
					<description><![CDATA[I agree with the reasons given why this is better than extracting a named helper function that is only used here: the lambda has better locality, is arguably more readable, and lets you use other locals directly without passing references to an artificially outlined function. I also agree that it&#039;s better than &quot;const int&#038; i = temp_i;&quot; which is less direct and also has the drawback that temp_i stays in scope.

@Bruno: How does this help with statics?]]></description>
		<content:encoded><![CDATA[<p>I agree with the reasons given why this is better than extracting a named helper function that is only used here: the lambda has better locality, is arguably more readable, and lets you use other locals directly without passing references to an artificially outlined function. I also agree that it&#8217;s better than &#8220;const int&amp; i = temp_i;&#8221; which is less direct and also has the drawback that temp_i stays in scope.</p>
<p>@Bruno: How does this help with statics?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8996</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 21:43:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8996</guid>
					<description><![CDATA[@Andrzej: Right, but I&#039;ll let it stand. The committee has already pretty much agreed that this should be allowed (which is why our compiler also already supports it, and with GCC and Clang that would make it de facto portable), and this extension is likely to be voted into the C++ working paper soon (this month, or September). I&#039;ll go out on a limb and say that if anything is a slam dunk for C++14, it would seem that this is. And it truly should just work.

Incidentally, this is one reason why I think I&#039;ll write Exceptional C++14... 14 is so close to done (we hope to technically finalize it in September of this year), and the delta from 11 is pretty small but with a number of convenient fit-and-finish tidy-ups like this one.]]></description>
		<content:encoded><![CDATA[<p>@Andrzej: Right, but I&#8217;ll let it stand. The committee has already pretty much agreed that this should be allowed (which is why our compiler also already supports it, and with GCC and Clang that would make it de facto portable), and this extension is likely to be voted into the C++ working paper soon (this month, or September). I&#8217;ll go out on a limb and say that if anything is a slam dunk for C++14, it would seem that this is. And it truly should just work.</p>
<p>Incidentally, this is one reason why I think I&#8217;ll write Exceptional C++14&#8230; 14 is so close to done (we hope to technically finalize it in September of this year), and the delta from 11 is pretty small but with a number of convenient fit-and-finish tidy-ups like this one.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bruno Martínez				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8994</link>
		<dc:creator><![CDATA[Bruno Martínez]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 18:41:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8994</guid>
					<description><![CDATA[The same trick lets you declare static vars so that the initialization is done only once and thread safely.]]></description>
		<content:encoded><![CDATA[<p>The same trick lets you declare static vars so that the initialization is done only once and thread safely.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrzej Krzemieński				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8990</link>
		<dc:creator><![CDATA[Andrzej Krzemieński]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 13:51:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8990</guid>
					<description><![CDATA[@Herb: While your example compiles in g++4.7, 4.8 and Clang 3.2, I believe it is not a valid C++11 code. According to sect 5.1.2 para 4, when the body of the lambda is not a simple return statement its deduced return type is void. While the expectation that this example would work is logical, and likely acceptable in C++14, C++11 seems to refuse it.]]></description>
		<content:encoded><![CDATA[<p>@Herb: While your example compiles in g++4.7, 4.8 and Clang 3.2, I believe it is not a valid C++11 code. According to sect 5.1.2 para 4, when the body of the lambda is not a simple return statement its deduced return type is void. While the expectation that this example would work is logical, and likely acceptable in C++14, C++11 seems to refuse it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cedric				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8981</link>
		<dc:creator><![CDATA[Cedric]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 11:19:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8981</guid>
					<description><![CDATA[constexpr keyword has been added for this purpose isn&#039;t it? Using a named constexpr function is a good way to achieve the result. 
Even if it adds a name in the symbol space, it could (it should in fact) be a private function within the class we&#039;re working in.

Though, I admit that the lambda solution is a nice one I too.]]></description>
		<content:encoded><![CDATA[<p>constexpr keyword has been added for this purpose isn&#8217;t it? Using a named constexpr function is a good way to achieve the result.<br />
Even if it adds a name in the symbol space, it could (it should in fact) be a private function within the class we&#8217;re working in.</p>
<p>Though, I admit that the lambda solution is a nice one I too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gang Jiang				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8980</link>
		<dc:creator><![CDATA[Gang Jiang]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 10:52:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8980</guid>
					<description><![CDATA[The function is similar to the reserved word &quot;readonly&quot; in C#? We can reference .NET to achieve it.]]></description>
		<content:encoded><![CDATA[<p>The function is similar to the reserved word &#8220;readonly&#8221; in C#? We can reference .NET to achieve it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8979</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 10:40:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8979</guid>
					<description><![CDATA[While technically the lambda is a good solution and may have its applications for initializations, in this case I&#039;d as well recommend using a separate function. When the main task of a function is to *use* i, then the SRP demands separating the calculation of the initial value of i from the function. That way the main logic of the function is not interrupted and cluttered with a multiline lambda containing the lower level logic of the constant&#039;s calculation.]]></description>
		<content:encoded><![CDATA[<p>While technically the lambda is a good solution and may have its applications for initializations, in this case I&#8217;d as well recommend using a separate function. When the main task of a function is to *use* i, then the SRP demands separating the calculation of the initial value of i from the function. That way the main logic of the function is not interrupted and cluttered with a multiline lambda containing the lower level logic of the constant&#8217;s calculation.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mjklaim				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8978</link>
		<dc:creator><![CDATA[mjklaim]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 08:30:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8978</guid>
					<description><![CDATA[@Arthur Langereis

You are hiding the verbosity of the lambda in the ellipse.
If you need a lambda in this context, you will certainly do at least some kind of branching, which mean for clarity your lambda will not be a one-liner. You can use terse if syntax but then there is no need for a lambda.

With a named function, if your code looks like it&#039;s noise in the middle of the code which use the constant, at least the code is out of the scope.
Which is a problem as you pointed, which is why I think a lambda is still better even if it looks like noise at first.]]></description>
		<content:encoded><![CDATA[<p>@Arthur Langereis</p>
<p>You are hiding the verbosity of the lambda in the ellipse.<br />
If you need a lambda in this context, you will certainly do at least some kind of branching, which mean for clarity your lambda will not be a one-liner. You can use terse if syntax but then there is no need for a lambda.</p>
<p>With a named function, if your code looks like it&#8217;s noise in the middle of the code which use the constant, at least the code is out of the scope.<br />
Which is a problem as you pointed, which is why I think a lambda is still better even if it looks like noise at first.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ternary				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8969</link>
		<dc:creator><![CDATA[Ternary]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 07:47:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8969</guid>
					<description><![CDATA[Or, in this simple case, you could just use the ternary operator:
    const int i = someCondition ? calculatedValue : defaultValue;]]></description>
		<content:encoded><![CDATA[<p>Or, in this simple case, you could just use the ternary operator:<br />
    const int i = someCondition ? calculatedValue : defaultValue;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cogito				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8967</link>
		<dc:creator><![CDATA[Cogito]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 05:45:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8967</guid>
					<description><![CDATA[@bsivko I like that solution. It was the one that immediately came to my mind as well. The only downside is that init_i is not scoped.]]></description>
		<content:encoded><![CDATA[<p>@bsivko I like that solution. It was the one that immediately came to my mind as well. The only downside is that init_i is not scoped.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bsivko				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8966</link>
		<dc:creator><![CDATA[bsivko]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 03:57:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8966</guid>
					<description><![CDATA[One more way:

	int init_i; 
	if(someConditionIstrue) 
	{ 
		Do some operations and calculate the value of i; 
		init_i = some calculated value; 
	} 
	const int &#038; i = init_i;]]></description>
		<content:encoded><![CDATA[<p>One more way:</p>
<p>	int init_i;<br />
	if(someConditionIstrue)<br />
	{<br />
		Do some operations and calculate the value of i;<br />
		init_i = some calculated value;<br />
	}<br />
	const int &amp; i = init_i;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: sdeetee				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8960</link>
		<dc:creator><![CDATA[sdeetee]]></dc:creator>
		<pubDate>Sat, 06 Apr 2013 01:23:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8960</guid>
					<description><![CDATA[Hey, I just learned about these things called &quot;immediately-invoked function expressions&quot; in JavaScript last week :).

http://en.m.wikipedia.org/wiki/Immediately-invoked_function_expression

It&#039;s neat that they have different but overlapping uses in C++. C++ doesn&#039;t quite have the scoping issues as JavaScript, but they can be used for some similar scenarios to those mentioned in the Wikipedia page above.]]></description>
		<content:encoded><![CDATA[<p>Hey, I just learned about these things called &#8220;immediately-invoked function expressions&#8221; in JavaScript last week :).</p>
<p><a href="http://en.m.wikipedia.org/wiki/Immediately-invoked_function_expression" rel="nofollow">http://en.m.wikipedia.org/wiki/Immediately-invoked_function_expression</a></p>
<p>It&#8217;s neat that they have different but overlapping uses in C++. C++ doesn&#8217;t quite have the scoping issues as JavaScript, but they can be used for some similar scenarios to those mentioned in the Wikipedia page above.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alan Tatourian				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8959</link>
		<dc:creator><![CDATA[Alan Tatourian]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 23:27:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8959</guid>
					<description><![CDATA[Would it not be better to encapsulate i into an immutable object?]]></description>
		<content:encoded><![CDATA[<p>Would it not be better to encapsulate i into an immutable object?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arthur Langereis				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8957</link>
		<dc:creator><![CDATA[Arthur Langereis]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 22:29:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8957</guid>
					<description><![CDATA[To mjklaim, why do you feel:

const int i = [&#038;]{ … }();

is more verbose than something like:

static int calcI() { … }
…
const int i = calcI();

To Johannes, In addition to not needing a name and being unique as mjklaim points out, a lambda can use scoped variables and is defined and used at the site where it is needed, making a lambda a superior choice to a non-member function in this case. Given the syntactic and semantic needs of C++, I think the current lambda notation is quite compact and the upcoming upgrades for it will only make it more seamless.

A statement like

const int i = [&#038;] …expression…;

is more terse but if you only have a single expression it won&#039;t make sense to use a lambda in this case. How would you like to see the the construction formed? (Using wished-for C++ language changes, if necessary)]]></description>
		<content:encoded><![CDATA[<p>To mjklaim, why do you feel:</p>
<p>const int i = [&amp;]{ … }();</p>
<p>is more verbose than something like:</p>
<p>static int calcI() { … }<br />
…<br />
const int i = calcI();</p>
<p>To Johannes, In addition to not needing a name and being unique as mjklaim points out, a lambda can use scoped variables and is defined and used at the site where it is needed, making a lambda a superior choice to a non-member function in this case. Given the syntactic and semantic needs of C++, I think the current lambda notation is quite compact and the upcoming upgrades for it will only make it more seamless.</p>
<p>A statement like</p>
<p>const int i = [&amp;] …expression…;</p>
<p>is more terse but if you only have a single expression it won&#8217;t make sense to use a lambda in this case. How would you like to see the the construction formed? (Using wished-for C++ language changes, if necessary)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Steven Harris				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8956</link>
		<dc:creator><![CDATA[Steven Harris]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 22:28:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8956</guid>
					<description><![CDATA[The one that always troubles me is initializing two or more variables that I&#039;d like to all be const, where their values depend on some condition that I&#039;d prefer to only evaluate once.

std::string/* const */ host;
unsigned int/* const*/ port;
if (something) {
  host = &quot;alpha&quot;;
  port = 119;
} else {
  host = &quot;omega&quot;;
  port = 563;
}

The only solution I know is to wrap the related variables up in struct and write a helper function that returns an instance with the proper values base on the condition.]]></description>
		<content:encoded><![CDATA[<p>The one that always troubles me is initializing two or more variables that I&#8217;d like to all be const, where their values depend on some condition that I&#8217;d prefer to only evaluate once.</p>
<p>std::string/* const */ host;<br />
unsigned int/* const*/ port;<br />
if (something) {<br />
  host = &#8220;alpha&#8221;;<br />
  port = 119;<br />
} else {<br />
  host = &#8220;omega&#8221;;<br />
  port = 563;<br />
}</p>
<p>The only solution I know is to wrap the related variables up in struct and write a helper function that returns an instance with the proper values base on the condition.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mjklaim				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8954</link>
		<dc:creator><![CDATA[mjklaim]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 20:39:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8954</guid>
					<description><![CDATA[The problem with named functions is that they have a name, so they can be used more than once.
When it is not the intention, it is a problem. Using a lambda makes it clear that there should be only one unique specifically located use.

Unfortunately it&#039;s more verbose than using a named function, which can be fixed with a simpler notation.]]></description>
		<content:encoded><![CDATA[<p>The problem with named functions is that they have a name, so they can be used more than once.<br />
When it is not the intention, it is a problem. Using a lambda makes it clear that there should be only one unique specifically located use.</p>
<p>Unfortunately it&#8217;s more verbose than using a named function, which can be fixed with a simpler notation.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johannes Ohlemacher				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8953</link>
		<dc:creator><![CDATA[Johannes Ohlemacher]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 19:26:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8953</guid>
					<description><![CDATA[Whats wrong with a simple helper function?
I think, in most cases a named function is a more readable solution to the problem (especially in respect of self documenting code). 

int calculateValue() { //choose a more descriptive name
  if (!someCondition)
    return default_value;
  
  //Do some operations and calculate the value
  return value;
}

....

const int i = calculateValue();
use i;


things might get messy if the helper function need lots of arguments...]]></description>
		<content:encoded><![CDATA[<p>Whats wrong with a simple helper function?<br />
I think, in most cases a named function is a more readable solution to the problem (especially in respect of self documenting code). </p>
<p>int calculateValue() { //choose a more descriptive name<br />
  if (!someCondition)<br />
    return default_value;</p>
<p>  //Do some operations and calculate the value<br />
  return value;<br />
}</p>
<p>&#8230;.</p>
<p>const int i = calculateValue();<br />
use i;</p>
<p>things might get messy if the helper function need lots of arguments&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Concerned C++ Programmer				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8952</link>
		<dc:creator><![CDATA[Concerned C++ Programmer]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 19:12:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8952</guid>
					<description><![CDATA[I&#039;m sure all these things will become clear once Ambassador Soval gets around to finishing off his next edition.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m sure all these things will become clear once Ambassador Soval gets around to finishing off his next edition.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sumant Tambe				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8951</link>
		<dc:creator><![CDATA[Sumant Tambe]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 19:05:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8951</guid>
					<description><![CDATA[I get the point but I seriously doubt if it is an advantage. It is not much different from calling a named function. If the complex calculation has a name I would a create a function with that name and call it with the necessary parameters. It is more explicit, well-understood, reusable, and more portable. You could also use the ternery operator: const int i = (condition) ? complex_func(args) : some_default_value; With a lambda, you are saving creating a function and jumping to that part of the code. It is not modular, however. With a function, you can use that same logic in more places if you need to. I would not copy-paste the lambda. Any day, I would prefer to reduce the number braces I&#039;ve to keep track of. lambdas add braces and a sneaky pair of parenthesis at the end.]]></description>
		<content:encoded><![CDATA[<p>I get the point but I seriously doubt if it is an advantage. It is not much different from calling a named function. If the complex calculation has a name I would a create a function with that name and call it with the necessary parameters. It is more explicit, well-understood, reusable, and more portable. You could also use the ternery operator: const int i = (condition) ? complex_func(args) : some_default_value; With a lambda, you are saving creating a function and jumping to that part of the code. It is not modular, however. With a function, you can use that same logic in more places if you need to. I would not copy-paste the lambda. Any day, I would prefer to reduce the number braces I&#8217;ve to keep track of. lambdas add braces and a sneaky pair of parenthesis at the end.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mjklaim				</title>
				<link>https://herbsutter.com/2013/04/05/complex-initialization-for-a-const-variable/#comment-8950</link>
		<dc:creator><![CDATA[mjklaim]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 18:24:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1792#comment-8950</guid>
					<description><![CDATA[I&#039;ve used this idiom from the beginning and it is indeed powerful.
However, it&#039;s still verbose compared to the initial code, so I hope more terse notations (and automatic generalization) will get in the standard ASAP.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve used this idiom from the beginning and it is indeed powerful.<br />
However, it&#8217;s still verbose compared to the initial code, so I hope more terse notations (and automatic generalization) will get in the standard ASAP.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
