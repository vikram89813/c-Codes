<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Words of wisdom: Bjarne Stroustrup	</title>
	<atom:link href="https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: pjmlp				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8949</link>
		<dc:creator><![CDATA[pjmlp]]></dc:creator>
		<pubDate>Fri, 05 Apr 2013 18:18:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8949</guid>
					<description><![CDATA[@Jeremy.

Microsoft has such compilers for the Singularity project and now for Windows Phone 8 apps.

And Xamarin has it for Mono.

I think it is just a political issue inside Microsoft dev units not investing in such a compiler for the desktop.]]></description>
		<content:encoded><![CDATA[<p>@Jeremy.</p>
<p>Microsoft has such compilers for the Singularity project and now for Windows Phone 8 apps.</p>
<p>And Xamarin has it for Mono.</p>
<p>I think it is just a political issue inside Microsoft dev units not investing in such a compiler for the desktop.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jeremy				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8840</link>
		<dc:creator><![CDATA[Jeremy]]></dc:creator>
		<pubDate>Thu, 28 Mar 2013 20:47:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8840</guid>
					<description><![CDATA[Not sure why, continually, language and runtime keep getting confused. C# is a fantastic language, the .NET runtime is the slow part. If a native C# compiler were developed, C# could be just as good as C++. C++ only benefit is old (well tuned) compilers which generate native code.]]></description>
		<content:encoded><![CDATA[<p>Not sure why, continually, language and runtime keep getting confused. C# is a fantastic language, the .NET runtime is the slow part. If a native C# compiler were developed, C# could be just as good as C++. C++ only benefit is old (well tuned) compilers which generate native code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Joe Piccoli				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8792</link>
		<dc:creator><![CDATA[Joe Piccoli]]></dc:creator>
		<pubDate>Mon, 25 Mar 2013 03:27:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8792</guid>
					<description><![CDATA[I believe the statement &quot;being able to do something is not sufficient reason for doing it&quot; neatly encapsulates (pun intended) a great deal of the controversy associated with C++. More than most other languages, C++ is incredibly flexible in its allowing varations of its constructs and features (e.g., overloaded operator overloading). This is all well and good, but the question arises, is it necessary to use the most complicated construct when a simpler one would achieve the same purpose within the same restrictions (memory, performance, etc.)? I have seen a lot of C++ code which I believe is unnecessarily complicated because the writer was more interested in showing off their knowledge of the language&#039;s features than solving the problem at hand. It appears to me that for these people using the language has become an end itself, not a tool to accomplish a task. On a more pragmatic level, the use of complex constructs tends to increase maintenance costs in terms of modification effort, breakage risk, and required retesting. This is supported by the fact that in general the same code is read more often than written. 
Also, my experience has been that the further into the obscure feature realm you venture the less likely it is that different compilers will produce the same results.

I am not one of those who thinks C++ has too many features or should be simplified. I do believe, however, that in a production environment the simplest constructs that meet the required performance, modularity, and expandability goals should be used. I definitely agree that this is a difficult balance to strike and it requires much more analysis than I am able to provide :).]]></description>
		<content:encoded><![CDATA[<p>I believe the statement &#8220;being able to do something is not sufficient reason for doing it&#8221; neatly encapsulates (pun intended) a great deal of the controversy associated with C++. More than most other languages, C++ is incredibly flexible in its allowing varations of its constructs and features (e.g., overloaded operator overloading). This is all well and good, but the question arises, is it necessary to use the most complicated construct when a simpler one would achieve the same purpose within the same restrictions (memory, performance, etc.)? I have seen a lot of C++ code which I believe is unnecessarily complicated because the writer was more interested in showing off their knowledge of the language&#8217;s features than solving the problem at hand. It appears to me that for these people using the language has become an end itself, not a tool to accomplish a task. On a more pragmatic level, the use of complex constructs tends to increase maintenance costs in terms of modification effort, breakage risk, and required retesting. This is supported by the fact that in general the same code is read more often than written.<br />
Also, my experience has been that the further into the obscure feature realm you venture the less likely it is that different compilers will produce the same results.</p>
<p>I am not one of those who thinks C++ has too many features or should be simplified. I do believe, however, that in a production environment the simplest constructs that meet the required performance, modularity, and expandability goals should be used. I definitely agree that this is a difficult balance to strike and it requires much more analysis than I am able to provide :).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jesse Good				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8738</link>
		<dc:creator><![CDATA[Jesse Good]]></dc:creator>
		<pubDate>Tue, 19 Mar 2013 06:43:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8738</guid>
					<description><![CDATA[@Jack:

I really hope that was a joke linking Google&#039;s C++ style guide...]]></description>
		<content:encoded><![CDATA[<p>@Jack:</p>
<p>I really hope that was a joke linking Google&#8217;s C++ style guide&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Name Name				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8719</link>
		<dc:creator><![CDATA[Name Name]]></dc:creator>
		<pubDate>Mon, 18 Mar 2013 02:27:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8719</guid>
					<description><![CDATA[I think that concepts in combination with modules could open up a whole new style of programming, at least new to C++. So far, templates basically break the compilation model, that&#039;s a given. Concepts will do so as well, because even for concepts the compiler needs to know the &quot;real&quot; type. But in combination with modules what we could end up with is a way to write most of the code generic, because it doesn&#039;t have the bitter aftertaste of current generation templates. Therefore, one really could write against interfaces and not types - without losing performance. (Making everything virtual is often not a viable choice.) The question on how two express relations between two types, I think, is sadly still not completely solved, but with static if one could do fine here as well. :)]]></description>
		<content:encoded><![CDATA[<p>I think that concepts in combination with modules could open up a whole new style of programming, at least new to C++. So far, templates basically break the compilation model, that&#8217;s a given. Concepts will do so as well, because even for concepts the compiler needs to know the &#8220;real&#8221; type. But in combination with modules what we could end up with is a way to write most of the code generic, because it doesn&#8217;t have the bitter aftertaste of current generation templates. Therefore, one really could write against interfaces and not types &#8211; without losing performance. (Making everything virtual is often not a viable choice.) The question on how two express relations between two types, I think, is sadly still not completely solved, but with static if one could do fine here as well. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jack				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8718</link>
		<dc:creator><![CDATA[Jack]]></dc:creator>
		<pubDate>Sun, 17 Mar 2013 20:06:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8718</guid>
					<description><![CDATA[“C++: The Good Parts”:
http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml]]></description>
		<content:encoded><![CDATA[<p>“C++: The Good Parts”:<br />
<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" rel="nofollow">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jack				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8717</link>
		<dc:creator><![CDATA[Jack]]></dc:creator>
		<pubDate>Sun, 17 Mar 2013 19:58:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8717</guid>
					<description><![CDATA[quote: Scott Meyers (2005)
Q: Every language has its flaws. What are the three things you dislike most strongly in C++?
I&#039;d like to answer this question with &quot;complexity, complexity, complexity!&quot;, but naming the same thing three times is cheating. Still, I think that C++&#039;s greatest weakness is complexity. For almost every rule in C++, there are exceptions, and often there are exceptions to the exceptions. For example, const objects can&#039;t be modified, unless you cast away their constness, in which case they can, unless they were originally defined to be const, in which case the attempted modifications yield undefined behavior.

As another example, names in base classes are visible in derived classes, unless the base class is instantiated from a template, in which case they&#039;re not, unless the derived class has employed a using declaration for them, in which case they are.

Such complexity affects more than just people who write programs in C++. It also affects people who want to write tools that analyze C++ programs. One of the reasons why there is a relative dearth of tools such as refactoring browsers for C++ is that C++ is just so darned complicated.

A related aspect of C++ I dislike has to do with what I perceive to be an attitude on the part of the standardization committee that such complexity is not a problem. I suspect that many members of the committee would object to my characterizing their attitude that way, but I&#039;m talking only about my perception of their attitude. I know that the people on the committee work hard to make C++ as good as it can be. I also know that there are proposals before the committee whose goal is to simplify C++. Still, my impression is that the committee as a whole is unsympathetic to arguments that C++ has become too complex, and I find that frustrating.]]></description>
		<content:encoded><![CDATA[<p>quote: Scott Meyers (2005)<br />
Q: Every language has its flaws. What are the three things you dislike most strongly in C++?<br />
I&#8217;d like to answer this question with &#8220;complexity, complexity, complexity!&#8221;, but naming the same thing three times is cheating. Still, I think that C++&#8217;s greatest weakness is complexity. For almost every rule in C++, there are exceptions, and often there are exceptions to the exceptions. For example, const objects can&#8217;t be modified, unless you cast away their constness, in which case they can, unless they were originally defined to be const, in which case the attempted modifications yield undefined behavior.</p>
<p>As another example, names in base classes are visible in derived classes, unless the base class is instantiated from a template, in which case they&#8217;re not, unless the derived class has employed a using declaration for them, in which case they are.</p>
<p>Such complexity affects more than just people who write programs in C++. It also affects people who want to write tools that analyze C++ programs. One of the reasons why there is a relative dearth of tools such as refactoring browsers for C++ is that C++ is just so darned complicated.</p>
<p>A related aspect of C++ I dislike has to do with what I perceive to be an attitude on the part of the standardization committee that such complexity is not a problem. I suspect that many members of the committee would object to my characterizing their attitude that way, but I&#8217;m talking only about my perception of their attitude. I know that the people on the committee work hard to make C++ as good as it can be. I also know that there are proposals before the committee whose goal is to simplify C++. Still, my impression is that the committee as a whole is unsympathetic to arguments that C++ has become too complex, and I find that frustrating.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marc Espie				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8706</link>
		<dc:creator><![CDATA[Marc Espie]]></dc:creator>
		<pubDate>Fri, 15 Mar 2013 13:57:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8706</guid>
					<description><![CDATA[c++ 2011: take the new stuff, embrace it. Each time you find something that can replace C++98 idioms, use the new one, it&#039;s better.

The stuff left from C++98 to C++11 is just there for legacy: don&#039;t break the old code.

Forget about the old arrays, forget about char *, forget about explicit iterators. Pass by value, embrace the move semantics.

Clean, simple and fun]]></description>
		<content:encoded><![CDATA[<p>c++ 2011: take the new stuff, embrace it. Each time you find something that can replace C++98 idioms, use the new one, it&#8217;s better.</p>
<p>The stuff left from C++98 to C++11 is just there for legacy: don&#8217;t break the old code.</p>
<p>Forget about the old arrays, forget about char *, forget about explicit iterators. Pass by value, embrace the move semantics.</p>
<p>Clean, simple and fun</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ixache				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8704</link>
		<dc:creator><![CDATA[ixache]]></dc:creator>
		<pubDate>Fri, 15 Mar 2013 09:53:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8704</guid>
					<description><![CDATA[&#062; &#062; We’re long overdue for “C++: The Good Parts”.
&#062; Also from Bjarne Stroustrup: “Within C++, there is a much smaller and cleaner language struggling to get out”.

Also from Bjarne Stroustrup: &quot;Programming — Principles and Practice Using C++&quot;.]]></description>
		<content:encoded><![CDATA[<p>&gt; &gt; We’re long overdue for “C++: The Good Parts”.<br />
&gt; Also from Bjarne Stroustrup: “Within C++, there is a much smaller and cleaner language struggling to get out”.</p>
<p>Also from Bjarne Stroustrup: &#8220;Programming — Principles and Practice Using C++&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alan Braggins				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8703</link>
		<dc:creator><![CDATA[Alan Braggins]]></dc:creator>
		<pubDate>Fri, 15 Mar 2013 09:11:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8703</guid>
					<description><![CDATA[&#062; We’re long overdue for “C++: The Good Parts”.

Also from Bjarne Stroustrup: &quot;Within C++, there is a much smaller and cleaner language struggling to get out&quot;.]]></description>
		<content:encoded><![CDATA[<p>&gt; We’re long overdue for “C++: The Good Parts”.</p>
<p>Also from Bjarne Stroustrup: &#8220;Within C++, there is a much smaller and cleaner language struggling to get out&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian m				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8702</link>
		<dc:creator><![CDATA[Brian m]]></dc:creator>
		<pubDate>Fri, 15 Mar 2013 00:20:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8702</guid>
					<description><![CDATA[Tito - Absolutely correct! Barring auto and support for parallel the new c++ represents an even better environment for bad and complicated code and more long nights for the maintenance guys in the future. We really do need the best of C++ preferably as a standard such a c++ 11 g ( for good). This time keep the gurus off the panel just the people who have to clean up the mess to define the good bits. Locked in a room guess it would take less than a week before white smoke would be seen!]]></description>
		<content:encoded><![CDATA[<p>Tito &#8211; Absolutely correct! Barring auto and support for parallel the new c++ represents an even better environment for bad and complicated code and more long nights for the maintenance guys in the future. We really do need the best of C++ preferably as a standard such a c++ 11 g ( for good). This time keep the gurus off the panel just the people who have to clean up the mess to define the good bits. Locked in a room guess it would take less than a week before white smoke would be seen!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bcs				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8701</link>
		<dc:creator><![CDATA[bcs]]></dc:creator>
		<pubDate>Thu, 14 Mar 2013 23:46:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8701</guid>
					<description><![CDATA[“Something must be done. This is something. Therefore we must do it!”

a.k.a. the politician&#039;s fallacy]]></description>
		<content:encoded><![CDATA[<p>“Something must be done. This is something. Therefore we must do it!”</p>
<p>a.k.a. the politician&#8217;s fallacy</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tito				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8700</link>
		<dc:creator><![CDATA[Tito]]></dc:creator>
		<pubDate>Thu, 14 Mar 2013 20:23:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8700</guid>
					<description><![CDATA[Giving a programming language too many features and too much flexibility is how you end up with one of the best books for the language being named: &quot;Javacript: The Good Parts&quot;.

Crockford correctly espouses that much of JS should just not be used.  (Amusingly, he puts the ++ operator pretty high on the &quot;do not use&quot; list.)  However, if you do restrict yourself to &quot;the good parts&quot;, you can end up with a clean system using the langauge.

We&#039;re long overdue for &quot;C++: The Good Parts&quot;.]]></description>
		<content:encoded><![CDATA[<p>Giving a programming language too many features and too much flexibility is how you end up with one of the best books for the language being named: &#8220;Javacript: The Good Parts&#8221;.</p>
<p>Crockford correctly espouses that much of JS should just not be used.  (Amusingly, he puts the ++ operator pretty high on the &#8220;do not use&#8221; list.)  However, if you do restrict yourself to &#8220;the good parts&#8221;, you can end up with a clean system using the langauge.</p>
<p>We&#8217;re long overdue for &#8220;C++: The Good Parts&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alex Fabijanic				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8699</link>
		<dc:creator><![CDATA[Alex Fabijanic]]></dc:creator>
		<pubDate>Thu, 14 Mar 2013 17:32:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8699</guid>
					<description><![CDATA[&quot;being able to do every trick is not a feature but a bug&quot;

Very, very good point. Something similar occurred during recent standard proposal discussion; a concern was raised over a single class abstracting two back-end versions - very nice to have from interface abstraction/simplification standpoint but imposes significant space (4x) overhead for the smaller back-end; a real-world scenario of million objects not fitting into a CPU cache surfaced. That&#039;s a problem, for sure. However, is the culprit (a) the object size or (b) trying to put too many of them into a small space at the same time.

A real world example: housing for one million persons.
Solutions: A 100,000-story skyscraper? Mandate each person to dwell in 2 square feet? Build a city?]]></description>
		<content:encoded><![CDATA[<p>&#8220;being able to do every trick is not a feature but a bug&#8221;</p>
<p>Very, very good point. Something similar occurred during recent standard proposal discussion; a concern was raised over a single class abstracting two back-end versions &#8211; very nice to have from interface abstraction/simplification standpoint but imposes significant space (4x) overhead for the smaller back-end; a real-world scenario of million objects not fitting into a CPU cache surfaced. That&#8217;s a problem, for sure. However, is the culprit (a) the object size or (b) trying to put too many of them into a small space at the same time.</p>
<p>A real world example: housing for one million persons.<br />
Solutions: A 100,000-story skyscraper? Mandate each person to dwell in 2 square feet? Build a city?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom Kirby-Green				</title>
				<link>https://herbsutter.com/2013/03/14/words-of-wisdom-bjarne-stroustrup/#comment-8698</link>
		<dc:creator><![CDATA[Tom Kirby-Green]]></dc:creator>
		<pubDate>Thu, 14 Mar 2013 15:55:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1790#comment-8698</guid>
					<description><![CDATA[“Something must be done. This is something. Therefore we must do it!”

Ran into the same. Dev in question wanted to remove some legit new code because it was crashing. The new code *was* legit, the problem is in some outer frame and the new code just happens to smoke it out. There&#039;s no convincing some people.]]></description>
		<content:encoded><![CDATA[<p>“Something must be done. This is something. Therefore we must do it!”</p>
<p>Ran into the same. Dev in question wanted to remove some legit new code because it was crashing. The new code *was* legit, the problem is in some outer frame and the new code just happens to smoke it out. There&#8217;s no convincing some people.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
