<!doctype html>
<html amp lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no">
	
<!-- Jetpack Open Graph Tags -->
<meta property="og:type" content="article" />
<meta property="og:title" content="GotW #94 Solution: AAA Style (Almost Always Auto)" />
<meta property="og:url" content="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/" />
<meta property="og:description" content="Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using &#8220;AAA style&#8221;… where &#8220;triple-A&#8221; is both a mnemonic and an evaluation …" />
<meta property="article:published_time" content="2013-08-12T19:42:37+00:00" />
<meta property="article:modified_time" content="2014-12-30T17:27:42+00:00" />
<meta property="og:site_name" content="Sutter’s Mill" />
<meta property="og:image" content="https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=200&amp;ts=1542965363" />
<meta property="og:image:width" content="200" />
<meta property="og:image:height" content="200" />
<meta property="og:locale" content="en_US" />
<meta name="twitter:site" content="@wordpressdotcom" />
<meta name="twitter:text:title" content="GotW #94 Solution: AAA Style (Almost Always Auto)" />
<meta name="twitter:image" content="https://secure.gravatar.com/blavatar/4554b8d24c7f200dc5e2e1b18db1893f?s=240" />
<meta name="twitter:card" content="summary" />
<meta property="article:publisher" content="https://www.facebook.com/WordPresscom" />

<!-- End Jetpack Open Graph Tags -->
	<title>GotW #94 Solution: AAA Style (Almost Always Auto) &#8211; Sutter’s Mill</title>
		<link rel="canonical" href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/" />
	<script src="https://cdn.ampproject.org/v0.js" async></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather:400,400italic,700,700italic">	<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script type="application/ld+json">{"@context":"http:\/\/schema.org","@type":"BlogPosting","mainEntityOfPage":"https:\/\/herbsutter.com\/2013\/08\/12\/gotw-94-solution-aaa-style-almost-always-auto\/","publisher":{"@type":"Organization","name":"Sutter\u2019s Mill","logo":{"@type":"ImageObject","url":"https:\/\/secure.gravatar.com\/blavatar\/4554b8d24c7f200dc5e2e1b18db1893f?s=60&d=https%3A%2F%2Fs0.wp.com%2Fi%2Ffavicons%2Fapple-touch-icon-60x60.png","width":60,"height":60}},"headline":"GotW #94 Solution: AAA Style (Almost Always Auto)","datePublished":"2013-08-12T11:42:37+00:00","dateModified":"2014-12-30T09:27:42+00:00","author":{"@type":"Person","name":"Herb Sutter"},"image":{"@type":"ImageObject","url":"https:\/\/secure.gravatar.com\/blavatar\/4554b8d24c7f200dc5e2e1b18db1893f?s=200","width":200,"height":200}}</script>
	<meta name="generator" content="AMP Plugin v0.6.2" />	<style amp-custom>
		/* Generic WP styling */

.alignright {
	float: right;
}

.alignleft {
	float: left;
}

.aligncenter {
	display: block;
	margin-left: auto;
	margin-right: auto;
}

.amp-wp-enforced-sizes {
	/** Our sizes fallback is 100vw, and we have a padding on the container; the max-width here prevents the element from overflowing. **/
	max-width: 100%;
	margin: 0 auto;
}

.amp-wp-unknown-size img {
	/** Worst case scenario when we can't figure out dimensions for an image. **/
	/** Force the image into a box of fixed dimensions and use object-fit to scale. **/
	object-fit: contain;
}

/* Template Styles */

.amp-wp-content,
.amp-wp-title-bar div {
		margin: 0 auto;
	max-width: 500px;
	}

html {
	background: #0a89c0;
}

body {
	background: #fff;
	color: #353535;
	font-family: 'Merriweather', 'Times New Roman', Times, Serif;
	font-weight: 300;
	line-height: 1.75em;
}

p,
ol,
ul,
figure {
	margin: 0 0 1em;
	padding: 0;
}

a,
a:visited {
	color: #0a89c0;
}

a:hover,
a:active,
a:focus {
	color: #353535;
}

/* Quotes */

blockquote {
	color: #353535;
	background: rgba(127,127,127,.125);
	border-left: 2px solid #0a89c0;
	margin: 8px 0 24px 0;
	padding: 16px;
}

blockquote p:last-child {
	margin-bottom: 0;
}

/* UI Fonts */

.amp-wp-meta,
.amp-wp-header div,
.amp-wp-title,
.wp-caption-text,
.amp-wp-tax-category,
.amp-wp-tax-tag,
.amp-wp-comments-link,
.amp-wp-footer p,
.back-to-top {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen-Sans", "Ubuntu", "Cantarell", "Helvetica Neue", sans-serif;
}

/* Header */

.amp-wp-header {
	background-color: #0a89c0;
}

.amp-wp-header div {
	color: #fff;
	font-size: 1em;
	font-weight: 400;
	margin: 0 auto;
	max-width: calc(840px - 32px);
	padding: .875em 16px;
	position: relative;
}

.amp-wp-header a {
	color: #fff;
	text-decoration: none;
}

/* Site Icon */

.amp-wp-header .amp-wp-site-icon {
	/** site icon is 32px **/
	background-color: #fff;
	border: 1px solid #fff;
	border-radius: 50%;
	position: absolute;
	right: 18px;
	top: 10px;
}

/* Article */

.amp-wp-article {
	color: #353535;
	font-weight: 400;
	margin: 1.5em auto;
	max-width: 840px;
	overflow-wrap: break-word;
	word-wrap: break-word;
}

/* Article Header */

.amp-wp-article-header {
	align-items: center;
	align-content: stretch;
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	margin: 1.5em 16px 0;
}

.amp-wp-title {
	color: #353535;
	display: block;
	flex: 1 0 100%;
	font-weight: 900;
	margin: 0 0 .625em;
	width: 100%;
}

/* Article Meta */

.amp-wp-meta {
	color: #696969;
	display: inline-block;
	flex: 2 1 50%;
	font-size: .875em;
	line-height: 1.5em;
	margin: 0 0 1.5em;
	padding: 0;
}

.amp-wp-article-header .amp-wp-meta:last-of-type {
	text-align: right;
}

.amp-wp-article-header .amp-wp-meta:first-of-type {
	text-align: left;
}

.amp-wp-byline amp-img,
.amp-wp-byline .amp-wp-author {
	display: inline-block;
	vertical-align: middle;
}

.amp-wp-byline amp-img {
	border: 1px solid #0a89c0;
	border-radius: 50%;
	position: relative;
	margin-right: 6px;
}

.amp-wp-posted-on {
	text-align: right;
}

/* Featured image */

.amp-wp-article-featured-image {
	margin: 0 0 1em;
}
.amp-wp-article-featured-image amp-img {
	margin: 0 auto;
}
.amp-wp-article-featured-image.wp-caption .wp-caption-text {
	margin: 0 18px;
}

/* Article Content */

.amp-wp-article-content {
	margin: 0 16px;
}

.amp-wp-article-content ul,
.amp-wp-article-content ol {
	margin-left: 1em;
}

.amp-wp-article-content amp-img {
	margin: 0 auto;
}

.amp-wp-article-content amp-img.alignright {
	margin: 0 0 1em 16px;
}

.amp-wp-article-content amp-img.alignleft {
	margin: 0 16px 1em 0;
}

/* Captions */

.wp-caption {
	padding: 0;
}

.wp-caption.alignleft {
	margin-right: 16px;
}

.wp-caption.alignright {
	margin-left: 16px;
}

.wp-caption .wp-caption-text {
	border-bottom: 1px solid #c2c2c2;
	color: #696969;
	font-size: .875em;
	line-height: 1.5em;
	margin: 0;
	padding: .66em 10px .75em;
}

/* AMP Media */

amp-carousel {
	background: #c2c2c2;
	margin: 0 -16px 1.5em;
}
amp-iframe,
amp-youtube,
amp-instagram,
amp-vine {
	background: #c2c2c2;
	margin: 0 -16px 1.5em;
}

.amp-wp-article-content amp-carousel amp-img {
	border: none;
}

amp-carousel > amp-img > img {
	object-fit: contain;
}

.amp-wp-iframe-placeholder {
	background: #c2c2c2 url( https://s2.wp.com/wp-content/plugins/amp/assets/images/placeholder-icon.png ) no-repeat center 40%;
	background-size: 48px 48px;
	min-height: 48px;
}

/* Article Footer Meta */

.amp-wp-article-footer .amp-wp-meta {
	display: block;
}

.amp-wp-tax-category,
.amp-wp-tax-tag {
	color: #696969;
	font-size: .875em;
	line-height: 1.5em;
	margin: 1.5em 16px;
}

.amp-wp-comments-link {
	color: #696969;
	font-size: .875em;
	line-height: 1.5em;
	text-align: center;
	margin: 2.25em 0 1.5em;
}

.amp-wp-comments-link a {
	border-style: solid;
	border-color: #c2c2c2;
	border-width: 1px 1px 2px;
	border-radius: 4px;
	background-color: transparent;
	color: #0a89c0;
	cursor: pointer;
	display: block;
	font-size: 14px;
	font-weight: 600;
	line-height: 18px;
	margin: 0 auto;
	max-width: 200px;
	padding: 11px 16px;
	text-decoration: none;
	width: 50%;
	-webkit-transition: background-color 0.2s ease;
			transition: background-color 0.2s ease;
}

/* AMP Footer */

.amp-wp-footer {
	border-top: 1px solid #c2c2c2;
	margin: calc(1.5em - 1px) 0 0;
}

.amp-wp-footer div {
	margin: 0 auto;
	max-width: calc(840px - 32px);
	padding: 1.25em 16px 1.25em;
	position: relative;
}

.amp-wp-footer h2 {
	font-size: 1em;
	line-height: 1.375em;
	margin: 0 0 .5em;
}

.amp-wp-footer p {
	color: #696969;
	font-size: .8em;
	line-height: 1.5em;
	margin: 0 85px 0 0;
}

.amp-wp-footer a {
	text-decoration: none;
}

.back-to-top {
	bottom: 1.275em;
	font-size: .8em;
	font-weight: 600;
	line-height: 2em;
	position: absolute;
	right: 16px;
}
		/* Inline styles */
.amp-wp-inline-e118b89cb574341583297a20935ac54c{color:#2e74b5;}.amp-wp-inline-a6ec8840dd8107f0c4f9cbd7d00cece0{text-align:center;}.amp-wp-inline-19f7f3ed0686319173cc7809a4f48fce{background-color:yellow;}.amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34{margin-left:36pt;}.amp-wp-inline-67e1925c715f5c48af6b92757f5a6f7b{color:#5a5a5a;}	</style>
</head>

<body class="">

<header id="top" class="amp-wp-header">
	<div>
		<a href="https://herbsutter.com">
									<span class="amp-site-title">
				Sutter’s Mill			</span>
		</a>
	</div>
</header>

<article class="amp-wp-article">
	<header class="amp-wp-article-header">
		<h1 class="amp-wp-title">GotW #94 Solution: AAA Style (Almost Always Auto)</h1>
			<div class="amp-wp-meta amp-wp-byline">
					<amp-img src="https://secure.gravatar.com/avatar/c0ba56bfd231f8f04feb057728975181?s=24&#038;d=identicon&#038;r=g" width="24" height="24" layout="fixed"></amp-img>
				<span class="amp-wp-author author vcard">Herb Sutter</span>
	</div>
<div class="amp-wp-meta amp-wp-posted-on">
	<time datetime="2013-08-12T11:42:37+00:00">
		5 years ago	</time>
</div>
	</header>

	
	<div class="amp-wp-article-content">
		<p><span class="amp-wp-inline-67e1925c715f5c48af6b92757f5a6f7b"><em>Toward correct-by-default, efficient-by-default, and pitfall-free-by-default variable declarations, using “AAA style”… where “triple-A” is both a mnemonic and an evaluation of its value.<br/></em></span></p><h1>Problem</h1><h2>JG Questions</h2><p>1. What does this code do? What would be a good name for <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">some_function</span>?</p><pre><code>template&lt;class Container, class Value&gt;&#13;
void some_function( Container&amp; c, const Value&amp; v ) {&#13;
    if( find(begin(c), end(c), v) == end(c) )&#13;
        c.emplace_back(v); &#13;
    assert( !c.empty() );&#13;
}&#13;
</code></pre><p>2. What does “write code against interfaces, not implementations” mean, and why is it generally beneficial?</p><h2>Guru Questions</h2><p>3. What are some popular concerns about using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> to declare variables? Are they valid? Discuss.</p><p>4. When declaring a new local variable <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">x</span>, what advantages are there to declaring it using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> and one of the two following syntaxes:</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(a) <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = init;</span> when you don’t need to commit to a specific type? (Note: The expression <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">init</span> might include calling a helper that performs partial type adjustment, such as <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">as_signed</span>, while still not committing to a specific type.)</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(b) <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = type{ init };</span> when you do want to commit to a specific type by naming a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">type</span>?</p><p>List as many as you can. (Hint: Look back to GotW #93.)</p><p>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(a) Heap allocation syntax.</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(b) Literal suffixes, including user-defined literal operators.</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(c) Named lambda syntax.</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(d) Function declarations.</p><p class="amp-wp-inline-44436b9b5909e9f28a17bab55ba41d34">(e) Template alias declarations.</p><p>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</p><h1>Solution</h1><h2>1. What does this code do? What would be a good name for some_function?</h2><pre><code>template&lt;class Container, class Value&gt;&#13;
void <span class="amp-wp-inline-19f7f3ed0686319173cc7809a4f48fce">append_unique</span>( Container&amp; c, const Value&amp; v ) {&#13;
    if( find(begin(c), end(c), v) == end(c) )&#13;
        c.emplace_back(v); &#13;
    assert( !c.empty() );&#13;
}&#13;
</code></pre><p>Let’s call this function <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">append_unique</span>. First, it checks to see whether the value <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">v</span> is already in the container. If not, it appends it at the end. Finally, it asserts that <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">c</span> is not empty, since by now it must contain one copy of the value <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">v</span>.</p><p>You probably thought this question was fairly easy.</p><p>Maybe <em>too</em> easy.</p><p>If so, good. That’s the point of the example. Hold the thought, and we’ll come back to this in Question 3.</p><h2>2. What does “write code against interfaces, not implementations” mean, and why is it generally beneficial?</h2><p>It means we should care principally about “what,” not “how.” This separation of concerns applies at all levels in high-quality modern software—hiding <em>code</em>, hiding <em>data</em>, and hiding <em>type</em>. Each increases encapsulation and reduces coupling, which are essential for large-scale and robust software.</p><p>Please indulge a little repetition in the following paragraphs. It’s there to make a point about similarity.</p><p><strong>Hiding code.</strong> With the invention of separately compiled functions and structured programming, we gained “encapsulation to <em>hide code.</em>” The caller knows the signature only—the function’s internal code is not his concern and not accessible programmatically, even if the function is <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">inline</span> and the body happens to be visible in source code. We try hard not to inadvertently leak implementation details, such as internal data structure types. The point is that the caller does not, and should not, commit to knowledge of the current internal code; if he did, it would create interdependencies and make separately compiled libraries impossible.</p><p><strong>Hiding data (and code).</strong> With object oriented styles (OO), we gained two new manifestations of this separation. First, we got “more encapsulation to <em>hide both code and data.</em>” The caller knows the class name, bases, and member function signatures only—the class’s internal data and internal code are hidden and not accessible programmatically, even though the <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">private</span> class members are lexically visible in the class definition and <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">inline</span> function bodies may also be visible. (In turn, dynamic libraries and the potential future-C++ modules work aim to accomplish the same thing at a still larger scale.) Again we try hard not to inadvertently leak implementation details, and again the point is that the caller does not, and should not, commit to knowledge of the current internal data or code, which would make the class difficult to ever change or to ship on its own as a library.</p><p><strong>Hiding type (run-time polymorphism).</strong> Second, OO also gave us “separation of interfaces to <em>hide type.</em>” A base class or interface can delegate work to a concrete derived implementation via virtual functions. Now the interface the caller sees and the implementation are actually different types, and the caller knows the base type only—he doesn’t know or care about the concrete type, including even its size. The point, once again, is that the caller does not, and should not, commit to a single concrete type, which would make the caller’s code less general and less able to be reused with new types.</p><p><strong>Hiding type (compile-time polymorphism).</strong> With templates, we gained a new compile-time form of this separation—and it’s still “separation of interfaces to <em>hide type</em>.” The caller knows an ad-hoc “duck typed” set of operations he wants to perform using a type, and any type that supports those operations will do just fine. The contemplated future C++ concepts feature will allow making this stricter and less ad-hoc, but still avoids committing to a concrete type at all. The whole point is still is that the caller does not, and should not, commit to a single concrete type, which would make the caller’s code less generic and less able to be reused with new types.</p><h2>3. What are some popular concerns about using auto to declare variables? Are they valid? Discuss.</h2><p>In many languages, not just C++, there are several reasons people commonly give for why they are reluctant to use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> to declare variables (or the equivalent in another language, such as <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">var</span> or <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">let</span>). We could summarize them as: <em>laziness</em>, <em>commitment</em>, and <em>readability</em>. Let’s take them in order.</p><h3>Laziness and commitment</h3><p>First, laziness: One common concern is that “writing <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> to declare a variable is primarily about saving typing.” However, this is just a misunderstanding of <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>. As we saw in GotW #92 and #93 and will see again below, the main reasons to declare variables using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> are for correctness, performance, maintainability, and robustness—and, yes, convenience, but that’s in last place on the list.</p><blockquote><p><strong>Guideline:</strong> Remember that preferring <strong>auto</strong> variables is motivated primarily by correctness, performance, maintainability, and robustness—and only lastly about typing convenience.</p></blockquote><p>Second, commitment: “But in some cases I do want to commit to a specific type, not automatically deduce it, so I can’t use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>.” It’s true that sometimes you do want to commit to a specific type, but you can still use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>. As demonstrated in GotW #92 and #93, not only can you still write declarations of the form <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = type{ init };</span> (instead of <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">type x{init};</span>) to commit to a specific type, but there are good reasons for doing so, such as that saying <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> means you can’t possibly forget to initialize the variable.</p><blockquote><p><strong>Guideline:</strong> Consider declaring local variables <strong>auto x = type{ expr };</strong> when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, it guarantees the variable will be initialized, and it won’t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use <strong>( )</strong> instead of <strong>{ }</strong>.</p></blockquote><h3>(Un)readability?</h3><p>The third and most common argument concerns readability: “My code gets unreadable quickly when I don’t know what exact type my variable is without hunting around to see what that function or expression returns, so I can’t just use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> all the time.” There is truth to this, including losing the ability to search for occurrences of specific types when using the non-typed syntax <em>auto x = expr;</em> in 4(a) below, so this appears at first to be a strong argument. And it’s true that any feature can be overused. However, I think this argument is actually weaker than it first seems for four reasons, two minor and two major.</p><p>The two minor counterarguments are:</p><ul><li>The “can’t use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>” part isn’t actually true, because as we just saw above you can be explicit about your type and still use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>, with good benefit.</li>
<li>The argument doesn’t apply when you’re using an IDE, because you can always tell the exact type, for example by hovering over the variable. Granted, this mitigation goes away when you leave the IDE, such as if you print the code.</li>
</ul><p>But we should focus on the two major counterarguments:</p><ul><li>It reflects a bias to code against implementations, not interfaces. Overcommitting to explicit types makes code less generic and more interdependent, and therefore more brittle and limited. It runs counter to the excellent reasons to “write code against interfaces, not implementations” we saw in Question 2.</li>
<li><strong>We (meaning <em>you</em>) already ignore actual types all the time…<br/></strong></li>
</ul><p>“… Wait, what? I do not ignore types all the time,” someone might say. Actually, not only do you do it, but you’re so comfortable and cavalier about it that you may not even realize you’re doing it. Let’s go back to that code in Question 1:</p><pre><code>template&lt;class Container, class Value&gt;&#13;
void append_unique( Container&amp; c, const Value&amp; v ) {&#13;
    if( find(begin(c), end(c), v) == end(c) )&#13;
        c.emplace_back(v); &#13;
    assert( !c.empty() );&#13;
}&#13;
</code></pre><p><em>Quick quiz:</em> How many specific types are mentioned in that function? Name as many as you can.</p><p>Take a moment to consider that before reading on…</p><p>… We can see pretty quickly that the answer is a nice round number: Zero. Zilch. (Pedantic mode: Yes, there’s <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">void</span>, but I’m going to declare that <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">void</span> doesn’t count because it’s to denote “no type,” it’s not a meaningful type.)</p><p>Not a single specific type appears anywhere in this code, and the lack of exact types makes it much more powerful and doesn’t significantly harm its readability. Like most people, you probably thought Question 1 felt “easy” when we did it in isolation. Granted, this is generic code, and not all your code will be templates—but the point is that the code isn’t unreadable even though it doesn’t mention specific types, and in fact auto gives you the ability to write generic code even when <em>not</em> writing a template.</p><p>So starting with the cases illustrated in this short example, let’s consider some places where we routinely ignore exact types. First, function template parameters:</p><ul><li>What exact type is <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">Container</span>? We have no idea, and that’s great… anything we can call <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">begin</span>, <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">end</span>, <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">emplace_back</span> and <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">empty</span> on and otherwise use as needed by this code will do just fine. In fact, we’re glad we don’t know anything about the exact type, because it means we’re following the Open/Closed Principle and staying open for extension— this <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">append_unique</span> will work fine with a type that won’t be written until years from now. Interestingly, the concepts feature currently being proposed for ISO C++ to express template parameter constraints doesn’t change how this works at all, it only makes it more convenient to express and check the requirements. Note how much more powerful this is compared to OO style frameworks: In OO frameworks where containers have to inherit from a base class or interface, that’s already inducing coupling and limiting the ability to just plug in and use arbitrary suitable types. It is important that we can know nothing at all about the type here besides its necessary interface, not even restricting it by as much as limiting it to types in a particular inheritance hierarchy. We should strongly resist compromising this wonderful and powerful “strictly typed but loosely coupled” genericity.</li>
<li>What exact type is <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">Value</span>? Again, we don’t know, and we don’t want to know… anything we can pass to <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">find</span> and <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">emplace_back</span> is just dandy. At this point some of you may be thinking: “Oh yes we know what type it is, it’s the container’s value type!” No, it doesn’t have to be that, it just has to be convertible, and that’s important. For example, we want <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">vector&lt;string&gt; vec; append_unique(vec, “xyzzy”);</span> to work, and <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">“xyzzy”</span> is a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">const char[6]</span>, not a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">string</span>.</li>
</ul><p>Second, function return values:</p><ul><li>What type does <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">find</span> return? Some iterator type, the same as <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">begin(c)</span> coughed up, but we don’t know specifically what type it is just from reading this code, and it doesn’t matter. We can look up the signature if we’re feeling really curious, but nobody bothers doing that because anything that’s comparable to <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">end(c)</span> will do.</li>
<li>What type does <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">empty</span> return? We don’t even think twice about it. Something testable like a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">bool</span>… we don’t care much what exactly as long as we can “not” it.</li>
</ul><p>Third, many function parameters:</p><ul><li>What specific type does <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">emplace_back</span> take? Don’t know; might be the same as <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">v</span>, might not. Really don’t care. Can we pass <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">v</span> to it? Yes? Groovy.</li>
</ul><p>And that’s just in this example. We routinely and desirably ignore types in many other places, such as:</p><ul><li>Fourth, any temporary object: We never get to name the object, much less name its type, and we may know what the type is but we don’t care about actually spelling out either name in our code.</li>
<li>Fifth, any use of a base class: We don’t know the dynamic concrete type we’re actually using, and that’s a benefit, not a bug.</li>
<li>Sixth, any call to a virtual function: Ditto; plus on top of that if the virtual function return type itself could also be covariant for another layer of “we don’t know the dynamic concrete type” since in the presence of covariance we don’t know what type we’re actually getting back.</li>
<li>Seventh, any use of <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">function&lt;&gt;</span>, <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">bind</span>, or other type erasure: Just think about how little we actually know, and how happy it makes us. For example, given a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">function&lt;int(string)&gt;</span>, not only don’t we know what specific function or object it’s bound to, we don’t even know that thing’s signature—it might not actually even take a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">string</span> or return an <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">int</span>, because conversions are allowed in both directions, so it only has to take something a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">string</span> can be converted to, and return something that can be converted to an <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">int</span>. All we know is that it’s something that we can invoke with a <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">string</span> and that gives us back something we can use as an <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">int</span>. Ignorance is bliss.</li>
<li>Eighth, Any use of a C++14 generic lambda function: A generic lambda just means the function call operator is a template, after all, and like any function template it gets stamped out individually for whatever actual argument types you pass each time you use it.</li>
</ul><p>There are probably more.</p><p>Although lack of commitment may be a bad thing in other areas of life, not committing to a specific type is often desirable by default in reusable code.</p><h2>4. When declaring a new local variable x, what advantages are there to declaring it using auto and one of the two following syntaxes:</h2><p>Let’s consider the base case first, which has by far the strongest arguments in its favor and is gaining quite a bit of traction in the C++ community.</p><h3>(a) auto x = init; when you don’t need to commit to a specific type?</h3><p>GotW #93 offered many concrete examples to support habitually declaring local variables using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = expr;</span> when you don’t need to explicitly commit to a type. The advantages include:</p><ul><li>It guarantees the variable will be initialized. Uninitialized variables are impossible because once you start by saying <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> the <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">=</span> is required and cannot be forgotten.</li>
<li>It is efficient by default and guarantees that no implicit conversions (including narrowing conversions), temporary objects, or wrapper indirections will occur. In particular, prefer using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> instead of <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">function&lt;&gt;</span> to name lambdas unless you need the type erasure and indirection.</li>
<li>It guarantees that you will use the correct exact type now.</li>
<li>It guarantees that you will continue to use the correct exact type under maintenance as the code changes, and the variable’s type automatically tracks other functions’ and expressions’ types unless you explicitly said otherwise.</li>
<li>It is the simplest way to portably spell the implementation-specific type of arithmetic operations on built-in types, which vary by platform, and ensure that you cannot accidentally get lossy narrowing conversions when storing the result.</li>
<li>It is the only good option for hard-to-spell and impossible-to-spell types such as lambdas, binders, <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">detail::</span> helpers, and template helpers (including expression templates when they should stay unevaluated for performance), short of resorting to repetitive <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">decltype</span> expressions or more-expensive indirections like <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">function&lt;&gt;</span>.</li>
<li>It is more symmetric and consistent with other parts of modern C++ (see Question 5).</li>
<li>And yes, it is just generally simpler and less typing.</li>
</ul><p>See GotW #93 for concrete examples of these cases, where using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> helps eliminate correctness bugs, performance bugs, and silently nonportable code.</p><p>As noted in the questions, the expression <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">init</span> might include calling a helper that performs partial type adjustment, such as <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">as_signed</span>, while still not committing to a specific type. As shown in GotW #93, prefer to use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = as_signed(integer_expr);</span> or <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = as_unsigned(integer_expr);</span> to store the result of an integer computation that should be signed or unsigned—these should be viewed as “casts that preserve width,” so we are not casting to a specific type but rather casting an attribute of the type while correctly preserving the other basic characteristics of the type, notably by not forcing it to commit to a particular size.</p><p>Using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> together with <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">as_signed</span> or <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">as_unsigned</span> makes code more portable: the variable will both be large enough (thanks to <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>) and preserve the required signedness on all platforms. Note that signed/unsigned conversions within <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">integer_expr</span> may still occur and so you may need additional finer-grained <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">as_signed</span>/<span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">as_unsigned</span> casts within the expression for full portability.</p><h3>(b) auto x = type{ init }; when you do want to commit to a specific type by naming a type?</h3><p>This is the explicitly typed form, and it still has advantages but they are not as clearly strong as implicitly typed form. The jury is still out on whether to recommend this one wholesale, as we’re still trying it out, but it does offer some advantages and I suggest you try it out for a while and see if it works well for you.</p><p>So here’s the recommendation to consider trying out for yourself: Consider declaring local variables <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = type{ expr };</span> when you do want to explicitly commit to a type. (Only when you do want to allow explicit narrowing, use <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">( )</span> instead of <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">{ }</span>.) The advantages of this typed <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> declaration style include:</p><ul><li>It guarantees the variable will be initialized; you can’t forget.</li>
<li>It is self-documenting to show that the code is explicitly requesting a conversion.</li>
<li>It won’t allow an accidental implicit narrowing conversion.</li>
<li>It is more symmetric and consistent, both with the basic <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = init;</span> form and with other parts of C++…</li>
</ul><p>… which brings us to Question 5.</p><h2>5. Explain how using the style suggested in #4 is consistent with, or actively leverages, the following other C++ features:</h2><p>Let’s start off this question with some side-by-side examples that give us a taste of the symmetry we gain when we habitually declare variables using modern <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> style. Starting with two examples where we don’t need to commit to a type and then two where we do, we see that the right-hand style is not only more robust and maintainable for the reasons already given, but also arguably cleaner and more regular with the type consistently on the right when it is mentioned:</p><pre><code>// Classic C++ declaration order     // Modern C++ style&#13;
&#13;
const char* s = "Hello";             <strong>auto</strong> s = "Hello";&#13;
widget w = get_widget();             <strong>auto</strong> w = get_widget();&#13;
&#13;
employee e{ empid };                 <strong>auto</strong> e = <strong>employee</strong>{ empid };&#13;
widget w{ 12, 34 };                  <strong>auto</strong> w = <strong>widget</strong>{ 12, 34 };&#13;
</code></pre><p>Now consider the (dare we say elegant) symmetry with each of the following.</p><h3>(a) Heap allocation syntax.</h3><p>When allocating heap variables, did you notice that the type name is already on the right naturally anyway? And since it’s there, we don’t want to have to repeat it. (I’ll show the raw “<span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">new</span>” form for completeness, but prefer <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">make_unique</span> and <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">make_shared</span> in that order for allocation in modern code, resorting to raw <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">new</span> only well-encapsulated inside the implementation of low-level data structures.)</p><pre><code>// Classic C++ declaration order     // Modern C++ style&#13;
&#13;
widget* w = new widget{};            /* <strong>auto</strong> w = new <strong>widget</strong>{}; */&#13;
unique_ptr&lt;widget&gt; w                 <strong>auto</strong> w = make_unique&lt;<strong>widget</strong>&gt;();&#13;
  = make_unique&lt;widget&gt;();&#13;
</code></pre><h3>(b) Literal suffixes, including user-defined literal operators.</h3><p>Using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> declaration style doesn’t merely work naturally with built-in literal suffixes like <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">ul</span> for <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">unsigned long</span>, plus user-defined literals including standard ones now in draft C++14, but it actively encourages using them:</p><pre><code>// Classic C++ declaration order     // Modern C++ style&#13;
&#13;
int x = 42;                          <strong>auto</strong> x = 42;&#13;
float x = 42.;                       <strong>auto</strong> x = 42.<strong>f</strong>;&#13;
unsigned long x = 42;                <strong>auto</strong> x = 42<strong>ul</strong>;&#13;
std::string x = "42";                <strong>auto</strong> x = "42"<strong>s</strong>;   // C++14&#13;
chrono::nanoseconds x{ 42 };         <strong>auto</strong> x = 42<strong>ns</strong>;    // C++14&#13;
</code></pre><p>Based on the examples so far, which do you think is more regular? But wait, there’s more…</p><h3>(c) Named lambda syntax.<br/>
(d) Function declarations.</h3><p>Lambdas have unutterable types, and <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> is the best way to capture them exactly and efficiently. But because their declarations are now so similar, let’s consider lambdas and (other) functions together, and in the last two lines of this example also use C++14 return type deduction:</p><pre><code>// Classic C++ declaration order     // Modern C++ style&#13;
&#13;
int f( double );                     <strong>auto</strong> f <strong>(double) -&gt; int</strong>;&#13;
…                                    <strong>auto</strong> f <strong>(double)</strong> { /*...*/ };&#13;
…                                    <strong>auto</strong> f = [=]<strong>(double)</strong> { /*...*/ };&#13;
</code></pre><h3>(e) Template alias declarations.</h3><p>Modern C++ frees us from the tyranny of un-template-able <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">typedef</span>:</p><pre><code>// Classic C++ workaround            // Modern C++ style&#13;
&#13;
typedef set&lt;string&gt; dict;            <strong>using</strong> dict = <strong>set&lt;string&gt;</strong>;&#13;
&#13;
template&lt;class T&gt; struct myvec {     template&lt;class T&gt;&#13;
  typedef vector&lt;T,myalloc&gt; type;    <strong>using</strong> myvec = <strong>vector&lt;T,myalloc&gt;</strong>;&#13;
};&#13;
</code></pre><h3>An observation</h3><p>Have you noticed that the C++ world is moving to a left-to-right declaration style everywhere, of the form</p><p class="amp-wp-inline-a6ec8840dd8107f0c4f9cbd7d00cece0"><strong>category</strong> name = <strong>type</strong> and/or initializer ;</p><p>where “category” can be <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> or <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">using</span>?</p><p>Take a moment to re-skim the two columns of examples above. Even ignoring correctness and performance advantages, do you find the right-hand column to be most consistent, and most readable?</p><h2>6. Are there any cases where it is not possible to use the style in #4 to declare all local variables?</h2><p>There is one case I know of where this style cannot be followed, and it applies to the type-specific <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = type{ init };</span> form. In that form, <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">type</span> has to be moveable (even though the move operation will be routinely elided by compilers), so these won’t work:</p><pre><code>auto lock <strong>=</strong> lock_guard&lt;mutex&gt;{ m };  // error, not moveable&#13;
auto ai   <strong>=</strong> atomic&lt;int&gt;{};           // error, not moveable&#13;
</code></pre><p>(Aside: For at least some of these cases, an argument could be made that this is actually more of a defect in the type itself, in particular that perhaps <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">atomic&lt;int&gt;</span> should be moveable.)</p><p>Having said that, there are three other cases I know of that you might encounter that may at first look like they don’t work with this <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> style, but actually do. Let’s consider those for completeness.</p><p>First, the basic form <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = init;</span> will exactly capture an <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">initializer_list</span> or a proxy type, such as an expression template. This is a feature, not a bug, because you have a convenient way to spell both “capture the list or proxy” and “resolve the computation” depending which you mean, and the default syntax goes to the more efficient one: If you want to efficiently capture the list or proxy, use the basic form which gives you performance by default, and if you mean to force the proxy to resolve the computation, specify the explicit type to ask for the conversion you want. For example:</p><pre><code>auto i1 = { 1 };                       // initializer_list&lt;int&gt;&#13;
auto i2 = 1;                           // int&#13;
&#13;
auto a = matrix{...}, b = matrix{...}; // some type that does lazy eval&#13;
auto ab = a * b;                       // to capture the lazy-eval proxy&#13;
auto c = matrix{ a * b };              // to force computation&#13;
&#13;
</code></pre><p>Second, here is a rare case that you may discover now that we have <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>: Due to the mechanics of the C++ grammar, you can’t legally write a multi-word type like <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">long long</span> or <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">class widget</span> in the place where <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">type</span> goes in the <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto x = type{ init };</span> form. However, note that this affects only those two cases:</p><ul><li>The multi-word built-in types like <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">long long</span>, where you’re better off anyway writing a known-width type alias or using a literal.</li>
<li>Elaborated type specifiers like <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">class widget</span>, where the “<span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">class</span>” part is already redundant. The “<span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">class widget</span>” syntax is allowed as a compatibility holdover from C which liked seeing <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">struct widget</span> everywhere unless you <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">typedef</span>‘d the <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">struct</span> part away.</li>
</ul><p>So just avoid the multi-word form and use the better alternative instead:</p><pre><code>auto x = long long{ 42 };            // error&#13;
auto x = int64_t{ 42 };              // ok, better &#13;
auto x = 42LL;                       // ok, better &#13;
&#13;
auto y = class X{1,2,3};             // error&#13;
auto y = X{1,2,3};                   // ok&#13;
</code></pre><h2>Summary</h2><p>We already ignore explicit and exact types much of the time, including with temporary objects, virtual functions, templates, and more. This is a feature, not a bug, because it makes our code less tightly coupled, and more generic, flexible, reusable, and future-proof.</p><p>Declaring variables using <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span>, whether or not we want to commit to a type, offers advantages for correctness, performance, maintainability, and robustness, as well as typing convenience. Furthermore, it is an example of how the C++ world is moving to a left-to-right declaration style everywhere, of the form</p><p class="amp-wp-inline-a6ec8840dd8107f0c4f9cbd7d00cece0"><strong>category</strong> name = <strong>type</strong> and/or initializer ;</p><p>where “category” can be <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">auto</span> or <span class="amp-wp-inline-e118b89cb574341583297a20935ac54c">using</span>, and we can get not only correctness and performance but also consistency benefits by using the style to consistently declare local variables (including using literals and user-defined literals), function declarations, named lambdas, aliases, template aliases, and more.</p><h2>Acknowledgments</h2><p>Thanks in particular to Scott Meyers and Andrei Alexandrescu for their time and insights in reviewing and discussing drafts of this material. Both helped generate candidate names for this idiom; it was Alexandrescu who suggested the name “AAA (almost always auto)” which I merged with the best names I’d thought of to that point (“auto style” or “auto (+type) style”) to get “AAA Style (almost always auto).” Thanks also to the following for their feedback to improve this article: Adrian, avjewe, mttpd, ned, zadecn, noniussenior, Marcel Wid, J Guy Davidson, Mark Garcia, Jonathan Wakely, “x y.”</p>	</div>

	<footer class="amp-wp-article-footer">
			<div class="amp-wp-meta amp-wp-tax-category">
		Categories: <a href="https://herbsutter.com/category/c/gotw/" rel="category tag">GotW</a>	</div>

		<div class="amp-wp-meta amp-wp-comments-link">
		<a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comments">
			View Comments		</a>
	</div>
	</footer>
</article>

<footer class="amp-wp-footer">
	<div>
		<h2>Sutter’s Mill</h2>
		<p>
			<a href="https://wordpress.com/?ref=footer_blog">Blog at WordPress.com.</a>
		</p>
		<a href="#top" class="back-to-top">Back to top</a>
	</div>
</footer>


	<amp-pixel src="https://pixel.wp.com/b.gif?rand=RANDOM&#038;host=herbsutter.com&#038;ref=DOCUMENT_REFERRER&#038;amp=1&#038;blog=3379246&#038;v=wpcom&#038;tz=-8&#038;user_id=0&#038;post=2230&#038;subd=herbsutter"></amp-pixel>
	<amp-pixel src="https://pixel.wp.com/b.gif?rand=RANDOM&#038;v=wpcom-no-pv&#038;crypt=UE40eW5QN0p8M2Y%2FRE1TaVhzUzFMbjdWNHpwZGhTayxPSUFCMGNrd29%2BSmw0TDhnZmRTK0hlRi9QSGh6bi9GXVhBJWIlZlR5U1JMLU8%2FMkNtblkvY1d1TjBELytHc0k%2FMXdHUVQyK2IyUVA5SjU1bj9VX3ExLHYsREFpcnlfNHYtXV1HSUIsLkJrcnp0eS5sLjdbUGtpJkIyNlYtRjRmfHo2NVIvMjldVjlQUCV6JWwsXUlyR3VFTVRNZ1lLT1VKdkg%2FOVg5cmg4NFFmaF10ZlZVST0mWWpTeEJXOSxoVUI5L2xzMmZkW0M5fkklLU82VU1HRw%3D%3D"></amp-pixel>
	
</body>
</html>
