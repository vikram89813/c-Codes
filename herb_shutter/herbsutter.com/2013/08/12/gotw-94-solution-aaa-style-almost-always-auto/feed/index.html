<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #94 Solution: AAA Style (Almost Always Auto)	</title>
	<atom:link href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Auto and copy elision &#124; 我爱源码网				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-36460</link>
		<dc:creator><![CDATA[Auto and copy elision &#124; 我爱源码网]]></dc:creator>
		<pubDate>Wed, 25 Feb 2015 02:49:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-36460</guid>
					<description><![CDATA[[&#8230;] What exactly are the rules for copy elision when one is using auto and commits to a specific type ? (see: GotW - Almost always auto). [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] What exactly are the rules for copy elision when one is using auto and commits to a specific type ? (see: GotW &#8211; Almost always auto). [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: thila				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-35596</link>
		<dc:creator><![CDATA[thila]]></dc:creator>
		<pubDate>Sat, 17 Jan 2015 19:03:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-35596</guid>
					<description><![CDATA[@herb: Perhaps this may be irrelevant here (Sorry!), I couldn&#039;t find any other relevant place to comment on this. When will the GotWs 8 - 88 be available? I read this article series with in the past few days and learned a lot about C++ !! Hope the other GotWs will be available soon. Thanks for your great work.]]></description>
		<content:encoded><![CDATA[<p>@herb: Perhaps this may be irrelevant here (Sorry!), I couldn&#8217;t find any other relevant place to comment on this. When will the GotWs 8 &#8211; 88 be available? I read this article series with in the past few days and learned a lot about C++ !! Hope the other GotWs will be available soon. Thanks for your great work.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Answer: How to implement classic sorting algorithms in modern C++? #fix #development #computers &#124; IT Info				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-35151</link>
		<dc:creator><![CDATA[Answer: How to implement classic sorting algorithms in modern C++? #fix #development #computers &#124; IT Info]]></dc:creator>
		<pubDate>Sat, 10 Jan 2015 11:44:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-35151</guid>
					<description><![CDATA[[&#8230;] Sutter&#8217;s &#8220;Almost Always Auto&#8221; and Scott Meyers&#8217;s &#8220;Prefer auto to specific type declarations&#8221; recommendation, [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter&#8217;s &#8220;Almost Always Auto&#8221; and Scott Meyers&#8217;s &#8220;Prefer auto to specific type declarations&#8221; recommendation, [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fixed: How to implement classic sorting algorithms in modern C++? #development #dev #programming &#124; Good Answer				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-34557</link>
		<dc:creator><![CDATA[Fixed: How to implement classic sorting algorithms in modern C++? #development #dev #programming &#124; Good Answer]]></dc:creator>
		<pubDate>Wed, 31 Dec 2014 03:12:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-34557</guid>
					<description><![CDATA[[&#8230;] Sutter&#8217;s &#8220;Almost Always Auto&#8221; and Scott Meyers&#8217;s &#8220;Prefer auto to specific type declarations&#8221; recommendation, [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter&#8217;s &#8220;Almost Always Auto&#8221; and Scott Meyers&#8217;s &#8220;Prefer auto to specific type declarations&#8221; recommendation, [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-34543</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 30 Dec 2014 17:29:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-34543</guid>
					<description><![CDATA[@x y: I think I had in mind that the auto version deduced an array, which it doesn&#039;t. If I had something else in mind, I&#039;ve forgotten it now, so I&#039;ve removed that phrase and added your moniker to the Acknowledgments. Thanks for the feedback!]]></description>
		<content:encoded><![CDATA[<p>@x y: I think I had in mind that the auto version deduced an array, which it doesn&#8217;t. If I had something else in mind, I&#8217;ve forgotten it now, so I&#8217;ve removed that phrase and added your moniker to the Acknowledgments. Thanks for the feedback!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: x y				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-34469</link>
		<dc:creator><![CDATA[x y]]></dc:creator>
		<pubDate>Mon, 29 Dec 2014 09:59:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-34469</guid>
					<description><![CDATA[What do you think is the &quot;subtle difference in the type of s, where the auto style is more correct&quot;? See https://stackoverflow.com/q/27550539]]></description>
		<content:encoded><![CDATA[<p>What do you think is the &#8220;subtle difference in the type of s, where the auto style is more correct&#8221;? See <a href="https://stackoverflow.com/q/27550539" rel="nofollow">https://stackoverflow.com/q/27550539</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: How to: How to implement classic sorting algorithms in modern C++? &#124; SevenNet				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-33404</link>
		<dc:creator><![CDATA[How to: How to implement classic sorting algorithms in modern C++? &#124; SevenNet]]></dc:creator>
		<pubDate>Mon, 08 Dec 2014 10:00:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-33404</guid>
					<description><![CDATA[[&#8230;] Sutter&#8217;s &#8220;Almost Always Auto&#8221; and Scott Meyers&#8217;s &#8220;Prefer auto to specific type declarations&#8221; recommendation, [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter&#8217;s &#8220;Almost Always Auto&#8221; and Scott Meyers&#8217;s &#8220;Prefer auto to specific type declarations&#8221; recommendation, [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Krzysztof Czaiński				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-31601</link>
		<dc:creator><![CDATA[Krzysztof Czaiński]]></dc:creator>
		<pubDate>Sun, 09 Nov 2014 07:01:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-31601</guid>
					<description><![CDATA[I am referring to this:
[code][/code]
auto a = matrix{...}, b = matrix{...}; // some type that does lazy eval
auto ab = a * b;                       // to capture the lazy-eval proxy
auto c = matrix{ a * b };              // to force computation
[code][/code]
I am surprised, that nobody pointed out, that the third line is a *hidden* static_cast. Consider:
[code][/code]
auto a = matrix{...};
auto x = 3;
auto da = a.size();
auto c = matrix{ x * da }; // oops, ment { x * a }
[code][/code]
In this example, the code will compile, assuming matrix has an explicit constructor matrix(size_t). In contrast, the following uses only implicit casting, so the error will be caught by the compiler.
[code][/code]
matrix c = x * da;
[code][/code]
I think it is good practice to use the weakest cast that is suitable. Using auto in this example not only conflicts with this, but also hides the static_cast.]]></description>
		<content:encoded><![CDATA[<p>I am referring to this:</p>
<p>auto a = matrix{&#8230;}, b = matrix{&#8230;}; // some type that does lazy eval<br />
auto ab = a * b;                       // to capture the lazy-eval proxy<br />
auto c = matrix{ a * b };              // to force computation</p>
<p>I am surprised, that nobody pointed out, that the third line is a *hidden* static_cast. Consider:</p>
<p>auto a = matrix{&#8230;};<br />
auto x = 3;<br />
auto da = a.size();<br />
auto c = matrix{ x * da }; // oops, ment { x * a }</p>
<p>In this example, the code will compile, assuming matrix has an explicit constructor matrix(size_t). In contrast, the following uses only implicit casting, so the error will be caught by the compiler.</p>
<p>matrix c = x * da;</p>
<p>I think it is good practice to use the weakest cast that is suitable. Using auto in this example not only conflicts with this, but also hides the static_cast.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Christian Hackl				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-29634</link>
		<dc:creator><![CDATA[Christian Hackl]]></dc:creator>
		<pubDate>Sat, 11 Oct 2014 09:09:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-29634</guid>
					<description><![CDATA[I have tried to use AAA for a while and cannot say I feel entirely comfortable with it. I am leaning towards using [code]auto[/code] only in certain situations, as it otherwise does reduce my code&#039;s readability. At least in my eyes. Then again, I think it is unfair to judge this feature as long as it has not been used widely, in huge projects, over the course of many years. I think it will show its true virtues (or the lack thereof) when it will be subject to code maintenance.

One fear I have is that AAA style may inadvertently cause a revival of Hungarian Notation. It would not surprise me if many people started to actually write stuff like [code]auto intCount = 0;[/code] or [code]auto strName = GetName();[/code] (or [code]auto dwRet = SomeWinApiFunction();[/code] :)), completely defeating the purpose of [code]auto[/code] in the first place.]]></description>
		<content:encoded><![CDATA[<p>I have tried to use AAA for a while and cannot say I feel entirely comfortable with it. I am leaning towards using </p>
<pre class="brush: plain; title: ; notranslate">auto</pre>
<p> only in certain situations, as it otherwise does reduce my code&#8217;s readability. At least in my eyes. Then again, I think it is unfair to judge this feature as long as it has not been used widely, in huge projects, over the course of many years. I think it will show its true virtues (or the lack thereof) when it will be subject to code maintenance.</p>
<p>One fear I have is that AAA style may inadvertently cause a revival of Hungarian Notation. It would not surprise me if many people started to actually write stuff like </p>
<pre class="brush: plain; title: ; notranslate">auto intCount = 0;</pre>
<p> or </p>
<pre class="brush: plain; title: ; notranslate">auto strName = GetName();</pre>
<p> (or </p>
<pre class="brush: plain; title: ; notranslate">auto dwRet = SomeWinApiFunction();</pre>
<p> :)), completely defeating the purpose of </p>
<pre class="brush: plain; title: ; notranslate">auto</pre>
<p> in the first place.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Using auto for declaring variables of move-only types. &#124; Feheren Fekete				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-28433</link>
		<dc:creator><![CDATA[Using auto for declaring variables of move-only types. &#124; Feheren Fekete]]></dc:creator>
		<pubDate>Fri, 26 Sep 2014 13:23:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-28433</guid>
					<description><![CDATA[[&#8230;] in this case) has a deleted copy constructor. Luckily, all is not lost on our quest for Almost Always Auto. The solution is to use Universal [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] in this case) has a deleted copy constructor. Luckily, all is not lost on our quest for Almost Always Auto. The solution is to use Universal [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tyson Nottingham				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-28295</link>
		<dc:creator><![CDATA[Tyson Nottingham]]></dc:creator>
		<pubDate>Fri, 26 Sep 2014 02:15:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-28295</guid>
					<description><![CDATA[I&#039;m wondering what downsides there are to using const auto&#038; wherever const auto would be appropriate (except in cases where you specifically want to copy the right hand side). Like auto in general, this protects you in the event that the right hand side changes.


For example, you might write be tempted to write...

[code]const auto x = widget.foo();[/code]

...if you know that widget.foo() returns a value, because using const auto&#038; here is superfluous. But if widget.foo() is changed to return a reference, then you&#039;d be making a copy/move where you probably didn&#039;t need one. Since you wanted a const object, it is unlikely that you wanted a copy anyway.


Another example -- you might decide to change...

[code]const auto x = get_raw_ptr();[/code]
...to...
[code]const auto x = *get_raw_ptr();[/code]

...without changing to const auto&#038;. Now you&#039;ve inadvertently copied/moved the right hand side. This type of change might not be likely, and will typically require modification to surrounding code, giving you an opportunity to re-evaluate your const auto declaration. Still, it could slip by.

Instead, if you had changed...

[code]const auto&#038; x = get_raw_ptr();[/code]
...to...
[code]const auto&#038; x = *get_raw_ptr();[/code]

...then no inadvertent copy would be introduced.

(The above example doesn&#039;t make sense if the function is get_unique_ptr(), because &lt;code&gt;const auto x = *get_unique_ptr()&lt;/code&gt; is probably wrong (unnecessary copy/move), and &lt;code&gt;const auto&#038; x = *get_unique_ptr();&lt;/code&gt; is always wrong (referring to an object that is about to be destroyed).)


Are these good enough reasons to prefer const auto&#038; even where const auto makes sense? Are there cases where using const auto&#038; in favor of const auto would backfire?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m wondering what downsides there are to using const auto&amp; wherever const auto would be appropriate (except in cases where you specifically want to copy the right hand side). Like auto in general, this protects you in the event that the right hand side changes.</p>
<p>For example, you might write be tempted to write&#8230;</p>
<pre class="brush: plain; title: ; notranslate">const auto x = widget.foo();</pre>
<p>&#8230;if you know that widget.foo() returns a value, because using const auto&amp; here is superfluous. But if widget.foo() is changed to return a reference, then you&#8217;d be making a copy/move where you probably didn&#8217;t need one. Since you wanted a const object, it is unlikely that you wanted a copy anyway.</p>
<p>Another example &#8212; you might decide to change&#8230;</p>
<pre class="brush: plain; title: ; notranslate">const auto x = get_raw_ptr();</pre>
<p>&#8230;to&#8230;</p>
<pre class="brush: plain; title: ; notranslate">const auto x = *get_raw_ptr();</pre>
<p>&#8230;without changing to const auto&amp;. Now you&#8217;ve inadvertently copied/moved the right hand side. This type of change might not be likely, and will typically require modification to surrounding code, giving you an opportunity to re-evaluate your const auto declaration. Still, it could slip by.</p>
<p>Instead, if you had changed&#8230;</p>
<pre class="brush: plain; title: ; notranslate">const auto&amp; x = get_raw_ptr();</pre>
<p>&#8230;to&#8230;</p>
<pre class="brush: plain; title: ; notranslate">const auto&amp; x = *get_raw_ptr();</pre>
<p>&#8230;then no inadvertent copy would be introduced.</p>
<p>(The above example doesn&#8217;t make sense if the function is get_unique_ptr(), because <code>const auto x = *get_unique_ptr()</code> is probably wrong (unnecessary copy/move), and <code>const auto&amp; x = *get_unique_ptr();</code> is always wrong (referring to an object that is about to be destroyed).)</p>
<p>Are these good enough reasons to prefer const auto&amp; even where const auto makes sense? Are there cases where using const auto&amp; in favor of const auto would backfire?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: auto considered awesome &#124; The New C++				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-24845</link>
		<dc:creator><![CDATA[auto considered awesome &#124; The New C++]]></dc:creator>
		<pubDate>Wed, 20 Aug 2014 03:42:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-24845</guid>
					<description><![CDATA[[&#8230;] think you shouldn&#8217;t use it. In fact I think you should almost always use it, as suggested in https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/ However, like everything in C++, you should know what you are doing, because if you don&#8217;t, [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] think you shouldn&#8217;t use it. In fact I think you should almost always use it, as suggested in <a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/" rel="nofollow">https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</a> However, like everything in C++, you should know what you are doing, because if you don&#8217;t, [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Confusion with auto assignment with list initialization syntax				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-24621</link>
		<dc:creator><![CDATA[Confusion with auto assignment with list initialization syntax]]></dc:creator>
		<pubDate>Fri, 15 Aug 2014 18:38:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-24621</guid>
					<description><![CDATA[[&#8230;] just now able to use C++11 for the first time at my job and I&#8217;m learning as I go. I have read GotW #94 and I&#8217;m trying to adopt his recommendation for using auto when declaring local variables [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] just now able to use C++11 for the first time at my job and I&#8217;m learning as I go. I have read GotW #94 and I&#8217;m trying to adopt his recommendation for using auto when declaring local variables [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Maxwell				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-24084</link>
		<dc:creator><![CDATA[Peter Maxwell]]></dc:creator>
		<pubDate>Mon, 04 Aug 2014 07:22:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-24084</guid>
					<description><![CDATA[@Richard:

Firstly, I&#039;m not concerned whether the library is efficiently returning types; I&#039;m concerned whether any given variable that is being passed round through assignment, parameters, etc is intrinsic type, object-by-value, reference, smart pointer, or raw pointer. Without understanding which of these you&#039;re dealing with, your understanding of what&#039;s going on is necessarily limited.

Secondly, you are not understanding me correctly. I am not and have never been talking about
[code]
auto x = y();
[/code]
and conversion operators.

I am talking about understanding the more fundamental
[code]
auto x = y;
[/code]
and knowing whether your assignment operator is plausibly overloaded and thus may throw.

Finally, when you are working with an existing codebase, you cannot guarantee that it is exception-safe, or even that RAII was used. Both the age of the codebase and the understanding of the programmer factor into these. Incidentally, RAII alone does not guarantee strong exception-safety (you also need to consider patterns such as copy-and-swap).]]></description>
		<content:encoded><![CDATA[<p>@Richard:</p>
<p>Firstly, I&#8217;m not concerned whether the library is efficiently returning types; I&#8217;m concerned whether any given variable that is being passed round through assignment, parameters, etc is intrinsic type, object-by-value, reference, smart pointer, or raw pointer. Without understanding which of these you&#8217;re dealing with, your understanding of what&#8217;s going on is necessarily limited.</p>
<p>Secondly, you are not understanding me correctly. I am not and have never been talking about</p>
<pre class="brush: plain; title: ; notranslate">
auto x = y();
</pre>
<p>and conversion operators.</p>
<p>I am talking about understanding the more fundamental</p>
<pre class="brush: plain; title: ; notranslate">
auto x = y;
</pre>
<p>and knowing whether your assignment operator is plausibly overloaded and thus may throw.</p>
<p>Finally, when you are working with an existing codebase, you cannot guarantee that it is exception-safe, or even that RAII was used. Both the age of the codebase and the understanding of the programmer factor into these. Incidentally, RAII alone does not guarantee strong exception-safety (you also need to consider patterns such as copy-and-swap).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-24058</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Sun, 03 Aug 2014 21:53:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-24058</guid>
					<description><![CDATA[@peter
Unfortunately every new feature is something else open to abuse/misuse, not totally sure a lot of new features are either warranted or sensible, auto being one of them, just more to go wrong and less compatible c++ code! Perhaps the working committees need to perhaps consider reducing the breadth of C++ rather than making it even more complex?

All that was really required was a good auto pointer, parallel/task support and some extras in STL!

Have to admit did like the idea of auto, but now realising it&#039;s folly in most circumstances, it&#039;s like maintaining with a blindfold on or at least running around to see what&#039;s going on! Your input has made me think!]]></description>
		<content:encoded><![CDATA[<p>@peter<br />
Unfortunately every new feature is something else open to abuse/misuse, not totally sure a lot of new features are either warranted or sensible, auto being one of them, just more to go wrong and less compatible c++ code! Perhaps the working committees need to perhaps consider reducing the breadth of C++ rather than making it even more complex?</p>
<p>All that was really required was a good auto pointer, parallel/task support and some extras in STL!</p>
<p>Have to admit did like the idea of auto, but now realising it&#8217;s folly in most circumstances, it&#8217;s like maintaining with a blindfold on or at least running around to see what&#8217;s going on! Your input has made me think!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard Hodges				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-24057</link>
		<dc:creator><![CDATA[Richard Hodges]]></dc:creator>
		<pubDate>Sun, 03 Aug 2014 21:44:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-24057</guid>
					<description><![CDATA[@Peter I hear you. I have been in the business for a long time too and I have seen my fair share of horrid upstream interfaces.
It seems to me that you are concerned about two things:
1) is my library efficiently returning types? Can I increase the efficiency in client code?
2) will it throw exceptions?

I would argue that (1) is intractable. Reading the documentation (or at least the interface declarations) of the library will tell you what types are being returned, whether they are intrinsic types, references or copies.
At this point whether you write auto or name a type in the client code is irrelevant unless you are planning to perform a conversion on the returned type. If I understand you correctly, you are considering a case like this:

[code]
  // declaration:
  thing get_a_thing();

  // user code
  part_of_a_thing mything = get_a_thing();  // conversion constructor called
[/code]

this can be expressed succinctly using auto

[code]
  // user code
  auto mything = part_of_a_thing { get_a_thing() };
[/code]

In fact, I would argue that the auto version is explicitly stating that a conversion constructor is being called and is therefore more easily understood and debugged.

regarding point 2, I am not sure I understand there to be a problem. The interface of get_a_thing() will indicate wether or not exceptions can be thrown. In any case, all your user code will be written in terms of RAII so it will at least be exception-safe. Any objects you use from the _thing_ library that do not use RAII can be wrapped in a unique_ptr (or shared_ptr) with a custom deleter, so they will be exception safe too.

example:
[code]
  // declarations
  thing* make_thing();
  void dispose_of_thing(thing*);

  // my user code
  {
    auto mything = std::shared_ptr&#060;thing&#062; { make_a_thing(), dispose_of_thing };
    // do things that may throw exceptions...
    ...
    // dispose_of_thing() called here upon destruction of the shared_ptr
  }

  // or maybe this is better
  // define my own safe factory function to wrap the unsafe library:
  std::shared_ptr&#060;thing&#062; my_safe_make_a_thing()  // lack of noexcept indicates that this may throw
  { 
    return { make_a_thing(), dispose_of_thing 
    }; 
  }

  // my user code:
  auto mything = my_safe_make_a_thing();
[/code]]]></description>
		<content:encoded><![CDATA[<p>@Peter I hear you. I have been in the business for a long time too and I have seen my fair share of horrid upstream interfaces.<br />
It seems to me that you are concerned about two things:<br />
1) is my library efficiently returning types? Can I increase the efficiency in client code?<br />
2) will it throw exceptions?</p>
<p>I would argue that (1) is intractable. Reading the documentation (or at least the interface declarations) of the library will tell you what types are being returned, whether they are intrinsic types, references or copies.<br />
At this point whether you write auto or name a type in the client code is irrelevant unless you are planning to perform a conversion on the returned type. If I understand you correctly, you are considering a case like this:</p>
<pre class="brush: plain; title: ; notranslate">
  // declaration:
  thing get_a_thing();

  // user code
  part_of_a_thing mything = get_a_thing();  // conversion constructor called
</pre>
<p>this can be expressed succinctly using auto</p>
<pre class="brush: plain; title: ; notranslate">
  // user code
  auto mything = part_of_a_thing { get_a_thing() };
</pre>
<p>In fact, I would argue that the auto version is explicitly stating that a conversion constructor is being called and is therefore more easily understood and debugged.</p>
<p>regarding point 2, I am not sure I understand there to be a problem. The interface of get_a_thing() will indicate wether or not exceptions can be thrown. In any case, all your user code will be written in terms of RAII so it will at least be exception-safe. Any objects you use from the _thing_ library that do not use RAII can be wrapped in a unique_ptr (or shared_ptr) with a custom deleter, so they will be exception safe too.</p>
<p>example:</p>
<pre class="brush: plain; title: ; notranslate">
  // declarations
  thing* make_thing();
  void dispose_of_thing(thing*);

  // my user code
  {
    auto mything = std::shared_ptr&lt;thing&gt; { make_a_thing(), dispose_of_thing };
    // do things that may throw exceptions...
    ...
    // dispose_of_thing() called here upon destruction of the shared_ptr
  }

  // or maybe this is better
  // define my own safe factory function to wrap the unsafe library:
  std::shared_ptr&lt;thing&gt; my_safe_make_a_thing()  // lack of noexcept indicates that this may throw
  { 
    return { make_a_thing(), dispose_of_thing 
    }; 
  }

  // my user code:
  auto mything = my_safe_make_a_thing();
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Maxwell				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-24052</link>
		<dc:creator><![CDATA[Peter Maxwell]]></dc:creator>
		<pubDate>Sun, 03 Aug 2014 20:24:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-24052</guid>
					<description><![CDATA[@Richard:

We appear to be talking fundamentally at cross purposes.

I am not discussing the choices made by the person who wrote the code. I am discussing a much more common scenario: the developer who has to read and understand the code. 

By the time you are maintaining the code, it is in some senses too late, as the dumb decisions have already been made. Certainly the compiler will try to ensure that
[code]
auto x = y();
[/code]
is efficient. (Though, please note I was *not* discussing the efficiency of that line at any point, only the line subsequent.) The compiler will not however be able to work out that the entire design is unreasonable, that the whole object is being passed back when subsequent use of it relies only on reading one flag. It will not warn you on occasions when an aliased shared pointer is being used as a parameter unsafely. There are many, many situations where the code you are reading is suboptimal, and you need to work out whether it is okay to be a little suboptimal here, or whether it is suboptimal in a way likely to prevent your new additions scaling well, or whether it is actually also unsafe. And, importantly, auto will do very little to help that code be more optimal. Certainly, it may stop some dumb conversions being made, but these represent only a very tiny fraction of bugs - and arguably, when the programmer stops thinking about types very hard, it frees them up to more easily make mistakes like writing a for loop that doesn&#039;t terminate because of overflow errors.

The example I actually gave you:
[code]
auto previous = result;
[/code]
could well throw. If it&#039;s an intrinsic type it won&#039;t. If it&#039;s a type you know well, you can probably hazard a guess as to whether it&#039;s likely to. If it is a type you haven&#039;t encountered before in this codebase, you either hope it doesn&#039;t and hope you don&#039;t get bitten later, or invest the time in finding out. But whether it throws or not may well change whether the function is strongly exception safe, or even exception safe at all. It&#039;s important.

C++ is a language of a myriad subtleties. Auto disguises some of them. In any context save toy problems, this is an issue. It is, I contend, hugely unwise to recommend its use by default. There are obvious situations where it can aid clarity. There are also situations where it will obscure useful details. Within the next ten years, I suspect we&#039;ll all have had our fill of the latter.]]></description>
		<content:encoded><![CDATA[<p>@Richard:</p>
<p>We appear to be talking fundamentally at cross purposes.</p>
<p>I am not discussing the choices made by the person who wrote the code. I am discussing a much more common scenario: the developer who has to read and understand the code. </p>
<p>By the time you are maintaining the code, it is in some senses too late, as the dumb decisions have already been made. Certainly the compiler will try to ensure that</p>
<pre class="brush: plain; title: ; notranslate">
auto x = y();
</pre>
<p>is efficient. (Though, please note I was *not* discussing the efficiency of that line at any point, only the line subsequent.) The compiler will not however be able to work out that the entire design is unreasonable, that the whole object is being passed back when subsequent use of it relies only on reading one flag. It will not warn you on occasions when an aliased shared pointer is being used as a parameter unsafely. There are many, many situations where the code you are reading is suboptimal, and you need to work out whether it is okay to be a little suboptimal here, or whether it is suboptimal in a way likely to prevent your new additions scaling well, or whether it is actually also unsafe. And, importantly, auto will do very little to help that code be more optimal. Certainly, it may stop some dumb conversions being made, but these represent only a very tiny fraction of bugs &#8211; and arguably, when the programmer stops thinking about types very hard, it frees them up to more easily make mistakes like writing a for loop that doesn&#8217;t terminate because of overflow errors.</p>
<p>The example I actually gave you:</p>
<pre class="brush: plain; title: ; notranslate">
auto previous = result;
</pre>
<p>could well throw. If it&#8217;s an intrinsic type it won&#8217;t. If it&#8217;s a type you know well, you can probably hazard a guess as to whether it&#8217;s likely to. If it is a type you haven&#8217;t encountered before in this codebase, you either hope it doesn&#8217;t and hope you don&#8217;t get bitten later, or invest the time in finding out. But whether it throws or not may well change whether the function is strongly exception safe, or even exception safe at all. It&#8217;s important.</p>
<p>C++ is a language of a myriad subtleties. Auto disguises some of them. In any context save toy problems, this is an issue. It is, I contend, hugely unwise to recommend its use by default. There are obvious situations where it can aid clarity. There are also situations where it will obscure useful details. Within the next ten years, I suspect we&#8217;ll all have had our fill of the latter.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard Hodges				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23923</link>
		<dc:creator><![CDATA[Richard Hodges]]></dc:creator>
		<pubDate>Fri, 01 Aug 2014 18:28:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23923</guid>
					<description><![CDATA[Let&#039;s assume we agree on the following principles:
1. early optimisation is evil (don&#039;t make programs untidy)
2. early pessimisation is evil (don&#039;t prevent the compiler from doing RVO etc)
3. write for clarity, good optimisation begins with logically efficient algorithms

I would argue that a software team which adheres to these principles will rarely be able to do better than the compiler for code such as
[code]
    auto x = y();
[/code]
Since the compiler will have optimised the construction of the return value by constructing it in-place or calling the move constructor (see 2).

y() is free to return whichever type is most logically appropriate, and there will be no performance cost.]]></description>
		<content:encoded><![CDATA[<p>Let&#8217;s assume we agree on the following principles:<br />
1. early optimisation is evil (don&#8217;t make programs untidy)<br />
2. early pessimisation is evil (don&#8217;t prevent the compiler from doing RVO etc)<br />
3. write for clarity, good optimisation begins with logically efficient algorithms</p>
<p>I would argue that a software team which adheres to these principles will rarely be able to do better than the compiler for code such as</p>
<pre class="brush: plain; title: ; notranslate">
    auto x = y();
</pre>
<p>Since the compiler will have optimised the construction of the return value by constructing it in-place or calling the move constructor (see 2).</p>
<p>y() is free to return whichever type is most logically appropriate, and there will be no performance cost.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Maxwell				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23918</link>
		<dc:creator><![CDATA[Peter Maxwell]]></dc:creator>
		<pubDate>Fri, 01 Aug 2014 16:20:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23918</guid>
					<description><![CDATA[@red1939:

I would entirely agree that it is possible that “Speed previous = result;” is actually surprisingly efficient, particularly given the brutalisations made possible with typedef. However, when you see float, you have a wealth of information to reason with. It is fast to copy. You are likely to be able to assume assignment is atomic, depending on your architecture. Numerical comparisons done with it require a little care. There&#039;s much more.

Beyond that, we can reason about standard types. Shared pointers, std::strings, container classes - we feel able to make certain expectations when we see them. Are you not nervous to see someone has implemented their own linked list class precisely because it is unknown?

The C++ language already makes it hard to reason about a wealth of things, and you will often be in unknown territory. Often this doesn&#039;t matter. Sometimes it does. Features which can easily be used to hide the fact you are actually in known territory are potentially dangerous features, and features that should be used with caution.

Thinking you understand an algorithm without understanding the data representation is, I submit, potentially folly. Algorithms that are excellent when you&#039;re working with a vector are idiocy when working with a linked list. And, if you&#039;re at the point you don&#039;t care about performance, there&#039;s no point in spending your time on C++; go off and work in Python and make your life easier.

I happen to agree that absurdly long types with nested namespaces are clumsy, hard on both writer and reader, and there are places where auto can only improve readability. (I suspect that the problem here originates with the way such namespaces grow up, but we are often in a position where we have to live with it now.) My concern is that there are also a great many places where it will be practically hazardous, where types being returned are not as the reader expects, and it will prove to be a particularly devastating weapon in the hands of the novice and the lazy coder.]]></description>
		<content:encoded><![CDATA[<p>@red1939:</p>
<p>I would entirely agree that it is possible that “Speed previous = result;” is actually surprisingly efficient, particularly given the brutalisations made possible with typedef. However, when you see float, you have a wealth of information to reason with. It is fast to copy. You are likely to be able to assume assignment is atomic, depending on your architecture. Numerical comparisons done with it require a little care. There&#8217;s much more.</p>
<p>Beyond that, we can reason about standard types. Shared pointers, std::strings, container classes &#8211; we feel able to make certain expectations when we see them. Are you not nervous to see someone has implemented their own linked list class precisely because it is unknown?</p>
<p>The C++ language already makes it hard to reason about a wealth of things, and you will often be in unknown territory. Often this doesn&#8217;t matter. Sometimes it does. Features which can easily be used to hide the fact you are actually in known territory are potentially dangerous features, and features that should be used with caution.</p>
<p>Thinking you understand an algorithm without understanding the data representation is, I submit, potentially folly. Algorithms that are excellent when you&#8217;re working with a vector are idiocy when working with a linked list. And, if you&#8217;re at the point you don&#8217;t care about performance, there&#8217;s no point in spending your time on C++; go off and work in Python and make your life easier.</p>
<p>I happen to agree that absurdly long types with nested namespaces are clumsy, hard on both writer and reader, and there are places where auto can only improve readability. (I suspect that the problem here originates with the way such namespaces grow up, but we are often in a position where we have to live with it now.) My concern is that there are also a great many places where it will be practically hazardous, where types being returned are not as the reader expects, and it will prove to be a particularly devastating weapon in the hands of the novice and the lazy coder.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: red1939				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23913</link>
		<dc:creator><![CDATA[red1939]]></dc:creator>
		<pubDate>Fri, 01 Aug 2014 14:05:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23913</guid>
					<description><![CDATA[@Peter Maxwell

In my opinion if anyone is writing such &quot;careless&quot; assignment he has to understand whether or not it&#039;s costly, or not, or maybe even required, no matter the cost. Let&#039;s assume you see something like &quot;Speed previous = result;&quot; and &quot;float previous = result;&quot;. Of course, knowing that the cost of copying a whole struct can be expensive, and a single float can be easily put into helper register, you assume that the first example is costly. That can be misleading as if Speed is defined as &quot;class Speed : public Wrapper {...}&quot; (for strong typing) and compiler will have slightly more work to optimize it.

You said that &quot;code itself is opaque without the benefit of additional information&quot;. For me the code becomes _more_ readable as you focus only on the structure and algorithms of the code: here you iterate over all elements calling a method &quot;foo()&quot; on them and lastly you make a copy of a result obtained from &quot;create()&quot; method of some factory.

I don&#039;t know what is your workflow but most of the time I have to quickly consume some block of code and decide to which class should I go and seek further. When a decent part of code is either &quot;using x = &quot;, &quot;typedef ...&quot; or &quot;my::very::nested::namespace::SomeFancy ret = x.create();&quot; it&#039;s truly harder to read, as you have to decode it, as - for me at least - that&#039;s like forcing you always to do the next step (knowing the exact types).

That said I am strongly against putting auto in method/function declarations. Also when in some local scope you would like to cast from right hand or clearly show that you are changing &quot;the mindset&quot;/domain then feel free to use the explicit type. When the type of the left side shouldn&#039;t be shocking to most of the people reading your code, then why make your life harder?]]></description>
		<content:encoded><![CDATA[<p>@Peter Maxwell</p>
<p>In my opinion if anyone is writing such &#8220;careless&#8221; assignment he has to understand whether or not it&#8217;s costly, or not, or maybe even required, no matter the cost. Let&#8217;s assume you see something like &#8220;Speed previous = result;&#8221; and &#8220;float previous = result;&#8221;. Of course, knowing that the cost of copying a whole struct can be expensive, and a single float can be easily put into helper register, you assume that the first example is costly. That can be misleading as if Speed is defined as &#8220;class Speed : public Wrapper {&#8230;}&#8221; (for strong typing) and compiler will have slightly more work to optimize it.</p>
<p>You said that &#8220;code itself is opaque without the benefit of additional information&#8221;. For me the code becomes _more_ readable as you focus only on the structure and algorithms of the code: here you iterate over all elements calling a method &#8220;foo()&#8221; on them and lastly you make a copy of a result obtained from &#8220;create()&#8221; method of some factory.</p>
<p>I don&#8217;t know what is your workflow but most of the time I have to quickly consume some block of code and decide to which class should I go and seek further. When a decent part of code is either &#8220;using x = &#8220;, &#8220;typedef &#8230;&#8221; or &#8220;my::very::nested::namespace::SomeFancy ret = x.create();&#8221; it&#8217;s truly harder to read, as you have to decode it, as &#8211; for me at least &#8211; that&#8217;s like forcing you always to do the next step (knowing the exact types).</p>
<p>That said I am strongly against putting auto in method/function declarations. Also when in some local scope you would like to cast from right hand or clearly show that you are changing &#8220;the mindset&#8221;/domain then feel free to use the explicit type. When the type of the left side shouldn&#8217;t be shocking to most of the people reading your code, then why make your life harder?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Maxwell				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23909</link>
		<dc:creator><![CDATA[Peter Maxwell]]></dc:creator>
		<pubDate>Fri, 01 Aug 2014 12:15:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23909</guid>
					<description><![CDATA[@Richard:

You&#039;ve sort of touched on this, but when I asked what the performance implications were of
[code]
auto previous = result;
[/code]
my point was that you don&#039;t know whether you&#039;re dealing with an intrinsic type or an object, whether you&#039;re working with a reference or a pointer or doing a full fat copy (or indeed a type with a custom assignment operator which may do something unexpected). The code itself is opaque without the benefit of additional information. Auto is here actively making it harder to reason about the code.]]></description>
		<content:encoded><![CDATA[<p>@Richard:</p>
<p>You&#8217;ve sort of touched on this, but when I asked what the performance implications were of</p>
<pre class="brush: plain; title: ; notranslate">
auto previous = result;
</pre>
<p>my point was that you don&#8217;t know whether you&#8217;re dealing with an intrinsic type or an object, whether you&#8217;re working with a reference or a pointer or doing a full fat copy (or indeed a type with a custom assignment operator which may do something unexpected). The code itself is opaque without the benefit of additional information. Auto is here actively making it harder to reason about the code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard Hodges				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23830</link>
		<dc:creator><![CDATA[Richard Hodges]]></dc:creator>
		<pubDate>Thu, 31 Jul 2014 17:23:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23830</guid>
					<description><![CDATA[@Peter The performance cost of
[code]
    auto x = make_a_thing();
[/code]

would normally be low because of return value optimisation. In any case the cost is the same as

[code]
    thing x = make_a_thing();
[/code]

Since we strive to produce code that is user-friendly, the author of &#039;thing&#039; and &#039;make_a_thing&#039; will seek to ensure that the object constructor and the function are efficient and that the function is a candidate for RVO.

Unnecessary (and possibly dangerous) copies will be generated with this code:
[code]
    auto x = get_a_reference_to_a_thing();
[/code]

which is of course cured with

[code]
    auto&#038; x = get_a_reference_to_a_thing();
[/code]

deleting the copy constructor and copy operator of &#039;thing&#039; catches that at compile time.]]></description>
		<content:encoded><![CDATA[<p>@Peter The performance cost of</p>
<pre class="brush: plain; title: ; notranslate">
    auto x = make_a_thing();
</pre>
<p>would normally be low because of return value optimisation. In any case the cost is the same as</p>
<pre class="brush: plain; title: ; notranslate">
    thing x = make_a_thing();
</pre>
<p>Since we strive to produce code that is user-friendly, the author of &#8216;thing&#8217; and &#8216;make_a_thing&#8217; will seek to ensure that the object constructor and the function are efficient and that the function is a candidate for RVO.</p>
<p>Unnecessary (and possibly dangerous) copies will be generated with this code:</p>
<pre class="brush: plain; title: ; notranslate">
    auto x = get_a_reference_to_a_thing();
</pre>
<p>which is of course cured with</p>
<pre class="brush: plain; title: ; notranslate">
    auto&amp; x = get_a_reference_to_a_thing();
</pre>
<p>deleting the copy constructor and copy operator of &#8216;thing&#8217; catches that at compile time.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Maxwell				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23801</link>
		<dc:creator><![CDATA[Peter Maxwell]]></dc:creator>
		<pubDate>Thu, 31 Jul 2014 07:26:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23801</guid>
					<description><![CDATA[I fear I messed up my input and lost the code I was trying to include in the text paragraphs - the text should read:
What are the performance implications of auto previous = result?
and
Certainly, all these questions can be cleared up, if you have an IDE instead of a text editor, by hovering over auto result.]]></description>
		<content:encoded><![CDATA[<p>I fear I messed up my input and lost the code I was trying to include in the text paragraphs &#8211; the text should read:<br />
What are the performance implications of auto previous = result?<br />
and<br />
Certainly, all these questions can be cleared up, if you have an IDE instead of a text editor, by hovering over auto result.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard Hodges				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23768</link>
		<dc:creator><![CDATA[Richard Hodges]]></dc:creator>
		<pubDate>Wed, 30 Jul 2014 21:01:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23768</guid>
					<description><![CDATA[I&#039;ve been using c++11 in production code for 18 months now. I find myself using auto when assigning return values from functions almost always - it seems to make it easier to code for intent rather than mechanics.

I do still find myself avoiding auto when declaring object variables, since many of my objects are deliberately non-copyable (often because they contain a mutex).

so I generally do things like this:

[code]
    complex_thing x { ... };    // because I don&#039;t have to care whether there is a copy constructor
    
    auto thing_ptr = make_shared&#060;thing&#062;(...);

    auto result = do_or_make_something(...);
[/code]

but...

[code]
    weak_ptr&#060;thing&#062; weak_thing { thing_ptr };
[/code]

...because there is no such thing as...

[code]
    auto weak_thing = make_weak_ptr(thing_ptr);
[/code]

... which is a shame.

in for loops:

[code]
    for(const auto&#038; entry : some_container) { ... }
[/code]

but

[code]
    auto container_size = some_container.size();
    for(size_t i = 0 ; i &#060; container_size ; ++i) {
        // although I&#039;m not completely happy with the mix here
    }
[/code]

perhaps this might be reasonable in principle:

[code]
    for(decltype(container_size) i = 0 ; ... ; ... )
[/code]

but it looks horrid]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve been using c++11 in production code for 18 months now. I find myself using auto when assigning return values from functions almost always &#8211; it seems to make it easier to code for intent rather than mechanics.</p>
<p>I do still find myself avoiding auto when declaring object variables, since many of my objects are deliberately non-copyable (often because they contain a mutex).</p>
<p>so I generally do things like this:</p>
<pre class="brush: plain; title: ; notranslate">
    complex_thing x { ... };    // because I don't have to care whether there is a copy constructor
    
    auto thing_ptr = make_shared&lt;thing&gt;(...);

    auto result = do_or_make_something(...);
</pre>
<p>but&#8230;</p>
<pre class="brush: plain; title: ; notranslate">
    weak_ptr&lt;thing&gt; weak_thing { thing_ptr };
</pre>
<p>&#8230;because there is no such thing as&#8230;</p>
<pre class="brush: plain; title: ; notranslate">
    auto weak_thing = make_weak_ptr(thing_ptr);
</pre>
<p>&#8230; which is a shame.</p>
<p>in for loops:</p>
<pre class="brush: plain; title: ; notranslate">
    for(const auto&amp; entry : some_container) { ... }
</pre>
<p>but</p>
<pre class="brush: plain; title: ; notranslate">
    auto container_size = some_container.size();
    for(size_t i = 0 ; i &lt; container_size ; ++i) {
        // although I'm not completely happy with the mix here
    }
</pre>
<p>perhaps this might be reasonable in principle:</p>
<pre class="brush: plain; title: ; notranslate">
    for(decltype(container_size) i = 0 ; ... ; ... )
</pre>
<p>but it looks horrid</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23765</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Wed, 30 Jul 2014 20:37:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23765</guid>
					<description><![CDATA[@peter have to admit did like the idea of auto, one of my pet hates is the horrible typing you have to do sometimes. Maybe the real answer is an IDE function to pickup on what auto really is referring to and substitute the full text definition once the right side is known. Better still the code would be backwards with earlier compilers!

Or perhaps auto could be reserved for when it&#039;s really useful, but that requires self restraint by the programer, not a known characteristic of the species!]]></description>
		<content:encoded><![CDATA[<p>@peter have to admit did like the idea of auto, one of my pet hates is the horrible typing you have to do sometimes. Maybe the real answer is an IDE function to pickup on what auto really is referring to and substitute the full text definition once the right side is known. Better still the code would be backwards with earlier compilers!</p>
<p>Or perhaps auto could be reserved for when it&#8217;s really useful, but that requires self restraint by the programer, not a known characteristic of the species!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Peter Maxwell				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-23751</link>
		<dc:creator><![CDATA[Peter Maxwell]]></dc:creator>
		<pubDate>Wed, 30 Jul 2014 14:56:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-23751</guid>
					<description><![CDATA[I feel wide use of auto is a mistake, and likely to lead to a maintainability nightmare in the future.

Firstly, before I produce any examples of my own, I note the previous article&#039;s error in its original state:
[code]
for(auto i = 0; i &#060; v.size(); i += 2) 
[/code]

With an explicit int, the error becomes more immediately visible. With auto, having to think about the type is elided, dangerously. When a programmer of your calibre makes mistakes in the most trivial of sample code - an indexed for loop - while trying to show that it leads to safer practices, it is hard to resist the conclusion that the opposite may be the case in some circumstances.

Secondly, you&#039;re far from tackling the real problems with readability. Maintenance programmers look at huge volumes of code. Understanding how safe it is, or isn&#039;t, needs to be as instant as possible.

[code]
auto result = my_opaquely_named_function();
auto previous = result;
process(result);
[/code]

What are the performance implications of ? Will it throw?
What conclusions can we draw about the lifetime of result?
If one of those lines does throw an exception, will we have a memory leak?

Certainly, all these questions can be cleared up, if you have an IDE instead of a text editor, by hovering over . But when you have a page full of autos, having to repeatedly do this to understand what is going on is a pain, a retrogressive step.

C++ is a big language, and people use it in very different ways. But if there&#039;s a common thread to most development, it is that it takes place in contexts where people will have to read the code again for a long time to come. Const is valuable because the human reading the code can see the const and can rely on the const variable following a certain contract. Auto is the opposite, hiding details of variable contracts in small print. 

And finally, it&#039;s fine to say &quot;it reflects a bias to code against implementations, not interfaces&quot; - but implementations matter. Your interface to void * and a shared_ptr are identical in the example I&#039;ve just given - you can initialize both, copy both, pass both as a parameter - but understanding enough of the implementation details to know what kind of contract they provide you is critical to writing code that is safe and performs well.]]></description>
		<content:encoded><![CDATA[<p>I feel wide use of auto is a mistake, and likely to lead to a maintainability nightmare in the future.</p>
<p>Firstly, before I produce any examples of my own, I note the previous article&#8217;s error in its original state:</p>
<pre class="brush: plain; title: ; notranslate">
for(auto i = 0; i &lt; v.size(); i += 2) 
</pre>
<p>With an explicit int, the error becomes more immediately visible. With auto, having to think about the type is elided, dangerously. When a programmer of your calibre makes mistakes in the most trivial of sample code &#8211; an indexed for loop &#8211; while trying to show that it leads to safer practices, it is hard to resist the conclusion that the opposite may be the case in some circumstances.</p>
<p>Secondly, you&#8217;re far from tackling the real problems with readability. Maintenance programmers look at huge volumes of code. Understanding how safe it is, or isn&#8217;t, needs to be as instant as possible.</p>
<pre class="brush: plain; title: ; notranslate">
auto result = my_opaquely_named_function();
auto previous = result;
process(result);
</pre>
<p>What are the performance implications of ? Will it throw?<br />
What conclusions can we draw about the lifetime of result?<br />
If one of those lines does throw an exception, will we have a memory leak?</p>
<p>Certainly, all these questions can be cleared up, if you have an IDE instead of a text editor, by hovering over . But when you have a page full of autos, having to repeatedly do this to understand what is going on is a pain, a retrogressive step.</p>
<p>C++ is a big language, and people use it in very different ways. But if there&#8217;s a common thread to most development, it is that it takes place in contexts where people will have to read the code again for a long time to come. Const is valuable because the human reading the code can see the const and can rely on the const variable following a certain contract. Auto is the opposite, hiding details of variable contracts in small print. </p>
<p>And finally, it&#8217;s fine to say &#8220;it reflects a bias to code against implementations, not interfaces&#8221; &#8211; but implementations matter. Your interface to void * and a shared_ptr are identical in the example I&#8217;ve just given &#8211; you can initialize both, copy both, pass both as a parameter &#8211; but understanding enough of the implementation details to know what kind of contract they provide you is critical to writing code that is safe and performs well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-22653</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 12 Jul 2014 15:59:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-22653</guid>
					<description><![CDATA[@sftrabbit: I&#039;ll only push back on the word &quot;incorrect&quot; which is not compatible with &quot;I’ll admit that this is entirely a matter of style&quot;... Just sayin&#039;. :)

I didn&#039;t say it&#039;s pitfall-free by default; any feature in any reasonable language can be abused. But it&#039;s objectively true that declaring variables using auto prevents classes of errors (e.g., you can&#039;t write an uninitialized variable), for example. Finally, opinions vary of course -- as I&#039;ve pointed out many times, whether/when to use &quot;auto&quot; or &quot;var&quot; or &quot;let&quot; is a perennial question also in other languages that offer such type deduction for local variables with debates going on for years with no sign of abating, so I don&#039;t expect this discussion to end anytime soon.]]></description>
		<content:encoded><![CDATA[<p>@sftrabbit: I&#8217;ll only push back on the word &#8220;incorrect&#8221; which is not compatible with &#8220;I’ll admit that this is entirely a matter of style&#8221;&#8230; Just sayin&#8217;. :)</p>
<p>I didn&#8217;t say it&#8217;s pitfall-free by default; any feature in any reasonable language can be abused. But it&#8217;s objectively true that declaring variables using auto prevents classes of errors (e.g., you can&#8217;t write an uninitialized variable), for example. Finally, opinions vary of course &#8212; as I&#8217;ve pointed out many times, whether/when to use &#8220;auto&#8221; or &#8220;var&#8221; or &#8220;let&#8221; is a perennial question also in other languages that offer such type deduction for local variables with debates going on for years with no sign of abating, so I don&#8217;t expect this discussion to end anytime soon.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: sftrabbit				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-22647</link>
		<dc:creator><![CDATA[sftrabbit]]></dc:creator>
		<pubDate>Sat, 12 Jul 2014 15:21:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-22647</guid>
					<description><![CDATA[It&#039;s a choice between using `auto` now and later constraining your declarations or using concrete types now and later relaxing your constraints. It is therefore a matter of weighing up the pros and cons of being overly relaxed against being overly strict, as long as we all agree to use concepts appropriately later.

I find that a number of your arguments for AAA are either incorrect (particularly about it being readable) or involve shoehorning `auto` into something that it&#039;s not (such as treating it like a var keyword or using it to enforce initialisation). Saying it&#039;s correct-by-default and pitfall-free-by-default is a stretch - only yesterday did a questioner on SO fall into such a pit (http://stackoverflow.com/q/24702953/150634). On the point of readability, AAA requires that type information is moved into the name of a variable to ensure that the meaning of the variable is still clear, which I find to be an ugly practice - the compiler is unable to enforce this, so we have to trust the programmer&#039;s naming abilities. Being overly specific does require more effort on behalf the programmer, but it&#039;s certainly safer and easier to read.

I&#039;ll admit that this is entirely a matter of style, but I feel like AAA has far too many cons to be suggesting it as the default approach for all C++ programmers (especially beginners). After all, the whole point of introducing concepts is to remove many of these problems from templates. Why would we introduce them to all of our variables?]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s a choice between using `auto` now and later constraining your declarations or using concrete types now and later relaxing your constraints. It is therefore a matter of weighing up the pros and cons of being overly relaxed against being overly strict, as long as we all agree to use concepts appropriately later.</p>
<p>I find that a number of your arguments for AAA are either incorrect (particularly about it being readable) or involve shoehorning `auto` into something that it&#8217;s not (such as treating it like a var keyword or using it to enforce initialisation). Saying it&#8217;s correct-by-default and pitfall-free-by-default is a stretch &#8211; only yesterday did a questioner on SO fall into such a pit (<a href="http://stackoverflow.com/q/24702953/150634" rel="nofollow">http://stackoverflow.com/q/24702953/150634</a>). On the point of readability, AAA requires that type information is moved into the name of a variable to ensure that the meaning of the variable is still clear, which I find to be an ugly practice &#8211; the compiler is unable to enforce this, so we have to trust the programmer&#8217;s naming abilities. Being overly specific does require more effort on behalf the programmer, but it&#8217;s certainly safer and easier to read.</p>
<p>I&#8217;ll admit that this is entirely a matter of style, but I feel like AAA has far too many cons to be suggesting it as the default approach for all C++ programmers (especially beginners). After all, the whole point of introducing concepts is to remove many of these problems from templates. Why would we introduce them to all of our variables?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-22645</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 12 Jul 2014 14:43:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-22645</guid>
					<description><![CDATA[Yes, &#039;auto&#039; is exactly equivalent to &#039;typename T&#039; by definition (modulo the one quirk that currently auto is allowed to deduce initializer_list).

As I wrote on the Reddit thread: Second, a huge amount of the discussion in this thread is of the form &quot;but if we had concepts we would write &quot;Conceptname x = ...;&quot;. That&#039;s exactly true and I&#039;m one of the ones pushing strongest for that -- and it&#039;s a reason to use &quot;auto x = ...;&quot; today because it will mean the same thing, namely to deduce the type (not specify it exactly, no conversions, etc.), just adding the ability to check that the deduced type matches the concept. This is a direct (and intended) evolution of declaring with auto per AAA. If you like that, you&#039;re in good company, and you should use auto today. Telling people to declare with concrete types today is not at all the same thing and puts you on a different path of committing to concrete types, which is the opposite of &quot;Conceptname x = ...;&quot;.]]></description>
		<content:encoded><![CDATA[<p>Yes, &#8216;auto&#8217; is exactly equivalent to &#8216;typename T&#8217; by definition (modulo the one quirk that currently auto is allowed to deduce initializer_list).</p>
<p>As I wrote on the Reddit thread: Second, a huge amount of the discussion in this thread is of the form &#8220;but if we had concepts we would write &#8220;Conceptname x = &#8230;;&#8221;. That&#8217;s exactly true and I&#8217;m one of the ones pushing strongest for that &#8212; and it&#8217;s a reason to use &#8220;auto x = &#8230;;&#8221; today because it will mean the same thing, namely to deduce the type (not specify it exactly, no conversions, etc.), just adding the ability to check that the deduced type matches the concept. This is a direct (and intended) evolution of declaring with auto per AAA. If you like that, you&#8217;re in good company, and you should use auto today. Telling people to declare with concrete types today is not at all the same thing and puts you on a different path of committing to concrete types, which is the opposite of &#8220;Conceptname x = &#8230;;&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: sftrabbit				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-22457</link>
		<dc:creator><![CDATA[sftrabbit]]></dc:creator>
		<pubDate>Tue, 08 Jul 2014 12:00:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-22457</guid>
					<description><![CDATA[I&#039;ve written an article (http://josephmansfield.uk/articles/dont-use-auto-unless-you-mean-it.html), which proposes an alternative convention for using &lt;code&gt;auto&lt;/code&gt;. It makes some similar arguments, but has a very different result - I suggest using &lt;code&gt;auto&lt;/code&gt; only when you want to impose no requirements on a variable. The intention is to unify variable declarations with template arguments, and how we will declare template arguments when concepts are available. I consider &lt;code&gt;auto&lt;/code&gt; to be equivalent to writing &lt;code&gt;typename T&lt;/code&gt; without any useful information about the requirements of the type. This is okay, but only in situations where you mean that the variable could be any type and behave correctly (such as the argument of &lt;code&gt;std::move&lt;/code&gt;).]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve written an article (<a href="http://josephmansfield.uk/articles/dont-use-auto-unless-you-mean-it.html" rel="nofollow">http://josephmansfield.uk/articles/dont-use-auto-unless-you-mean-it.html</a>), which proposes an alternative convention for using <code>auto</code>. It makes some similar arguments, but has a very different result &#8211; I suggest using <code>auto</code> only when you want to impose no requirements on a variable. The intention is to unify variable declarations with template arguments, and how we will declare template arguments when concepts are available. I consider <code>auto</code> to be equivalent to writing <code>typename T</code> without any useful information about the requirements of the type. This is okay, but only in situations where you mean that the variable could be any type and behave correctly (such as the argument of <code>std::move</code>).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-18305</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Wed, 09 Apr 2014 02:54:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-18305</guid>
					<description><![CDATA[It&#039;s an X.  When used to declare a variable, auto does not deduce to a reference.  You need to explicitly include the &#038;.  If you write it as auto &#038;, then you get X &#038;.  If myDeque were a const deque, then auto &#038; would result in X const &#038;.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s an X.  When used to declare a variable, auto does not deduce to a reference.  You need to explicitly include the &amp;.  If you write it as auto &amp;, then you get X &amp;.  If myDeque were a const deque, then auto &amp; would result in X const &amp;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Richard Hodges				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-18127</link>
		<dc:creator><![CDATA[Richard Hodges]]></dc:creator>
		<pubDate>Fri, 04 Apr 2014 14:22:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-18127</guid>
					<description><![CDATA[Hi Herb, thanks for the informative and well presented site.

C++11 question du jour:
given:
[code]
struct X { ... };
auto myDeque = std::deque&#060;X&#062; {};
myDequeue.emplace_back( X{} };
auto x = myDequeue.front()
[/code]

question 1:
What type is x?
a) an X ?
b) an X&#038; ?
c) a const X&#038; ?

question 2:
Where is the rule book on this?]]></description>
		<content:encoded><![CDATA[<p>Hi Herb, thanks for the informative and well presented site.</p>
<p>C++11 question du jour:<br />
given:</p>
<pre class="brush: plain; title: ; notranslate">
struct X { ... };
auto myDeque = std::deque&lt;X&gt; {};
myDequeue.emplace_back( X{} };
auto x = myDequeue.front()
</pre>
<p>question 1:<br />
What type is x?<br />
a) an X ?<br />
b) an X&amp; ?<br />
c) a const X&amp; ?</p>
<p>question 2:<br />
Where is the rule book on this?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nh				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-17278</link>
		<dc:creator><![CDATA[nh]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 17:56:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-17278</guid>
					<description><![CDATA[@Norbert What I&#039;d really like to see with auto return type detection would be the ability to return a local struct. This would nicely encapsulate &quot;multiple return types&quot;, where you currently have to pass things in by reference or return a tuple and use tie, which is icky.

[code]

#include &#060;tuple&#062;

bool func1(int input, int&#038; output)
{
	output = input;

	return true;
}

std::tuple&#060;bool, int&#062; func2(int input)
{
	return std::make_tuple(true, input);
}


auto func3(int input) // Not actual C++
{
	struct ret { bool success; int output; };

	return ret{true, input};
}

int main()
{
	{
		int output;

		if (func1(5, output))
		{
			// ...
		}
	}

	{
		bool success;
		int output;

		std::tie(success, output) = func2(5);

		if (success)
		{
			// ...
		}
	}

	{
		auto data = func3(5);

		if (data.success) // :)
		{
			// ...
		}
	}
}

[/code]

Perhaps the local struct could even have a bool conversion operator for success or inherit one from another class. IIRC there are currently limits on local classes (no template members) so this might open up a whole other can of worms.]]></description>
		<content:encoded><![CDATA[<p>@Norbert What I&#8217;d really like to see with auto return type detection would be the ability to return a local struct. This would nicely encapsulate &#8220;multiple return types&#8221;, where you currently have to pass things in by reference or return a tuple and use tie, which is icky.</p>
<pre class="brush: plain; title: ; notranslate">

#include &lt;tuple&gt;

bool func1(int input, int&amp; output)
{
	output = input;

	return true;
}

std::tuple&lt;bool, int&gt; func2(int input)
{
	return std::make_tuple(true, input);
}


auto func3(int input) // Not actual C++
{
	struct ret { bool success; int output; };

	return ret{true, input};
}

int main()
{
	{
		int output;

		if (func1(5, output))
		{
			// ...
		}
	}

	{
		bool success;
		int output;

		std::tie(success, output) = func2(5);

		if (success)
		{
			// ...
		}
	}

	{
		auto data = func3(5);

		if (data.success) // :)
		{
			// ...
		}
	}
}

</pre>
<p>Perhaps the local struct could even have a bool conversion operator for success or inherit one from another class. IIRC there are currently limits on local classes (no template members) so this might open up a whole other can of worms.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Declaration and initialization with auto &#124; Feheren Fekete				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-13971</link>
		<dc:creator><![CDATA[Declaration and initialization with auto &#124; Feheren Fekete]]></dc:creator>
		<pubDate>Tue, 31 Dec 2013 13:57:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-13971</guid>
					<description><![CDATA[[&#8230;] https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/ [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] <a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/" rel="nofollow">https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/</a> [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: void*				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-13890</link>
		<dc:creator><![CDATA[void*]]></dc:creator>
		<pubDate>Fri, 20 Dec 2013 10:46:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-13890</guid>
					<description><![CDATA[We have been trying to define a good strategy for the use of auto for a customer&#039;s C++11 guidelines. Researching we found these nice three GotWs about auto. :) Thanks for those!

Trying to consequently use auto for local variables we ran into three situations where it does not work nicely:

[code]
#include &#060;vector&#062;


class foo_t
{
public:
   foo_t() {}

   foo_t( const foo_t&#038; ) = delete;

   void bar() const {}
};


int main()
{
   // example 1: doesn&#039;t work for pointer types
   // auto i_ptr = int*{};

   // like this it&#039;s fine
   typedef int* int_ptr_t;
   auto i_ptr_2 = int_ptr_t{};


   // example 2: doesn&#039;t work for non-copyable classes
   // compiles with VS2013, but I think it shouldn&#039;t (g++ doesn&#039;t like it)
   //auto foo = foo_t{};


   // example 3: auto does worse than manually written code can
   std::vector&#060; foo_t* &#062; foo_ptrs;

   // foo is not as const as it could be (only foo_t* const, could be const foo_t* const)
   for( const auto foo : foo_ptrs )
   {
      foo-&#062;bar();
   }

   // better because it&#039;s &#034;more&#034; const
   for( const foo_t* const foo: foo_ptrs )
   {
      foo-&#062;bar();
   }
}
[/code]

- The pointer example is an edge case. Probably don&#039;t need this very much in C++-code (and there&#039;s a work around).
- Having non-copyable objects is more relevant though. I regularly see that...probably thanks to Scott Meyers (Effective C++, Item 6: Explicitly disallow the use of compiler-generated functions you do not want).
- The third situations occurs quite often in legacy code and it just runs against Effective C++, Item 3: Use const whenever possible

Any thoughts/comments about these three cases?

Best regards
Wolfgang Petroschka]]></description>
		<content:encoded><![CDATA[<p>We have been trying to define a good strategy for the use of auto for a customer&#8217;s C++11 guidelines. Researching we found these nice three GotWs about auto. :) Thanks for those!</p>
<p>Trying to consequently use auto for local variables we ran into three situations where it does not work nicely:</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;vector&gt;


class foo_t
{
public:
   foo_t() {}

   foo_t( const foo_t&amp; ) = delete;

   void bar() const {}
};


int main()
{
   // example 1: doesn't work for pointer types
   // auto i_ptr = int*{};

   // like this it's fine
   typedef int* int_ptr_t;
   auto i_ptr_2 = int_ptr_t{};


   // example 2: doesn't work for non-copyable classes
   // compiles with VS2013, but I think it shouldn't (g++ doesn't like it)
   //auto foo = foo_t{};


   // example 3: auto does worse than manually written code can
   std::vector&lt; foo_t* &gt; foo_ptrs;

   // foo is not as const as it could be (only foo_t* const, could be const foo_t* const)
   for( const auto foo : foo_ptrs )
   {
      foo-&gt;bar();
   }

   // better because it's &quot;more&quot; const
   for( const foo_t* const foo: foo_ptrs )
   {
      foo-&gt;bar();
   }
}
</pre>
<p>&#8211; The pointer example is an edge case. Probably don&#8217;t need this very much in C++-code (and there&#8217;s a work around).<br />
&#8211; Having non-copyable objects is more relevant though. I regularly see that&#8230;probably thanks to Scott Meyers (Effective C++, Item 6: Explicitly disallow the use of compiler-generated functions you do not want).<br />
&#8211; The third situations occurs quite often in legacy code and it just runs against Effective C++, Item 3: Use const whenever possible</p>
<p>Any thoughts/comments about these three cases?</p>
<p>Best regards<br />
Wolfgang Petroschka</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: White Wolf				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-13860</link>
		<dc:creator><![CDATA[White Wolf]]></dc:creator>
		<pubDate>Mon, 16 Dec 2013 20:54:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-13860</guid>
					<description><![CDATA[Does &quot;AAA&quot; come with a 12 step program?  I guess using &#039;auto&#039; is already means trusting a higher power... ;)]]></description>
		<content:encoded><![CDATA[<p>Does &#8220;AAA&#8221; come with a 12 step program?  I guess using &#8216;auto&#8217; is already means trusting a higher power&#8230; ;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++1y Automatic Type Deduction &#124; Bulldozer00&#039;s Blog				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-13785</link>
		<dc:creator><![CDATA[C++1y Automatic Type Deduction &#124; Bulldozer00&#039;s Blog]]></dc:creator>
		<pubDate>Wed, 11 Dec 2013 06:01:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-13785</guid>
					<description><![CDATA[[&#8230;] For a more in depth treatment of C++11&#8242;s automatic type deduction capability, check out Herb Sutter&#8217;s masterful post on the new AAA (Almost Always Auto) idiom. [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] For a more in depth treatment of C++11&#8242;s automatic type deduction capability, check out Herb Sutter&#8217;s masterful post on the new AAA (Almost Always Auto) idiom. [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Yongwei Wu				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-13294</link>
		<dc:creator><![CDATA[Yongwei Wu]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 14:26:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-13294</guid>
					<description><![CDATA[People already mentioned searchability, but that is only part of tool support. There are others. For example, ctags is a popular tool used with editors like Vim: I bet it does not support the new syntax well. Even compilers like VC 2012, which I currently use, do not support all the needed language features.]]></description>
		<content:encoded><![CDATA[<p>People already mentioned searchability, but that is only part of tool support. There are others. For example, ctags is a popular tool used with editors like Vim: I bet it does not support the new syntax well. Even compilers like VC 2012, which I currently use, do not support all the needed language features.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Automatically Made Weak &#124; Backwards Incompatibilities				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-13210</link>
		<dc:creator><![CDATA[Automatically Made Weak &#124; Backwards Incompatibilities]]></dc:creator>
		<pubDate>Tue, 12 Nov 2013 19:07:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-13210</guid>
					<description><![CDATA[[&#8230;] been experimenting with the new “auto everything” style in C++. I also make regular use of std::weak_ptr, often when passing a lambda to be evaluated [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] been experimenting with the new “auto everything” style in C++. I also make regular use of std::weak_ptr, often when passing a lambda to be evaluated [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gabor Fekete				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12334</link>
		<dc:creator><![CDATA[Gabor Fekete]]></dc:creator>
		<pubDate>Fri, 30 Aug 2013 15:55:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12334</guid>
					<description><![CDATA[@Ralph Tandetzky: You can also say &quot;for (auto i = 0u; i &#060; v.size(); ++i) {}&#034;. Notice the &#034;u&#034; after the &#034;0&#034;!]]></description>
		<content:encoded><![CDATA[<p>@Ralph Tandetzky: You can also say &#8220;for (auto i = 0u; i &lt; v.size(); ++i) {}&quot;. Notice the &quot;u&quot; after the &quot;0&quot;!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter GotW94: AAA Style (Almost Always Auto) &#124; musingstudio				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12227</link>
		<dc:creator><![CDATA[Herb Sutter GotW94: AAA Style (Almost Always Auto) &#124; musingstudio]]></dc:creator>
		<pubDate>Mon, 19 Aug 2013 07:53:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12227</guid>
					<description><![CDATA[[&#8230;] Sutter&#8217;s Guru of the Week article on Almost Always Auto is a tour de force covering everything you always wanted to know about [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter&#8217;s Guru of the Week article on Almost Always Auto is a tour de force covering everything you always wanted to know about [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12196</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Fri, 16 Aug 2013 09:05:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12196</guid>
					<description><![CDATA[Some feedback from the trenches: I love auto. I use it all the time. It&#039;s convenient. It simplifies refactoring. It&#039;s useful in templated and non-templated code as well. Im using the &lt;code&gt; auto x = init; &lt;/code&gt; type of initialization all the time. However, I tried the &lt;code&gt; auto x = type{init}; &lt;/code&gt; syntax for a while and find it slightly less convenient compared to &lt;code&gt; type x = init &lt;/code&gt;. I find it more pragmatic to use this in order to say &quot;I wanna commit to a specific type&quot; while possibly getting a conversion operation there. It avoids the restriction to use movable types only (which can be quite a challenge outside the standard library). Whenever I do not need to commit to a specific type I **prefer** to use &lt;code&gt; auto &lt;/code&gt;. I&#039;m not a great fan of saying &quot;always&quot; here. 

Most of the time I use &lt;code&gt; auto &lt;/code&gt;, I&#039;m actually using &lt;code&gt; const auto &lt;/code&gt; which gives me a bunch of single static assignments in my code. This is nice, because I can use a const variable as an equivalent to the expression on the right hand side and it makes the code very easy to reason about. At the same time I don&#039;t need to care about the type of the right hand side. These two keywords are an awesome combination!

One more thing: I found it quite annoying to get compiler warnings when I write stuff like this:
[code] for ( auto i = 0; i &#060; v.size(); ++i ) {...} [/code]
It warns me that I get a comparison between a signed and an unsigned type. This is one of the places where I prefer to write &lt;code&gt; size_t &lt;/code&gt; instead of &lt;code&gt; auto &lt;/code&gt;. 

Thanks for the many insightful posts. Keep it up!]]></description>
		<content:encoded><![CDATA[<p>Some feedback from the trenches: I love auto. I use it all the time. It&#8217;s convenient. It simplifies refactoring. It&#8217;s useful in templated and non-templated code as well. Im using the <code> auto x = init; </code> type of initialization all the time. However, I tried the <code> auto x = type{init}; </code> syntax for a while and find it slightly less convenient compared to <code> type x = init </code>. I find it more pragmatic to use this in order to say &#8220;I wanna commit to a specific type&#8221; while possibly getting a conversion operation there. It avoids the restriction to use movable types only (which can be quite a challenge outside the standard library). Whenever I do not need to commit to a specific type I **prefer** to use <code> auto </code>. I&#8217;m not a great fan of saying &#8220;always&#8221; here. </p>
<p>Most of the time I use <code> auto </code>, I&#8217;m actually using <code> const auto </code> which gives me a bunch of single static assignments in my code. This is nice, because I can use a const variable as an equivalent to the expression on the right hand side and it makes the code very easy to reason about. At the same time I don&#8217;t need to care about the type of the right hand side. These two keywords are an awesome combination!</p>
<p>One more thing: I found it quite annoying to get compiler warnings when I write stuff like this:</p>
<pre class="brush: plain; title: ; notranslate"> for ( auto i = 0; i &lt; v.size(); ++i ) {...} </pre>
<p>It warns me that I get a comparison between a signed and an unsigned type. This is one of the places where I prefer to write <code> size_t </code> instead of <code> auto </code>. </p>
<p>Thanks for the many insightful posts. Keep it up!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Cassio Neri				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12194</link>
		<dc:creator><![CDATA[Cassio Neri]]></dc:creator>
		<pubDate>Fri, 16 Aug 2013 06:02:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12194</guid>
					<description><![CDATA[On &quot;auto x = init; [...] It [...] guarantees that no implicit conversions [...] will occur.&quot; Well, array-to-pointer and function-to-pointer conversions might occur. These conversions are, surely, efficient (loosely speaking they are &quot;compile-time conversions&quot;) and, I believe, no other conversion might occur.

[code]

  int a[3] = {};
  a = nullptr; // invalid: type of a is int[3] 
  
  auto b = a;
  b = nullptr; // OK     : type of b is int*
  
  auto&#038; c = a;
  c = nullptr; // invalid: type of c is int(&#038;)[3]

  // ...
  
  void f();
  f = nullptr; // invalid: type of f is void()
  
  auto g = f;
  g = nullptr; // OK     : type of g is void(*)()
  
  auto&#038; h = f;
  h = nullptr; // invalid: type of h is void(&#038;)() 

[/code]

I think it&#039;s also worth mentionning that qualifications are not preserved (especially because they are often mistaken as conversions):

[code]

  int const i = 0; // or &#034;auto const i = 0;&#034; :-)
  i = 1;       // invalid: i is const
  
  auto j = i;
  j = 1;       // OK     : j is not const
  
  auto const k = i;
  k = 1:       // invalid: k is const

[/code]]]></description>
		<content:encoded><![CDATA[<p>On &#8220;auto x = init; [&#8230;] It [&#8230;] guarantees that no implicit conversions [&#8230;] will occur.&#8221; Well, array-to-pointer and function-to-pointer conversions might occur. These conversions are, surely, efficient (loosely speaking they are &#8220;compile-time conversions&#8221;) and, I believe, no other conversion might occur.</p>
<pre class="brush: plain; title: ; notranslate">

  int a[3] = {};
  a = nullptr; // invalid: type of a is int[3] 
  
  auto b = a;
  b = nullptr; // OK     : type of b is int*
  
  auto&amp; c = a;
  c = nullptr; // invalid: type of c is int(&amp;)[3]

  // ...
  
  void f();
  f = nullptr; // invalid: type of f is void()
  
  auto g = f;
  g = nullptr; // OK     : type of g is void(*)()
  
  auto&amp; h = f;
  h = nullptr; // invalid: type of h is void(&amp;)() 

</pre>
<p>I think it&#8217;s also worth mentionning that qualifications are not preserved (especially because they are often mistaken as conversions):</p>
<pre class="brush: plain; title: ; notranslate">

  int const i = 0; // or &quot;auto const i = 0;&quot; :-)
  i = 1;       // invalid: i is const
  
  auto j = i;
  j = 1;       // OK     : j is not const
  
  auto const k = i;
  k = 1:       // invalid: k is const

</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alex Turbov				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12191</link>
		<dc:creator><![CDATA[Alex Turbov]]></dc:creator>
		<pubDate>Thu, 15 Aug 2013 22:17:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12191</guid>
					<description><![CDATA[I&#039;m curious, how it is supposed to use auto for classes w/o copy/move constructors? For example if it contains std::atomic type and the only constructor with some parameters.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m curious, how it is supposed to use auto for classes w/o copy/move constructors? For example if it contains std::atomic type and the only constructor with some parameters.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Bielecki				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12190</link>
		<dc:creator><![CDATA[Bartosz Bielecki]]></dc:creator>
		<pubDate>Thu, 15 Aug 2013 17:42:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12190</guid>
					<description><![CDATA[@ned I believe the non-searchability isn&#039;t that bad if you consider that at least the interfaces of the classes/functions will have to explicitly state the type. Because of that I am not a big fan of the auto-deduced type of non-template functions. Also if you use the &quot;auto f = Foo{ sth. }&quot; you will still be able to find the usages of your class in your codebase.]]></description>
		<content:encoded><![CDATA[<p>@ned I believe the non-searchability isn&#8217;t that bad if you consider that at least the interfaces of the classes/functions will have to explicitly state the type. Because of that I am not a big fan of the auto-deduced type of non-template functions. Also if you use the &#8220;auto f = Foo{ sth. }&#8221; you will still be able to find the usages of your class in your codebase.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12189</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 15 Aug 2013 15:29:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12189</guid>
					<description><![CDATA[@J Guy Davidson: Actually, I also noticed that the example isn&#039;t really relevant because it has nothing to do with auto -- taking the address of an overloaded function and storing it directly in function is problematic with or without the auto style syntax, so I’ve removed the example.]]></description>
		<content:encoded><![CDATA[<p>@J Guy Davidson: Actually, I also noticed that the example isn&#8217;t really relevant because it has nothing to do with auto &#8212; taking the address of an overloaded function and storing it directly in function is problematic with or without the auto style syntax, so I’ve removed the example.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris Vine				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12186</link>
		<dc:creator><![CDATA[Chris Vine]]></dc:creator>
		<pubDate>Thu, 15 Aug 2013 10:36:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12186</guid>
					<description><![CDATA[I doubt the &#039;auto x = type{ init };&#039; style, in place of the standard &#039;type x{init};&#039;, is going to catch on.  This is because, as noted, it cannot be used with types which are neither copyable nor movable, so it cannot be used universally.  I discount the fact that (to me) it looks plain odd, because that can pass with usage and familiarity.

The standard C++ library tries hard to make as many aggregate types as are reasonable movable, but in user code I commonly come across, and write, there are often types which are neither copyable nor movable.  There are a number of reasons for this: two types may be closely coupled as part of a single implementation, so objects of those types may hold references to each other.  Trying to track which object happens to own some movable resource in such cases is often far more trouble (and introduces more inefficiency) than it is worth.  Efficient movability also implies constructing the internal implementation data of aggregates on free store so the data can easily be moved by swapping pointers.  However where efficiency is at a premium for objects likely to be constructed on the stack and unlikely to be moved, constructing things like arrays with known sizes at compile time may be desirable, and member arrays of aggregates (or std::array objects) can only be copied in linear time and not moved.  In those cases you may want to prohibit copying/moving entirely.  Users who in a particular case want to move and are willing to take the hit of allocation can call make_unique() for the unmovable type in user code where they really want to.

Lastly of course, prohibiting moving and copying may be necessary to enforce the thread-safe use of some objects at reasonable cost.  And some objects cannot semantically properly support moving (the article mentions locks, but there are many others).]]></description>
		<content:encoded><![CDATA[<p>I doubt the &#8216;auto x = type{ init };&#8217; style, in place of the standard &#8216;type x{init};&#8217;, is going to catch on.  This is because, as noted, it cannot be used with types which are neither copyable nor movable, so it cannot be used universally.  I discount the fact that (to me) it looks plain odd, because that can pass with usage and familiarity.</p>
<p>The standard C++ library tries hard to make as many aggregate types as are reasonable movable, but in user code I commonly come across, and write, there are often types which are neither copyable nor movable.  There are a number of reasons for this: two types may be closely coupled as part of a single implementation, so objects of those types may hold references to each other.  Trying to track which object happens to own some movable resource in such cases is often far more trouble (and introduces more inefficiency) than it is worth.  Efficient movability also implies constructing the internal implementation data of aggregates on free store so the data can easily be moved by swapping pointers.  However where efficiency is at a premium for objects likely to be constructed on the stack and unlikely to be moved, constructing things like arrays with known sizes at compile time may be desirable, and member arrays of aggregates (or std::array objects) can only be copied in linear time and not moved.  In those cases you may want to prohibit copying/moving entirely.  Users who in a particular case want to move and are willing to take the hit of allocation can call make_unique() for the unmovable type in user code where they really want to.</p>
<p>Lastly of course, prohibiting moving and copying may be necessary to enforce the thread-safe use of some objects at reasonable cost.  And some objects cannot semantically properly support moving (the article mentions locks, but there are many others).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: J Guy Davidson				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12185</link>
		<dc:creator><![CDATA[J Guy Davidson]]></dc:creator>
		<pubDate>Thu, 15 Aug 2013 09:52:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12185</guid>
					<description><![CDATA[Excellent arguments.  However, unless I don&#039;t understand std::function or these chaps http://en.cppreference.com/w/cpp/utility/functional/function have got it wrong, there&#039;s a misspelling in the last line of your third code block in section 6.
[code]auto f = function&#060;int()&#062;{ &#038;func };   // ok[/code]
should be 
[code]auto f = function&#060;void(int)&#062;{ &#038;func };   // ok[/code]]]></description>
		<content:encoded><![CDATA[<p>Excellent arguments.  However, unless I don&#8217;t understand std::function or these chaps <a href="http://en.cppreference.com/w/cpp/utility/functional/function" rel="nofollow">http://en.cppreference.com/w/cpp/utility/functional/function</a> have got it wrong, there&#8217;s a misspelling in the last line of your third code block in section 6.</p>
<pre class="brush: plain; title: ; notranslate">auto f = function&lt;int()&gt;{ &amp;func };   // ok</pre>
<p>should be </p>
<pre class="brush: plain; title: ; notranslate">auto f = function&lt;void(int)&gt;{ &amp;func };   // ok</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mark Garcia				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12174</link>
		<dc:creator><![CDATA[Mark Garcia]]></dc:creator>
		<pubDate>Wed, 14 Aug 2013 07:55:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12174</guid>
					<description><![CDATA[With all the issues about the readability of the type of an &quot;autoed&quot; variable, we must see that what is more important is not the variable itself, but instead its initializer. Consider this somehow innocuous piece of code

[code]
auto result = make_something();
result.do_something();
send_something(result);
[/code]

Long story short, by using auto, we are emphasizing the initializer, as the initializer is the one who gives the actual type of its result. By emphasizing the initializer, we are emphasizing the operation(s) involved in the initializer. In the above code, make_something() is actually the one who is more important. It is a clear statement that &quot;we are making something, then return some result&quot;. But this is just for the functional programming part...

Now you may (and you will) argue &quot;Hey! We are now in an OOP world! result there would almost always be an instance of some class. make_something() wouldn&#039;t matter if doesn&#039;t clearly know what we can do with result.&quot;

&quot;what we can do&quot;
&quot;can&quot;

What should you do? &quot;Where do you want to go today?&quot; not &quot;Where can I go today?&quot;. &quot;What operations should I do?&quot; not &quot;What operations can I do?&quot;. A good thing with OOP is that we are encapsulating data with operations. The operations that we do is what matters. But what matters most is what operations we _should_ do. (You may see that it&#039;s analogous to test-driven development.)

With the line &lt;code&gt;result.do_something();&lt;/code&gt;, we are not focusing on what result is (i.e. what&#039;s its exact type), but instead, we focus more on the operation. Sometimes we think it the wrong way with OOP. With its syntax we often we read that line as &quot;result, do_something()&quot; (emphasis on the object) where instead it should be &quot;do_something() with result&quot; (emphasis on the operation). Now you are seeing some reasoning template library authors usually have. These are the properties of templates, of generic code. And now, we can enjoy it in non-template, &quot;daily&quot; code.

My own sentiment with auto is a very positive one. As said, it brings much generic code goodies without writing inside a template at all. Most importantly, it makes your code emphasize more on the operations, something we&#039;ve been taking for granted for the past few years.]]></description>
		<content:encoded><![CDATA[<p>With all the issues about the readability of the type of an &#8220;autoed&#8221; variable, we must see that what is more important is not the variable itself, but instead its initializer. Consider this somehow innocuous piece of code</p>
<pre class="brush: plain; title: ; notranslate">
auto result = make_something();
result.do_something();
send_something(result);
</pre>
<p>Long story short, by using auto, we are emphasizing the initializer, as the initializer is the one who gives the actual type of its result. By emphasizing the initializer, we are emphasizing the operation(s) involved in the initializer. In the above code, make_something() is actually the one who is more important. It is a clear statement that &#8220;we are making something, then return some result&#8221;. But this is just for the functional programming part&#8230;</p>
<p>Now you may (and you will) argue &#8220;Hey! We are now in an OOP world! result there would almost always be an instance of some class. make_something() wouldn&#8217;t matter if doesn&#8217;t clearly know what we can do with result.&#8221;</p>
<p>&#8220;what we can do&#8221;<br />
&#8220;can&#8221;</p>
<p>What should you do? &#8220;Where do you want to go today?&#8221; not &#8220;Where can I go today?&#8221;. &#8220;What operations should I do?&#8221; not &#8220;What operations can I do?&#8221;. A good thing with OOP is that we are encapsulating data with operations. The operations that we do is what matters. But what matters most is what operations we _should_ do. (You may see that it&#8217;s analogous to test-driven development.)</p>
<p>With the line <code>result.do_something();</code>, we are not focusing on what result is (i.e. what&#8217;s its exact type), but instead, we focus more on the operation. Sometimes we think it the wrong way with OOP. With its syntax we often we read that line as &#8220;result, do_something()&#8221; (emphasis on the object) where instead it should be &#8220;do_something() with result&#8221; (emphasis on the operation). Now you are seeing some reasoning template library authors usually have. These are the properties of templates, of generic code. And now, we can enjoy it in non-template, &#8220;daily&#8221; code.</p>
<p>My own sentiment with auto is a very positive one. As said, it brings much generic code goodies without writing inside a template at all. Most importantly, it makes your code emphasize more on the operations, something we&#8217;ve been taking for granted for the past few years.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/#comment-12170</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Wed, 14 Aug 2013 02:16:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2230#comment-12170</guid>
					<description><![CDATA[I didn&#039;t quite follow why &quot;auto e = employee{empid};&quot; is better than &quot;employee e{empid};&quot;. It&#039;s more typing which is a (tiny) negative. Is it just for consistency with other declarations?]]></description>
		<content:encoded><![CDATA[<p>I didn&#8217;t quite follow why &#8220;auto e = employee{empid};&#8221; is better than &#8220;employee e{empid};&#8221;. It&#8217;s more typing which is a (tiny) negative. Is it just for consistency with other declarations?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
