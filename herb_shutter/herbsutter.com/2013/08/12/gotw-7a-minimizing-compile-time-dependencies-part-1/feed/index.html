<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #7a: Minimizing Compile-Time Dependencies, Part 1	</title>
	<atom:link href="https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12230</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 19 Aug 2013 10:30:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12230</guid>
					<description><![CDATA[@Gennaro: Yes, I&#039;ll add a note to be clear it&#039;s okay to replace #include with a forward declaration.

All: Remember to use [code][/code] for code blocks, or escape those pesky characters using &quot;&#038; l t ;&quot; and &quot;&#038; g t ;&quot;. Sorry, it&#039;s a WordPress thing.]]></description>
		<content:encoded><![CDATA[<p>@Gennaro: Yes, I&#8217;ll add a note to be clear it&#8217;s okay to replace #include with a forward declaration.</p>
<p>All: Remember to use  for code blocks, or escape those pesky characters using &#8220;&amp; l t ;&#8221; and &#8220;&amp; g t ;&#8221;. Sorry, it&#8217;s a WordPress thing.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Norm				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12199</link>
		<dc:creator><![CDATA[Norm]]></dc:creator>
		<pubDate>Fri, 16 Aug 2013 19:00:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12199</guid>
					<description><![CDATA[It appears something is drastically removing things from peoples comments. 
A lot of them are saying remove #include and nothing after.
like this

To the includes:
#include
#include]]></description>
		<content:encoded><![CDATA[<p>It appears something is drastically removing things from peoples comments.<br />
A lot of them are saying remove #include and nothing after.<br />
like this</p>
<p>To the includes:<br />
#include<br />
#include</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul Omta				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12198</link>
		<dc:creator><![CDATA[Paul Omta]]></dc:creator>
		<pubDate>Fri, 16 Aug 2013 14:22:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12198</guid>
					<description><![CDATA[Guru question #2.

* Replace iostream and ostream include with an include of iosfwd. I forgot where I read this, but this neat trick avoids including the heavy iostream header.

* Remove c.h and e.h, as previously stated. These can be replaced with forward declarations.

* d.h and list includes can be removed if one uses Herb&#039;s own Private Implementation Pattern, but from the wording of the question, this seems out of scope of the question. It would require a change in the class itself.]]></description>
		<content:encoded><![CDATA[<p>Guru question #2.</p>
<p>* Replace iostream and ostream include with an include of iosfwd. I forgot where I read this, but this neat trick avoids including the heavy iostream header.</p>
<p>* Remove c.h and e.h, as previously stated. These can be replaced with forward declarations.</p>
<p>* d.h and list includes can be removed if one uses Herb&#8217;s own Private Implementation Pattern, but from the wording of the question, this seems out of scope of the question. It would require a change in the class itself.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johannes Schaub (litb)				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12179</link>
		<dc:creator><![CDATA[Johannes Schaub (litb)]]></dc:creator>
		<pubDate>Wed, 14 Aug 2013 22:45:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12179</guid>
					<description><![CDATA[There&#039;s another detail for class &quot;C&quot;. Since &quot;A&quot; has virtual functions, and we don&#039;t know which, we must assume that &quot;A::g( B )&quot; might be virtual. If so, for the worstcase scenario we need to include &quot;C&quot; because the return type in the overridden function might differ from &quot;C&#038;&quot; (if C is a derived class of it, covariance).]]></description>
		<content:encoded><![CDATA[<p>There&#8217;s another detail for class &#8220;C&#8221;. Since &#8220;A&#8221; has virtual functions, and we don&#8217;t know which, we must assume that &#8220;A::g( B )&#8221; might be virtual. If so, for the worstcase scenario we need to include &#8220;C&#8221; because the return type in the overridden function might differ from &#8220;C&amp;&#8221; (if C is a derived class of it, covariance).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mark				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12178</link>
		<dc:creator><![CDATA[Mark]]></dc:creator>
		<pubDate>Wed, 14 Aug 2013 20:17:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12178</guid>
					<description><![CDATA[You can get rid of all of them if you parameterise the entire class.]]></description>
		<content:encoded><![CDATA[<p>You can get rid of all of them if you parameterise the entire class.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kostas Dritsas				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12166</link>
		<dc:creator><![CDATA[Kostas Dritsas]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 17:34:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12166</guid>
					<description><![CDATA[Sorry, in my first sentence, i wanted to say: we remove header , we leave header ]]></description>
		<content:encoded><![CDATA[<p>Sorry, in my first sentence, i wanted to say: we remove header , we leave header </p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kostas Dritsas				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12165</link>
		<dc:creator><![CDATA[Kostas Dritsas]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 17:31:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12165</guid>
					<description><![CDATA[First, i assume all header files use proper include guards. 

*Here, the header  can be removed, because the function std::ostream&#038; operator&#060;&#060;( std::ostream&#038; os, const X&#038; x ) uses std::ostream object (typedef basic_ostream ostream, actually) so we can leave only the  header.

*From the class E, the header x.h uses the result and argument type; therefore its header file can be removed.

*A virtual table is a global variable declared implicitly for each class with at least one virtual function. So i think we should leave there the header &quot;c.h&quot;, otherwise the virtual table can&#039;t be created.

*Definitely we ween the header file , because of the private object clist. 
*The same applies for the header &quot;d.h&quot;. (we need it, we construct the object d_ inside class X

*Class A has at least one virtual function, i understand it has one function declaration in it:  virtual std::ostream&#038; print( std::ostream&#038; ) const; it is overloaded by the function std::ostream&#038; class X::print( std::ostream&#038; ) const; 
Moreover, function std::ostream&#038; operator&#060;&#060;( std::ostream&#038; os, const X&#038; x ) calls function: print( std::ostream&#038; ); and object x can be of type either &#034;class X&#034; or &#034;class A&#034;, so i would leave the header a.h]]></description>
		<content:encoded><![CDATA[<p>First, i assume all header files use proper include guards. </p>
<p>*Here, the header  can be removed, because the function std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) uses std::ostream object (typedef basic_ostream ostream, actually) so we can leave only the  header.</p>
<p>*From the class E, the header x.h uses the result and argument type; therefore its header file can be removed.</p>
<p>*A virtual table is a global variable declared implicitly for each class with at least one virtual function. So i think we should leave there the header &#8220;c.h&#8221;, otherwise the virtual table can&#8217;t be created.</p>
<p>*Definitely we ween the header file , because of the private object clist.<br />
*The same applies for the header &#8220;d.h&#8221;. (we need it, we construct the object d_ inside class X</p>
<p>*Class A has at least one virtual function, i understand it has one function declaration in it:  virtual std::ostream&amp; print( std::ostream&amp; ) const; it is overloaded by the function std::ostream&amp; class X::print( std::ostream&amp; ) const;<br />
Moreover, function std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) calls function: print( std::ostream&amp; ); and object x can be of type either &quot;class X&quot; or &quot;class A&quot;, so i would leave the header a.h</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12164</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 17:09:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12164</guid>
					<description><![CDATA[Agree too many includes is a bad thing but does the use of precompiled headers containing a lot of headers perhaps favour more than less? i.e you might have a lot of includes precompiled but is this better than fewer but not precompiled.   Spending a lot of time working out what to remove is also costly in time.]]></description>
		<content:encoded><![CDATA[<p>Agree too many includes is a bad thing but does the use of precompiled headers containing a lot of headers perhaps favour more than less? i.e you might have a lot of includes precompiled but is this better than fewer but not precompiled.   Spending a lot of time working out what to remove is also costly in time.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Victor				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12159</link>
		<dc:creator><![CDATA[Victor]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 13:24:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12159</guid>
					<description><![CDATA[Guru Question: In the following header file, what #include directives could be immediately removed without ill effect? You may not make any changes other than removing or rewriting #include directives. Note that the comments are important.

About std headers: 

1. Including  automatically includes also , , ,  and . So, we don&#039;t need both  and , simple  is enouth. However, there is references only for ostream classes in function declarations - so we don&#039;t need complete ostream type here. (Remember about function declarations). Just use forward declaration from  instead of  and .

2. Including  is needed - we use std::list as data member, so compiler needs complete type information here.

About custom headers:

1. class X is derived from A and B. So, compiler heeds complete type information here, leave &quot;a.h&quot; and &quot;b.h&quot; as is.

2. Class C is a great candidate for further removal, but it&#039;s used in function declaration as parameter with passing by-value. It&#039;s sad, but compiler needs to know about what class C is right here, so complete type is needed, and we leave #include &quot;c.h&quot; in code. Additionally, it is strange that class C has virtual functions, but is passed by-value. Schedule a meet with this code author :)

3. Class D is a data member. So, we need to leave &quot;d.h&quot;

4. Class E is used as return type in function declarations only. It&#039;s strange, but compiler doesn&#039;t need complete type here. AFAIR, it was side effect of C calling convention on x86 compilers. Maybe I&#039;m wrong about why it&#039;s not not needed (please correct me?) but I think, we could change #include &quot;e.h&quot; to forward declaration on class E;
The only thing preventing us from this simple optimization is this exercise statement: We may not make any changes other than removing or rewriting #include directives. So, leave as is.

So, there is result:
[code]
// #include &#060;iostream&#062; - removed
// #include &#060;ostream&#062; - changed to iosfwd
#include &#060;iosfwd&#062;  // placed instead of &#060;ostream&#062;
#include &#060;list&#062;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &#034;a.h&#034;  // class A
#include &#034;b.h&#034;  // class B
#include &#034;c.h&#034;  // class C - candidate for further removal by rewriting &#039;C  f( int, C );&#039; signature and adding forward declaration
#include &#034;d.h&#034;  // class D 
#include &#034;e.h&#034;  // class E - candidate for removal by changing to forward declaration right here and right now.

class X : public A, private B {
public:
       X( const C&#038; );
    B  f( int, char* );
    C  f( int, C );
    C&#038; g( B );
    E  h( E );
    virtual std::ostream&#038; print( std::ostream&#038; ) const;

  private:
    std::list&#060;C&#062; clist;
    D            d_;
  };

std::ostream&#038; operator&#060;&#060;( std::ostream&#038; os, const X&#038; x ) {
    return x.print(os);
}
[/code]

I think, another optimization will result in redesign, so we can&#039;t omit more headers right now.]]></description>
		<content:encoded><![CDATA[<p>Guru Question: In the following header file, what #include directives could be immediately removed without ill effect? You may not make any changes other than removing or rewriting #include directives. Note that the comments are important.</p>
<p>About std headers: </p>
<p>1. Including  automatically includes also , , ,  and . So, we don&#8217;t need both  and , simple  is enouth. However, there is references only for ostream classes in function declarations &#8211; so we don&#8217;t need complete ostream type here. (Remember about function declarations). Just use forward declaration from  instead of  and .</p>
<p>2. Including  is needed &#8211; we use std::list as data member, so compiler needs complete type information here.</p>
<p>About custom headers:</p>
<p>1. class X is derived from A and B. So, compiler heeds complete type information here, leave &#8220;a.h&#8221; and &#8220;b.h&#8221; as is.</p>
<p>2. Class C is a great candidate for further removal, but it&#8217;s used in function declaration as parameter with passing by-value. It&#8217;s sad, but compiler needs to know about what class C is right here, so complete type is needed, and we leave #include &#8220;c.h&#8221; in code. Additionally, it is strange that class C has virtual functions, but is passed by-value. Schedule a meet with this code author :)</p>
<p>3. Class D is a data member. So, we need to leave &#8220;d.h&#8221;</p>
<p>4. Class E is used as return type in function declarations only. It&#8217;s strange, but compiler doesn&#8217;t need complete type here. AFAIR, it was side effect of C calling convention on x86 compilers. Maybe I&#8217;m wrong about why it&#8217;s not not needed (please correct me?) but I think, we could change #include &#8220;e.h&#8221; to forward declaration on class E;<br />
The only thing preventing us from this simple optimization is this exercise statement: We may not make any changes other than removing or rewriting #include directives. So, leave as is.</p>
<p>So, there is result:</p>
<pre class="brush: plain; title: ; notranslate">
// #include &lt;iostream&gt; - removed
// #include &lt;ostream&gt; - changed to iosfwd
#include &lt;iosfwd&gt;  // placed instead of &lt;ostream&gt;
#include &lt;list&gt;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &quot;a.h&quot;  // class A
#include &quot;b.h&quot;  // class B
#include &quot;c.h&quot;  // class C - candidate for further removal by rewriting 'C  f( int, C );' signature and adding forward declaration
#include &quot;d.h&quot;  // class D 
#include &quot;e.h&quot;  // class E - candidate for removal by changing to forward declaration right here and right now.

class X : public A, private B {
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
  };

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</pre>
<p>I think, another optimization will result in redesign, so we can&#8217;t omit more headers right now.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Victor				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12157</link>
		<dc:creator><![CDATA[Victor]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 12:58:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12157</guid>
					<description><![CDATA[Guru Question #2. Many programmers habitually #include many more headers than necessary. Unfortunately, doing so can seriously degrade build times, especially when a popular header file includes too many other headers.

1. Including  automatically includes also , , ,  and .
So,  is not needed. However, don&#039;t fool ourself -  is excess. Actually,  is enough, don&#039;t include .

2. Next step about io streams usage: there is references to streams only. Compiler initially knows reference size for any class, so forward declaration is enough here. Replace streams implementation header  with forward declaration: .

That&#039;s all about std headers - unfortunately, we use std::list as member, so full std::list class definition is needed. Lease  as is.

Class X is derived from A and B, so we need to know what A and B is - leave &quot;a.h&quot; and &quot;b.h&quot;.

Class C is candidate for further header removal, unfortunatelly, it&#039;s passed into function declarations by value, so compiler need to know what is C, what constructors it have, etc. So, draw a sigh and leave &quot;c.h&quot;.

Class D is a data membe - compiler needs D declaration. Leave &quot;d.h&quot;

Class E is used in return type only - that&#039;s good news. Return type might be incomplete type. This may be surprise, AFAIR, it&#039;s good side effect of C calling conversions. I may be wrong in describing why it may be omitted (please correct me?) but I think we can remove &quot;e.h&quot;.

So, we have:

[code]
#include &#060;iosfwd&#062;
#include &#060;list&#062;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &#034;a.h&#034;  // class A
#include &#034;b.h&#034;  // class B
#include &#034;c.h&#034;  // class C - it&#039;s sad to see it here
#include &#034;d.h&#034;  // class D

class X : public A, private B {
public:
       X( const C&#038; );
    B  f( int, char* );
    C  f( int, C );
    C&#038; g( B );
    E  h( E );
    virtual std::ostream&#038; print( std::ostream&#038; ) const;

  private:
    std::list&#060;C&#062; clist;
    D            d_;
  };

std::ostream&#038; operator&#060;&#060;( std::ostream&#038; os, const X&#038; x ) {
    return x.print(os);
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Guru Question #2. Many programmers habitually #include many more headers than necessary. Unfortunately, doing so can seriously degrade build times, especially when a popular header file includes too many other headers.</p>
<p>1. Including  automatically includes also , , ,  and .<br />
So,  is not needed. However, don&#8217;t fool ourself &#8211;  is excess. Actually,  is enough, don&#8217;t include .</p>
<p>2. Next step about io streams usage: there is references to streams only. Compiler initially knows reference size for any class, so forward declaration is enough here. Replace streams implementation header  with forward declaration: .</p>
<p>That&#8217;s all about std headers &#8211; unfortunately, we use std::list as member, so full std::list class definition is needed. Lease  as is.</p>
<p>Class X is derived from A and B, so we need to know what A and B is &#8211; leave &#8220;a.h&#8221; and &#8220;b.h&#8221;.</p>
<p>Class C is candidate for further header removal, unfortunatelly, it&#8217;s passed into function declarations by value, so compiler need to know what is C, what constructors it have, etc. So, draw a sigh and leave &#8220;c.h&#8221;.</p>
<p>Class D is a data membe &#8211; compiler needs D declaration. Leave &#8220;d.h&#8221;</p>
<p>Class E is used in return type only &#8211; that&#8217;s good news. Return type might be incomplete type. This may be surprise, AFAIR, it&#8217;s good side effect of C calling conversions. I may be wrong in describing why it may be omitted (please correct me?) but I think we can remove &#8220;e.h&#8221;.</p>
<p>So, we have:</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;iosfwd&gt;
#include &lt;list&gt;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &quot;a.h&quot;  // class A
#include &quot;b.h&quot;  // class B
#include &quot;c.h&quot;  // class C - it's sad to see it here
#include &quot;d.h&quot;  // class D

class X : public A, private B {
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
  };

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Victor				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12155</link>
		<dc:creator><![CDATA[Victor]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 12:40:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12155</guid>
					<description><![CDATA[JQ #1: For a function or a class, what is the difference between a forward declaration and a definition?

For function: 

Forward declaration specifies function&#039;s return type and signature (parameters, cv-qualifiers if memeber, template parameters if any). It tells compiler about how to call this function, so parameters sizes should be known. Parameter size if known for any pointers, references or for complete types.
Function definition may be treated as declaration, but additionally should contain function body: zero or more statements which will be executed during function call.

For class: 

Class forward declaration provides incomplete type, including class name and template parameters (if any). Note, it doesn&#039;t provide information about inheritance from base classes.
Class definition provides complete type, including instance size (so, data member sizes and definition of base class are needed), declaration of all class methods and template parameters. So, definition provides all necessary information to compiler about what class is and how to use it, with or without function definitions.]]></description>
		<content:encoded><![CDATA[<p>JQ #1: For a function or a class, what is the difference between a forward declaration and a definition?</p>
<p>For function: </p>
<p>Forward declaration specifies function&#8217;s return type and signature (parameters, cv-qualifiers if memeber, template parameters if any). It tells compiler about how to call this function, so parameters sizes should be known. Parameter size if known for any pointers, references or for complete types.<br />
Function definition may be treated as declaration, but additionally should contain function body: zero or more statements which will be executed during function call.</p>
<p>For class: </p>
<p>Class forward declaration provides incomplete type, including class name and template parameters (if any). Note, it doesn&#8217;t provide information about inheritance from base classes.<br />
Class definition provides complete type, including instance size (so, data member sizes and definition of base class are needed), declaration of all class methods and template parameters. So, definition provides all necessary information to compiler about what class is and how to use it, with or without function definitions.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: abrarov				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12154</link>
		<dc:creator><![CDATA[abrarov]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 11:59:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12154</guid>
					<description><![CDATA[[code language=&quot;cpp&quot;]
//  x.h: original header
//

#ifndef X_H
#define X_H
#endif

#if defined(_MSC_VER) &#038;&#038; (_MSC_VER &#062;= 1020)
#pragma once
#endif

#include &#060;iosfwd&#062;
#include &#060;list&#062;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &#034;a.h&#034;  // class A
#include &#034;b.h&#034;  // class B
#include &#034;c.h&#034;  // class C
#include &#034;d.h&#034;  // class D

class E;

class X : public A, private B {
public:
       X(const C&#038;);
    B  f(int, char*);
    C  f(int, C);
    C&#038; g(B);
    E  h(E);
    virtual std::ostream&#038; print(std::ostream&#038;) const;

  private:
    std::list&#060;C&#062; clist;
    D            d_;
};

inline std::ostream&#038; operator&#060;&#060;(std::ostream&#038; os, const X&#038; x) {
    return x.print(os);
}

#endif // !defined(X_H)

[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: cpp; title: ; notranslate">
//  x.h: original header
//

#ifndef X_H
#define X_H
#endif

#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
#pragma once
#endif

#include &lt;iosfwd&gt;
#include &lt;list&gt;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &quot;a.h&quot;  // class A
#include &quot;b.h&quot;  // class B
#include &quot;c.h&quot;  // class C
#include &quot;d.h&quot;  // class D

class E;

class X : public A, private B {
public:
       X(const C&amp;);
    B  f(int, char*);
    C  f(int, C);
    C&amp; g(B);
    E  h(E);
    virtual std::ostream&amp; print(std::ostream&amp;) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
};

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X&amp; x) {
    return x.print(os);
}

#endif // !defined(X_H)

</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marat Abrarov				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12153</link>
		<dc:creator><![CDATA[Marat Abrarov]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 11:57:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12153</guid>
					<description><![CDATA[[code language=&quot;css&quot;]
//  x.h: original header
//

#ifndef X_H
#define X_H
#endif

#if defined(_MSC_VER) &#038;&#038; (_MSC_VER &#062;= 1020)
#pragma once
#endif

#include &#060;iosfwd&#062;
#include &#060;list&#062;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &#034;a.h&#034;  // class A
#include &#034;b.h&#034;  // class B
#include &#034;c.h&#034;  // class C
#include &#034;d.h&#034;  // class D

class E;

class X : public A, private B {
public:
       X(const C&#038;);
    B  f(int, char*);
    C  f(int, C);
    C&#038; g(B);
    E  h(E);
    virtual std::ostream&#038; print(std::ostream&#038;) const;

  private:
    std::list&#060;C&#062; clist;
    D            d_;
};

inline std::ostream&#038; operator&#060;&#060;(std::ostream&#038; os, const X&#038; x) {
    return x.print(os);
}

#endif // !defined(X_H)

[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: css; title: ; notranslate">
//  x.h: original header
//

#ifndef X_H
#define X_H
#endif

#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)
#pragma once
#endif

#include &lt;iosfwd&gt;
#include &lt;list&gt;

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &quot;a.h&quot;  // class A
#include &quot;b.h&quot;  // class B
#include &quot;c.h&quot;  // class C
#include &quot;d.h&quot;  // class D

class E;

class X : public A, private B {
public:
       X(const C&amp;);
    B  f(int, char*);
    C  f(int, C);
    C&amp; g(B);
    E  h(E);
    virtual std::ostream&amp; print(std::ostream&amp;) const;

  private:
    std::list&lt;C&gt; clist;
    D            d_;
};

inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X&amp; x) {
    return x.print(os);
}

#endif // !defined(X_H)

</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marat Abrarov				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12152</link>
		<dc:creator><![CDATA[Marat Abrarov]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 11:53:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12152</guid>
					<description><![CDATA[[code language=&quot;css&quot;][/code]
//  x.h: original header
//

#ifndef X_H
#define X_H
#endif

#if defined(_MSC_VER) &#038;&#038; (_MSC_VER &#062;= 1020)
#pragma once
#endif

#include 
#include 

// None of A, B, C, D or E are templates.
// Only A and C have virtual functions.
#include &quot;a.h&quot;  // class A
#include &quot;b.h&quot;  // class B
#include &quot;c.h&quot;  // class C
#include &quot;d.h&quot;  // class D

class E;

class X : public A, private B {
public:
       X(const C&#038;);
    B  f(int, char*);
    C  f(int, C);
    C&#038; g(B);
    E  h(E);
    virtual std::ostream&#038; print(std::ostream&#038;) const;

  private:
    std::list clist;
    D            d_;
};

inline std::ostream&#038; operator&#060;&#060;(std::ostream&#038; os, const X&#038; x) {
    return x.print(os);
}

#endif // !defined(X_H)

[/ecode]]]></description>
		<content:encoded><![CDATA[<p>//  x.h: original header<br />
//</p>
<p>#ifndef X_H<br />
#define X_H<br />
#endif</p>
<p>#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1020)<br />
#pragma once<br />
#endif</p>
<p>#include<br />
#include </p>
<p>// None of A, B, C, D or E are templates.<br />
// Only A and C have virtual functions.<br />
#include &#8220;a.h&#8221;  // class A<br />
#include &#8220;b.h&#8221;  // class B<br />
#include &#8220;c.h&#8221;  // class C<br />
#include &#8220;d.h&#8221;  // class D</p>
<p>class E;</p>
<p>class X : public A, private B {<br />
public:<br />
       X(const C&amp;);<br />
    B  f(int, char*);<br />
    C  f(int, C);<br />
    C&amp; g(B);<br />
    E  h(E);<br />
    virtual std::ostream&amp; print(std::ostream&amp;) const;</p>
<p>  private:<br />
    std::list clist;<br />
    D            d_;<br />
};</p>
<p>inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X&amp; x) {<br />
    return x.print(os);<br />
}</p>
<p>#endif // !defined(X_H)</p>
<p>[/ecode]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12149</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 10:07:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12149</guid>
					<description><![CDATA[@Gennaro rewriting #include direcitves includes their replacement by forward declarations.

@Alf I am not 100% sure, but wasn&#039;t the requirement on the completely defined template argument type relaxed for auto_ptr? It is for shared_ptr and unique_ptr in C++11

To the includes:
#include 
#include 
 --&#062; replace them by #include 

#include &quot;a.h&quot;  // class A
#include &quot;b.h&quot;  // class B
#include &quot;d.h&quot;  // class D

--&#062; these are needed, as definitions of base classes and direct member variables are always needed (direct as compared to pointer/reference members and instantiated template members that have the class in their argument list)

#include &quot;e.h&quot;  // class E
 --&#062; rewrite this one as forward declaration to class E; as its only used in function parameters and return types 

#include &quot;c.h&quot;  // class C
--&#062; needed. Formally, because the standard demands so for std::list template arguments. Technically at least, because X&#039;s destructor is not declared and thus will be implicitly defined by the compiler, wich will instantiate the destructor for the std::list, wich in turn will destroy its elements, needing access to C::~C]]></description>
		<content:encoded><![CDATA[<p>@Gennaro rewriting #include direcitves includes their replacement by forward declarations.</p>
<p>@Alf I am not 100% sure, but wasn&#8217;t the requirement on the completely defined template argument type relaxed for auto_ptr? It is for shared_ptr and unique_ptr in C++11</p>
<p>To the includes:<br />
#include<br />
#include<br />
 &#8211;&gt; replace them by #include </p>
<p>#include &#8220;a.h&#8221;  // class A<br />
#include &#8220;b.h&#8221;  // class B<br />
#include &#8220;d.h&#8221;  // class D</p>
<p>&#8211;&gt; these are needed, as definitions of base classes and direct member variables are always needed (direct as compared to pointer/reference members and instantiated template members that have the class in their argument list)</p>
<p>#include &#8220;e.h&#8221;  // class E<br />
 &#8211;&gt; rewrite this one as forward declaration to class E; as its only used in function parameters and return types </p>
<p>#include &#8220;c.h&#8221;  // class C<br />
&#8211;&gt; needed. Formally, because the standard demands so for std::list template arguments. Technically at least, because X&#8217;s destructor is not declared and thus will be implicitly defined by the compiler, wich will instantiate the destructor for the std::list, wich in turn will destroy its elements, needing access to C::~C</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anubhav				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12143</link>
		<dc:creator><![CDATA[Anubhav]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 04:05:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12143</guid>
					<description><![CDATA[In accordance with $3.2/4 - 
-&#039;A&#039; and &#039;B&#039; need to be complete types.
-Classes C and E need not be complete, because X does not define (as opposed to declaring) any of it&#039;s member functions, 
-D needs to be complete because class &#039;X&#039; has a member object of type &#039;D&#039;.
-iostream can also be removed as we already include ostream]]></description>
		<content:encoded><![CDATA[<p>In accordance with $3.2/4 &#8211;<br />
-&#8216;A&#8217; and &#8216;B&#8217; need to be complete types.<br />
-Classes C and E need not be complete, because X does not define (as opposed to declaring) any of it&#8217;s member functions,<br />
-D needs to be complete because class &#8216;X&#8217; has a member object of type &#8216;D&#8217;.<br />
-iostream can also be removed as we already include ostream</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tianyu Zhu				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12139</link>
		<dc:creator><![CDATA[Tianyu Zhu]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 01:14:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12139</guid>
					<description><![CDATA[Remove #include , it&#039;s not needed.
Remove #include . Replace with #include.
Forward declare class C.

I&#039;m probably missing a lot of this.]]></description>
		<content:encoded><![CDATA[<p>Remove #include , it&#8217;s not needed.<br />
Remove #include . Replace with #include.<br />
Forward declare class C.</p>
<p>I&#8217;m probably missing a lot of this.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gennaro				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12138</link>
		<dc:creator><![CDATA[Gennaro]]></dc:creator>
		<pubDate>Tue, 13 Aug 2013 00:30:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12138</guid>
					<description><![CDATA[Hi Herb, a little note just in case there&#039;s an unintended limitation:

&#062; You may not make any changes other than removing or rewriting #include directives

Is the prohibition to forward declare intentional or was the wording just changed at the latest moment resulting too strict?]]></description>
		<content:encoded><![CDATA[<p>Hi Herb, a little note just in case there&#8217;s an unintended limitation:</p>
<p>&gt; You may not make any changes other than removing or rewriting #include directives</p>
<p>Is the prohibition to forward declare intentional or was the wording just changed at the latest moment resulting too strict?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: helloworld922				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12137</link>
		<dc:creator><![CDATA[helloworld922]]></dc:creator>
		<pubDate>Mon, 12 Aug 2013 23:45:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12137</guid>
					<description><![CDATA[2. With only modifying the #include statements the only obvious inclusion I can get rid of is iostream (alt. can get rid of ostream, but I like including ostream instead of iostream because it&#039;s more specific, and this doesn&#039;t rely on iostream including ostream internally).

With forward declarations of class C and class E, c.h and e.h can be safely moved to x.cpp.

Also, shouldn&#039;t the &lt;code&gt;operator&#060;&#060;&lt;/code&gt; overload be extern with the actual implementation defined in x.cpp (alt.: declare it inline)?]]></description>
		<content:encoded><![CDATA[<p>2. With only modifying the #include statements the only obvious inclusion I can get rid of is iostream (alt. can get rid of ostream, but I like including ostream instead of iostream because it&#8217;s more specific, and this doesn&#8217;t rely on iostream including ostream internally).</p>
<p>With forward declarations of class C and class E, c.h and e.h can be safely moved to x.cpp.</p>
<p>Also, shouldn&#8217;t the <code>operator&lt;&lt;</code> overload be extern with the actual implementation defined in x.cpp (alt.: declare it inline)?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: MF				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12135</link>
		<dc:creator><![CDATA[MF]]></dc:creator>
		<pubDate>Mon, 12 Aug 2013 23:43:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12135</guid>
					<description><![CDATA[Remove #include  - removes (often costly) instantiation of cin, cout, cerr and so on and ostream is enough here.
Replace #include  with #include  - removes definition of ostream since only the declaration is needed here.
Replace #include &quot;e.h&quot; with class E; - E is only used as a argument and return type.
A, B and D are needed to calculate the size of X.
C is needed since instantiation of std::list where C is an incomplete type is undefined behaviour.(17.6.4.8ยง2)

(operator&#060;&#060; should be inline to avoid ODR violations)]]></description>
		<content:encoded><![CDATA[<p>Remove #include  &#8211; removes (often costly) instantiation of cin, cout, cerr and so on and ostream is enough here.<br />
Replace #include  with #include  &#8211; removes definition of ostream since only the declaration is needed here.<br />
Replace #include &#8220;e.h&#8221; with class E; &#8211; E is only used as a argument and return type.<br />
A, B and D are needed to calculate the size of X.<br />
C is needed since instantiation of std::list where C is an incomplete type is undefined behaviour.(17.6.4.8ยง2)</p>
<p>(operator&lt;&lt; should be inline to avoid ODR violations)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alf P. Steinbach				</title>
				<link>https://herbsutter.com/2013/08/12/gotw-7a-minimizing-compile-time-dependencies-part-1/#comment-12134</link>
		<dc:creator><![CDATA[Alf P. Steinbach]]></dc:creator>
		<pubDate>Mon, 12 Aug 2013 23:17:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2277#comment-12134</guid>
					<description><![CDATA[In C++03 the &#060;ostream&#062; header could not be formally removed if one used e.g. std::endl, or the &#060;&#060; operator. However, in practice one could use just &#060;iostream&#062; (as all examples in the C++03 standard erroneously did), and with C++11 that&#039;s also formally supported. In the above code it&#039;s not an issue, so &#060;ostream&#062; can just be removed. I would also replace full &#060;iostream&#062; with &#060;iosfwd&#062;.

Class E is only used result and argument type, and so its header can be removed. The situation for class C is more complicated. The C++03 standard (I&#039;m not 100% sure of C++11 and don&#039;t have the time to check now, sorry) required the item type of a standard library container such as the std::list in this code, to be a complete type. However, this formal requirement was regularly sinned against with e.g. std::auto_ptr, by ensuring that the code conformed to the actual requirements of the particular C++ implementation. The most infamous case of this lets-be-practical-about-it approach was one of your own PIMPL GOTWs.. :-)  But anyway, at least for the formal class C&#039;s header is needed, since C is used as a container item type, so, only the header for E can be omitted.

I would put a de facto standard #pragma once at the of that header.]]></description>
		<content:encoded><![CDATA[<p>In C++03 the &lt;ostream&gt; header could not be formally removed if one used e.g. std::endl, or the &lt;&lt; operator. However, in practice one could use just &lt;iostream&gt; (as all examples in the C++03 standard erroneously did), and with C++11 that&#8217;s also formally supported. In the above code it&#8217;s not an issue, so &lt;ostream&gt; can just be removed. I would also replace full &lt;iostream&gt; with &lt;iosfwd&gt;.</p>
<p>Class E is only used result and argument type, and so its header can be removed. The situation for class C is more complicated. The C++03 standard (I&#8217;m not 100% sure of C++11 and don&#8217;t have the time to check now, sorry) required the item type of a standard library container such as the std::list in this code, to be a complete type. However, this formal requirement was regularly sinned against with e.g. std::auto_ptr, by ensuring that the code conformed to the actual requirements of the particular C++ implementation. The most infamous case of this lets-be-practical-about-it approach was one of your own PIMPL GOTWs.. :-)  But anyway, at least for the formal class C&#8217;s header is needed, since C is used as a container item type, so, only the header for E can be omitted.</p>
<p>I would put a de facto standard #pragma once at the of that header.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
