<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #7a Solution: Minimizing Compile-Time Dependencies, Part 1	</title>
	<atom:link href="https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Guru of the week 7 &#124; C++, Qt, OpenGL, CUDA				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-14055</link>
		<dc:creator><![CDATA[Guru of the week 7 &#124; C++, Qt, OpenGL, CUDA]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 17:20:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-14055</guid>
					<description><![CDATA[[&#8230;] GotW #7a Solution: Minimizing Compile-Time Dependencies, Part 1 [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] GotW #7a Solution: Minimizing Compile-Time Dependencies, Part 1 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-13049</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 31 Oct 2013 23:20:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-13049</guid>
					<description><![CDATA[Catching up...

@Sebastian: I cover those in the other parts, but you&#039;re right it would be easier to add a short note here. Done.

@bcs: The point, which I&#039;ve now clarified, is that the caller can&#039;t even invoke E h(E) unless he already has an E object -- so he already has its definition.

@Emmanuel: As above, I&#039;ve improved the text to distinguish between parameter and return types.

Thanks for the comments.]]></description>
		<content:encoded><![CDATA[<p>Catching up&#8230;</p>
<p>@Sebastian: I cover those in the other parts, but you&#8217;re right it would be easier to add a short note here. Done.</p>
<p>@bcs: The point, which I&#8217;ve now clarified, is that the caller can&#8217;t even invoke E h(E) unless he already has an E object &#8212; so he already has its definition.</p>
<p>@Emmanuel: As above, I&#8217;ve improved the text to distinguish between parameter and return types.</p>
<p>Thanks for the comments.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: daramarak				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12294</link>
		<dc:creator><![CDATA[daramarak]]></dc:creator>
		<pubDate>Fri, 23 Aug 2013 09:13:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12294</guid>
					<description><![CDATA[Sebastians comment is truly excellent, Sutter should definitely consider incorporating these explanations into the solution.]]></description>
		<content:encoded><![CDATA[<p>Sebastians comment is truly excellent, Sutter should definitely consider incorporating these explanations into the solution.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JonKalb				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12288</link>
		<dc:creator><![CDATA[JonKalb]]></dc:creator>
		<pubDate>Thu, 22 Aug 2013 19:43:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12288</guid>
					<description><![CDATA[Excellent comment Sebastian.]]></description>
		<content:encoded><![CDATA[<p>Excellent comment Sebastian.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Christopher				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12279</link>
		<dc:creator><![CDATA[Christopher]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 21:36:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12279</guid>
					<description><![CDATA[For solution 1, you might want to write 

[code]
class widget { // &#034;{&#034; means definition
public:
    widget();
    // ...
};

widget* p;     // ok: allocs sizeof(ptr) space typed as widget*

widget  w;     // ok: allocs sizeof(widget) space typed as widget
               //     and calls default constructor
[/code]

Otherwise, trying to compile this code will complain about the &lt;code&gt;widge w&lt;/code&gt; line. (The linker ends up complaining anyway, later on...)]]></description>
		<content:encoded><![CDATA[<p>For solution 1, you might want to write </p>
<pre class="brush: plain; title: ; notranslate">
class widget { // &quot;{&quot; means definition
public:
    widget();
    // ...
};

widget* p;     // ok: allocs sizeof(ptr) space typed as widget*

widget  w;     // ok: allocs sizeof(widget) space typed as widget
               //     and calls default constructor
</pre>
<p>Otherwise, trying to compile this code will complain about the <code>widge w</code> line. (The linker ends up complaining anyway, later on&#8230;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Emmanuel Thivierge				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12277</link>
		<dc:creator><![CDATA[Emmanuel Thivierge]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 18:01:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12277</guid>
					<description><![CDATA[To me to have public member function that return incomplete type is actually a bad style and a bad habit. Because you will have to include the header for the return type anyway. It makes dependencies explicit where it doesn&#039;t need to be and it doesn&#039;t help compile time because you need to include it anyway at the point of use. I find it really frustrating to include a file and to get compile errors because i need to include more file because of incomplete type. Those dependencies have no really good ways to be documented either and it would not be the good solution.

I think the good solution is to just include those header for public member and non members functions. Your collegue will thanks you and it should impact the build time anyway.]]></description>
		<content:encoded><![CDATA[<p>To me to have public member function that return incomplete type is actually a bad style and a bad habit. Because you will have to include the header for the return type anyway. It makes dependencies explicit where it doesn&#8217;t need to be and it doesn&#8217;t help compile time because you need to include it anyway at the point of use. I find it really frustrating to include a file and to get compile errors because i need to include more file because of incomplete type. Those dependencies have no really good ways to be documented either and it would not be the good solution.</p>
<p>I think the good solution is to just include those header for public member and non members functions. Your collegue will thanks you and it should impact the build time anyway.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bcs				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12276</link>
		<dc:creator><![CDATA[bcs]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 14:07:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12276</guid>
					<description><![CDATA[Yes technically you can replace &quot;e.h&quot; with &quot;class E;&quot; but that leads to the rather obnoxious situation where I&#039;ve included &quot;x.h&quot; and then go try to use X::h and have to go track down which header E is defined in and include it as well.]]></description>
		<content:encoded><![CDATA[<p>Yes technically you can replace &#8220;e.h&#8221; with &#8220;class E;&#8221; but that leads to the rather obnoxious situation where I&#8217;ve included &#8220;x.h&#8221; and then go try to use X::h and have to go track down which header E is defined in and include it as well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Redl				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12271</link>
		<dc:creator><![CDATA[Sebastian Redl]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 10:52:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12271</guid>
					<description><![CDATA[Given the boatload of wrong answers when you originally posted this question, and the lingering confusion now, it would have been a good idea to go through every use in more detail and document why it does or does not need the full definition. I&#039;ll give it a try here.

class X : public A, private B {

This uses A and B as base classes and thus requires the full definition. This is independent of the access specifier on the inheritance.

    X( const C&#038; );

Reference to C, doesn&#039;t need the full definition. References and pointers never need the full definition until you actually do something interesting with them, and just copying them around doesn&#039;t count.

    B  f( int, char* );

B as a return type. A return type need not be complete until the function is actually called.

    C  f( int, C );

C as a return type and argument type. Argument types need not be complete either until the function is actually called. However, the overloading here might create a situation where the lack of a complete type leads to very unintuitive behavior. I&#039;ll get to that later.

    C&#038; g( B );

Reference to C as return type, B as argument type. Nothing new here. However, if g was virtual, it would be interesting, because of covariant overriding. Another thing for later.

    E  h( E );

E as return type and argument type. Yawn.

    virtual std::ostream&#038; print( std::ostream&#038; ) const;

Reference to std::ostream as argument and return type. Not special here either, and print being virtual doesn&#039;t really change that. As I mentioned, derived classes might have to worry about establishing covariance.

    std::list&#038;lt:C&#062; clist;

Formally, all standard containers require their member type to be complete when their definition is instantiated, so C must be complete here. Most implementations of std::list let you get away with not doing that, but I wouldn&#039;t rely on it. So C needs to be complete.

    D            d_;

Data member of type D, requires a complete type.

  };

At this point, the class ends, but some special members are not here. The compiler will add declarations for them:
X(const X&#038;); // copy ctor
X(X&#038;&#038;); // move ctor
X&#038; operator =(const X&#038;); // copy assignment
X&#038; operator =(X&#038;&#038;); // move assignment
~X(); // destructor

Note that the compiler does not actually *define* these (and thus trigger instantiation of std::list&#039;s corresponding
member functions, which would *definitely* require the definition of C) until they are actually used. In other words, it doesn&#039;t bite you here in the header, it bites the user of the class.

std::ostream&#038; operator&#060;&#060;( std::ostream&#038; os, const X&#038; x ) {
    return x.print(os);
}

As mentioned, this function needs to be inline to avoid ODR violations. Other than that, it only copies around references, so it doesn&#039;t need a full definition of ostream. Note that this would be different if any hierarchy conversions were going on.

And this brings me to the two points I delayed.

1) Covariance. If you have a virtual function that returns a reference or pointer to a class T, a derived class&#039;s override of the function can return a reference or pointer to a class S : public T instead. However, the compiler needs to actually know the classes are related. So in the above example, let&#039;s assume that g is virtual, and C only has a forward declaration (the list member is gone). Then I define a class Y:

[code]#include &#034;x.h&#034;

class F; // derives from C

class Y : public X {
public:
  F&#038; g(B) override; // error: compiler cannot establish relation between C and F
};[/code]

If the code instead includes the header for F (which in turn has to include the header for C, because F derives from it), then the code is fine.

2) Overloading. There are two versions of f, both taking an int as the first argument. The second argument is char* for one and C for the other. Now imagine C is incomplete. Then I have a class S, which has an implicit conversion to char*, and I call x.f(0, S()). Which version will it call? Well, obviously the char* version, because S can be converted to that, and there is no relationship between C and S ...
... or is there? What if C, if it were fully defined, had a converting constructor from S? Then the second overload would be just as good as the first - and with just a small code modification (make f take a const char*), it could even be better!

Unfortunately, I just scoured the standard for any indication on whether this is defined or undefined behavior, and as far as I can see, it&#039;s perfectly defined: if C is incomplete, the first overload will be called; if it is complete, the second. Only if the call is inside a template, not dependent and the completeness of C changes between the definition and instantiation of the template is the behavior undefined.

The lesson here is: avoiding redundant includes is a good thing, but in some cases, you might want to include the header for a class even though your own header strictly doesn&#039;t need it, simply to avoid nasty surprises for the users of your class.]]></description>
		<content:encoded><![CDATA[<p>Given the boatload of wrong answers when you originally posted this question, and the lingering confusion now, it would have been a good idea to go through every use in more detail and document why it does or does not need the full definition. I&#8217;ll give it a try here.</p>
<p>class X : public A, private B {</p>
<p>This uses A and B as base classes and thus requires the full definition. This is independent of the access specifier on the inheritance.</p>
<p>    X( const C&amp; );</p>
<p>Reference to C, doesn&#8217;t need the full definition. References and pointers never need the full definition until you actually do something interesting with them, and just copying them around doesn&#8217;t count.</p>
<p>    B  f( int, char* );</p>
<p>B as a return type. A return type need not be complete until the function is actually called.</p>
<p>    C  f( int, C );</p>
<p>C as a return type and argument type. Argument types need not be complete either until the function is actually called. However, the overloading here might create a situation where the lack of a complete type leads to very unintuitive behavior. I&#8217;ll get to that later.</p>
<p>    C&amp; g( B );</p>
<p>Reference to C as return type, B as argument type. Nothing new here. However, if g was virtual, it would be interesting, because of covariant overriding. Another thing for later.</p>
<p>    E  h( E );</p>
<p>E as return type and argument type. Yawn.</p>
<p>    virtual std::ostream&amp; print( std::ostream&amp; ) const;</p>
<p>Reference to std::ostream as argument and return type. Not special here either, and print being virtual doesn&#8217;t really change that. As I mentioned, derived classes might have to worry about establishing covariance.</p>
<p>    std::list&amp;lt:C&gt; clist;</p>
<p>Formally, all standard containers require their member type to be complete when their definition is instantiated, so C must be complete here. Most implementations of std::list let you get away with not doing that, but I wouldn&#8217;t rely on it. So C needs to be complete.</p>
<p>    D            d_;</p>
<p>Data member of type D, requires a complete type.</p>
<p>  };</p>
<p>At this point, the class ends, but some special members are not here. The compiler will add declarations for them:<br />
X(const X&amp;); // copy ctor<br />
X(X&amp;&amp;); // move ctor<br />
X&amp; operator =(const X&amp;); // copy assignment<br />
X&amp; operator =(X&amp;&amp;); // move assignment<br />
~X(); // destructor</p>
<p>Note that the compiler does not actually *define* these (and thus trigger instantiation of std::list&#8217;s corresponding<br />
member functions, which would *definitely* require the definition of C) until they are actually used. In other words, it doesn&#8217;t bite you here in the header, it bites the user of the class.</p>
<p>std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {<br />
    return x.print(os);<br />
}</p>
<p>As mentioned, this function needs to be inline to avoid ODR violations. Other than that, it only copies around references, so it doesn&#039;t need a full definition of ostream. Note that this would be different if any hierarchy conversions were going on.</p>
<p>And this brings me to the two points I delayed.</p>
<p>1) Covariance. If you have a virtual function that returns a reference or pointer to a class T, a derived class&#039;s override of the function can return a reference or pointer to a class S : public T instead. However, the compiler needs to actually know the classes are related. So in the above example, let&#039;s assume that g is virtual, and C only has a forward declaration (the list member is gone). Then I define a class Y:</p>
<pre class="brush: plain; title: ; notranslate">#include &quot;x.h&quot;

class F; // derives from C

class Y : public X {
public:
  F&amp; g(B) override; // error: compiler cannot establish relation between C and F
};</pre>
<p>If the code instead includes the header for F (which in turn has to include the header for C, because F derives from it), then the code is fine.</p>
<p>2) Overloading. There are two versions of f, both taking an int as the first argument. The second argument is char* for one and C for the other. Now imagine C is incomplete. Then I have a class S, which has an implicit conversion to char*, and I call x.f(0, S()). Which version will it call? Well, obviously the char* version, because S can be converted to that, and there is no relationship between C and S &#8230;<br />
&#8230; or is there? What if C, if it were fully defined, had a converting constructor from S? Then the second overload would be just as good as the first &#8211; and with just a small code modification (make f take a const char*), it could even be better!</p>
<p>Unfortunately, I just scoured the standard for any indication on whether this is defined or undefined behavior, and as far as I can see, it&#039;s perfectly defined: if C is incomplete, the first overload will be called; if it is complete, the second. Only if the call is inside a template, not dependent and the completeness of C changes between the definition and instantiation of the template is the behavior undefined.</p>
<p>The lesson here is: avoiding redundant includes is a good thing, but in some cases, you might want to include the header for a class even though your own header strictly doesn&#039;t need it, simply to avoid nasty surprises for the users of your class.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Bielecki				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12268</link>
		<dc:creator><![CDATA[Bartosz Bielecki]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 07:37:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12268</guid>
					<description><![CDATA[It&#039;s unnecessary as it&#039;s only used as a parameter and/or return value. Compiler doesn&#039;t need to know their size. Only class members that are of type [code]E[/code] are required to be known, as their size is required to calculate the total size of the class.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s unnecessary as it&#8217;s only used as a parameter and/or return value. Compiler doesn&#8217;t need to know their size. Only class members that are of type </p>
<pre class="brush: plain; title: ; notranslate">E</pre>
<p> are required to be known, as their size is required to calculate the total size of the class.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Bielecki				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12266</link>
		<dc:creator><![CDATA[Bartosz Bielecki]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 07:31:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12266</guid>
					<description><![CDATA[It&#039;s unecessary as it&#039;s only used as a parameter and/or return value. Compiler doesn&#039;t need to know their size. Only class members that are of type E are required to be known, as their size is required to calculate the total size of the class.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s unecessary as it&#8217;s only used as a parameter and/or return value. Compiler doesn&#8217;t need to know their size. Only class members that are of type E are required to be known, as their size is required to calculate the total size of the class.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: khurshid				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12263</link>
		<dc:creator><![CDATA[khurshid]]></dc:creator>
		<pubDate>Wed, 21 Aug 2013 03:57:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12263</guid>
					<description><![CDATA[I didn&#039;t understand, why &quot;e.h&quot;  is unnecessary?  
class X{   .....    
E  h(E ) ; // here  definition of `E` needed or not ?  If not , why?]]></description>
		<content:encoded><![CDATA[<p>I didn&#8217;t understand, why &#8220;e.h&#8221;  is unnecessary?<br />
class X{   &#8230;..<br />
E  h(E ) ; // here  definition of `E` needed or not ?  If not , why?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Juraj Blaho				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12258</link>
		<dc:creator><![CDATA[Juraj Blaho]]></dc:creator>
		<pubDate>Tue, 20 Aug 2013 20:24:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12258</guid>
					<description><![CDATA[Is it worth avoiding inclusion of standard library headers (ostream in this case) when I can have them all in a precompiled header?]]></description>
		<content:encoded><![CDATA[<p>Is it worth avoiding inclusion of standard library headers (ostream in this case) when I can have them all in a precompiled header?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Bielecki				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12256</link>
		<dc:creator><![CDATA[Bartosz Bielecki]]></dc:creator>
		<pubDate>Tue, 20 Aug 2013 18:14:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12256</guid>
					<description><![CDATA[Everything is fine but that doesn&#039;t work that well for typedefs and templates (thankfully enum classes can be now forward declared). From my side I would add that it&#039;s useful to create &quot;x_fwd.hpp&quot; files with all required typedefs. It requires some more work and keeping both files in sync, but it&#039;s feasible. Templates can be nicely divided into two files, where one is a strict declaration, while the other file is the implementation. Impl. part you obviously want to use only in .cpp file.]]></description>
		<content:encoded><![CDATA[<p>Everything is fine but that doesn&#8217;t work that well for typedefs and templates (thankfully enum classes can be now forward declared). From my side I would add that it&#8217;s useful to create &#8220;x_fwd.hpp&#8221; files with all required typedefs. It requires some more work and keeping both files in sync, but it&#8217;s feasible. Templates can be nicely divided into two files, where one is a strict declaration, while the other file is the implementation. Impl. part you obviously want to use only in .cpp file.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: thokra				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12254</link>
		<dc:creator><![CDATA[thokra]]></dc:creator>
		<pubDate>Tue, 20 Aug 2013 15:10:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12254</guid>
					<description><![CDATA[BC: From where did X suddenly get a member function &lt;code&gt;to_string()&lt;/code&gt;? Also, you cannot get completely rid of everything. At the very minimum you need the forward decl to let the compiler know that there actually is a type std::ostream - which is just a typedef:

[code]
typedef basic_ostream&#060;char&#062; ostream;
[/code]

The problem is the virtual function &lt;code&gt;X::print( std::ostream&#038; )&lt;/code&gt;. If you could make a template member function out of that, it&#039;d be fine - but you can&#039;t because it&#039;s virtual. Merely throwing the virtual function out is a crude design alteration and if there are classes that inhereit from x and override it, you&#039;ll have completely unwanted side-effects. It&#039;s not the case that base classes of X declare the virtual function, because &lt;code&gt;&lt;/code&gt; would have already been included in A.h.

If it compiles anyway, it&#039;s likely because the symbol is pulled from somewhere else - or because you simply thew out &lt;code&gt;X::print( std::ostream&#038; )&lt;/code&gt;.

Also, if you have a function that spits out a string representation of the class, why would you need a overload for operator&#060;&#060; ? You can feed the string to any ostream already.]]></description>
		<content:encoded><![CDATA[<p>BC: From where did X suddenly get a member function <code>to_string()</code>? Also, you cannot get completely rid of everything. At the very minimum you need the forward decl to let the compiler know that there actually is a type std::ostream &#8211; which is just a typedef:</p>
<pre class="brush: plain; title: ; notranslate">
typedef basic_ostream&lt;char&gt; ostream;
</pre>
<p>The problem is the virtual function <code>X::print( std::ostream&amp; )</code>. If you could make a template member function out of that, it&#8217;d be fine &#8211; but you can&#8217;t because it&#8217;s virtual. Merely throwing the virtual function out is a crude design alteration and if there are classes that inhereit from x and override it, you&#8217;ll have completely unwanted side-effects. It&#8217;s not the case that base classes of X declare the virtual function, because <code></code> would have already been included in A.h.</p>
<p>If it compiles anyway, it&#8217;s likely because the symbol is pulled from somewhere else &#8211; or because you simply thew out <code>X::print( std::ostream&amp; )</code>.</p>
<p>Also, if you have a function that spits out a string representation of the class, why would you need a overload for operator&lt;&lt; ? You can feed the string to any ostream already.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: BC				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12248</link>
		<dc:creator><![CDATA[BC]]></dc:creator>
		<pubDate>Tue, 20 Aug 2013 07:49:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12248</guid>
					<description><![CDATA[I have a trick to avoid both #include and forward declaration for the operator &#060;&#060;, but I am not sure whether it is good thing to do. Could you give some opinion?

[code]
template&#060;class OS&#062;
OS&#038; operator&#060;&#060; (OS&#038; os, const X&#038; x)
{
	return ( os &#060;&#060; x.to_string() );
}
[/code]

By letting the compiler deduce the output stream type, both #include and forward declaration are avoided, and the operator is now more generic. I am not sure whether it is a good practice but it works for me anyway.]]></description>
		<content:encoded><![CDATA[<p>I have a trick to avoid both #include and forward declaration for the operator &lt;&lt;, but I am not sure whether it is good thing to do. Could you give some opinion?</p>
<pre class="brush: plain; title: ; notranslate">
template&lt;class OS&gt;
OS&amp; operator&lt;&lt; (OS&amp; os, const X&amp; x)
{
	return ( os &lt;&lt; x.to_string() );
}
</pre>
<p>By letting the compiler deduce the output stream type, both #include and forward declaration are avoided, and the operator is now more generic. I am not sure whether it is a good practice but it works for me anyway.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: thokra				</title>
				<link>https://herbsutter.com/2013/08/19/gotw-7a-solution-minimizing-compile-time-dependencies-part-1/#comment-12235</link>
		<dc:creator><![CDATA[thokra]]></dc:creator>
		<pubDate>Mon, 19 Aug 2013 12:17:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2292#comment-12235</guid>
					<description><![CDATA[I&#039;m aware that this isn&#039;t the topic of this GotW, but one minor detail: shouldn&#039;t &lt;code&gt;X(const C&#038;)&lt;/code&gt; be declared explicit, since there is no obvious indication that, by design, C should be implicitly convertible to X? Doesn&#039;t that go against the general coding guideline in C++ Coding Standards (Item 40)?

More in regards to coding conventions, is there any reason why &lt;code&gt;clist&lt;/code&gt; doesn&#039;t have a trailing underscore?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m aware that this isn&#8217;t the topic of this GotW, but one minor detail: shouldn&#8217;t <code>X(const C&amp;)</code> be declared explicit, since there is no obvious indication that, by design, C should be implicitly convertible to X? Doesn&#8217;t that go against the general coding guideline in C++ Coding Standards (Item 40)?</p>
<p>More in regards to coding conventions, is there any reason why <code>clist</code> doesn&#8217;t have a trailing underscore?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
