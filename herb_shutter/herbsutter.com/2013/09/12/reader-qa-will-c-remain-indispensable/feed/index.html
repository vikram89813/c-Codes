<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Reader Q&#038;A: “Will C++ remain indispensable…?”	</title>
	<atom:link href="https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Patrick Fromberg				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-13870</link>
		<dc:creator><![CDATA[Patrick Fromberg]]></dc:creator>
		<pubDate>Wed, 18 Dec 2013 01:43:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-13870</guid>
					<description><![CDATA[@Tim

Good languages need good forums. One big unnoticed achievement of C++11 has been improving the quality of the online discussions. The recent C++11 conference and video tsunami may have also contributed.

You say Garbage collection can be disabled in D. I have read this often but no clue what it means. I can write my own standard D library that does not use GC? Great! So I stopped reading D language forums. I will check in a year or so again to see if quality improved. After all, Alexandrescu is amazing (hopefully Herb will not read this)! 

But even Alexandrescu is talking more C then D lately.]]></description>
		<content:encoded><![CDATA[<p>@Tim</p>
<p>Good languages need good forums. One big unnoticed achievement of C++11 has been improving the quality of the online discussions. The recent C++11 conference and video tsunami may have also contributed.</p>
<p>You say Garbage collection can be disabled in D. I have read this often but no clue what it means. I can write my own standard D library that does not use GC? Great! So I stopped reading D language forums. I will check in a year or so again to see if quality improved. After all, Alexandrescu is amazing (hopefully Herb will not read this)! </p>
<p>But even Alexandrescu is talking more C then D lately.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Asoft Raiden				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12694</link>
		<dc:creator><![CDATA[Asoft Raiden]]></dc:creator>
		<pubDate>Sat, 21 Sep 2013 22:14:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12694</guid>
					<description><![CDATA[I am a medical doctor and I use C++.]]></description>
		<content:encoded><![CDATA[<p>I am a medical doctor and I use C++.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pjmlp				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12683</link>
		<dc:creator><![CDATA[pjmlp]]></dc:creator>
		<pubDate>Sat, 21 Sep 2013 07:09:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12683</guid>
					<description><![CDATA[@Herb

Thanks for the invitation, sadly it is a bit far from Düsseldorf. :)]]></description>
		<content:encoded><![CDATA[<p>@Herb</p>
<p>Thanks for the invitation, sadly it is a bit far from Düsseldorf. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12674</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 20 Sep 2013 15:45:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12674</guid>
					<description><![CDATA[@pjmlp: Yes. He is smart and a good guy, but so negative that I wonder whether we were at the same conference. He&#039;s welcome to his opinion, and many people have said the same; but I don&#039;t share it, and I disagree with most of his examples.

Two particular things he&#039;s wrong about involve compatibility:

1. He underestimates the importance of source backward compatibility. It&#039;s extremely important, see here: https://herbsutter.com/2012/12/04/compatibility/

2. He overestimates the complexity cost of source backward compatibility. It isn&#039;t as high or important as he thinks.

I&#039;ll talk about this on Tuesday night in Chicago at the Chicago C++ Users Group meeting: https://sites.google.com/a/chicagoacm.org/chicago-chapter-of-the-acm/meeting-topics/2013-09-24-onec-herb-sutter (Note it says the event is at capacity, but they&#039;re looking for a bigger room, so do add yourself to the waiting list.)]]></description>
		<content:encoded><![CDATA[<p>@pjmlp: Yes. He is smart and a good guy, but so negative that I wonder whether we were at the same conference. He&#8217;s welcome to his opinion, and many people have said the same; but I don&#8217;t share it, and I disagree with most of his examples.</p>
<p>Two particular things he&#8217;s wrong about involve compatibility:</p>
<p>1. He underestimates the importance of source backward compatibility. It&#8217;s extremely important, see here: <a href="https://herbsutter.com/2012/12/04/compatibility/" rel="nofollow">https://herbsutter.com/2012/12/04/compatibility/</a></p>
<p>2. He overestimates the complexity cost of source backward compatibility. It isn&#8217;t as high or important as he thinks.</p>
<p>I&#8217;ll talk about this on Tuesday night in Chicago at the Chicago C++ Users Group meeting: <a href="https://sites.google.com/a/chicagoacm.org/chicago-chapter-of-the-acm/meeting-topics/2013-09-24-onec-herb-sutter" rel="nofollow">https://sites.google.com/a/chicagoacm.org/chicago-chapter-of-the-acm/meeting-topics/2013-09-24-onec-herb-sutter</a> (Note it says the event is at capacity, but they&#8217;re looking for a bigger room, so do add yourself to the waiting list.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pjmlp				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12669</link>
		<dc:creator><![CDATA[pjmlp]]></dc:creator>
		<pubDate>Fri, 20 Sep 2013 06:44:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12669</guid>
					<description><![CDATA[Bartosz Milewski seems to have another opinion,

http://bartoszmilewski.com/2013/09/19/edward-chands/]]></description>
		<content:encoded><![CDATA[<p>Bartosz Milewski seems to have another opinion,</p>
<p><a href="http://bartoszmilewski.com/2013/09/19/edward-chands/" rel="nofollow">http://bartoszmilewski.com/2013/09/19/edward-chands/</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Magnus				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12627</link>
		<dc:creator><![CDATA[Magnus]]></dc:creator>
		<pubDate>Wed, 18 Sep 2013 02:05:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12627</guid>
					<description><![CDATA[Matt:  Clang (and other tools) is getting really good at detecting undefined behaviours and unwanted memory accesses in debug builds.  There is also a lot more emphasis on defining what standard behaviour should be in C++, and for compiler vendors to follow it.  I think this the &quot;one C++&quot; thing Herb talked about, but I haven&#039;t got to that video yet in my Going Native binge :).  Lots of great work being done by Herb and others at the moment, thanks!

Programmes operate on data in memory.  C++ is a &quot;real&quot; programming language while others aren&#039;t as far as I&#039;m concerned because it lets me tell what the computer to do with that memory, without fuss.  I don&#039;t like working in languages that think I don&#039;t even know what a pointer is.]]></description>
		<content:encoded><![CDATA[<p>Matt:  Clang (and other tools) is getting really good at detecting undefined behaviours and unwanted memory accesses in debug builds.  There is also a lot more emphasis on defining what standard behaviour should be in C++, and for compiler vendors to follow it.  I think this the &#8220;one C++&#8221; thing Herb talked about, but I haven&#8217;t got to that video yet in my Going Native binge :).  Lots of great work being done by Herb and others at the moment, thanks!</p>
<p>Programmes operate on data in memory.  C++ is a &#8220;real&#8221; programming language while others aren&#8217;t as far as I&#8217;m concerned because it lets me tell what the computer to do with that memory, without fuss.  I don&#8217;t like working in languages that think I don&#8217;t even know what a pointer is.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12609</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 17 Sep 2013 20:06:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12609</guid>
					<description><![CDATA[@Matt: Short answer: No, and they won&#039;t be because it&#039;s not what they&#039;re for. See https://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/ .

I heard what you said a lot last decade (200x), and it&#039;s dying out now that people are grokking that it isn&#039;t so.]]></description>
		<content:encoded><![CDATA[<p>@Matt: Short answer: No, and they won&#8217;t be because it&#8217;s not what they&#8217;re for. See <a href="https://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/" rel="nofollow">https://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/</a> .</p>
<p>I heard what you said a lot last decade (200x), and it&#8217;s dying out now that people are grokking that it isn&#8217;t so.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt Campbell				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12604</link>
		<dc:creator><![CDATA[Matt Campbell]]></dc:creator>
		<pubDate>Tue, 17 Sep 2013 13:10:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12604</guid>
					<description><![CDATA[I think it&#039;s dangerous to promote C++ as a general-purpose programming language today, because C++ is not memory-safe. For the vast majority of code, we should use a language and runtime environment that provide a solid bedrock of abstraction, so that things like buffer overflows and stack smashes are simply impossible. Aren&#039;t JIT compilers good enough now that we can relegate C++ to the last resort for the small amount of code that where performance really matters, rather than the first choice?

See also:
http://wingolog.org/archives/2011/10/13/whats-your-c-migration-plan
http://www.loper-os.org/?p=55]]></description>
		<content:encoded><![CDATA[<p>I think it&#8217;s dangerous to promote C++ as a general-purpose programming language today, because C++ is not memory-safe. For the vast majority of code, we should use a language and runtime environment that provide a solid bedrock of abstraction, so that things like buffer overflows and stack smashes are simply impossible. Aren&#8217;t JIT compilers good enough now that we can relegate C++ to the last resort for the small amount of code that where performance really matters, rather than the first choice?</p>
<p>See also:<br />
<a href="http://wingolog.org/archives/2011/10/13/whats-your-c-migration-plan" rel="nofollow">http://wingolog.org/archives/2011/10/13/whats-your-c-migration-plan</a><br />
<a href="http://www.loper-os.org/?p=55" rel="nofollow">http://www.loper-os.org/?p=55</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Magnus				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12591</link>
		<dc:creator><![CDATA[Magnus]]></dc:creator>
		<pubDate>Tue, 17 Sep 2013 01:02:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12591</guid>
					<description><![CDATA[It *should* be a silly question to ask if the main industrial-strength language that emits fast native code has a future.  Otherwise, what&#039;s the point of CPU manufacturers continuing to strive to make their chips faster and use less power?

But here is the sad reality.

The &quot;critical measure&quot; for writing code for server systems (besides the sector Herb mentioned) isn&#039;t speed, it isn&#039;t power efficiency, and it isn&#039;t even programmer productivity.  It&#039;s programmer salaries.  This is the overriding concern of the employers of most professional programmers today.  Large companies might think they care about productivity, but to them driving down salaries is more important.  Look at modern trends, and look at the FizzBuzz phenomenon to see how much value is really placed on competency.

As for mobile platforms, C++&#039;s benefits are even less important.  The &quot;critical measure&quot; is getting your stupid (cr)applet out to as many tablets/phones as possible.  Herb himself linked to an article a couple of weeks ago showing the dire state of the mobile ecosystem.  Who cares if your finely-tuned, well-written app can run for ten hours straight if there are ten other dodgy apps that have killed the battery long within that time?  This isn&#039;t even an important issue, more urgent is how many apps that leak credit card or login details to the outside world in plaintext.  Fast mobile code doesn&#039;t matter even to OS developers, a guy wrote his own jpeg coder in C and assembler that outperform&#039;s Apple&#039;s native one for an app that can take lots of hires photos rapidly.]]></description>
		<content:encoded><![CDATA[<p>It *should* be a silly question to ask if the main industrial-strength language that emits fast native code has a future.  Otherwise, what&#8217;s the point of CPU manufacturers continuing to strive to make their chips faster and use less power?</p>
<p>But here is the sad reality.</p>
<p>The &#8220;critical measure&#8221; for writing code for server systems (besides the sector Herb mentioned) isn&#8217;t speed, it isn&#8217;t power efficiency, and it isn&#8217;t even programmer productivity.  It&#8217;s programmer salaries.  This is the overriding concern of the employers of most professional programmers today.  Large companies might think they care about productivity, but to them driving down salaries is more important.  Look at modern trends, and look at the FizzBuzz phenomenon to see how much value is really placed on competency.</p>
<p>As for mobile platforms, C++&#8217;s benefits are even less important.  The &#8220;critical measure&#8221; is getting your stupid (cr)applet out to as many tablets/phones as possible.  Herb himself linked to an article a couple of weeks ago showing the dire state of the mobile ecosystem.  Who cares if your finely-tuned, well-written app can run for ten hours straight if there are ten other dodgy apps that have killed the battery long within that time?  This isn&#8217;t even an important issue, more urgent is how many apps that leak credit card or login details to the outside world in plaintext.  Fast mobile code doesn&#8217;t matter even to OS developers, a guy wrote his own jpeg coder in C and assembler that outperform&#8217;s Apple&#8217;s native one for an app that can take lots of hires photos rapidly.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: AGPX				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12581</link>
		<dc:creator><![CDATA[AGPX]]></dc:creator>
		<pubDate>Mon, 16 Sep 2013 07:24:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12581</guid>
					<description><![CDATA[Until a language/technology have some advantage over others, it will survive. And C++ have a great advantage: the performance and this is a continuous demand, no matter how fast the processors will become. I like Java/C# languages, but C++ it&#039;s still my prefered.]]></description>
		<content:encoded><![CDATA[<p>Until a language/technology have some advantage over others, it will survive. And C++ have a great advantage: the performance and this is a continuous demand, no matter how fast the processors will become. I like Java/C# languages, but C++ it&#8217;s still my prefered.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: lineage casio				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12575</link>
		<dc:creator><![CDATA[lineage casio]]></dc:creator>
		<pubDate>Mon, 16 Sep 2013 00:14:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12575</guid>
					<description><![CDATA[casio ゴールド]]></description>
		<content:encoded><![CDATA[<p>casio ゴールド</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Steve				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12553</link>
		<dc:creator><![CDATA[Steve]]></dc:creator>
		<pubDate>Sun, 15 Sep 2013 02:35:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12553</guid>
					<description><![CDATA[Great post folks! Having experienced the birth of OO and the migration to C++,from Assembly to C and reaping the benefits of abstraction and ease of use of well designed interfaces and contracts. You should take a moment to thank K&#038;R and Bjarne for building a discipline which has remained a solid foundation for many of the modern languages that focused on safety and ease of use as opposed to pedal on the metal power.

Are Fortran and Cobol still in use ?

Use the best tool for the job!

The customer only cares if it is delivered in time, on budget, and is supportable for the perceived life of the product range.

Java is cool, but its not C++, C++ is not C, but its not Assembly language, Assembly Language is not machine ops,
write code in zeroes and ones, if your not capable to re-architecture the silicon.

Make money, and always write code as if you are going to die tomorrow and someone else has to take it over, in whatever language you like, as long as it&#039;s English!


SW.]]></description>
		<content:encoded><![CDATA[<p>Great post folks! Having experienced the birth of OO and the migration to C++,from Assembly to C and reaping the benefits of abstraction and ease of use of well designed interfaces and contracts. You should take a moment to thank K&amp;R and Bjarne for building a discipline which has remained a solid foundation for many of the modern languages that focused on safety and ease of use as opposed to pedal on the metal power.</p>
<p>Are Fortran and Cobol still in use ?</p>
<p>Use the best tool for the job!</p>
<p>The customer only cares if it is delivered in time, on budget, and is supportable for the perceived life of the product range.</p>
<p>Java is cool, but its not C++, C++ is not C, but its not Assembly language, Assembly Language is not machine ops,<br />
write code in zeroes and ones, if your not capable to re-architecture the silicon.</p>
<p>Make money, and always write code as if you are going to die tomorrow and someone else has to take it over, in whatever language you like, as long as it&#8217;s English!</p>
<p>SW.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: CodeVisio				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12544</link>
		<dc:creator><![CDATA[CodeVisio]]></dc:creator>
		<pubDate>Sat, 14 Sep 2013 19:39:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12544</guid>
					<description><![CDATA[@ Jon

&quot;I’d love to see a language that had all the performance of C++ but much of the productivity of C#&quot;

Jon,
What is the productivity of a procedural language?
I assume the productivity of C# will come along after the answer above.]]></description>
		<content:encoded><![CDATA[<p>@ Jon</p>
<p>&#8220;I’d love to see a language that had all the performance of C++ but much of the productivity of C#&#8221;</p>
<p>Jon,<br />
What is the productivity of a procedural language?<br />
I assume the productivity of C# will come along after the answer above.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adriano Viana				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12537</link>
		<dc:creator><![CDATA[Adriano Viana]]></dc:creator>
		<pubDate>Sat, 14 Sep 2013 11:44:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12537</guid>
					<description><![CDATA[Sutter, I enjoy reading your articles.   It always gives me hope of one thing:  That C++ will be used in software factory companies. I mean those companies that need to build good software products in a short amount of time.]]></description>
		<content:encoded><![CDATA[<p>Sutter, I enjoy reading your articles.   It always gives me hope of one thing:  That C++ will be used in software factory companies. I mean those companies that need to build good software products in a short amount of time.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dexter				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12534</link>
		<dc:creator><![CDATA[Dexter]]></dc:creator>
		<pubDate>Sat, 14 Sep 2013 06:58:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12534</guid>
					<description><![CDATA[@Herb: Since this is my first comment on your blog, let me start by saying that I&#039;ve been watching your talks for a long time now, and I&#039;m a big fan of yours. You are one of the few people whose presentations are easy to understand and fun to watch, despite the complexity involved.

You already were very clever in saying &quot;but don&#039;t stop there [...]&quot;, because being simply &quot;indispensable&quot; is obviously not the real question here when considering that even things like the linkers &#038; loaders &quot;crowd&quot; are still very much indispensable today. Yet that specific field (and others like it) despite being absolutely crucial for the continued existence of civilization as we know it, still remains an arcane art, for all practical purposes, for most of us, and entering the field is not a viable career option (unless you already happen to be the son of linker author or similar..). Similarly, how many of us will really end up working for Google/FB/etc. in that kind of capacity?

The real question is what portion of developers will still be writing C++ 10 and more years from now, or for what portion of projects C++ will be the first choice 10 years from now, and so on. You already tried to answer this a bit with the &quot;100 years from now&quot; question on the panel at Going Native 2013, but that obviously was a bit too futuristic.

Also note that this is not about how many C++ developers or projects there will exist in absolute numbers. I remember someone claiming that there were more Assembly programmers around today than ever before, simply because there are more developers in total around today than ever before. But of course the relative share of Assembly programmers today is nothing like what it was 10 and 20 or even more years ago. 

You said in your answer “C++ is getting easier”, and while I agree with that, I still think that Andrei was right on this, when asked during GN2013, when he said that a C++ beginner will be simply lost on the first compiler error that he’ll see, because the error will contain all sorts of notions that he knows nothing about. And even if the compiler error isn’t enough of a hurdle, then the first runtime error surely will be, because the C++ abstractions simply fade away during compilation and there’s nothing like a stacktrace to help you out when things go sideways.

To give some context, I’m a fairly young Java developer looking to get into C++ since Java feels a bit dull (which is not to say it doesn’t get the job done). As such, I have been reading the C++ Primer and my impression of it so far has been that each new page unveils new horrors. Bjarne said if you know int and vector you know C++. Someone joked about the complexity involved in vector during the panel later, but the really scary piece is that a lot of people don’t even know int. And how could they possibly, considering that both size and semantics of int are implementation-defined? And that’s still leaving out things like unsigned and overflow.]]></description>
		<content:encoded><![CDATA[<p>@Herb: Since this is my first comment on your blog, let me start by saying that I&#8217;ve been watching your talks for a long time now, and I&#8217;m a big fan of yours. You are one of the few people whose presentations are easy to understand and fun to watch, despite the complexity involved.</p>
<p>You already were very clever in saying &#8220;but don&#8217;t stop there [&#8230;]&#8221;, because being simply &#8220;indispensable&#8221; is obviously not the real question here when considering that even things like the linkers &amp; loaders &#8220;crowd&#8221; are still very much indispensable today. Yet that specific field (and others like it) despite being absolutely crucial for the continued existence of civilization as we know it, still remains an arcane art, for all practical purposes, for most of us, and entering the field is not a viable career option (unless you already happen to be the son of linker author or similar..). Similarly, how many of us will really end up working for Google/FB/etc. in that kind of capacity?</p>
<p>The real question is what portion of developers will still be writing C++ 10 and more years from now, or for what portion of projects C++ will be the first choice 10 years from now, and so on. You already tried to answer this a bit with the &#8220;100 years from now&#8221; question on the panel at Going Native 2013, but that obviously was a bit too futuristic.</p>
<p>Also note that this is not about how many C++ developers or projects there will exist in absolute numbers. I remember someone claiming that there were more Assembly programmers around today than ever before, simply because there are more developers in total around today than ever before. But of course the relative share of Assembly programmers today is nothing like what it was 10 and 20 or even more years ago. </p>
<p>You said in your answer “C++ is getting easier”, and while I agree with that, I still think that Andrei was right on this, when asked during GN2013, when he said that a C++ beginner will be simply lost on the first compiler error that he’ll see, because the error will contain all sorts of notions that he knows nothing about. And even if the compiler error isn’t enough of a hurdle, then the first runtime error surely will be, because the C++ abstractions simply fade away during compilation and there’s nothing like a stacktrace to help you out when things go sideways.</p>
<p>To give some context, I’m a fairly young Java developer looking to get into C++ since Java feels a bit dull (which is not to say it doesn’t get the job done). As such, I have been reading the C++ Primer and my impression of it so far has been that each new page unveils new horrors. Bjarne said if you know int and vector you know C++. Someone joked about the complexity involved in vector during the panel later, but the really scary piece is that a lot of people don’t even know int. And how could they possibly, considering that both size and semantics of int are implementation-defined? And that’s still leaving out things like unsigned and overflow.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12530</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 19:29:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12530</guid>
					<description><![CDATA[@Matt: Actually Bjarne&#039;s auto/decltype proposal included auto parameters for implicit templates. That&#039;s likely to still come back in the future. However, C++14 does already allow auto for parameters in lambda functions, so this is legal C++14 and actually often better than a hardcoded type: 
[code]
[](auto&#038; coll, auto val){ coll.push_back(val); }
[/code]]]></description>
		<content:encoded><![CDATA[<p>@Matt: Actually Bjarne&#8217;s auto/decltype proposal included auto parameters for implicit templates. That&#8217;s likely to still come back in the future. However, C++14 does already allow auto for parameters in lambda functions, so this is legal C++14 and actually often better than a hardcoded type: </p>
<pre class="brush: plain; title: ; notranslate">
[](auto&amp; coll, auto val){ coll.push_back(val); }
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt Spatola				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12529</link>
		<dc:creator><![CDATA[Matt Spatola]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 18:46:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12529</guid>
					<description><![CDATA[@Dain, I think the problem with this is that the problem with auto as a parameter like that is that C++ still only allows a single parameter type for a method.  If you used auto to support more than one type, then you would be generating multiple methods, which is a bit surprising since it&#039;s not a templated method.  The alternative is for the auto to try to find a type that is implicitly convertible to from the types of all parameters that it is called with, also a bit surprising.

Maybe I&#039;m just missing something obvious, but with auto return type, you can easily deduce return type from what is being returned, and it will always be the same.  If you want auto to work the same as a templated parameter type, I don&#039;t see how to always generate a single method, and it seems odd for it to generate multiple methods.]]></description>
		<content:encoded><![CDATA[<p>@Dain, I think the problem with this is that the problem with auto as a parameter like that is that C++ still only allows a single parameter type for a method.  If you used auto to support more than one type, then you would be generating multiple methods, which is a bit surprising since it&#8217;s not a templated method.  The alternative is for the auto to try to find a type that is implicitly convertible to from the types of all parameters that it is called with, also a bit surprising.</p>
<p>Maybe I&#8217;m just missing something obvious, but with auto return type, you can easily deduce return type from what is being returned, and it will always be the same.  If you want auto to work the same as a templated parameter type, I don&#8217;t see how to always generate a single method, and it seems odd for it to generate multiple methods.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12528</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 15:36:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12528</guid>
					<description><![CDATA[@Jon, take a look at some of the languages mentioned here:
http://parasail-programming-language.blogspot.com/2013/04/systems-programming-with-go-rust-and.html

Neither ParaSail nor Rust require GC (it&#039;s not needed for memory safety, it&#039;s not sufficient for general resource safety anyway, and it introduces unnecessary run-time costs -- to be honest, I&#039;m not sure why there are &quot;modern&quot; programming languages still being invented that keep dragging this invention from over half a century ago to the current day and age).

http://pcwalton.github.io/blog/2013/06/02/removing-garbage-collection-from-the-rust-language/
https://air.mozilla.org/region-based-storage-management-parasailing-without-a-garbage-chute/

// As for Go, let&#039;s forget about Go ;] Personally, I&#039;m just not that impressed by it--I don&#039;t find sufficiently many reasons compelling enough for it to be even a potential contender in the systems programming category.

BTW, @Herb, I&#039;m wondering what are your thoughts on these?]]></description>
		<content:encoded><![CDATA[<p>@Jon, take a look at some of the languages mentioned here:<br />
<a href="http://parasail-programming-language.blogspot.com/2013/04/systems-programming-with-go-rust-and.html" rel="nofollow">http://parasail-programming-language.blogspot.com/2013/04/systems-programming-with-go-rust-and.html</a></p>
<p>Neither ParaSail nor Rust require GC (it&#8217;s not needed for memory safety, it&#8217;s not sufficient for general resource safety anyway, and it introduces unnecessary run-time costs &#8212; to be honest, I&#8217;m not sure why there are &#8220;modern&#8221; programming languages still being invented that keep dragging this invention from over half a century ago to the current day and age).</p>
<p><a href="http://pcwalton.github.io/blog/2013/06/02/removing-garbage-collection-from-the-rust-language/" rel="nofollow">http://pcwalton.github.io/blog/2013/06/02/removing-garbage-collection-from-the-rust-language/</a><br />
<a href="https://air.mozilla.org/region-based-storage-management-parasailing-without-a-garbage-chute/" rel="nofollow">https://air.mozilla.org/region-based-storage-management-parasailing-without-a-garbage-chute/</a></p>
<p>// As for Go, let&#8217;s forget about Go ;] Personally, I&#8217;m just not that impressed by it&#8211;I don&#8217;t find sufficiently many reasons compelling enough for it to be even a potential contender in the systems programming category.</p>
<p>BTW, @Herb, I&#8217;m wondering what are your thoughts on these?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tim				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12520</link>
		<dc:creator><![CDATA[Tim]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 14:03:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12520</guid>
					<description><![CDATA[@Jon, &quot;I thought the D language and Google Go might be attempts in that direction but they both use garbage collection by default, which appears to favor productivity over performance. Do you think such a language is feasible?&quot;

Garbage collection can be disabled in D.]]></description>
		<content:encoded><![CDATA[<p>@Jon, &#8220;I thought the D language and Google Go might be attempts in that direction but they both use garbage collection by default, which appears to favor productivity over performance. Do you think such a language is feasible?&#8221;</p>
<p>Garbage collection can be disabled in D.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: germinolegrand				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12519</link>
		<dc:creator><![CDATA[germinolegrand]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 14:02:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12519</guid>
					<description><![CDATA[In my opinion, there are great progresses to be made on the teaching side. Do you know what is the #1 reason for C++ expanding to non-professional-developers ? The accessibility of a free online course for beginers (i learnt C++ this way, did not pay anything for learning it). There is no such thing like that for C++11 yet, that&#039;s why although i just love C++11 and think C++98 is deprecated, i&#039;m still forced to recommand a C++98 course (sadly not even modern style :/ ).

On my side, i&#039;m going to try to do something (in french sorry, language accessibility is also really important !) for that, i think it&#039;s really worth it. Something not the book way, because lot&#039;s of online courses are written in a style for books (because they aim to become a published book, or are taken from a published book), and it&#039;s not really adapted to the web&#039;s way of learning.]]></description>
		<content:encoded><![CDATA[<p>In my opinion, there are great progresses to be made on the teaching side. Do you know what is the #1 reason for C++ expanding to non-professional-developers ? The accessibility of a free online course for beginers (i learnt C++ this way, did not pay anything for learning it). There is no such thing like that for C++11 yet, that&#8217;s why although i just love C++11 and think C++98 is deprecated, i&#8217;m still forced to recommand a C++98 course (sadly not even modern style :/ ).</p>
<p>On my side, i&#8217;m going to try to do something (in french sorry, language accessibility is also really important !) for that, i think it&#8217;s really worth it. Something not the book way, because lot&#8217;s of online courses are written in a style for books (because they aim to become a published book, or are taken from a published book), and it&#8217;s not really adapted to the web&#8217;s way of learning.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pjmlp				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12508</link>
		<dc:creator><![CDATA[pjmlp]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 07:31:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12508</guid>
					<description><![CDATA[I really enjoyed the presentations done at Going Native this year.

Let me also thank you for making us aware of openFrameworks and Cinder, they are really nice.

What I think might be an issue with C++11, C++14 and the still very far away C++17 is how far away some of them still are.  Not to mention the C++ style guides most companies tend to have.

A year in computer time can mean many changes, let alone the time until we get stuff like modules into the language and mainstream compilers.

This will leave the door open to other languages with native compilers that are good enough for the same type of tasks C++ is good for. It is already happening, actually.

Here I agree with Andrei Alexandrescu, even C++14 will require developers to know archaic C and C++ stuff when problems arise.]]></description>
		<content:encoded><![CDATA[<p>I really enjoyed the presentations done at Going Native this year.</p>
<p>Let me also thank you for making us aware of openFrameworks and Cinder, they are really nice.</p>
<p>What I think might be an issue with C++11, C++14 and the still very far away C++17 is how far away some of them still are.  Not to mention the C++ style guides most companies tend to have.</p>
<p>A year in computer time can mean many changes, let alone the time until we get stuff like modules into the language and mainstream compilers.</p>
<p>This will leave the door open to other languages with native compilers that are good enough for the same type of tasks C++ is good for. It is already happening, actually.</p>
<p>Here I agree with Andrei Alexandrescu, even C++14 will require developers to know archaic C and C++ stuff when problems arise.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12507</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 07:16:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12507</guid>
					<description><![CDATA[@Herb, 

I&#039;d love to see a language that had all the performance of C++ but much of the productivity of C#. Whenever a trade-off had to be made, it would favor performance over productivity.

I thought the D language and Google Go might be attempts in that direction but they both use garbage collection by default, which appears to favor productivity over performance. Do you think such a language is feasible?]]></description>
		<content:encoded><![CDATA[<p>@Herb, </p>
<p>I&#8217;d love to see a language that had all the performance of C++ but much of the productivity of C#. Whenever a trade-off had to be made, it would favor performance over productivity.</p>
<p>I thought the D language and Google Go might be attempts in that direction but they both use garbage collection by default, which appears to favor productivity over performance. Do you think such a language is feasible?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Muhammad Faizan				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12506</link>
		<dc:creator><![CDATA[Muhammad Faizan]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 06:22:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12506</guid>
					<description><![CDATA[I think the advantages of C/C++ truly shine in software with clearly defined, scoped, and relatively static requirements and responsibilities. When requirements are not a fast moving target, C++ allows the programmer complete freedom to exploit the hardware to, as you said, maximize performance per watt, while still maintaining levels of abstraction that allow for readable, reusable, and maintainable code. And I think this is why C/C++ is so prevalent in software that most of us use: such software is likely to be established and mature (traction takes time), and as a result, its designers and programmers have had time to nail down the main user scenarios and come up with a performant and extensible architecture. 

The key here is time: C++ allows programmers to exploit the hardware, but doing so introduces complexity into the language which means that developers need more time to think through the design, which can only happen when requirements are not quickly changing. These conditions happen to be true for many software systems that we all use such as operating systems, browsers, libraries, etc. But there are also a world of applications out there that are only used by a relatively small team of people, in domains where requirements are quickly changing, iteration times are fast, and product/market fit is the main challenge as opposed to performance. I think that in these types of situations, managed/interpreted languages will always remain more suitable than C/C++ due to the increased developer productivity they offer.

tl;dr: C/C++ will remain indispensable for high performance, mature, and established software with clear requirements, whereas managed languages will remain indispensable for developing prototypes and software with uncertain or changing requirements with quick iteration times.]]></description>
		<content:encoded><![CDATA[<p>I think the advantages of C/C++ truly shine in software with clearly defined, scoped, and relatively static requirements and responsibilities. When requirements are not a fast moving target, C++ allows the programmer complete freedom to exploit the hardware to, as you said, maximize performance per watt, while still maintaining levels of abstraction that allow for readable, reusable, and maintainable code. And I think this is why C/C++ is so prevalent in software that most of us use: such software is likely to be established and mature (traction takes time), and as a result, its designers and programmers have had time to nail down the main user scenarios and come up with a performant and extensible architecture. </p>
<p>The key here is time: C++ allows programmers to exploit the hardware, but doing so introduces complexity into the language which means that developers need more time to think through the design, which can only happen when requirements are not quickly changing. These conditions happen to be true for many software systems that we all use such as operating systems, browsers, libraries, etc. But there are also a world of applications out there that are only used by a relatively small team of people, in domains where requirements are quickly changing, iteration times are fast, and product/market fit is the main challenge as opposed to performance. I think that in these types of situations, managed/interpreted languages will always remain more suitable than C/C++ due to the increased developer productivity they offer.</p>
<p>tl;dr: C/C++ will remain indispensable for high performance, mature, and established software with clear requirements, whereas managed languages will remain indispensable for developing prototypes and software with uncertain or changing requirements with quick iteration times.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dain Bray				</title>
				<link>https://herbsutter.com/2013/09/12/reader-qa-will-c-remain-indispensable/#comment-12504</link>
		<dc:creator><![CDATA[Dain Bray]]></dc:creator>
		<pubDate>Fri, 13 Sep 2013 05:30:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2334#comment-12504</guid>
					<description><![CDATA[Hi Herb I was looking at the C++ 14 language additions and was surprised that it doesn&#039;t appear that you can use auto in normal function params?  

Like:
 
struct Object{
 auto Func(auto i){ return i;} //&#060;-- better, but  not possible
 
 template
 atuo Func(T i){return i;} //&#060;-- pointless extra typing to express the same thing :(
}

 They appear to have added auto return types, and auto for generic lambdas though-- how did this part get missed(or did it?)?

 I realize that this is basically forcing it to act as a template(header only implementation?), but the terser syntax seems very desirable..

Thanks!]]></description>
		<content:encoded><![CDATA[<p>Hi Herb I was looking at the C++ 14 language additions and was surprised that it doesn&#8217;t appear that you can use auto in normal function params?  </p>
<p>Like:</p>
<p>struct Object{<br />
 auto Func(auto i){ return i;} //&lt;&#8211; better, but  not possible</p>
<p> template<br />
 atuo Func(T i){return i;} //&lt;&#8211; pointless extra typing to express the same thing :(<br />
}</p>
<p> They appear to have added auto return types, and auto for generic lambdas though&#8211; how did this part get missed(or did it?)?</p>
<p> I realize that this is basically forcing it to act as a template(header only implementation?), but the terser syntax seems very desirable..</p>
<p>Thanks!</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
