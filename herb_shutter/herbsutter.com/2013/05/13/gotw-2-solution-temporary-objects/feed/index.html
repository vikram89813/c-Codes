<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #2 Solution: Temporary Objects	</title>
	<atom:link href="https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Kenneth Ho				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-13078</link>
		<dc:creator><![CDATA[Kenneth Ho]]></dc:creator>
		<pubDate>Mon, 04 Nov 2013 05:48:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-13078</guid>
					<description><![CDATA[Hi Sutter,

I failed to find a more appropriate article to post this question, so here it goes.

Why doesn&#039;t std::min/max take URefs? I imagine something along the lines of the following would be reasonable:
[code]
  template &#060;typename T&#062; 
  T min(T&#038;&#038; v1, T&#038;&#038; v2) 
  { 
    return v1 &#060; v2 ? std::forward&#060;T&#062;(v1) : std::forward&#060;T&#062;(v2); 
  } 
[/code]]]></description>
		<content:encoded><![CDATA[<p>Hi Sutter,</p>
<p>I failed to find a more appropriate article to post this question, so here it goes.</p>
<p>Why doesn&#8217;t std::min/max take URefs? I imagine something along the lines of the following would be reasonable:</p>
<pre class="brush: plain; title: ; notranslate">
  template &lt;typename T&gt; 
  T min(T&amp;&amp; v1, T&amp;&amp; v2) 
  { 
    return v1 &lt; v2 ? std::forward&lt;T&gt;(v1) : std::forward&lt;T&gt;(v2); 
  } 
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: The Bogus SE/SE Rule &#124; Bulldozer00&#039;s Blog				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-12048</link>
		<dc:creator><![CDATA[The Bogus SE/SE Rule &#124; Bulldozer00&#039;s Blog]]></dc:creator>
		<pubDate>Thu, 25 Jul 2013 09:03:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-12048</guid>
					<description><![CDATA[[&#8230;] Single Entry / Single Exit (SE/SE) &#8220;rule&#8221; of programming. I wish I had this eloquent Herb Sutter treatise on hand when it [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Single Entry / Single Exit (SE/SE) &#8220;rule&#8221; of programming. I wish I had this eloquent Herb Sutter treatise on hand when it [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10388</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Fri, 24 May 2013 04:56:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10388</guid>
					<description><![CDATA[@Herb Sutter: Thanks for your answer.  I had not considered locality.  Saying &quot;a wash&quot; makes It is easier to understand why libstdc++ may not have rushed into using it - of course the status with C++11 changes that.  I note also that consistent use of iterators over operator[] (one of the places where the extra test is potentially significant) would help even if the optimiser should miss it.  I&#039;ve learned to be careful about assuming what optimisers may do.  I&#039;m looking forward to a review of GotW#33 and discussing inline which has given me some grief lately (it&#039;s often trying to do double duty, normal inline and macro/code replacement, the latter of which can be problematic in the face of optimiser choices).]]></description>
		<content:encoded><![CDATA[<p>@Herb Sutter: Thanks for your answer.  I had not considered locality.  Saying &#8220;a wash&#8221; makes It is easier to understand why libstdc++ may not have rushed into using it &#8211; of course the status with C++11 changes that.  I note also that consistent use of iterators over operator[] (one of the places where the extra test is potentially significant) would help even if the optimiser should miss it.  I&#8217;ve learned to be careful about assuming what optimisers may do.  I&#8217;m looking forward to a review of GotW#33 and discussing inline which has given me some grief lately (it&#8217;s often trying to do double duty, normal inline and macro/code replacement, the latter of which can be problematic in the face of optimiser choices).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10382</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 23 May 2013 23:41:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10382</guid>
					<description><![CDATA[@GeoffW: I don&#039;t know of SSO specific studies offhand, but it&#039;s well known from studies that small strings dominate most applications, and that SSO optimizes two specific things that are well-known to be important: locality, and allocation (for allocation it&#039;s both straight cost plus often poor scaling, though scaleable allocators are getting more common).

When Dinkumware switched from COW (which still had bugs) to SSO back around 2000, P.J. Plauger told me about performance measurements he had made that justified SSO, and also that when he made the switch he got no performance feedback from customers. You know that if there were any significant performance regressions in some code patterns then customers would report it. So this means switching from COW to SSO was &quot;a wash&quot; (his words) or better across a very broad set of customer code bases. (And of course switching away from COW put him in a good place because COW was made non-conforming in C++11.)

Finally, if you want a little more, remember that: (a) basic_string is a template which means all of its functions are inline; and (b) you usually perform more than just one operation on a string in a given function. So most of the time I would assume that optimizers routinely hoist/eliminate repeated code like isInternal ? useInternal : useExternal checks without even trying very hard. That&#039;s low-hanging fruit for a modern optimizer.]]></description>
		<content:encoded><![CDATA[<p>@GeoffW: I don&#8217;t know of SSO specific studies offhand, but it&#8217;s well known from studies that small strings dominate most applications, and that SSO optimizes two specific things that are well-known to be important: locality, and allocation (for allocation it&#8217;s both straight cost plus often poor scaling, though scaleable allocators are getting more common).</p>
<p>When Dinkumware switched from COW (which still had bugs) to SSO back around 2000, P.J. Plauger told me about performance measurements he had made that justified SSO, and also that when he made the switch he got no performance feedback from customers. You know that if there were any significant performance regressions in some code patterns then customers would report it. So this means switching from COW to SSO was &#8220;a wash&#8221; (his words) or better across a very broad set of customer code bases. (And of course switching away from COW put him in a good place because COW was made non-conforming in C++11.)</p>
<p>Finally, if you want a little more, remember that: (a) basic_string is a template which means all of its functions are inline; and (b) you usually perform more than just one operation on a string in a given function. So most of the time I would assume that optimizers routinely hoist/eliminate repeated code like isInternal ? useInternal : useExternal checks without even trying very hard. That&#8217;s low-hanging fruit for a modern optimizer.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10378</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Thu, 23 May 2013 22:04:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10378</guid>
					<description><![CDATA[The more I look at SSO the more I wonder just how effective it is - but I&#039;m having trouble finding any discussion of actual testing.  It sounds great - no allocation overheads for some percentage of strings - but the cost is that almost every interaction with the string object comes prefixed with (isInternal ? useInternal : useExternal).  Yes this is very minor when taken alone, but when added to the extra cost of move, the extra space consumed by even empty strings (think vectors and lists of objects containing strings), it must add up over the life of the object and application.  Testing the difference between COW and non-COW was relatively simple, but testing the advantages of SSO is much less so (and may vary widely between applications).]]></description>
		<content:encoded><![CDATA[<p>The more I look at SSO the more I wonder just how effective it is &#8211; but I&#8217;m having trouble finding any discussion of actual testing.  It sounds great &#8211; no allocation overheads for some percentage of strings &#8211; but the cost is that almost every interaction with the string object comes prefixed with (isInternal ? useInternal : useExternal).  Yes this is very minor when taken alone, but when added to the extra cost of move, the extra space consumed by even empty strings (think vectors and lists of objects containing strings), it must add up over the life of the object and application.  Testing the difference between COW and non-COW was relatively simple, but testing the advantages of SSO is much less so (and may vary widely between applications).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10377</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Thu, 23 May 2013 21:49:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10377</guid>
					<description><![CDATA[@Thomas Gahr: The single pointer implementation points to a structure that embeds the counter, size etc. in the allocated buffer - essentially just your typical pimpl pattern.  There are many examples of this - for an easy to read version see the test harness that went with the old GotW#45 (COW_AtomicInt2) - more realistic implementations optimise the empty string case.]]></description>
		<content:encoded><![CDATA[<p>@Thomas Gahr: The single pointer implementation points to a structure that embeds the counter, size etc. in the allocated buffer &#8211; essentially just your typical pimpl pattern.  There are many examples of this &#8211; for an easy to read version see the test harness that went with the old GotW#45 (COW_AtomicInt2) &#8211; more realistic implementations optimise the empty string case.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thomas Gahr				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10363</link>
		<dc:creator><![CDATA[Thomas Gahr]]></dc:creator>
		<pubDate>Thu, 23 May 2013 15:04:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10363</guid>
					<description><![CDATA[@GeoffW: FWIW: as far as I can see counter-COW argument boils down to exception safety since now any non-const access to the string (like operator[]) can throw std::bad_alloc as it mandates a deep copy of the data. I know your question was mainly about SSO, I just wanted to complete my last comment.]]></description>
		<content:encoded><![CDATA[<p>@GeoffW: FWIW: as far as I can see counter-COW argument boils down to exception safety since now any non-const access to the string (like operator[]) can throw std::bad_alloc as it mandates a deep copy of the data. I know your question was mainly about SSO, I just wanted to complete my last comment.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thomas Gahr				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10360</link>
		<dc:creator><![CDATA[Thomas Gahr]]></dc:creator>
		<pubDate>Thu, 23 May 2013 14:48:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10360</guid>
					<description><![CDATA[@GeoffW: I don&#039;t think sizeof(void*) std::string is doable no matter if you use SSO or COW - if we take COW, you&#039;ll need one pointer for the data and one pointer for the reference count (or linked list, whichever you prefer) at least. You&#039;ll also want to store the size of the string or you&#039;re back to ::strlen for implementing .size(). If you take the &quot;dumb&quot; implementation of a string without any optimization - always allocate and memcpy data - you&#039;ll need the data-pointer and the size member so you&#039;re at 2*sizeof(void*) at least. Or am I wrong?
Either way, I&#039;d be interested in links to discussions about advantages/disadvantages of SSO and/or COW, too.]]></description>
		<content:encoded><![CDATA[<p>@GeoffW: I don&#8217;t think sizeof(void*) std::string is doable no matter if you use SSO or COW &#8211; if we take COW, you&#8217;ll need one pointer for the data and one pointer for the reference count (or linked list, whichever you prefer) at least. You&#8217;ll also want to store the size of the string or you&#8217;re back to ::strlen for implementing .size(). If you take the &#8220;dumb&#8221; implementation of a string without any optimization &#8211; always allocate and memcpy data &#8211; you&#8217;ll need the data-pointer and the size member so you&#8217;re at 2*sizeof(void*) at least. Or am I wrong?<br />
Either way, I&#8217;d be interested in links to discussions about advantages/disadvantages of SSO and/or COW, too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10303</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Wed, 22 May 2013 04:56:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10303</guid>
					<description><![CDATA[A question about the short string optimisation comments made in this article.  You say that &quot;SSO is a wonderful optimization&quot;, but offer no references in support of this.  Are there articles around that demonstrate the advantages of SSO in a realistic manner?  I mean SSO looks good in theory, but so does copy-on-write.  Is it proven to be worth blowing out the size of a string object from a single pointer to something that is some multiple of that just to implement SSO?  In particular I am wondering if the perceived advantages of SSO may be less as more code takes advantage of C++11 move semantics in their interfaces.]]></description>
		<content:encoded><![CDATA[<p>A question about the short string optimisation comments made in this article.  You say that &#8220;SSO is a wonderful optimization&#8221;, but offer no references in support of this.  Are there articles around that demonstrate the advantages of SSO in a realistic manner?  I mean SSO looks good in theory, but so does copy-on-write.  Is it proven to be worth blowing out the size of a string object from a single pointer to something that is some multiple of that just to implement SSO?  In particular I am wondering if the perceived advantages of SSO may be less as more code takes advantage of C++11 move semantics in their interfaces.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10268</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Tue, 21 May 2013 03:38:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10268</guid>
					<description><![CDATA[I think @Adrian makes some good points about single-exit.  It was never about optimisation, or structured programming rules (or not for me), it was about code clarity.  In short, simple functions I am happy to have multiple exits, it&#039;s all there in front of you and your are unlikely to miss them when you come back to maintain the function.  In longer or more complex functions multiple-exit points can become a problem for maintenance - and any performance advantages in those situations are dubious and would have to be demonstrated.  (Of course we all avoid longer and more complex functions when we can, but they do still happen.)]]></description>
		<content:encoded><![CDATA[<p>I think @Adrian makes some good points about single-exit.  It was never about optimisation, or structured programming rules (or not for me), it was about code clarity.  In short, simple functions I am happy to have multiple exits, it&#8217;s all there in front of you and your are unlikely to miss them when you come back to maintain the function.  In longer or more complex functions multiple-exit points can become a problem for maintenance &#8211; and any performance advantages in those situations are dubious and would have to be demonstrated.  (Of course we all avoid longer and more complex functions when we can, but they do still happen.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10225</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 19 May 2013 16:14:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10225</guid>
					<description><![CDATA[@Ahmed: I used to agree with you -- the original GotW and Exceptional C++ said &quot;hoist end()&quot;. I switched to the current recommendation at Bjarne&#039;s urging because compilers have for a long time routinely inlined the container.end() case in particular. Re (1), no you don&#039;t need to inline both find_addr and end, just end -- find_addr is its own function. Re (2), I agree one should write the clearest code first, so the extra variable for end is arguably less clear. But yes, range-for and std::find are the preferred answer anyway, see GotW #3.]]></description>
		<content:encoded><![CDATA[<p>@Ahmed: I used to agree with you &#8212; the original GotW and Exceptional C++ said &#8220;hoist end()&#8221;. I switched to the current recommendation at Bjarne&#8217;s urging because compilers have for a long time routinely inlined the container.end() case in particular. Re (1), no you don&#8217;t need to inline both find_addr and end, just end &#8212; find_addr is its own function. Re (2), I agree one should write the clearest code first, so the extra variable for end is arguably less clear. But yes, range-for and std::find are the preferred answer anyway, see GotW #3.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ahmed Charles				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10222</link>
		<dc:creator><![CDATA[Ahmed Charles]]></dc:creator>
		<pubDate>Sun, 19 May 2013 11:05:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10222</guid>
					<description><![CDATA[I disagree with both points given which suggest that the end iterator being recomputed each loop should be preferred.

1) After seeing Chandler&#039;s talk on Optimizations at C++Now, I&#039;m significantly less likely to think that compilers will optimize this sort of code into &#039;the right thing&#039;. It would require inlining find_addr and end, while hoping that emps is a stack local in the caller.

2) Ignoring optimizations and compiler quality: For the same reasons that using algorithms is better than a normal for loop, because they are constrained and therefore provide more information to the reader, a for loop with the end calculated once provides more information to the reader, in that it guarantees that end isn&#039;t changing (or if it is, that it&#039;s likely to be a bug). I also don&#039;t view this as a premature optimization, because it should simply be idiomatic to write code with the begin and end iterators assigned to variables in the for loop initializer, much like writing ++i is idiomatic. Granted, it should be idiomatic to write this as a range based for loop or std::foreach with a lambda, rather than a normal for loop. And with C++14, both of these are probably equivalent or less typing and they both cause end to be called only once.]]></description>
		<content:encoded><![CDATA[<p>I disagree with both points given which suggest that the end iterator being recomputed each loop should be preferred.</p>
<p>1) After seeing Chandler&#8217;s talk on Optimizations at C++Now, I&#8217;m significantly less likely to think that compilers will optimize this sort of code into &#8216;the right thing&#8217;. It would require inlining find_addr and end, while hoping that emps is a stack local in the caller.</p>
<p>2) Ignoring optimizations and compiler quality: For the same reasons that using algorithms is better than a normal for loop, because they are constrained and therefore provide more information to the reader, a for loop with the end calculated once provides more information to the reader, in that it guarantees that end isn&#8217;t changing (or if it is, that it&#8217;s likely to be a bug). I also don&#8217;t view this as a premature optimization, because it should simply be idiomatic to write code with the begin and end iterators assigned to variables in the for loop initializer, much like writing ++i is idiomatic. Granted, it should be idiomatic to write this as a range based for loop or std::foreach with a lambda, rather than a normal for loop. And with C++14, both of these are probably equivalent or less typing and they both cause end to be called only once.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10193</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 17 May 2013 19:51:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10193</guid>
					<description><![CDATA[@Robert: That&#039;s not the same example as in the article. :) I agree your two lines are equivalent, and in both cases the calling code can easily see the bug locally in code review just by knowing the return type of the function (by value). What&#039;s different to me in find_addr is that we&#039;d be returning a reference that refers, not &quot;directly within this here object I&#039;m returning,&quot; but &quot;deep within some data structure plus I&#039;m not going to tell you exactly which node it is either.&quot; The article was doing the latter, and there&#039;s no way to check the calling code&#039;s correctness during code review without carefully reading the English documentation of find_addr to figure out if the reference was still valid. Doing the former, returning a reference directly into this visible object the caller knows about, is much less problematic IMO and does not require English documentation analysis to spot the bug.

@tivrfoa: I just compared using &quot;no optimizations&quot; vs. &quot;max optimizations&quot; compiler flags.]]></description>
		<content:encoded><![CDATA[<p>@Robert: That&#8217;s not the same example as in the article. :) I agree your two lines are equivalent, and in both cases the calling code can easily see the bug locally in code review just by knowing the return type of the function (by value). What&#8217;s different to me in find_addr is that we&#8217;d be returning a reference that refers, not &#8220;directly within this here object I&#8217;m returning,&#8221; but &#8220;deep within some data structure plus I&#8217;m not going to tell you exactly which node it is either.&#8221; The article was doing the latter, and there&#8217;s no way to check the calling code&#8217;s correctness during code review without carefully reading the English documentation of find_addr to figure out if the reference was still valid. Doing the former, returning a reference directly into this visible object the caller knows about, is much less problematic IMO and does not require English documentation analysis to spot the bug.</p>
<p>@tivrfoa: I just compared using &#8220;no optimizations&#8221; vs. &#8220;max optimizations&#8221; compiler flags.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: tivrfoa				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10183</link>
		<dc:creator><![CDATA[tivrfoa]]></dc:creator>
		<pubDate>Fri, 17 May 2013 15:21:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10183</guid>
					<description><![CDATA[Hello. &quot;with aggressive optimizations&quot;. How are these &quot;aggressive optimizations&quot;? Could someone show an example? Thank you.]]></description>
		<content:encoded><![CDATA[<p>Hello. &#8220;with aggressive optimizations&#8221;. How are these &#8220;aggressive optimizations&#8221;? Could someone show an example? Thank you.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10175</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 17 May 2013 09:14:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10175</guid>
					<description><![CDATA[@GregM: [code]std::get&#060;0&#062;()[/code] (blog ate my pointy braces) isn&#039;t a member function of std::tuple, still isn&#039;t returning by value..
@Herb: Wait a minute. Are you saying that [code]auto&#038; x = function_that_creates_widget_and_returns_by_value().get_name();[/code] is &#039;good&#039;, but [code]auto&#038; x = get_widget_name(function_that_creates_widget_and_returns_by_value());[/code] isn&#039;t? I so far failed to create any example where a get(xx) construct can have a dangling reference what is fixed just by replacing that call to a xx.get() construct, that&#039;s why I think the two are equivalent, thus should use the same guidelines for return type.]]></description>
		<content:encoded><![CDATA[<p>@GregM: </p>
<pre class="brush: plain; title: ; notranslate">std::get&lt;0&gt;()</pre>
<p> (blog ate my pointy braces) isn&#8217;t a member function of std::tuple, still isn&#8217;t returning by value..<br />
@Herb: Wait a minute. Are you saying that </p>
<pre class="brush: plain; title: ; notranslate">auto&amp; x = function_that_creates_widget_and_returns_by_value().get_name();</pre>
<p> is &#8216;good&#8217;, but </p>
<pre class="brush: plain; title: ; notranslate">auto&amp; x = get_widget_name(function_that_creates_widget_and_returns_by_value());</pre>
<p> isn&#8217;t? I so far failed to create any example where a get(xx) construct can have a dangling reference what is fixed just by replacing that call to a xx.get() construct, that&#8217;s why I think the two are equivalent, thus should use the same guidelines for return type.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rick Yorgason				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10161</link>
		<dc:creator><![CDATA[Rick Yorgason]]></dc:creator>
		<pubDate>Fri, 17 May 2013 02:32:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10161</guid>
					<description><![CDATA[@Herb But in practice, I&#039;ve never seen it cause much of a problem. Any time a function is returning a &#038;, whether it&#039;s a getter or a function like yours, the caller always knows one thing: the return value is valid if used immediately.

So if you&#039;re returning a const&#038;, I know that both of these are safe:
A) string s = find_addr(emps, &quot;Rick&quot;);
B) if(find_addr( emps, &quot;Rick&quot; ).find( &quot;Toronto&quot; ) != string::npos) {}

But if you&#039;re returning a value, one of those is less efficient.

I agree that hanging references/iterators is a very common problem, but every time I&#039;ve encountered it, the caller made a conscious decision to store a reference rather than a value, including in the example you provided.]]></description>
		<content:encoded><![CDATA[<p>@Herb But in practice, I&#8217;ve never seen it cause much of a problem. Any time a function is returning a &amp;, whether it&#8217;s a getter or a function like yours, the caller always knows one thing: the return value is valid if used immediately.</p>
<p>So if you&#8217;re returning a const&amp;, I know that both of these are safe:<br />
A) string s = find_addr(emps, &#8220;Rick&#8221;);<br />
B) if(find_addr( emps, &#8220;Rick&#8221; ).find( &#8220;Toronto&#8221; ) != string::npos) {}</p>
<p>But if you&#8217;re returning a value, one of those is less efficient.</p>
<p>I agree that hanging references/iterators is a very common problem, but every time I&#8217;ve encountered it, the caller made a conscious decision to store a reference rather than a value, including in the example you provided.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10116</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 16 May 2013 14:15:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10116</guid>
					<description><![CDATA[@kkoehne: Which ironically was the one Ville quoted. :) Thanks.]]></description>
		<content:encoded><![CDATA[<p>@kkoehne: Which ironically was the one Ville quoted. :) Thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: kkoehne				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10110</link>
		<dc:creator><![CDATA[kkoehne]]></dc:creator>
		<pubDate>Thu, 16 May 2013 06:27:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10110</guid>
					<description><![CDATA[@Herb: You only fixed it in one place. Two paragraphs below there still is &quot;So there is no difference between auto i{begin(emps)}&quot;]]></description>
		<content:encoded><![CDATA[<p>@Herb: You only fixed it in one place. Two paragraphs below there still is &#8220;So there is no difference between auto i{begin(emps)}&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10105</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 15 May 2013 21:04:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10105</guid>
					<description><![CDATA[@Ville: Good catch, I meant (). Fixed, thanks.

@Rick: &#038; parameters are much safer because they do fall into the structured lifetime bucket -- as long as the caller holds a valid reference at the time he calls the function (and modulo aliasing) the reference is guaranteed to stay valid for the lifetime of the function. The same is not true when you return a pointer or reference, or store a pointer or reference on the heap or anywhere else non-local, because by definition that&#039;s unstructured.]]></description>
		<content:encoded><![CDATA[<p>@Ville: Good catch, I meant (). Fixed, thanks.</p>
<p>@Rick: &amp; parameters are much safer because they do fall into the structured lifetime bucket &#8212; as long as the caller holds a valid reference at the time he calls the function (and modulo aliasing) the reference is guaranteed to stay valid for the lifetime of the function. The same is not true when you return a pointer or reference, or store a pointer or reference on the heap or anywhere else non-local, because by definition that&#8217;s unstructured.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10104</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 15 May 2013 21:00:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10104</guid>
					<description><![CDATA[@Adrian, @Michael: OK, I&#039;ve added that &quot;helping optimization&quot; was another motivation for single exit and added a bit more discussion about RVO and how the measurement I presented demonstrated that single-return actually harmed optimization.]]></description>
		<content:encoded><![CDATA[<p>@Adrian, @Michael: OK, I&#8217;ve added that &#8220;helping optimization&#8221; was another motivation for single exit and added a bit more discussion about RVO and how the measurement I presented demonstrated that single-return actually harmed optimization.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10103</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 15 May 2013 20:50:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10103</guid>
					<description><![CDATA[@Róbert Dávid: No, returning a &#038; can make sense. In the cases you mention, the lifetime issue is considerably simpler because you&#039;re returning a reference guaranteed to be valid for the lifetime of the same object that is producing it, which is very different and much easier to reason about. In the case in the article, it&#039;s a function returning a reference into an unknown node inside the list data structure; in the case of a getter like auto&#038; s = mywidget.get_name(), it&#039;s a function returning a reference that is good for as long as the known named mywidget object is alive.]]></description>
		<content:encoded><![CDATA[<p>@Róbert Dávid: No, returning a &amp; can make sense. In the cases you mention, the lifetime issue is considerably simpler because you&#8217;re returning a reference guaranteed to be valid for the lifetime of the same object that is producing it, which is very different and much easier to reason about. In the case in the article, it&#8217;s a function returning a reference into an unknown node inside the list data structure; in the case of a getter like auto&amp; s = mywidget.get_name(), it&#8217;s a function returning a reference that is good for as long as the known named mywidget object is alive.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10098</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Wed, 15 May 2013 17:06:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10098</guid>
					<description><![CDATA[Robert,

&quot;By that logic, no getter function should return a const reference, including vector::operator[], map::at(), std::get(), etc.! The fact that find_addr is free-standing doesn’t make a difference compared to the usual member getters&quot;

I think it is much more obvious that [], at(), and get() member functions return data whose lifetime is defined by the container than it is that a standalone function returns data whose lifetime is defined by one of its parameters.]]></description>
		<content:encoded><![CDATA[<p>Robert,</p>
<p>&#8220;By that logic, no getter function should return a const reference, including vector::operator[], map::at(), std::get(), etc.! The fact that find_addr is free-standing doesn’t make a difference compared to the usual member getters&#8221;</p>
<p>I think it is much more obvious that [], at(), and get() member functions return data whose lifetime is defined by the container than it is that a standalone function returns data whose lifetime is defined by one of its parameters.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10097</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Wed, 15 May 2013 17:03:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10097</guid>
					<description><![CDATA[&quot;Yes, checking !*p is the “check for empty string” I was talking about.&quot;

Thanks.  I wasn&#039;t sure whether it was &quot;checking for !*p&quot; or &quot;checking for 0 == strlen(p)&quot;.]]></description>
		<content:encoded><![CDATA[<p>&#8220;Yes, checking !*p is the “check for empty string” I was talking about.&#8221;</p>
<p>Thanks.  I wasn&#8217;t sure whether it was &#8220;checking for !*p&#8221; or &#8220;checking for 0 == strlen(p)&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rick Yorgason				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10081</link>
		<dc:creator><![CDATA[Rick Yorgason]]></dc:creator>
		<pubDate>Wed, 15 May 2013 00:55:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10081</guid>
					<description><![CDATA[I&#039;m not sure it&#039;s fair to demonize return by const&#038; while preferring const&#038; parameters. Both of these can lead to brittle code: in the former case, it&#039;s because of hanging references, and in the latter case it&#039;s because of aliasing. But often the brittleness is worthwhile, especially if you have large objects or if it&#039;s likely that the return value will be chained or passed into another function.

However, it&#039;s very rare that I use that static string technique. Usually if I&#039;m returning by reference, it&#039;s a caller error to ask for a reference that doesn&#039;t exist, and I&#039;ll throw an exception.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not sure it&#8217;s fair to demonize return by const&amp; while preferring const&amp; parameters. Both of these can lead to brittle code: in the former case, it&#8217;s because of hanging references, and in the latter case it&#8217;s because of aliasing. But often the brittleness is worthwhile, especially if you have large objects or if it&#8217;s likely that the return value will be chained or passed into another function.</p>
<p>However, it&#8217;s very rare that I use that static string technique. Usually if I&#8217;m returning by reference, it&#8217;s a caller error to ask for a reference that doesn&#8217;t exist, and I&#8217;ll throw an exception.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10080</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 14 May 2013 22:47:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10080</guid>
					<description><![CDATA[@Daan: Yes, but part of the question was not to mess with the basic shape of the function. :) We&#039;re focusing on temporary/extra objects in this one.]]></description>
		<content:encoded><![CDATA[<p>@Daan: Yes, but part of the question was not to mess with the basic shape of the function. :) We&#8217;re focusing on temporary/extra objects in this one.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gonzalo BG				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10078</link>
		<dc:creator><![CDATA[Gonzalo BG]]></dc:creator>
		<pubDate>Tue, 14 May 2013 21:07:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10078</guid>
					<description><![CDATA[&quot;So I actually don’t recommend any change to hoist the end calculation here, because that would make the code slightly more complex [...]&quot; 

Does

[code]
for(auto i = begin(emp), e = end(emp); i != e; ++i) {
  //...
}
[/code]

make the code more complex? The list::end() iterator is never invalidated. I think that what you propose, i.e. calling the function end() at every loop iteration (and hoping for the compiler to optimize it), fits into your description of premature pessimization.]]></description>
		<content:encoded><![CDATA[<p>&#8220;So I actually don’t recommend any change to hoist the end calculation here, because that would make the code slightly more complex [&#8230;]&#8221; </p>
<p>Does</p>
<pre class="brush: plain; title: ; notranslate">
for(auto i = begin(emp), e = end(emp); i != e; ++i) {
  //...
}
</pre>
<p>make the code more complex? The list::end() iterator is never invalidated. I think that what you propose, i.e. calling the function end() at every loop iteration (and hoping for the compiler to optimize it), fits into your description of premature pessimization.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ville Voutilainen				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10077</link>
		<dc:creator><![CDATA[Ville Voutilainen]]></dc:creator>
		<pubDate>Tue, 14 May 2013 20:47:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10077</guid>
					<description><![CDATA[The blog ate the code. It will give you [code]initializer_list&#060;list&#060;employee&#062;::iterator&#062;[/code]]]></description>
		<content:encoded><![CDATA[<p>The blog ate the code. It will give you </p>
<pre class="brush: plain; title: ; notranslate">initializer_list&lt;list&lt;employee&gt;::iterator&gt;</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ville Voutilainen				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10076</link>
		<dc:creator><![CDATA[Ville Voutilainen]]></dc:creator>
		<pubDate>Tue, 14 May 2013 20:46:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10076</guid>
					<description><![CDATA[Oops, meant to say the former will give you an initializer_list. That it will do. :)]]></description>
		<content:encoded><![CDATA[<p>Oops, meant to say the former will give you an initializer_list. That it will do. :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ville Voutilainen				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10075</link>
		<dc:creator><![CDATA[Ville Voutilainen]]></dc:creator>
		<pubDate>Tue, 14 May 2013 20:45:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10075</guid>
					<description><![CDATA[Uh oh. &quot;So there is no difference between auto i{begin(emps)} and auto i = begin(emps). &quot;
Sure there is - the latter will give you an initializer_list&#060;list::iterator&#062;&#062;. Which is probably not
what you want.]]></description>
		<content:encoded><![CDATA[<p>Uh oh. &#8220;So there is no difference between auto i{begin(emps)} and auto i = begin(emps). &#8221;<br />
Sure there is &#8211; the latter will give you an initializer_list&lt;list::iterator&gt;&gt;. Which is probably not<br />
what you want.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10058</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Tue, 14 May 2013 08:51:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10058</guid>
					<description><![CDATA[@Michael A safety belt does not affect your car&#039;s performance, returning by value does.]]></description>
		<content:encoded><![CDATA[<p>@Michael A safety belt does not affect your car&#8217;s performance, returning by value does.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10056</link>
		<dc:creator><![CDATA[Martin]]></dc:creator>
		<pubDate>Tue, 14 May 2013 08:15:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10056</guid>
					<description><![CDATA[I still prefer:
[code] for(auto i=begin(x), e=end(x); i!=e; ++i) [/code]
It&#039;s not so much about the optimization, it&#039;s that the semantics now exactly match range based for.]]></description>
		<content:encoded><![CDATA[<p>I still prefer:</p>
<pre class="brush: plain; title: ; notranslate"> for(auto i=begin(x), e=end(x); i!=e; ++i) </pre>
<p>It&#8217;s not so much about the optimization, it&#8217;s that the semantics now exactly match range based for.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rvalue and Lvalue &#124; oraclechang				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10051</link>
		<dc:creator><![CDATA[Rvalue and Lvalue &#124; oraclechang]]></dc:creator>
		<pubDate>Tue, 14 May 2013 02:21:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10051</guid>
					<description><![CDATA[[&#8230;] GotW #2 Solution: Temporary Objects (herbsutter.com) [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] GotW #2 Solution: Temporary Objects (herbsutter.com) [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Marcin				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10049</link>
		<dc:creator><![CDATA[Michael Marcin]]></dc:creator>
		<pubDate>Tue, 14 May 2013 00:27:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10049</guid>
					<description><![CDATA[I&#039;ve heard it&#039;s harder/impossible for the compiler to do RVO with multiple exit functions, is this true?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;ve heard it&#8217;s harder/impossible for the compiler to do RVO with multiple exit functions, is this true?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10048</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Tue, 14 May 2013 00:14:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10048</guid>
					<description><![CDATA[I disagree with the return type argument. By that logic, no getter function should return a const reference, including vector::operator[], map::at(), std::get(), etc.! The fact that find_addr is free-standing doesn&#039;t make a difference compared to the usual member getters - it&#039;s the same deal as with std::get().

[code]auto&#038; a = find_addr( emps, &#034;John Doe&#034; );  // yay, avoided temporary!
emps.clear();
cout &#060;&#060; a;                                // oops[/code]
is almost the same as
[code]auto&#038; a = emps.front().addr;
emps.clear();
cout &#060;&#060; a;                                // oops[/code]
and even,
[code]vector&#060;int&#062; emps = { 0, 1, 2, 3 };
int&#038; a = emps[1];
emps.clear();
cout &#060;&#060; a;                                // oops[/code]]]></description>
		<content:encoded><![CDATA[<p>I disagree with the return type argument. By that logic, no getter function should return a const reference, including vector::operator[], map::at(), std::get(), etc.! The fact that find_addr is free-standing doesn&#8217;t make a difference compared to the usual member getters &#8211; it&#8217;s the same deal as with std::get().</p>
<pre class="brush: plain; title: ; notranslate">auto&amp; a = find_addr( emps, &quot;John Doe&quot; );  // yay, avoided temporary!
emps.clear();
cout &lt;&lt; a;                                // oops</pre>
<p>is almost the same as</p>
<pre class="brush: plain; title: ; notranslate">auto&amp; a = emps.front().addr;
emps.clear();
cout &lt;&lt; a;                                // oops</pre>
<p>and even,</p>
<pre class="brush: plain; title: ; notranslate">vector&lt;int&gt; emps = { 0, 1, 2, 3 };
int&amp; a = emps[1];
emps.clear();
cout &lt;&lt; a;                                // oops</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10043</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 13 May 2013 21:51:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10043</guid>
					<description><![CDATA[@litb1: Good point, clarified. I was sure that somewhere over the years I already fixed that to say &quot;temporary or extra objects&quot; but perhaps it was in a different GotW. Thanks.]]></description>
		<content:encoded><![CDATA[<p>@litb1: Good point, clarified. I was sure that somewhere over the years I already fixed that to say &#8220;temporary or extra objects&#8221; but perhaps it was in a different GotW. Thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10042</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 13 May 2013 21:48:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10042</guid>
					<description><![CDATA[@GregM: Yes, checking !*p is the &quot;check for empty string&quot; I was talking about.]]></description>
		<content:encoded><![CDATA[<p>@GregM: Yes, checking !*p is the &#8220;check for empty string&#8221; I was talking about.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10041</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 13 May 2013 21:46:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10041</guid>
					<description><![CDATA[@Thomas: Right, either check-for-empty or SSO is sufficient by itself, and all implementations I know of do at least one of those. It&#039;s only if you don&#039;t check for empty and you don&#039;t do SSO that you can get an allocation with return &quot;&quot;;.

Having said that, since you&#039;re looking into libstdc++&#039;s basic_string, there&#039;s actually something even worse in there -- instead of SSO, when I tried it on the weekend it looked like gcc 4.8 libstdc++ was still doing COW (copy on write). COW has long been a bad idea and is now actively nonconforming to C++11, which deliberately made COW basic_string implementations nonconforming. So the fix you want should probably be phrased something like &quot;please rip out brittle COW to conform to C++11 and replace it with modern SSO like everyone else did years ago.&quot; :) I&#039;ve been bellyaching about this for years, see 1999&#039;s &quot;Optimizations That Aren&#039;t (in a Multithreaded World)&quot; http://www.gotw.ca/publications/optimizations.htm .

(Obligatory disclaimer: Yes, VC++ has way more conformance issues than GCC right now, and I&#039;m pointing those out too. Just sayin&#039; that this is also a decade-long overdue fix to libstdc++.)]]></description>
		<content:encoded><![CDATA[<p>@Thomas: Right, either check-for-empty or SSO is sufficient by itself, and all implementations I know of do at least one of those. It&#8217;s only if you don&#8217;t check for empty and you don&#8217;t do SSO that you can get an allocation with return &#8220;&#8221;;.</p>
<p>Having said that, since you&#8217;re looking into libstdc++&#8217;s basic_string, there&#8217;s actually something even worse in there &#8212; instead of SSO, when I tried it on the weekend it looked like gcc 4.8 libstdc++ was still doing COW (copy on write). COW has long been a bad idea and is now actively nonconforming to C++11, which deliberately made COW basic_string implementations nonconforming. So the fix you want should probably be phrased something like &#8220;please rip out brittle COW to conform to C++11 and replace it with modern SSO like everyone else did years ago.&#8221; :) I&#8217;ve been bellyaching about this for years, see 1999&#8217;s &#8220;Optimizations That Aren&#8217;t (in a Multithreaded World)&#8221; <a href="http://www.gotw.ca/publications/optimizations.htm" rel="nofollow">http://www.gotw.ca/publications/optimizations.htm</a> .</p>
<p>(Obligatory disclaimer: Yes, VC++ has way more conformance issues than GCC right now, and I&#8217;m pointing those out too. Just sayin&#8217; that this is also a decade-long overdue fix to libstdc++.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10039</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Mon, 13 May 2013 20:52:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10039</guid>
					<description><![CDATA[@Herb:  I shouldn&#039;t have mentioned &quot;structured programming&quot; as that brings other debates into it.

My point was to contest your claim that single exit style exists only because of symmetry arguments with single entry.  This is simply not true, and, in fact, I&#039;ve never heard the symmetry argument made before.

I argue that single exit remains a valuable, useful practice that is neither &quot;errant&quot; nor &quot;obsolete.&quot;  Single exit code is almost always easier to understand and reason about, and it provides a chokepoint to assert invariants and post conditions.  This has nothing to do with resource management or variable lifetimes--we all agree that RAII is the right thing to do.  Nor is the argument for single exit specific to languages like C.  The cases where early returns help, even in C++, are minimal, and in many, many cases, they introduce complexity and reduce robustness.

@Michael Gmelin:  Single-exit does not inherently lead to deep nesting, and multiple return code is generally more fragile when code must be modified to meet new requirements.]]></description>
		<content:encoded><![CDATA[<p>@Herb:  I shouldn&#8217;t have mentioned &#8220;structured programming&#8221; as that brings other debates into it.</p>
<p>My point was to contest your claim that single exit style exists only because of symmetry arguments with single entry.  This is simply not true, and, in fact, I&#8217;ve never heard the symmetry argument made before.</p>
<p>I argue that single exit remains a valuable, useful practice that is neither &#8220;errant&#8221; nor &#8220;obsolete.&#8221;  Single exit code is almost always easier to understand and reason about, and it provides a chokepoint to assert invariants and post conditions.  This has nothing to do with resource management or variable lifetimes&#8211;we all agree that RAII is the right thing to do.  Nor is the argument for single exit specific to languages like C.  The cases where early returns help, even in C++, are minimal, and in many, many cases, they introduce complexity and reduce robustness.</p>
<p>@Michael Gmelin:  Single-exit does not inherently lead to deep nesting, and multiple return code is generally more fragile when code must be modified to meet new requirements.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Gmelin				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10037</link>
		<dc:creator><![CDATA[Michael Gmelin]]></dc:creator>
		<pubDate>Mon, 13 May 2013 18:33:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10037</guid>
					<description><![CDATA[@Herb: Couldn&#039;t agree more. Single-exit tends to lead to deep nesting, hard to read and easy to break code. In C it&#039;s common to use goto for proper clean up and reduce nesting (therefore doing what C++ does automatically explicitly and as a result of it have single exit). Been there, it doesn&#039;t make sense in C++ at all - especially new/delete free C++14 code.

Maybe calling it &quot;early return&quot; isn&#039;t helpful though, since that implies it&#039;s something extraordinary. To me, returning as soon as a final result is available is quite common these days.]]></description>
		<content:encoded><![CDATA[<p>@Herb: Couldn&#8217;t agree more. Single-exit tends to lead to deep nesting, hard to read and easy to break code. In C it&#8217;s common to use goto for proper clean up and reduce nesting (therefore doing what C++ does automatically explicitly and as a result of it have single exit). Been there, it doesn&#8217;t make sense in C++ at all &#8211; especially new/delete free C++14 code.</p>
<p>Maybe calling it &#8220;early return&#8221; isn&#8217;t helpful though, since that implies it&#8217;s something extraordinary. To me, returning as soon as a final result is available is quite common these days.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10036</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 13 May 2013 18:17:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10036</guid>
					<description><![CDATA[@Adrian: Early return is not a violation of structured programming. This is exactly at the heart of the misconception that single entry (which is essential to structured programming) has anything at all to do with single exit (which is not). Structured means simply that lifetimes (such as of function calls and local variables) nest properly, like Russian dolls -- which jumping into a function would violate, but returning early or throwing does not.

Having said that, &quot;single exit&quot; matters, but for different reasons(!), in languages like C where you don&#039;t get stack lifetimes and automatic cleanup, and you typically have a cascade of goto labels and a single return at the end to make sure you got it right. For example, see http://www.c2.com/cgi/wiki?SingleFunctionExitPoint . That&#039;s a limitation of C specifically, not an inherent benefit of single exit or a generally symmetry with single entry which is important in all languages for entirely different reasons.]]></description>
		<content:encoded><![CDATA[<p>@Adrian: Early return is not a violation of structured programming. This is exactly at the heart of the misconception that single entry (which is essential to structured programming) has anything at all to do with single exit (which is not). Structured means simply that lifetimes (such as of function calls and local variables) nest properly, like Russian dolls &#8212; which jumping into a function would violate, but returning early or throwing does not.</p>
<p>Having said that, &#8220;single exit&#8221; matters, but for different reasons(!), in languages like C where you don&#8217;t get stack lifetimes and automatic cleanup, and you typically have a cascade of goto labels and a single return at the end to make sure you got it right. For example, see <a href="http://www.c2.com/cgi/wiki?SingleFunctionExitPoint" rel="nofollow">http://www.c2.com/cgi/wiki?SingleFunctionExitPoint</a> . That&#8217;s a limitation of C specifically, not an inherent benefit of single exit or a generally symmetry with single entry which is important in all languages for entirely different reasons.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ambarish Sridharanarayanan				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10032</link>
		<dc:creator><![CDATA[Ambarish Sridharanarayanan]]></dc:creator>
		<pubDate>Mon, 13 May 2013 16:34:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10032</guid>
					<description><![CDATA[I&#039;d always thought of something like SSO as a no-brainer, but Andrew Koenig&#039;s tale has made me stop and think:

http://www.drdobbs.com/cpp/is-optimization-immoral/240151916]]></description>
		<content:encoded><![CDATA[<p>I&#8217;d always thought of something like SSO as a no-brainer, but Andrew Koenig&#8217;s tale has made me stop and think:</p>
<p><a href="http://www.drdobbs.com/cpp/is-optimization-immoral/240151916" rel="nofollow">http://www.drdobbs.com/cpp/is-optimization-immoral/240151916</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dave Harris				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10031</link>
		<dc:creator><![CDATA[Dave Harris]]></dc:creator>
		<pubDate>Mon, 13 May 2013 16:06:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10031</guid>
					<description><![CDATA[It seems to me that changing the argument from by-value to by-reference changes the operational semantics of this function. In the original, the function gets a local copy of the list, which cannot be affected by anything outside of the function. The by-reference list can be affected by other code. That is mostly likely if the code is multi-threaded, but it can also happen if the list is accessible from a static variable and some of the functions called modify it.

(It also makes it harder for the compiler to optimise things like end(). For example, if the (*i == name) line invokes code that the compiler can&#039;t see, then it&#039;s harder for the compiler to be sure that it does not modify the list through some alias.)

(I&#039;d also hesitate to say emps is a temporary variable, given that it has a name and its address can be taken. Yes, it is an unnecessary copy that you would want to avoid, but it surely isn&#039;t a temporary variable.)

The (*i == name) does not need a temporary if employee has an operator==() that accepts a string. I would have thought that were more common than being able to convert an employee to a string or vice versa.]]></description>
		<content:encoded><![CDATA[<p>It seems to me that changing the argument from by-value to by-reference changes the operational semantics of this function. In the original, the function gets a local copy of the list, which cannot be affected by anything outside of the function. The by-reference list can be affected by other code. That is mostly likely if the code is multi-threaded, but it can also happen if the list is accessible from a static variable and some of the functions called modify it.</p>
<p>(It also makes it harder for the compiler to optimise things like end(). For example, if the (*i == name) line invokes code that the compiler can&#8217;t see, then it&#8217;s harder for the compiler to be sure that it does not modify the list through some alias.)</p>
<p>(I&#8217;d also hesitate to say emps is a temporary variable, given that it has a name and its address can be taken. Yes, it is an unnecessary copy that you would want to avoid, but it surely isn&#8217;t a temporary variable.)</p>
<p>The (*i == name) does not need a temporary if employee has an operator==() that accepts a string. I would have thought that were more common than being able to convert an employee to a string or vice versa.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10029</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Mon, 13 May 2013 15:53:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10029</guid>
					<description><![CDATA[&quot;“Single exit,” on the other hand, got unfairly popular on the basis of symmetry&quot; [citation needed]

Single exit popular because it makes code easier to reason about.  It provides more places to assert your invariants, which helps in ensuring your code is correct.  Early returns (and other violations of structured programming) make invariant checking impossible.

Exceptions are exceptional--that is, they usually mean your invariant is violated anyway, so it makes sense to have those skip your invariant checking.  But early returns in non-exceptional cases create complexity by creating more paths that have to be analyzed and understood.

In the benchmark I just threw together, early returns provided only a 10% increase in speed with aggressive compiler optimizations, so I&#039;d accept an early return as an optimization in performance-critical code.  I&#039;d also except it in the rare case that it does clarify rather than confuse.  But in general, early returns are a premature optimization:  more complex code without data supporting a performance improvement.]]></description>
		<content:encoded><![CDATA[<p>&#8220;“Single exit,” on the other hand, got unfairly popular on the basis of symmetry&#8221; [citation needed]</p>
<p>Single exit popular because it makes code easier to reason about.  It provides more places to assert your invariants, which helps in ensuring your code is correct.  Early returns (and other violations of structured programming) make invariant checking impossible.</p>
<p>Exceptions are exceptional&#8211;that is, they usually mean your invariant is violated anyway, so it makes sense to have those skip your invariant checking.  But early returns in non-exceptional cases create complexity by creating more paths that have to be analyzed and understood.</p>
<p>In the benchmark I just threw together, early returns provided only a 10% increase in speed with aggressive compiler optimizations, so I&#8217;d accept an early return as an optimization in performance-critical code.  I&#8217;d also except it in the rare case that it does clarify rather than confuse.  But in general, early returns are a premature optimization:  more complex code without data supporting a performance improvement.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: litb1				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10028</link>
		<dc:creator><![CDATA[litb1]]></dc:creator>
		<pubDate>Mon, 13 May 2013 15:41:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10028</guid>
					<description><![CDATA[I recommend to change 

    &quot;The most obvious temporaries are buried in the function signature itself:&quot;

To avoid saying &quot;temporaries&quot;, or to clarify your definition of &quot;temporary&quot;. Both of these by-value parameters have a name, their lifetime last the entire functions activation, and their address can be taken. Or did I misunderstand your descriptions?]]></description>
		<content:encoded><![CDATA[<p>I recommend to change </p>
<p>    &#8220;The most obvious temporaries are buried in the function signature itself:&#8221;</p>
<p>To avoid saying &#8220;temporaries&#8221;, or to clarify your definition of &#8220;temporary&#8221;. Both of these by-value parameters have a name, their lifetime last the entire functions activation, and their address can be taken. Or did I misunderstand your descriptions?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Daan Nusman				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10027</link>
		<dc:creator><![CDATA[Daan Nusman]]></dc:creator>
		<pubDate>Mon, 13 May 2013 15:20:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10027</guid>
					<description><![CDATA[std::optional as return type might be useful here (this is a C++14 GotW after all).]]></description>
		<content:encoded><![CDATA[<p>std::optional as return type might be useful here (this is a C++14 GotW after all).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10024</link>
		<dc:creator><![CDATA[Chris]]></dc:creator>
		<pubDate>Mon, 13 May 2013 14:53:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10024</guid>
					<description><![CDATA[@zahirtezcan, That&#039;s exactly what I was thinking. I&#039;d probably change the ending to use the ternary conditional operator, though.]]></description>
		<content:encoded><![CDATA[<p>@zahirtezcan, That&#8217;s exactly what I was thinking. I&#8217;d probably change the ending to use the ternary conditional operator, though.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Albert				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10023</link>
		<dc:creator><![CDATA[Albert]]></dc:creator>
		<pubDate>Mon, 13 May 2013 14:52:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10023</guid>
					<description><![CDATA[By the way, concerning the other advice &quot;Guideline: Prefer preincrement. Only use postincrement if you’re going to use the original value. &quot;, I always use preincrement. If I need post increment, I explicity do the copy and then call the preincrement : 
[code]
++v;
//or if post increment needed :
v1 = v;
++v;
[/code]
I  think the intention is clear doing so and avoids a reviewer to wonder if a post increment has been wanted by the coder or is an inattention.]]></description>
		<content:encoded><![CDATA[<p>By the way, concerning the other advice &#8220;Guideline: Prefer preincrement. Only use postincrement if you’re going to use the original value. &#8220;, I always use preincrement. If I need post increment, I explicity do the copy and then call the preincrement : </p>
<pre class="brush: plain; title: ; notranslate">
++v;
//or if post increment needed :
v1 = v;
++v;
</pre>
<p>I  think the intention is clear doing so and avoids a reviewer to wonder if a post increment has been wanted by the coder or is an inattention.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Albert				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10022</link>
		<dc:creator><![CDATA[Albert]]></dc:creator>
		<pubDate>Mon, 13 May 2013 14:48:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10022</guid>
					<description><![CDATA[Hello,
Thank you for this new *modern* gotw source of thought and learning as usual.

It happend that this morning I also read the article from Andrew Koenig about *subtleties of Aliasing* (http://www.drdobbs.com/cpp/some-subtleties-of-aliasing/240154618) which has a slightly different conclusion about the rule : &quot;Guideline: Prefer passing read-only parameters by const&#038; instead of by value. &quot;

For a long, I had the same conclusion as Mr Sutter about prefering const reference than value. But, since a time I changed my mind. 
I observed that my interfaces have more and more &#039;light&#039; objects as parameters (*). For instance, a function like find_addr would probably take an iterator pair (possibly wrapped in a range) rather than an explicit container. 
Even for the string parameter, I am higly tempted to pass a value. To my mind, it makes the function more loosely of what happen to the string outside the function which, I think, enforces the reliability of the find_addr function. const reference does only write in the contract that the supplyer does not change the value of the string but tells nothing about the customer. Yesterday, all multithread seemed so far away, now it looks as though they&#039;re here to stay ;)
(*) well, my remarks, of course, concern arguments that have a &#039;value&#039; semantic that it to say those that are mainly substituable by any instance with the same value. Classes providing a &#039;reference&#039; semantic (that is distinct only by their adress not by their internal state) are of course systematically passed by reference (and even more so that the semantics of reference is generally incompatible with the copy/move ones). In fact, potentially big (i.e. &#039;costly&#039;) value-typed object I manipulate tend to have helpers (like iterator) that are more light and are often better candidates for function since they isolate a facet of the object.

Regards,

Alb]]></description>
		<content:encoded><![CDATA[<p>Hello,<br />
Thank you for this new *modern* gotw source of thought and learning as usual.</p>
<p>It happend that this morning I also read the article from Andrew Koenig about *subtleties of Aliasing* (<a href="http://www.drdobbs.com/cpp/some-subtleties-of-aliasing/240154618" rel="nofollow">http://www.drdobbs.com/cpp/some-subtleties-of-aliasing/240154618</a>) which has a slightly different conclusion about the rule : &#8220;Guideline: Prefer passing read-only parameters by const&amp; instead of by value. &#8221;</p>
<p>For a long, I had the same conclusion as Mr Sutter about prefering const reference than value. But, since a time I changed my mind.<br />
I observed that my interfaces have more and more &#8216;light&#8217; objects as parameters (*). For instance, a function like find_addr would probably take an iterator pair (possibly wrapped in a range) rather than an explicit container.<br />
Even for the string parameter, I am higly tempted to pass a value. To my mind, it makes the function more loosely of what happen to the string outside the function which, I think, enforces the reliability of the find_addr function. const reference does only write in the contract that the supplyer does not change the value of the string but tells nothing about the customer. Yesterday, all multithread seemed so far away, now it looks as though they&#8217;re here to stay ;)<br />
(*) well, my remarks, of course, concern arguments that have a &#8216;value&#8217; semantic that it to say those that are mainly substituable by any instance with the same value. Classes providing a &#8216;reference&#8217; semantic (that is distinct only by their adress not by their internal state) are of course systematically passed by reference (and even more so that the semantics of reference is generally incompatible with the copy/move ones). In fact, potentially big (i.e. &#8216;costly&#8217;) value-typed object I manipulate tend to have helpers (like iterator) that are more light and are often better candidates for function since they isolate a facet of the object.</p>
<p>Regards,</p>
<p>Alb</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thomas Gahr				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10021</link>
		<dc:creator><![CDATA[Thomas Gahr]]></dc:creator>
		<pubDate>Mon, 13 May 2013 14:34:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10021</guid>
					<description><![CDATA[Huh. You just sent me off reading through lilbstdc++&#039;s string sources and indeed they don&#039;t use sso (or I just didn&#039;t understand the source code correctly), though some posts I found on the interwebs suggest they at least did so a few years ago [1].
If anyone could point me to some post with a discussion about when/why they changed, I&#039;d be very interested. I found [2] (pre-sso) where it is raised that a decent allocator can bring enough advantage to not require sso - though they&#039;re using the default allocator in std::string - so no speedy small strings for g++ folks :(

However - and this is relevant for the problem posed here: they&#039;re using the null object pattern for the empty string so return std::string() is not expensive.

[1] https://bugzilla.redhat.com/show_bug.cgi?id=197718#c30
[2] http://gcc.gnu.org/ml/libstdc++/2005-11/msg00013.html]]></description>
		<content:encoded><![CDATA[<p>Huh. You just sent me off reading through lilbstdc++&#8217;s string sources and indeed they don&#8217;t use sso (or I just didn&#8217;t understand the source code correctly), though some posts I found on the interwebs suggest they at least did so a few years ago [1].<br />
If anyone could point me to some post with a discussion about when/why they changed, I&#8217;d be very interested. I found [2] (pre-sso) where it is raised that a decent allocator can bring enough advantage to not require sso &#8211; though they&#8217;re using the default allocator in std::string &#8211; so no speedy small strings for g++ folks :(</p>
<p>However &#8211; and this is relevant for the problem posed here: they&#8217;re using the null object pattern for the empty string so return std::string() is not expensive.</p>
<p>[1] <a href="https://bugzilla.redhat.com/show_bug.cgi?id=197718#c30" rel="nofollow">https://bugzilla.redhat.com/show_bug.cgi?id=197718#c30</a><br />
[2] <a href="http://gcc.gnu.org/ml/libstdc++/2005-11/msg00013.html" rel="nofollow">http://gcc.gnu.org/ml/libstdc++/2005-11/msg00013.html</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-2-solution-temporary-objects/#comment-10019</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Mon, 13 May 2013 14:17:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1874#comment-10019</guid>
					<description><![CDATA[In summary, there’s no difference in practice among returning “”, “”s, or { }; use whichever you prefer for stylistic reasons. If your string implementation is either smart or uses SSO, which covers all implementations I know of, there’s exactly zero allocation difference.

What about performance difference?  Don&#039;t the first two forms require a strlen call, or are there string implementations that check the first character for NUL and thus skip the strlen?]]></description>
		<content:encoded><![CDATA[<p>In summary, there’s no difference in practice among returning “”, “”s, or { }; use whichever you prefer for stylistic reasons. If your string implementation is either smart or uses SSO, which covers all implementations I know of, there’s exactly zero allocation difference.</p>
<p>What about performance difference?  Don&#8217;t the first two forms require a strlen call, or are there string implementations that check the first character for NUL and thus skip the strlen?</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
