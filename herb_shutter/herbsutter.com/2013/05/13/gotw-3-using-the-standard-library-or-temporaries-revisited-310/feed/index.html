<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #3: Using the Standard Library (or, Temporaries Revisited) (3/10)	</title>
	<atom:link href="https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: jonh				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-30993</link>
		<dc:creator><![CDATA[jonh]]></dc:creator>
		<pubDate>Wed, 29 Oct 2014 16:13:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-30993</guid>
					<description><![CDATA[Ouch. Sorry. &quot;Let&#039;s learn the lession from ambiguous expressions in &quot;if&quot; and &quot;for&quot; statements, and require &quot;{}&quot; in situations where there&#039;s no benefit to allowing them to be elided.&quot;]]></description>
		<content:encoded><![CDATA[<p>Ouch. Sorry. &#8220;Let&#8217;s learn the lession from ambiguous expressions in &#8220;if&#8221; and &#8220;for&#8221; statements, and require &#8220;{}&#8221; in situations where there&#8217;s no benefit to allowing them to be elided.&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jonh				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-30992</link>
		<dc:creator><![CDATA[jonh]]></dc:creator>
		<pubDate>Wed, 29 Oct 2014 16:11:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-30992</guid>
					<description><![CDATA[I really hope that &#039;expression lambdas&#039; don&#039;t get added to a future version of C++. Consider:

[code]
int i = 1, j =1;
auto f = [](auto &#038;i, auto &#038;j) i++; j++;
[/code]

Unless we&#039;re going to adopt a policy of &quot;never let a lambda parameter name shadow a variable in scope&quot;, then expression lambda syntax is just a trap for the unwary. Let&#039;s learn the lesson from ambiguous expressions in [code]if[/code] and [code]for[/code] statements, and require [code]{}[/code] in situations where there&#039;s no benefit to allowing them to be elided.

Adding (more) syntactical ambiguity to the language for the &#039;benefit&#039; of typing two characters fewer is not a net win, in my opinion.]]></description>
		<content:encoded><![CDATA[<p>I really hope that &#8216;expression lambdas&#8217; don&#8217;t get added to a future version of C++. Consider:</p>
<pre class="brush: plain; title: ; notranslate">
int i = 1, j =1;
auto f = [](auto &amp;i, auto &amp;j) i++; j++;
</pre>
<p>Unless we&#8217;re going to adopt a policy of &#8220;never let a lambda parameter name shadow a variable in scope&#8221;, then expression lambda syntax is just a trap for the unwary. Let&#8217;s learn the lesson from ambiguous expressions in </p>
<pre class="brush: plain; title: ; notranslate">if</pre>
<p> and </p>
<pre class="brush: plain; title: ; notranslate">for</pre>
<p> statements, and require </p>
<pre class="brush: plain; title: ; notranslate">{}</pre>
<p> in situations where there&#8217;s no benefit to allowing them to be elided.</p>
<p>Adding (more) syntactical ambiguity to the language for the &#8216;benefit&#8217; of typing two characters fewer is not a net win, in my opinion.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10204</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 17 May 2013 23:16:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10204</guid>
					<description><![CDATA[@Olaf van der Spek: The other guys already told about find_if being self documenting: To discover that this code is doing a search, you only need to read the function name in the find_if case, but for range for, you need to check the loop body, and if the condition is more complex than this, you might need to take more than 0.1s to discover that it is a search. It&#039;s also less error prone (no silently compiling mistakes e.g. if( name = emp.name() ) ).

And if you are into unit testing, you would also like that find_if version has only 2 branches (I&#039;m not really into testing STL implementation), while the range-for version has 4 (depending on how you define branches), so you need more test cases for 100% code coverage.]]></description>
		<content:encoded><![CDATA[<p>@Olaf van der Spek: The other guys already told about find_if being self documenting: To discover that this code is doing a search, you only need to read the function name in the find_if case, but for range for, you need to check the loop body, and if the condition is more complex than this, you might need to take more than 0.1s to discover that it is a search. It&#8217;s also less error prone (no silently compiling mistakes e.g. if( name = emp.name() ) ).</p>
<p>And if you are into unit testing, you would also like that find_if version has only 2 branches (I&#8217;m not really into testing STL implementation), while the range-for version has 4 (depending on how you define branches), so you need more test cases for 100% code coverage.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10134</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 16 May 2013 19:48:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10134</guid>
					<description><![CDATA[@Bret Kuhns: C++14 does have generic lambdas, meaning &quot;auto&quot; type parameters that generate a templated function call operator. However, other parts of lambda syntax refinements, including potentially allowing expression lambdas like [](auto&#038; e) ++e, , are still under active discussion.]]></description>
		<content:encoded><![CDATA[<p>@Bret Kuhns: C++14 does have generic lambdas, meaning &#8220;auto&#8221; type parameters that generate a templated function call operator. However, other parts of lambda syntax refinements, including potentially allowing expression lambdas like [](auto&amp; e) ++e, , are still under active discussion.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10100</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Wed, 15 May 2013 17:38:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10100</guid>
					<description><![CDATA[I seriously hope that Steve is just woefully uninformed, and we will in fact be receiving VC++ updates prior to VS.Next.  That assertion is completely ridiculous (see VS2008 vs. VS2008 SP1 for a direct contradiction).]]></description>
		<content:encoded><![CDATA[<p>I seriously hope that Steve is just woefully uninformed, and we will in fact be receiving VC++ updates prior to VS.Next.  That assertion is completely ridiculous (see VS2008 vs. VS2008 SP1 for a direct contradiction).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Klaim - Joel Lamotte (@MJKlaim)				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10096</link>
		<dc:creator><![CDATA[Klaim - Joel Lamotte (@MJKlaim)]]></dc:creator>
		<pubDate>Wed, 15 May 2013 16:29:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10096</guid>
					<description><![CDATA[I totally agree with Bret Kuhns that find_if is clearer than a raw loop. A raw loop is an implementation of the algorithm, not it&#039;s name. We have abstractions to help us understand our code, let&#039;s user them.]]></description>
		<content:encoded><![CDATA[<p>I totally agree with Bret Kuhns that find_if is clearer than a raw loop. A raw loop is an implementation of the algorithm, not it&#8217;s name. We have abstractions to help us understand our code, let&#8217;s user them.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sigh				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10094</link>
		<dc:creator><![CDATA[Sigh]]></dc:creator>
		<pubDate>Wed, 15 May 2013 14:53:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10094</guid>
					<description><![CDATA[http://blogs.msdn.com/b/bharry/archive/2013/05/08/some-thoughts-on-a-comment-about-vs-2012-3.aspx
Steve Teixeira, MSFT 13 May 2013 12:17 PM #
@Tom Kirby-Green, C++11 support remains a very high priority. However, we are targeting the next VS release for additional C++11 support (you&#039;ve already seen the beginnings of this in the CTP). It is problematic for us to add new language features in VS Updates because doing so creates a situation whereas two VS2012 developers may not be able to share code with one another due to different levels of language support in different point-releases.

-----

How disappointing.. Sigh.]]></description>
		<content:encoded><![CDATA[<p><a href="http://blogs.msdn.com/b/bharry/archive/2013/05/08/some-thoughts-on-a-comment-about-vs-2012-3.aspx" rel="nofollow">http://blogs.msdn.com/b/bharry/archive/2013/05/08/some-thoughts-on-a-comment-about-vs-2012-3.aspx</a><br />
Steve Teixeira, MSFT 13 May 2013 12:17 PM #<br />
@Tom Kirby-Green, C++11 support remains a very high priority. However, we are targeting the next VS release for additional C++11 support (you&#8217;ve already seen the beginnings of this in the CTP). It is problematic for us to add new language features in VS Updates because doing so creates a situation whereas two VS2012 developers may not be able to share code with one another due to different levels of language support in different point-releases.</p>
<p>&#8212;&#8211;</p>
<p>How disappointing.. Sigh.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10092</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Wed, 15 May 2013 12:28:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10092</guid>
					<description><![CDATA[@Olaf I said information density, not functionality. There are lots of things you can do to pack more functionality in less code, and the majority of those techniques are a bad idea because they reduce readability. Whereas STL algorithms give the reader more information in a tight space than imperative for/while loops.]]></description>
		<content:encoded><![CDATA[<p>@Olaf I said information density, not functionality. There are lots of things you can do to pack more functionality in less code, and the majority of those techniques are a bad idea because they reduce readability. Whereas STL algorithms give the reader more information in a tight space than imperative for/while loops.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10086</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Wed, 15 May 2013 10:12:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10086</guid>
					<description><![CDATA[@bkuhns The for variant packs the same functionality into less code, so IMO that one wins the dense contest. 
However, the find_if variant is less lines.]]></description>
		<content:encoded><![CDATA[<p>@bkuhns The for variant packs the same functionality into less code, so IMO that one wins the dense contest.<br />
However, the find_if variant is less lines.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Example				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10084</link>
		<dc:creator><![CDATA[Example]]></dc:creator>
		<pubDate>Wed, 15 May 2013 07:51:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10084</guid>
					<description><![CDATA[@PietroV: 
 &#062;I know, i call the employee’s constructor, but it’s more readable (I think).

You don&#039;t know whether employee::employee(std::string) or employee::operator==(...) exist, and even if they do, it is rather unlikely that two employees are only identified by their name and find() will most-likely return end().]]></description>
		<content:encoded><![CDATA[<p>@PietroV:<br />
 &gt;I know, i call the employee’s constructor, but it’s more readable (I think).</p>
<p>You don&#8217;t know whether employee::employee(std::string) or employee::operator==(&#8230;) exist, and even if they do, it is rather unlikely that two employees are only identified by their name and find() will most-likely return end().</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bkuhns				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10082</link>
		<dc:creator><![CDATA[bkuhns]]></dc:creator>
		<pubDate>Wed, 15 May 2013 01:00:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10082</guid>
					<description><![CDATA[@Olaf What about if we&#039;re skimming through code, trying to get a grasp on what it does. Let&#039;s say my eyes catch this line:

[code]for (auto&#038; e : emps) {[/code]

All this tells me is that you&#039;re looking through `emps`. If I instead see this line:

[code]auto it = find_if(emps, [&#038;](auto&#038; e) e.name == name );[/code]

Then, well... the story&#039;s over. I see exactly what it&#039;s doing. Even if I don&#039;t read the lambda, I know you&#039;re looking for something in `emps` and whatever&#039;s found, if any, is stored in `it`. I know this from reading only part of one line of code.

The advantage of using STL algorithms is about information density, IMO.]]></description>
		<content:encoded><![CDATA[<p>@Olaf What about if we&#8217;re skimming through code, trying to get a grasp on what it does. Let&#8217;s say my eyes catch this line:</p>
<pre class="brush: plain; title: ; notranslate">for (auto&amp; e : emps) {</pre>
<p>All this tells me is that you&#8217;re looking through `emps`. If I instead see this line:</p>
<pre class="brush: plain; title: ; notranslate">auto it = find_if(emps, [&amp;](auto&amp; e) e.name == name );</pre>
<p>Then, well&#8230; the story&#8217;s over. I see exactly what it&#8217;s doing. Even if I don&#8217;t read the lambda, I know you&#8217;re looking for something in `emps` and whatever&#8217;s found, if any, is stored in `it`. I know this from reading only part of one line of code.</p>
<p>The advantage of using STL algorithms is about information density, IMO.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10074</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Tue, 14 May 2013 19:47:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10074</guid>
					<description><![CDATA[Well may be this sound strange for some peoples here but STL is not used all the time.
In some projects I was working on STL usage was a bad sign and was not really permitted.
Boost look like a great library but it is much too big and many times slow (compiler time and runtime).

IMHO range based for loop is shorter and better as find_if.
And less dependencies on STL :)
[code]
string find_addr( const vector&#060;employee&#062;&#038; emps, const  u16string&#038; name ) {
    for(const auto&#038; i : emps ) {    if( i.name() == name)   return i.addr;   }
    return &#034;&#034;;
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Well may be this sound strange for some peoples here but STL is not used all the time.<br />
In some projects I was working on STL usage was a bad sign and was not really permitted.<br />
Boost look like a great library but it is much too big and many times slow (compiler time and runtime).</p>
<p>IMHO range based for loop is shorter and better as find_if.<br />
And less dependencies on STL :)</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const vector&lt;employee&gt;&amp; emps, const  u16string&amp; name ) {
    for(const auto&amp; i : emps ) {    if( i.name() == name)   return i.addr;   }
    return &quot;&quot;;
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: germinolegrand				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10072</link>
		<dc:creator><![CDATA[germinolegrand]]></dc:creator>
		<pubDate>Tue, 14 May 2013 15:37:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10072</guid>
					<description><![CDATA[@Olaf : code self-expressivity i guess...]]></description>
		<content:encoded><![CDATA[<p>@Olaf : code self-expressivity i guess&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10071</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Tue, 14 May 2013 15:36:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10071</guid>
					<description><![CDATA[For is still shorter / simpler. What&#039;s the advantage of find_if?]]></description>
		<content:encoded><![CDATA[<p>For is still shorter / simpler. What&#8217;s the advantage of find_if?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10070</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Tue, 14 May 2013 14:53:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10070</guid>
					<description><![CDATA[@Olaf
range-based-for
[code]
for (auto&#038; e : emps) {
    if (name == e.name()) {
        return e.addr();
    }
}
return {};
[/code]
vs stl-range-find + generic lambda + N3560 section 2.2:
[code]
auto it = find_if(emps, [&#038;](auto&#038; e) e.name == name );
if (it != emps.end())
    return it-&#062;addr();
return {};
[/code]

Not convinced :)]]></description>
		<content:encoded><![CDATA[<p>@Olaf<br />
range-based-for</p>
<pre class="brush: plain; title: ; notranslate">
for (auto&amp; e : emps) {
    if (name == e.name()) {
        return e.addr();
    }
}
return {};
</pre>
<p>vs stl-range-find + generic lambda + N3560 section 2.2:</p>
<pre class="brush: plain; title: ; notranslate">
auto it = find_if(emps, [&amp;](auto&amp; e) e.name == name );
if (it != emps.end())
    return it-&gt;addr();
return {};
</pre>
<p>Not convinced :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bkuhns				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10066</link>
		<dc:creator><![CDATA[bkuhns]]></dc:creator>
		<pubDate>Tue, 14 May 2013 12:29:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10066</guid>
					<description><![CDATA[@bilbothegravatar Also, the Range Study Group is targeting a TS after C++14. They fixed some wording for C++14 to remove some roadblocks for the TS, hopefully making it all the easier to adopt in C++17. Judging by your gravatar, I&#039;ll assume you know to use boost.range for now ;-)]]></description>
		<content:encoded><![CDATA[<p>@bilbothegravatar Also, the Range Study Group is targeting a TS after C++14. They fixed some wording for C++14 to remove some roadblocks for the TS, hopefully making it all the easier to adopt in C++17. Judging by your gravatar, I&#8217;ll assume you know to use boost.range for now ;-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bkuhns				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10065</link>
		<dc:creator><![CDATA[bkuhns]]></dc:creator>
		<pubDate>Tue, 14 May 2013 12:15:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10065</guid>
					<description><![CDATA[@bilbothegravatar Herb mentioned the GotW&#039;s are covering C++14 now. That lambda syntax is a new feature of C++14. It uses both generic/polymorphic lambdas (note the const auto&#038; parameter), and the abbreviated syntax that makes the curly braces and return statement optional (the return becomes assumed).]]></description>
		<content:encoded><![CDATA[<p>@bilbothegravatar Herb mentioned the GotW&#8217;s are covering C++14 now. That lambda syntax is a new feature of C++14. It uses both generic/polymorphic lambdas (note the const auto&amp; parameter), and the abbreviated syntax that makes the curly braces and return statement optional (the return becomes assumed).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bilbothegravatar				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10063</link>
		<dc:creator><![CDATA[bilbothegravatar]]></dc:creator>
		<pubDate>Tue, 14 May 2013 11:13:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10063</guid>
					<description><![CDATA[Comparing the boiler plate needed for std::find_if vs. the code needed to write this with a range-based-for loop IMHO clearly shows that we need range algorithms (not in C++14, right?) in the standard and (at least) auto lambdas (in C++14, right?).

And, btw. [CODE][&#038;](const auto&#038; e) e.name() == name;[/CODE] ... being able to get rid of the curly braces for one-line lambdas would also be nice. Is this actually in C++14 of a typo of @BretKuhns?]]></description>
		<content:encoded><![CDATA[<p>Comparing the boiler plate needed for std::find_if vs. the code needed to write this with a range-based-for loop IMHO clearly shows that we need range algorithms (not in C++14, right?) in the standard and (at least) auto lambdas (in C++14, right?).</p>
<p>And, btw. [CODE][&amp;](const auto&amp; e) e.name() == name;[/CODE] &#8230; being able to get rid of the curly braces for one-line lambdas would also be nice. Is this actually in C++14 of a typo of @BretKuhns?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10061</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Tue, 14 May 2013 09:24:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10061</guid>
					<description><![CDATA[(Don&#039;t you hate this editor??? That&#039;s what I call an arrogant interface :P - ) - Let&#039;s try again...

[code]
std::optional&#060;std::string&#062; find_addr( const list&#060;employee&#062;&#038; emps, const std::string&#038; name )
{
    std::optional&#060;std::string&#062; result;
    find_if(begin(emps), end(emps), [&#038;result, &#038;name](const auto&#038; employee) {
        if(employee.name() == name){
            result = employee.addr;
            return true;
         }
        else
           return false; } );
    return result;
}
[/code]

usage:

[code]
auto result = find_addr(employees, lookup_name);
if(result)
std::cout &#060;&#060; &#034;Employee&#039;s address found: &#034; &#060;&#060; *result &#060;&#060; std::endl;
else
std::cout &#060;&#060; &#034;Sorry. Employee not found.&#034; &#060;&#060; std::endl;
[/code]]]></description>
		<content:encoded><![CDATA[<p>(Don&#8217;t you hate this editor??? That&#8217;s what I call an arrogant interface :P &#8211; ) &#8211; Let&#8217;s try again&#8230;</p>
<pre class="brush: plain; title: ; notranslate">
std::optional&lt;std::string&gt; find_addr( const list&lt;employee&gt;&amp; emps, const std::string&amp; name )
{
    std::optional&lt;std::string&gt; result;
    find_if(begin(emps), end(emps), [&amp;result, &amp;name](const auto&amp; employee) {
        if(employee.name() == name){
            result = employee.addr;
            return true;
         }
        else
           return false; } );
    return result;
}
</pre>
<p>usage:</p>
<pre class="brush: plain; title: ; notranslate">
auto result = find_addr(employees, lookup_name);
if(result)
std::cout &lt;&lt; &quot;Employee's address found: &quot; &lt;&lt; *result &lt;&lt; std::endl;
else
std::cout &lt;&lt; &quot;Sorry. Employee not found.&quot; &lt;&lt; std::endl;
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10060</link>
		<dc:creator><![CDATA[Fernando]]></dc:creator>
		<pubDate>Tue, 14 May 2013 09:19:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10060</guid>
					<description><![CDATA[Using C++14 this function should return a std::optional:

[CODE]
std::optional find_addr( const list&#038; emps, const string&#038; name ) 
{
    std::optional result;
    find_if(begin(emps), end(emps), [&#038;result, &#038;name](const auto&#038; employee) { 
        if(employee.name() == name){
            result = employee.addr;
            return true;
        }
        else
            return false;
    } );
    return result;
}
[/CODE]

usage:

[CODE]
auto result = find_addr(employees, lookup_name);
if(result)
    std::cout &#060;&#060; &#034;Employee&#039;s address found: &#034; &#060;&#060; *result &#060;&#060; std::endl;
else
    std::cout &#060;&#060; &#034;Sorry. Employee not found.&#034; &#060;&#060; std::endl;
[/CODE]]]></description>
		<content:encoded><![CDATA[<p>Using C++14 this function should return a std::optional:</p>
<p>[CODE]<br />
std::optional find_addr( const list&amp; emps, const string&amp; name )<br />
{<br />
    std::optional result;<br />
    find_if(begin(emps), end(emps), [&amp;result, &amp;name](const auto&amp; employee) {<br />
        if(employee.name() == name){<br />
            result = employee.addr;<br />
            return true;<br />
        }<br />
        else<br />
            return false;<br />
    } );<br />
    return result;<br />
}<br />
[/CODE]</p>
<p>usage:</p>
<p>[CODE]<br />
auto result = find_addr(employees, lookup_name);<br />
if(result)<br />
    std::cout &lt;&lt; &quot;Employee&#039;s address found: &quot; &lt;&lt; *result &lt;&lt; std::endl;<br />
else<br />
    std::cout &lt;&lt; &quot;Sorry. Employee not found.&quot; &lt;&lt; std::endl;<br />
[/CODE]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10057</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Tue, 14 May 2013 08:40:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10057</guid>
					<description><![CDATA[@Róbert As I wrote: &quot;Using find_if is quite verbose, the for variant is simpler.&quot;
A range-based find_if won&#039;t really help.]]></description>
		<content:encoded><![CDATA[<p>@Róbert As I wrote: &#8220;Using find_if is quite verbose, the for variant is simpler.&#8221;<br />
A range-based find_if won&#8217;t really help.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gonzalo BG				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10055</link>
		<dc:creator><![CDATA[Gonzalo BG]]></dc:creator>
		<pubDate>Tue, 14 May 2013 07:41:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10055</guid>
					<description><![CDATA[1. What is the most widely used C++ library? The Standard Library, hopefully followed by Boost.

2. a) See other answers, the right thing to do is to use find_if.
2. b) Quoting from my answer to the previous question:

Taking the parameters by const reference and using boost::find_if solves all the “sought” problems (it&#039;s just a range-based wrapper to the STL call):

auto find_addr(const list&#038; emps, const string&#038; name) {
    const auto pos = find_if(emps, [&#038;](const auto&#038; e){ return e.name == name; });
    return pos != end(emps) ? pos-&#062;addr : string();
}

In code review I would probably complain that with the find_addr function you get an empty string if:
– the employee does not exist, _and_
– the employee exists but its adress has not been set yet (e.g. addr was default constructed to an empty string).

If the function is required I’d recommend using boost::optional for the return type. However I would _strongly_ recommend that the best way to improve this function is not to write it in the first place. Is just a one-liner call to find_if. And by using find_if directly the semantics of not found are crystal clear.

@Gabriel Garcia used std::optional up there. I still think the best thing is not to write this function at all.]]></description>
		<content:encoded><![CDATA[<p>1. What is the most widely used C++ library? The Standard Library, hopefully followed by Boost.</p>
<p>2. a) See other answers, the right thing to do is to use find_if.<br />
2. b) Quoting from my answer to the previous question:</p>
<p>Taking the parameters by const reference and using boost::find_if solves all the “sought” problems (it&#8217;s just a range-based wrapper to the STL call):</p>
<p>auto find_addr(const list&amp; emps, const string&amp; name) {<br />
    const auto pos = find_if(emps, [&amp;](const auto&amp; e){ return e.name == name; });<br />
    return pos != end(emps) ? pos-&gt;addr : string();<br />
}</p>
<p>In code review I would probably complain that with the find_addr function you get an empty string if:<br />
– the employee does not exist, _and_<br />
– the employee exists but its adress has not been set yet (e.g. addr was default constructed to an empty string).</p>
<p>If the function is required I’d recommend using boost::optional for the return type. However I would _strongly_ recommend that the best way to improve this function is not to write it in the first place. Is just a one-liner call to find_if. And by using find_if directly the semantics of not found are crystal clear.</p>
<p>@Gabriel Garcia used std::optional up there. I still think the best thing is not to write this function at all.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: monamimani				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10053</link>
		<dc:creator><![CDATA[monamimani]]></dc:creator>
		<pubDate>Tue, 14 May 2013 03:16:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10053</guid>
					<description><![CDATA[For fun I&#039;ll try something new :)
[code]
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) 
{
    string result;
    find_if(begin(emps), end(emps), [&#038;result, &#038;name](const auto&#038; employee) 
    { 
        bool found = employee.name() == name; 
        if(found)
            result = employee.addr;
        return found;
    } );
    return result;
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>For fun I&#8217;ll try something new :)</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) 
{
    string result;
    find_if(begin(emps), end(emps), [&amp;result, &amp;name](const auto&amp; employee) 
    { 
        bool found = employee.name() == name; 
        if(found)
            result = employee.addr;
        return found;
    } );
    return result;
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pindragon				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10052</link>
		<dc:creator><![CDATA[pindragon]]></dc:creator>
		<pubDate>Tue, 14 May 2013 02:26:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10052</guid>
					<description><![CDATA[&#062; What would these people say about the range-version std::find?

I’m a part of those people (I&#039;m Mikhail Belyaev with wordpress messing my name for every second comment) and I would say it rocks. I even have my own set of range-based algorithms in my current project (as well as a function that wraps any pair of iterators into a range-for-enabled structure). Too bad we don&#039;t have &#039;em in the stl yet.
On the other hand, some complex loopy operations will still be expressed with range-for much better.]]></description>
		<content:encoded><![CDATA[<p>&gt; What would these people say about the range-version std::find?</p>
<p>I’m a part of those people (I&#8217;m Mikhail Belyaev with wordpress messing my name for every second comment) and I would say it rocks. I even have my own set of range-based algorithms in my current project (as well as a function that wraps any pair of iterators into a range-for-enabled structure). Too bad we don&#8217;t have &#8217;em in the stl yet.<br />
On the other hand, some complex loopy operations will still be expressed with range-for much better.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gabriel Garcia				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10047</link>
		<dc:creator><![CDATA[Gabriel Garcia]]></dc:creator>
		<pubDate>Tue, 14 May 2013 00:08:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10047</guid>
					<description><![CDATA[C++14 + Concepts Lite:

[code]
template &#060;Container Cont&#062;
    requires std::is_same&#060;typename Value_type&#060;Cont&#062;, employee&#062;
std::optional&#060;string&#062; find_addr(const Cont &#038;cont, const string &#038;name) {
    for (const auto &#038;cur : cont) {
        if (cur.name() == name) {
            return cur.addr;
        }
    }
    return std::nullopt;
}
[/code]

(I may be missing a thing or two, regarding Concepts Lite correctness)]]></description>
		<content:encoded><![CDATA[<p>C++14 + Concepts Lite:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;Container Cont&gt;
    requires std::is_same&lt;typename Value_type&lt;Cont&gt;, employee&gt;
std::optional&lt;string&gt; find_addr(const Cont &amp;cont, const string &amp;name) {
    for (const auto &amp;cur : cont) {
        if (cur.name() == name) {
            return cur.addr;
        }
    }
    return std::nullopt;
}
</pre>
<p>(I may be missing a thing or two, regarding Concepts Lite correctness)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: germinolegrand				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10046</link>
		<dc:creator><![CDATA[germinolegrand]]></dc:creator>
		<pubDate>Mon, 13 May 2013 23:35:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10046</guid>
					<description><![CDATA[&#062; What would these people say about the range-version std::find?

I&#039;m not part of those people, but I&#039;d really love to have all algorithms range version, because it would both combine simplicity (whitch means mostly relyability) and full expressivity !]]></description>
		<content:encoded><![CDATA[<p>&gt; What would these people say about the range-version std::find?</p>
<p>I&#8217;m not part of those people, but I&#8217;d really love to have all algorithms range version, because it would both combine simplicity (whitch means mostly relyability) and full expressivity !</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10045</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Mon, 13 May 2013 23:22:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10045</guid>
					<description><![CDATA[I wonder why do people prefer range-for over std::find/find_if. Is it because the &#039;redundant&#039; begin(), end() pair? What would these people say about the range-version std::find? It should be roughly [code]auto it = find(emps, employee(name));[/code]]]></description>
		<content:encoded><![CDATA[<p>I wonder why do people prefer range-for over std::find/find_if. Is it because the &#8216;redundant&#8217; begin(), end() pair? What would these people say about the range-version std::find? It should be roughly </p>
<pre class="brush: plain; title: ; notranslate">auto it = find(emps, employee(name));</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: PietroV				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10044</link>
		<dc:creator><![CDATA[PietroV]]></dc:creator>
		<pubDate>Mon, 13 May 2013 22:12:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10044</guid>
					<description><![CDATA[1) STL

2a) range-for:
[code]
string find_addr( list const&#038; emps, string const&#038; name ) {
    for( auto const&#038; emp : emps )
        if( emp.name() == name )
            return emp.addr;
    return &#034;&#034;;
}
[/code]

2b) stl algo:
I’ll try a different approach..
[code]
string find_addr( list const&#038; emps, string const&#038; name ) {
    auto found = find(begin(emps), end(emps), employee(name) );
    if( found != end(emps) )
        return found-&#062;addr;
    return &#034;&#034;;
}
[/code]
I know, i call the employee’s constructor, but it’s more readable (I think).
I still prefer the range-for version.]]></description>
		<content:encoded><![CDATA[<p>1) STL</p>
<p>2a) range-for:</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( list const&amp; emps, string const&amp; name ) {
    for( auto const&amp; emp : emps )
        if( emp.name() == name )
            return emp.addr;
    return &quot;&quot;;
}
</pre>
<p>2b) stl algo:<br />
I’ll try a different approach..</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( list const&amp; emps, string const&amp; name ) {
    auto found = find(begin(emps), end(emps), employee(name) );
    if( found != end(emps) )
        return found-&gt;addr;
    return &quot;&quot;;
}
</pre>
<p>I know, i call the employee’s constructor, but it’s more readable (I think).<br />
I still prefer the range-for version.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mordachaiwolf				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10040</link>
		<dc:creator><![CDATA[mordachaiwolf]]></dc:creator>
		<pubDate>Mon, 13 May 2013 21:10:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10040</guid>
					<description><![CDATA[I would just add a niggling note that since we use end(emps) multiple times, but it won&#039;t change, it wouldn&#039;t hurt to store that once &#038; only once:

string find_addr(const list&#038; emps, const string&#038; name )
{
    auto notfound = end(emps);
    auto location = find_if(begin(emps), notfound, [&#038;name](const auto&#038; emp)
    {
        return emp.name() == name;
    });
 
    if (location != notfound)
        return location-&#062;addr;
 
    return &quot;&quot;;
}]]></description>
		<content:encoded><![CDATA[<p>I would just add a niggling note that since we use end(emps) multiple times, but it won&#8217;t change, it wouldn&#8217;t hurt to store that once &amp; only once:</p>
<p>string find_addr(const list&amp; emps, const string&amp; name )<br />
{<br />
    auto notfound = end(emps);<br />
    auto location = find_if(begin(emps), notfound, [&amp;name](const auto&amp; emp)<br />
    {<br />
        return emp.name() == name;<br />
    });</p>
<p>    if (location != notfound)<br />
        return location-&gt;addr;</p>
<p>    return &#8220;&#8221;;<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: germinolegrand				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10033</link>
		<dc:creator><![CDATA[germinolegrand]]></dc:creator>
		<pubDate>Mon, 13 May 2013 16:38:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10033</guid>
					<description><![CDATA[1. STL is the best.
2. STL Algoritms + lambda are the best.

I won&#039;t give the range for based loop (uh, need an abbreviation for this :D) since is simple and already given by everyone here.

I will rather try to point something about the lambda+algo one :
[code]
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) 
{
    auto empIt = find_if(begin(emps), end(emps), [&#038;name](const auto&#038; emp)
    {
        return emp.name() == name;
    });

    if(empIt != end(emps))
        return empIt -&#062;addr;

    return &#034;&#034;;
}
[/code]

Since we write for C++14, we can use auto. This is cool because it simplifies a generic code. I personnaly always try to avoid repeating a type.

In C++11 (because I can&#039;t use C++14 in production code of course), I have to write this :
[code]
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) 
{
    auto empIt = find_if(begin(emps), end(emps), [&#038;name](const decltype(emps)::value_type&#038; emp)
    {
        return emp.name() == name;
    });

    if(empIt != end(emps))
        return empIt-&#062;addr;

    return &#034;&#034;;
}
[/code]

But even if I&#039;m restricting to STL like containers in the C++11 version, it is highly preferable than repeating the type of what is stored in emps (perhaps const decltype(*begin(emps))&#038; would be better ? I think it lacks of clarity but it would have the great advantage of working on any kind of container, STL like or not).

With this, I am able to change the container type, or even the type in the container (as long as it has a name() method and an addr member attribute) from one and only one point (here the function declaration) without changing at all the meaning and the validity of the code.
This increases code reusability.

For the difference between RBFL and lambda+algo :
* RBFL is simpler : no extra variables, no extra code. But it needs either a comment or a longer read time later.
* lambda+algo is more expressive : the code itself says it wants to *find* the *emp* *whose name* is *name* and *return* *its addr* *if you found one* or *&quot;&quot; as the default value*. Could you even be more expressive on what this code does in a comment poorly paraphrasing the code ?]]></description>
		<content:encoded><![CDATA[<p>1. STL is the best.<br />
2. STL Algoritms + lambda are the best.</p>
<p>I won&#8217;t give the range for based loop (uh, need an abbreviation for this :D) since is simple and already given by everyone here.</p>
<p>I will rather try to point something about the lambda+algo one :</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) 
{
    auto empIt = find_if(begin(emps), end(emps), [&amp;name](const auto&amp; emp)
    {
        return emp.name() == name;
    });

    if(empIt != end(emps))
        return empIt -&gt;addr;

    return &quot;&quot;;
}
</pre>
<p>Since we write for C++14, we can use auto. This is cool because it simplifies a generic code. I personnaly always try to avoid repeating a type.</p>
<p>In C++11 (because I can&#8217;t use C++14 in production code of course), I have to write this :</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) 
{
    auto empIt = find_if(begin(emps), end(emps), [&amp;name](const decltype(emps)::value_type&amp; emp)
    {
        return emp.name() == name;
    });

    if(empIt != end(emps))
        return empIt-&gt;addr;

    return &quot;&quot;;
}
</pre>
<p>But even if I&#8217;m restricting to STL like containers in the C++11 version, it is highly preferable than repeating the type of what is stored in emps (perhaps const decltype(*begin(emps))&amp; would be better ? I think it lacks of clarity but it would have the great advantage of working on any kind of container, STL like or not).</p>
<p>With this, I am able to change the container type, or even the type in the container (as long as it has a name() method and an addr member attribute) from one and only one point (here the function declaration) without changing at all the meaning and the validity of the code.<br />
This increases code reusability.</p>
<p>For the difference between RBFL and lambda+algo :<br />
* RBFL is simpler : no extra variables, no extra code. But it needs either a comment or a longer read time later.<br />
* lambda+algo is more expressive : the code itself says it wants to *find* the *emp* *whose name* is *name* and *return* *its addr* *if you found one* or *&#8221;&#8221; as the default value*. Could you even be more expressive on what this code does in a comment poorly paraphrasing the code ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: stackedcrooked				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10026</link>
		<dc:creator><![CDATA[stackedcrooked]]></dc:creator>
		<pubDate>Mon, 13 May 2013 15:09:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10026</guid>
					<description><![CDATA[1. The Standard C++ library
2. I think Mikhail Belyaev&#039;s answer is perfect here.]]></description>
		<content:encoded><![CDATA[<p>1. The Standard C++ library<br />
2. I think Mikhail Belyaev&#8217;s answer is perfect here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Paul				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10025</link>
		<dc:creator><![CDATA[Paul]]></dc:creator>
		<pubDate>Mon, 13 May 2013 15:03:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10025</guid>
					<description><![CDATA[Maybe this isn&#039;t appropriate but using Linq in C++, it can be done in one line without much clutter:
[code] 
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) 
{
    return LINQ(from(emp, emps) where(emp.name() == name)) &#124; linq::first_or_default;
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Maybe this isn&#8217;t appropriate but using Linq in C++, it can be done in one line without much clutter:</p>
<pre class="brush: plain; title: ; notranslate"> 
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) 
{
    return LINQ(from(emp, emps) where(emp.name() == name)) | linq::first_or_default;
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mikhail Belyaev				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10020</link>
		<dc:creator><![CDATA[Mikhail Belyaev]]></dc:creator>
		<pubDate>Mon, 13 May 2013 14:33:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10020</guid>
					<description><![CDATA[1. If you take the question like &quot;what library is used in most C++ projects&quot;, it&#039;s probably iostreams. If you take it like &quot;what library&#039;s functions are called most of all&quot;, it&#039;s STL.
2. As I&#039;ve already proposed range-for-based loop, here it is again:
[code]
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    for( const auto&#038; emp : emps)
        if( emp.name() == name ) return emp.addr;
    return &#034;&#034;;
}
[/code]

for_each:
[code]
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    auto where = 
           std::find_if(cbegin(emps), cend(emps), [&#038;name](const employee&#038; emp) { return emp.name() == name; });
    return (where == cend(emps))? &#034;&#034; : where-&#062;addr;
}
[/code]

What do we get from both?
1. We do not need to memoize end(emps);
2. No possible ++ issues (hey, nobody can guarantee he never wrote postfix ++ accidentally);
3. We&#039;ve got and employee&#038; inside the body rather than some_fancy_iterator.

What do we get from range-for?
It soo much more clear what&#039;s happening with less code. Not all algorithm combinations can be expressed with this loop though.]]></description>
		<content:encoded><![CDATA[<p>1. If you take the question like &#8220;what library is used in most C++ projects&#8221;, it&#8217;s probably iostreams. If you take it like &#8220;what library&#8217;s functions are called most of all&#8221;, it&#8217;s STL.<br />
2. As I&#8217;ve already proposed range-for-based loop, here it is again:</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    for( const auto&amp; emp : emps)
        if( emp.name() == name ) return emp.addr;
    return &quot;&quot;;
}
</pre>
<p>for_each:</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    auto where = 
           std::find_if(cbegin(emps), cend(emps), [&amp;name](const employee&amp; emp) { return emp.name() == name; });
    return (where == cend(emps))? &quot;&quot; : where-&gt;addr;
}
</pre>
<p>What do we get from both?<br />
1. We do not need to memoize end(emps);<br />
2. No possible ++ issues (hey, nobody can guarantee he never wrote postfix ++ accidentally);<br />
3. We&#8217;ve got and employee&amp; inside the body rather than some_fancy_iterator.</p>
<p>What do we get from range-for?<br />
It soo much more clear what&#8217;s happening with less code. Not all algorithm combinations can be expressed with this loop though.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10018</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Mon, 13 May 2013 13:39:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10018</guid>
					<description><![CDATA[[code]string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    for( const auto&#038; i : emps ) {
        if( i.name() == name ) {
            return i.addr;
        }
    }
    return &#034;&#034;;
}[/code]

[code]string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    auto iter = find_if(cbegin(emps), cend(emps), [&#038;](const auto&#038; e) e.name() == name );
    return iter != cend(emps) 
         ? iter-&#062;addr
         : &#034;&#034;;
}[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    for( const auto&amp; i : emps ) {
        if( i.name() == name ) {
            return i.addr;
        }
    }
    return &quot;&quot;;
}</pre>
<pre class="brush: plain; title: ; notranslate">string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    auto iter = find_if(cbegin(emps), cend(emps), [&amp;](const auto&amp; e) e.name() == name );
    return iter != cend(emps) 
         ? iter-&gt;addr
         : &quot;&quot;;
}</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/13/gotw-3-using-the-standard-library-or-temporaries-revisited-310/#comment-10012</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Mon, 13 May 2013 13:09:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1888#comment-10012</guid>
					<description><![CDATA[[code]
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    for( auto&#038; i : emps ) {
        if( i.name() == name )
            return i.addr;
    }
    return &#034;&#034;;
}
[/code]
[code]
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
	auto i = find_if(begin(emps), end(emps), [&#038;](const employee&#038; a) { return a.name() == name; } );
	return i == end(emps) ? &#034;&#034; : i-&#062;addr;
}
[/code]
Using find_if is quite verbose, the for variant is simpler. I&#039;d still return employee* though. :p]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    for( auto&amp; i : emps ) {
        if( i.name() == name )
            return i.addr;
    }
    return &quot;&quot;;
}
</pre>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
	auto i = find_if(begin(emps), end(emps), [&amp;](const employee&amp; a) { return a.name() == name; } );
	return i == end(emps) ? &quot;&quot; : i-&gt;addr;
}
</pre>
<p>Using find_if is quite verbose, the for variant is simpler. I&#8217;d still return employee* though. :p</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
