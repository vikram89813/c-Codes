<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #2: Temporary Objects	</title>
	<atom:link href="https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Roger				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-10035</link>
		<dc:creator><![CDATA[Roger]]></dc:creator>
		<pubDate>Mon, 13 May 2013 18:09:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-10035</guid>
					<description><![CDATA[@Robert,
No, we don&#039;t want to write code that depends on the caller knowing that they have to store the data differently than how it is returned. That way lies madness.

There is no reason not to return by value. We have move semantics, we have compiler optimizations if move semantics is not enabled. Anything other than return by value is unsafe.]]></description>
		<content:encoded><![CDATA[<p>@Robert,<br />
No, we don&#8217;t want to write code that depends on the caller knowing that they have to store the data differently than how it is returned. That way lies madness.</p>
<p>There is no reason not to return by value. We have move semantics, we have compiler optimizations if move semantics is not enabled. Anything other than return by value is unsafe.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Magnus				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-10003</link>
		<dc:creator><![CDATA[Magnus]]></dc:creator>
		<pubDate>Mon, 13 May 2013 08:30:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-10003</guid>
					<description><![CDATA[The return value should never be const std::string&#038; as so many has suggested. In C++11 we have move constructors. The data will be &quot;moved&quot; so there is no copying. All data should as of C++11 be returned by value, as long as you have implemented a move constructor. Also the parameter should be const reference.]]></description>
		<content:encoded><![CDATA[<p>The return value should never be const std::string&amp; as so many has suggested. In C++11 we have move constructors. The data will be &#8220;moved&#8221; so there is no copying. All data should as of C++11 be returned by value, as long as you have implemented a move constructor. Also the parameter should be const reference.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: TheMatto				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-10002</link>
		<dc:creator><![CDATA[TheMatto]]></dc:creator>
		<pubDate>Mon, 13 May 2013 03:38:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-10002</guid>
					<description><![CDATA[Tested with VS2012CTP:

[code]
string find_addr( const list&#060;employee&#062; &#038; emps, const string &#038; name ) {
    for ( auto &#038;&#038; i : emps ) {
        if ( i.name == name ) {
            return {i.addr};
        }
    }
    return {&#034;&#034;};
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Tested with VS2012CTP:</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt; &amp; emps, const string &amp; name ) {
    for ( auto &amp;&amp; i : emps ) {
        if ( i.name == name ) {
            return {i.addr};
        }
    }
    return {&quot;&quot;};
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: c-smile				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-10001</link>
		<dc:creator><![CDATA[c-smile]]></dc:creator>
		<pubDate>Mon, 13 May 2013 03:18:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-10001</guid>
					<description><![CDATA[Keeping original semantic and behavior intact :
[code]string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    for( auto i = begin(emps), e = end(emps); i != e; ++i )
      if( i-&#062;name == name )
        return i-&#062;addr;
    return string();
}[/code]]]></description>
		<content:encoded><![CDATA[<p>Keeping original semantic and behavior intact :</p>
<pre class="brush: plain; title: ; notranslate">string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    for( auto i = begin(emps), e = end(emps); i != e; ++i )
      if( i-&gt;name == name )
        return i-&gt;addr;
    return string();
}</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gonzalo BG				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-10000</link>
		<dc:creator><![CDATA[Gonzalo BG]]></dc:creator>
		<pubDate>Sun, 12 May 2013 21:42:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-10000</guid>
					<description><![CDATA[Taking the parameters by const reference and using boost::find_if solves all the &quot;sought&quot; problems:

[code]
auto find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name) {
    const auto pos = find_if(emps, [&#038;](const auto&#038; e){ return e.name == name; });
    return pos != end(emps) ? pos-&#062;addr : string();
}
[/code]

In code review I would probably complain that with the find_addr function you get an empty string if:
  - the employee does not exist, _and_
  - the employee exists but its adress has not been set yet (e.g. addr was default constructed to an empty string).

If the function is required I&#039;d recommend using boost::optional for the return type. However I would _strongly_ recommend that the best way to improve this function is not to write it in the first place. Is just a one-liner call to find_if. And by using find_if directly the semantics of not found are crystal clear.]]></description>
		<content:encoded><![CDATA[<p>Taking the parameters by const reference and using boost::find_if solves all the &#8220;sought&#8221; problems:</p>
<pre class="brush: plain; title: ; notranslate">
auto find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name) {
    const auto pos = find_if(emps, [&amp;](const auto&amp; e){ return e.name == name; });
    return pos != end(emps) ? pos-&gt;addr : string();
}
</pre>
<p>In code review I would probably complain that with the find_addr function you get an empty string if:<br />
  &#8211; the employee does not exist, _and_<br />
  &#8211; the employee exists but its adress has not been set yet (e.g. addr was default constructed to an empty string).</p>
<p>If the function is required I&#8217;d recommend using boost::optional for the return type. However I would _strongly_ recommend that the best way to improve this function is not to write it in the first place. Is just a one-liner call to find_if. And by using find_if directly the semantics of not found are crystal clear.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9999</link>
		<dc:creator><![CDATA[John]]></dc:creator>
		<pubDate>Sun, 12 May 2013 19:32:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9999</guid>
					<description><![CDATA[Since const is nowhere to be found, it&#039;s possible that the implementation of operator==(Employee,string) takes non-const refs as args. In that case, there isn&#039;t much room for improvement. 

Assuming operator== is better than the sample code, then I see 5 temporaries: the two args, the return val, the value returned by end() and the expression i++.

I&#039;d fix the args and the 2nd return statement, leaving the rest as-is.]]></description>
		<content:encoded><![CDATA[<p>Since const is nowhere to be found, it&#8217;s possible that the implementation of operator==(Employee,string) takes non-const refs as args. In that case, there isn&#8217;t much room for improvement. </p>
<p>Assuming operator== is better than the sample code, then I see 5 temporaries: the two args, the return val, the value returned by end() and the expression i++.</p>
<p>I&#8217;d fix the args and the 2nd return statement, leaving the rest as-is.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9984</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Sat, 11 May 2013 12:06:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9984</guid>
					<description><![CDATA[Clarification: returning a std::string() may create the object in-place if the function is called in the declaration/initialization - i.e. auto res = find_string(my_strings, lookup_string);]]></description>
		<content:encoded><![CDATA[<p>Clarification: returning a std::string() may create the object in-place if the function is called in the declaration/initialization &#8211; i.e. auto res = find_string(my_strings, lookup_string);</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9983</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Sat, 11 May 2013 11:58:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9983</guid>
					<description><![CDATA[Please note: If you return string(), you are creating a temporary object. 
returning &quot;&quot; will invoke either the const char* assignment operator or the [CODE]const char*[CODE] constructor - i.e. doesn&#039;t create any temporary object. Also, returning something different than the original &quot;&quot; might seem innocuous, but you should never make assumptions - let&#039;s say in the future an uninitialized std::string is not the same as empty string/zero-length string, or if you decide to replace std::string for an [CODE]std::optional[/CODE], or (very common) decide to use a better string manipulation class that treats empty strings differently... 

If you use the old [b]for[/b], you need a temporary iterator. Use the C++ range [b]for[/b] with a reference, i.e. for( auto&#038; refval : emps) instead.

Although the original code suggests there is a [CODE]bool employee::operator==(const std::string&#038;)[/CODE] prefer a more explicit code: i.e. [CODE]emp.name == lookup_name[/CODE] (Isn&#039;t that much more obvious?) comparing a string to a user defined object might be confusing - i.e. lead the reviewer to make wrong assumptions or check the implementation of the object&#039;s class to try to understand what is really doing.]]></description>
		<content:encoded><![CDATA[<p>Please note: If you return string(), you are creating a temporary object.<br />
returning &#8220;&#8221; will invoke either the const char* assignment operator or the [CODE]const char*[CODE] constructor &#8211; i.e. doesn&#8217;t create any temporary object. Also, returning something different than the original &#8220;&#8221; might seem innocuous, but you should never make assumptions &#8211; let&#8217;s say in the future an uninitialized std::string is not the same as empty string/zero-length string, or if you decide to replace std::string for an [CODE]std::optional[/CODE], or (very common) decide to use a better string manipulation class that treats empty strings differently&#8230; </p>
<p>If you use the old [b]for[/b], you need a temporary iterator. Use the C++ range [b]for[/b] with a reference, i.e. for( auto&amp; refval : emps) instead.</p>
<p>Although the original code suggests there is a [CODE]bool employee::operator==(const std::string&amp;)[/CODE] prefer a more explicit code: i.e. [CODE]emp.name == lookup_name[/CODE] (Isn&#8217;t that much more obvious?) comparing a string to a user defined object might be confusing &#8211; i.e. lead the reviewer to make wrong assumptions or check the implementation of the object&#8217;s class to try to understand what is really doing.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: borishr				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9982</link>
		<dc:creator><![CDATA[borishr]]></dc:creator>
		<pubDate>Sat, 11 May 2013 10:51:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9982</guid>
					<description><![CDATA[Here&#039;s my take.
&lt;code&gt;
string find_addr( list emps, string name ) {   // pass by value - 2 temporaries
    for( auto i = begin(emps); i != end(emps); i++ ) { // auto instead of auto&#038; (1 temp), end(emps) possibly emps.size()  temps, in practice probably one; i++ possibly emps.size()  temps, probably none. 
        if( *i == name ) {    // Here we don&#039;t know enough details. (maybe there&#039;s operator==(const employee&#038; , const string&#038;)). In any case, if temporary is created, it can&#039;t be avoided

            return i-&#062;addr;  // same here, if addr is not string (or const char*) temporary cannot be avoided.
        }
    }
    return &quot;&quot;; 
}
&lt;/code&gt;

My solution
&lt;code&gt;
string find_addr( const list&#038; emps, const string&#038; name ) {   
    for( auto&#038; emp: emps) {  
       if( emp == name ) {    
            return emp.addr;  
        }
    }
    return string{}; 
}
&lt;/code&gt;]]></description>
		<content:encoded><![CDATA[<p>Here&#8217;s my take.<br />
<code><br />
string find_addr( list emps, string name ) {   // pass by value - 2 temporaries<br />
    for( auto i = begin(emps); i != end(emps); i++ ) { // auto instead of auto&amp; (1 temp), end(emps) possibly emps.size()  temps, in practice probably one; i++ possibly emps.size()  temps, probably none.<br />
        if( *i == name ) {    // Here we don't know enough details. (maybe there's operator==(const employee&amp; , const string&amp;)). In any case, if temporary is created, it can't be avoided</p>
<p>            return i-&gt;addr;  // same here, if addr is not string (or const char*) temporary cannot be avoided.<br />
        }<br />
    }<br />
    return "";<br />
}<br />
</code></p>
<p>My solution<br />
<code><br />
string find_addr( const list&amp; emps, const string&amp; name ) {<br />
    for( auto&amp; emp: emps) {<br />
       if( emp == name ) {<br />
            return emp.addr;<br />
        }<br />
    }<br />
    return string{};<br />
}<br />
</code></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ronag89				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9981</link>
		<dc:creator><![CDATA[ronag89]]></dc:creator>
		<pubDate>Sat, 11 May 2013 10:24:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9981</guid>
					<description><![CDATA[[code language=&quot;cpp&quot;]
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
	auto it = find_if(begin(emps), end(emps), [&#038;](const employee&#038; emp) {
		return emp.name == name;
	});
	return it != end(emps) ? it-&#062;name : string();
}
[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: cpp; title: ; notranslate">
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
	auto it = find_if(begin(emps), end(emps), [&amp;](const employee&amp; emp) {
		return emp.name == name;
	});
	return it != end(emps) ? it-&gt;name : string();
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9975</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 10 May 2013 22:35:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9975</guid>
					<description><![CDATA[@Roger: True. The solution for that is to *store* the result as a value, what is not-so-tightly coupled with the return type being value or ref.

My problem with returning a value is that you have to pay for the copy even if you don&#039;t need it. If you return reference, you still have the choice to save the result in a (non-ref) string, avoiding that error you told, but if you know you are not changing the container, you have a faster code. Yes, you can shoot yourself in the foot if you are reckless. But the whole function almost the same as a find_if and just using it-&#062;addr after (tbh, I would drop the whole function because of this!). And if you are using iterators, you are aware they can/will be invalidated if you change the container, aren&#039;t you.

Question is what do you prefer: Want best performance+possibility of error for reckless users, or absolute safety+performance penalty (necessary evil note: why don&#039;t you write Java or C# or .. then?)]]></description>
		<content:encoded><![CDATA[<p>@Roger: True. The solution for that is to *store* the result as a value, what is not-so-tightly coupled with the return type being value or ref.</p>
<p>My problem with returning a value is that you have to pay for the copy even if you don&#8217;t need it. If you return reference, you still have the choice to save the result in a (non-ref) string, avoiding that error you told, but if you know you are not changing the container, you have a faster code. Yes, you can shoot yourself in the foot if you are reckless. But the whole function almost the same as a find_if and just using it-&gt;addr after (tbh, I would drop the whole function because of this!). And if you are using iterators, you are aware they can/will be invalidated if you change the container, aren&#8217;t you.</p>
<p>Question is what do you prefer: Want best performance+possibility of error for reckless users, or absolute safety+performance penalty (necessary evil note: why don&#8217;t you write Java or C# or .. then?)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9974</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Fri, 10 May 2013 21:51:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9974</guid>
					<description><![CDATA[@Herb:Sutter: Have you considered creating a Google+ Community page? (or facebook if you don&#039;t the spam) :) 

(Probably your boss wouldn&#039;t like that, right?)]]></description>
		<content:encoded><![CDATA[<p>@Herb:Sutter: Have you considered creating a Google+ Community page? (or facebook if you don&#8217;t the spam) :) </p>
<p>(Probably your boss wouldn&#8217;t like that, right?)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9973</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Fri, 10 May 2013 21:43:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9973</guid>
					<description><![CDATA[Thanks for the tip David! :) (Unfortunatelly I don&#039;e find a way to edit my last post, so...)

[code]
// assuming Herb&#039;s intention was:
// employee{std::string name; std::string address};

//....
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
   for( const auto&#038; emp : emps) {
       if( emp.name == name ) {
           return emp.addr;
       }
   }
   return “”;
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Thanks for the tip David! :) (Unfortunatelly I don&#8217;e find a way to edit my last post, so&#8230;)</p>
<pre class="brush: plain; title: ; notranslate">
// assuming Herb's intention was:
// employee{std::string name; std::string address};

//....
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
   for( const auto&amp; emp : emps) {
       if( emp.name == name ) {
           return emp.addr;
       }
   }
   return “”;
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9972</link>
		<dc:creator><![CDATA[David]]></dc:creator>
		<pubDate>Fri, 10 May 2013 21:36:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9972</guid>
					<description><![CDATA[[ code ]    you code  [ / code ]]]></description>
		<content:encoded><![CDATA[<p>[ code ]    you code  [ / code ]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9971</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Fri, 10 May 2013 21:16:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9971</guid>
					<description><![CDATA[list template arg  was stripped by the site :P]]></description>
		<content:encoded><![CDATA[<p>list template arg  was stripped by the site :P</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Moreira				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9970</link>
		<dc:creator><![CDATA[Fernando Moreira]]></dc:creator>
		<pubDate>Fri, 10 May 2013 20:54:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9970</guid>
					<description><![CDATA[Assume struct employee{std::string name; std::string address};

string find_addr( const list&#038; emps, const string&#038; name ) {
    for( const auto&#038; emp : emps) {
        if( emp.name == name ) {
            return emp.addr;
        }
    }
    return &quot;&quot;;
}]]></description>
		<content:encoded><![CDATA[<p>Assume struct employee{std::string name; std::string address};</p>
<p>string find_addr( const list&amp; emps, const string&amp; name ) {<br />
    for( const auto&amp; emp : emps) {<br />
        if( emp.name == name ) {<br />
            return emp.addr;<br />
        }<br />
    }<br />
    return &#8220;&#8221;;<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: thefloatingbrain				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9969</link>
		<dc:creator><![CDATA[thefloatingbrain]]></dc:creator>
		<pubDate>Fri, 10 May 2013 19:25:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9969</guid>
					<description><![CDATA[string&#038; find_addr( const list&#038; emps, const string&#038; name ) {
    for( auto i = begin(emps); i != end(emps); i++ ) {
        if( *i == name ) {
            return i-&#062;addr;
        }
    }
    return std::string{ &quot;&quot; };
}
Changed: 
    * : The return type to a reference
    * : The parameters to be a const reference
    * : The last return statement to return a constant.]]></description>
		<content:encoded><![CDATA[<p>string&amp; find_addr( const list&amp; emps, const string&amp; name ) {<br />
    for( auto i = begin(emps); i != end(emps); i++ ) {<br />
        if( *i == name ) {<br />
            return i-&gt;addr;<br />
        }<br />
    }<br />
    return std::string{ &#8220;&#8221; };<br />
}<br />
Changed:<br />
    * : The return type to a reference<br />
    * : The parameters to be a const reference<br />
    * : The last return statement to return a constant.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roger				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9968</link>
		<dc:creator><![CDATA[Roger]]></dc:creator>
		<pubDate>Fri, 10 May 2013 18:10:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9968</guid>
					<description><![CDATA[@Robert, the concern about returning a reference is not limited to the case where the list is a temporary. The concern is that the caller can store and attempt to use the returned value far past the lifetime of the object:

const string&#038; addr = find_addr (emp, name);
.... sometime later....
cout &#060;&#060; addr;   //BOOM if emp has been deleted.]]></description>
		<content:encoded><![CDATA[<p>@Robert, the concern about returning a reference is not limited to the case where the list is a temporary. The concern is that the caller can store and attempt to use the returned value far past the lifetime of the object:</p>
<p>const string&amp; addr = find_addr (emp, name);<br />
&#8230;. sometime later&#8230;.<br />
cout &lt;&lt; addr;   //BOOM if emp has been deleted.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roger				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9967</link>
		<dc:creator><![CDATA[Roger]]></dc:creator>
		<pubDate>Fri, 10 May 2013 18:06:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9967</guid>
					<description><![CDATA[@brandon

end(emps) is valid C++11 code, and is the preferred idiom. Why? Because it is a template function which you can specialize for any type that does not provide an end() member function. 

I personally see no reason to create a local variable to hold end(emps). Any compiler will optimize that call away anyways, and getting &#039;clever&#039; like this just adds more code, makes things less readable, and makes it more likely that you confuse the compiler&#039;s optimization stage. And, of course the find_if solutions also optimize the multiple calss.]]></description>
		<content:encoded><![CDATA[<p>@brandon</p>
<p>end(emps) is valid C++11 code, and is the preferred idiom. Why? Because it is a template function which you can specialize for any type that does not provide an end() member function. </p>
<p>I personally see no reason to create a local variable to hold end(emps). Any compiler will optimize that call away anyways, and getting &#8216;clever&#8217; like this just adds more code, makes things less readable, and makes it more likely that you confuse the compiler&#8217;s optimization stage. And, of course the find_if solutions also optimize the multiple calss.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brandon				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9966</link>
		<dc:creator><![CDATA[Brandon]]></dc:creator>
		<pubDate>Fri, 10 May 2013 17:27:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9966</guid>
					<description><![CDATA[1.) A temporary is a variable that is implicitly created during execution of a function. one example this happens in 

is when returning by value.

2.) The function parameters should be passed by const reference to eliminate two potentially large variables (although they are not &quot;temporaries&quot; strictly speaking ) to preventing deep copying of the list or string.

end(emps) (I presume you meant emps.end() ) returns an iterator object into a temporary for comparison with i. It could be put into a const named variable instead of building that temporary each iteration.

return &quot;&quot; will possibly construct a string object (implicitly) and then assign to the return temporary, unless the compiler optimizes. This can be explicitly avoided by returning string() ( or string(&quot;&quot;) if you prefer ). This utilizes the &quot;return value optimization&quot;


string find_addr( const list &#038;emps, const string &#038;name ) {
    const auto the_end = emps.end();
    for( auto i = emps.begin(); i != the_end; i++ ) {
        if( *i == name ) {
            return i-&#062;addr;
        }
    }
    return string(&quot;&quot;);
}]]></description>
		<content:encoded><![CDATA[<p>1.) A temporary is a variable that is implicitly created during execution of a function. one example this happens in </p>
<p>is when returning by value.</p>
<p>2.) The function parameters should be passed by const reference to eliminate two potentially large variables (although they are not &#8220;temporaries&#8221; strictly speaking ) to preventing deep copying of the list or string.</p>
<p>end(emps) (I presume you meant emps.end() ) returns an iterator object into a temporary for comparison with i. It could be put into a const named variable instead of building that temporary each iteration.</p>
<p>return &#8220;&#8221; will possibly construct a string object (implicitly) and then assign to the return temporary, unless the compiler optimizes. This can be explicitly avoided by returning string() ( or string(&#8220;&#8221;) if you prefer ). This utilizes the &#8220;return value optimization&#8221;</p>
<p>string find_addr( const list &amp;emps, const string &amp;name ) {<br />
    const auto the_end = emps.end();<br />
    for( auto i = emps.begin(); i != the_end; i++ ) {<br />
        if( *i == name ) {<br />
            return i-&gt;addr;<br />
        }<br />
    }<br />
    return string(&#8220;&#8221;);<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9960</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Fri, 10 May 2013 15:47:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9960</guid>
					<description><![CDATA[[code]
//	first temporary list&#060;employee&#062; emps the biggest one	
//	second temporary string name --	&#124; -----------
//									\/			\/
string find_addr( list&#060;employee&#062; emps, string name ) {
	for( auto i = begin(emps); i != end(emps); i++ ) {
		// third temporary employee 
		// if we assume then employee::employee(const string &#038;name) exist
		// and we only have bool employee::operator==(const employee&#038; other)
		//			\/
		if( *i == name ) {
			return i-&#062;addr;
		}
	}
	return &#034;&#034;;
}
[/code]
Now the question is if bool employee::operator==(const employee&#038; other) compares every employee member and not only name then this code will not find anything at all.

@Chris:  you are returning address of local variable string() !
I would change it like this but think that range based for loop is still easier to read.
[code]
string find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name)
{
	const auto found = find(cbegin(emps), cend(emps), name); //temporal employee object !
	if(found == cend(emps)) return string();
	else return found-&#062;addr;
}
[/code]


So I would still prefer to use this one.
Assuming name is not protected.
[code]
string find_addr(const list&#060;employee&#062; &#038;emps, const string &#038;name) {
	for(const auto&#038; emp : emps) {
		if( emp.name == name ) { return emp.addr; }
	}
	return string();
}
[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">
//	first temporary list&lt;employee&gt; emps the biggest one	
//	second temporary string name --	| -----------
//									\/			\/
string find_addr( list&lt;employee&gt; emps, string name ) {
	for( auto i = begin(emps); i != end(emps); i++ ) {
		// third temporary employee 
		// if we assume then employee::employee(const string &amp;name) exist
		// and we only have bool employee::operator==(const employee&amp; other)
		//			\/
		if( *i == name ) {
			return i-&gt;addr;
		}
	}
	return &quot;&quot;;
}
</pre>
<p>Now the question is if bool employee::operator==(const employee&amp; other) compares every employee member and not only name then this code will not find anything at all.</p>
<p>@Chris:  you are returning address of local variable string() !<br />
I would change it like this but think that range based for loop is still easier to read.</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name)
{
	const auto found = find(cbegin(emps), cend(emps), name); //temporal employee object !
	if(found == cend(emps)) return string();
	else return found-&gt;addr;
}
</pre>
<p>So I would still prefer to use this one.<br />
Assuming name is not protected.</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt; &amp;emps, const string &amp;name) {
	for(const auto&amp; emp : emps) {
		if( emp.name == name ) { return emp.addr; }
	}
	return string();
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pillsy				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9958</link>
		<dc:creator><![CDATA[pillsy]]></dc:creator>
		<pubDate>Fri, 10 May 2013 13:31:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9958</guid>
					<description><![CDATA[I would use `std::find_if` on the grounds that it&#039;s more immediately obvious what you&#039;re trying to do with your loop. I agree with all the folks who object to returning a `const string &#038;`; it&#039;s asking for trouble and is pretty pointless, performance-wise, in the presence of RVO.

    string find_addr(const list &#038; emps, const string &#038; name) 
    {
         auto has_same_name = [&#038;name] (const employee &#038; e) { 
               return e.name == name;
         };

         auto found = find_if(begin(emps), end(emps), has_same_name);

         return found != end(emps) ? found-&#062;addr : string{};
     }]]></description>
		<content:encoded><![CDATA[<p>I would use `std::find_if` on the grounds that it&#8217;s more immediately obvious what you&#8217;re trying to do with your loop. I agree with all the folks who object to returning a `const string &amp;`; it&#8217;s asking for trouble and is pretty pointless, performance-wise, in the presence of RVO.</p>
<p>    string find_addr(const list &amp; emps, const string &amp; name)<br />
    {<br />
         auto has_same_name = [&amp;name] (const employee &amp; e) {<br />
               return e.name == name;<br />
         };</p>
<p>         auto found = find_if(begin(emps), end(emps), has_same_name);</p>
<p>         return found != end(emps) ? found-&gt;addr : string{};<br />
     }</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9957</link>
		<dc:creator><![CDATA[Chris]]></dc:creator>
		<pubDate>Fri, 10 May 2013 13:31:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9957</guid>
					<description><![CDATA[Well, it might violate &quot;do not change the operational semantics of this function&quot; rule, but... how about this:

[code language=&quot;cpp&quot;]
const string&#038; find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name)
{
    const auto found = find(cbegin(emps), cend(emps), name);
    return (found == cend(emps)) ? string() : found-&#062;addr;
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Well, it might violate &#8220;do not change the operational semantics of this function&#8221; rule, but&#8230; how about this:</p>
<pre class="brush: cpp; title: ; notranslate">
const string&amp; find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name)
{
    const auto found = find(cbegin(emps), cend(emps), name);
    return (found == cend(emps)) ? string() : found-&gt;addr;
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Klaim - Joel Lamotte (@MJKlaim)				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9955</link>
		<dc:creator><![CDATA[Klaim - Joel Lamotte (@MJKlaim)]]></dc:creator>
		<pubDate>Fri, 10 May 2013 12:28:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9955</guid>
					<description><![CDATA[@Roger I am not sure exactly what this explains. Isn&#039;t the case we have here totally different as it is about function arguments, not function return type? Or maybe I was not clear that I was talking about the arguments?]]></description>
		<content:encoded><![CDATA[<p>@Roger I am not sure exactly what this explains. Isn&#8217;t the case we have here totally different as it is about function arguments, not function return type? Or maybe I was not clear that I was talking about the arguments?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9953</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 10 May 2013 11:05:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9953</guid>
					<description><![CDATA[Meh. Why can&#039;t I edit, and how to make quotes here? :-/ Change the end object to endit..]]></description>
		<content:encoded><![CDATA[<p>Meh. Why can&#8217;t I edit, and how to make quotes here? :-/ Change the end object to endit..</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9952</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 10 May 2013 11:02:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9952</guid>
					<description><![CDATA[Still no solution with std::find_if ? Come on people! That&#039;s the first thing that fails when I do the review, even before temporaries.

Otherwise - if employee passed code review, this code didn&#039;t even compile :) : What does operator==(employee, string) mean? Or, why isn&#039;t employee::employee(string) explicit? This is a problem borderline to changing operational semantics, but it actually creates a temporary employee object, so..

[code]
namespace {
        static string empty_string;
};
const string&#038; find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    auto end = end(emps);
    auto it = std::find_if(begin(emps), end, [&#038;name](const employee&#038; emp) {
        return name == emp.name;
    });
    if (it == end)
    {
        return empty_string;
    }
    return it-&#062;addr;
}
[/code]

There was some concerns about returning a reference instead of a value (because we have no control over the list&#039;s lifetime here - well, if the first parameter is a temporary, it will still exist when we return: [quote]A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.[/quote]]]></description>
		<content:encoded><![CDATA[<p>Still no solution with std::find_if ? Come on people! That&#8217;s the first thing that fails when I do the review, even before temporaries.</p>
<p>Otherwise &#8211; if employee passed code review, this code didn&#8217;t even compile :) : What does operator==(employee, string) mean? Or, why isn&#8217;t employee::employee(string) explicit? This is a problem borderline to changing operational semantics, but it actually creates a temporary employee object, so..</p>
<pre class="brush: plain; title: ; notranslate">
namespace {
        static string empty_string;
};
const string&amp; find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    auto end = end(emps);
    auto it = std::find_if(begin(emps), end, [&amp;name](const employee&amp; emp) {
        return name == emp.name;
    });
    if (it == end)
    {
        return empty_string;
    }
    return it-&gt;addr;
}
</pre>
<p>There was some concerns about returning a reference instead of a value (because we have no control over the list&#8217;s lifetime here &#8211; well, if the first parameter is a temporary, it will still exist when we return: [quote]A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full expression containing the call.[/quote]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mikhail Belyaev				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9951</link>
		<dc:creator><![CDATA[Mikhail Belyaev]]></dc:creator>
		<pubDate>Fri, 10 May 2013 10:19:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9951</guid>
					<description><![CDATA[Just putting my upper comment to a proper code-blocks (I just didn&#039;t know how to do it).

[code]
string find_addr(const list&#038; emps, const string&#038; name ) {
    for( const auto&#038; emp : emps) 
        if( emp.name == name ) return emp.addr;
    static const string empty;
    return empty;
}
[/code]

return {}; seems much better to me now, but inserting it would not be &quot;just putting previous code inside code-blocks&quot;.]]></description>
		<content:encoded><![CDATA[<p>Just putting my upper comment to a proper code-blocks (I just didn&#8217;t know how to do it).</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&amp; emps, const string&amp; name ) {
    for( const auto&amp; emp : emps) 
        if( emp.name == name ) return emp.addr;
    static const string empty;
    return empty;
}
</pre>
<p>return {}; seems much better to me now, but inserting it would not be &#8220;just putting previous code inside code-blocks&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bgb				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9946</link>
		<dc:creator><![CDATA[bgb]]></dc:creator>
		<pubDate>Fri, 10 May 2013 00:25:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9946</guid>
					<description><![CDATA[In the loop it should have been 
if( i == name ) instead of if ( *i == name )
and i.addr instead of i-&#062;addr]]></description>
		<content:encoded><![CDATA[<p>In the loop it should have been<br />
if( i == name ) instead of if ( *i == name )<br />
and i.addr instead of i-&gt;addr</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bgb				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9945</link>
		<dc:creator><![CDATA[bgb]]></dc:creator>
		<pubDate>Fri, 10 May 2013 00:22:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9945</guid>
					<description><![CDATA[2) Easy question first:

&quot;Do not change the operational semantics of this function&quot; -&#062; I&#039;ll try but I am a bit drunk (2am over here, but Ive never trusted myself to answer a guru question here so thanks alcohol, ducks!).

const string&#038; find_addr( const list&#038; emps, const string&#038; name ) { // #1 #3
    for( const auto&#038;&#038; i : emps ) { // #2
        if( *i == name ) {
            return i-&#062;addr; // #3
        }
    }
    return &quot;&quot;; 
}


#1
-  taking a list by value is a _bad_ idea: it will be copied if its not a temporary, and list of employees sounds like something potentially pretty big. 
- taking the name by value it&#039;s ok I guess (I wouldn&#039;t kill that on code review). If it&#039;s a temporary it will be moved (so no problem). If it&#039;s not a temporary it will be copied. Anyways it&#039;s just a string, if the function is not a hotspot it&#039;ll be ok. I would use const tho, it expresses intent. The lvalue reference might save a copy which would help if the function is a hotspot. So let&#039;s not pessimize and make it const lvalue reference.

#2 end() was being called at every iteration, and the &quot;i&quot; string was being copied at every iteration.

#3 Const lvalue reference avoid a copy in the return type: addr is a member of the list, its not a temporary, it will trigger a copy. &quot;&quot; was fine I guess. If it constructs a string it&#039;ll just trigger a move or some fancy compiler optimization later. 

So that makes hopefully three of them, if only I could count the amount of beers I&#039;ve had...

1) Now the hard question What is a temporary object?
- My answer: you don&#039;t want to know. As a rule of thumb:
- if you cannot refer to an object by a name, then it&#039;s a temporary. 
- If you can refer to an object by it&#039;s name, and the name was declared with const&#038; or T&#038;&#038; then it might be a temporary. 
- otherwise, it _probably_ isn&#039;t a temporary (i&#039;m actually not too sure about the probably).

If you want the truth, I guess the real truth is that no-one should need to know about glvalues, rvalues, lvalues, xvalues, prvalues... I&#039;d can recommend http://stackoverflow.com/questions/3106110/what-are-move-semantics There is a nice answer by FredOverflow reviewed by Stephan that is pretty detailed and one that gives an overview. Read the overview, fight through the detailed one. Then watch Scott&#039;s videos about universal references. Then read the detailed one again. And if you ever feel lost with the terminology here is a nice reference: http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues and http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf]]></description>
		<content:encoded><![CDATA[<p>2) Easy question first:</p>
<p>&#8220;Do not change the operational semantics of this function&#8221; -&gt; I&#8217;ll try but I am a bit drunk (2am over here, but Ive never trusted myself to answer a guru question here so thanks alcohol, ducks!).</p>
<p>const string&amp; find_addr( const list&amp; emps, const string&amp; name ) { // #1 #3<br />
    for( const auto&amp;&amp; i : emps ) { // #2<br />
        if( *i == name ) {<br />
            return i-&gt;addr; // #3<br />
        }<br />
    }<br />
    return &#8220;&#8221;;<br />
}</p>
<p>#1<br />
&#8211;  taking a list by value is a _bad_ idea: it will be copied if its not a temporary, and list of employees sounds like something potentially pretty big.<br />
&#8211; taking the name by value it&#8217;s ok I guess (I wouldn&#8217;t kill that on code review). If it&#8217;s a temporary it will be moved (so no problem). If it&#8217;s not a temporary it will be copied. Anyways it&#8217;s just a string, if the function is not a hotspot it&#8217;ll be ok. I would use const tho, it expresses intent. The lvalue reference might save a copy which would help if the function is a hotspot. So let&#8217;s not pessimize and make it const lvalue reference.</p>
<p>#2 end() was being called at every iteration, and the &#8220;i&#8221; string was being copied at every iteration.</p>
<p>#3 Const lvalue reference avoid a copy in the return type: addr is a member of the list, its not a temporary, it will trigger a copy. &#8220;&#8221; was fine I guess. If it constructs a string it&#8217;ll just trigger a move or some fancy compiler optimization later. </p>
<p>So that makes hopefully three of them, if only I could count the amount of beers I&#8217;ve had&#8230;</p>
<p>1) Now the hard question What is a temporary object?<br />
&#8211; My answer: you don&#8217;t want to know. As a rule of thumb:<br />
&#8211; if you cannot refer to an object by a name, then it&#8217;s a temporary.<br />
&#8211; If you can refer to an object by it&#8217;s name, and the name was declared with const&amp; or T&amp;&amp; then it might be a temporary.<br />
&#8211; otherwise, it _probably_ isn&#8217;t a temporary (i&#8217;m actually not too sure about the probably).</p>
<p>If you want the truth, I guess the real truth is that no-one should need to know about glvalues, rvalues, lvalues, xvalues, prvalues&#8230; I&#8217;d can recommend <a href="http://stackoverflow.com/questions/3106110/what-are-move-semantics" rel="nofollow">http://stackoverflow.com/questions/3106110/what-are-move-semantics</a> There is a nice answer by FredOverflow reviewed by Stephan that is pretty detailed and one that gives an overview. Read the overview, fight through the detailed one. Then watch Scott&#8217;s videos about universal references. Then read the detailed one again. And if you ever feel lost with the terminology here is a nice reference: <a href="http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues" rel="nofollow">http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues</a> and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Francisco Lopes (@pepper_chico)				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9944</link>
		<dc:creator><![CDATA[Francisco Lopes (@pepper_chico)]]></dc:creator>
		<pubDate>Thu, 09 May 2013 23:42:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9944</guid>
					<description><![CDATA[[code]
string find_addr(const list&#060;employee&#062; &#038;emps,const string &#038;name ) {
    for(const auto&#038; emp : emps) {
        if( emp == name ) { return emp.addr; } //copy of addr will be made.
    }
    return {}; // use copy-list-initialization, resolves like direct-initialization.
}
[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt; &amp;emps,const string &amp;name ) {
    for(const auto&amp; emp : emps) {
        if( emp == name ) { return emp.addr; } //copy of addr will be made.
    }
    return {}; // use copy-list-initialization, resolves like direct-initialization.
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Francisco Lopes (@pepper_chico)				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9943</link>
		<dc:creator><![CDATA[Francisco Lopes (@pepper_chico)]]></dc:creator>
		<pubDate>Thu, 09 May 2013 23:40:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9943</guid>
					<description><![CDATA[I&#039;m with Tom, just an slight detail:

string find_addr(const list &#038;emps,const string &#038;name ) {
    for(const auto&#038; emp : emps) {
        if( emp == name ) { return emp.addr; }
    }
    return {}; // use copy-list-initialization, resolves like direct-initialization.
}]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m with Tom, just an slight detail:</p>
<p>string find_addr(const list &amp;emps,const string &amp;name ) {<br />
    for(const auto&amp; emp : emps) {<br />
        if( emp == name ) { return emp.addr; }<br />
    }<br />
    return {}; // use copy-list-initialization, resolves like direct-initialization.<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: kjellkod				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9942</link>
		<dc:creator><![CDATA[kjellkod]]></dc:creator>
		<pubDate>Thu, 09 May 2013 23:24:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9942</guid>
					<description><![CDATA[@Tom. Nice,. of course, it makes more sence in your code example (http://rise4fun.com/Vcpp/1F). 
You have my vote!]]></description>
		<content:encoded><![CDATA[<p>@Tom. Nice,. of course, it makes more sence in your code example (<a href="http://rise4fun.com/Vcpp/1F" rel="nofollow">http://rise4fun.com/Vcpp/1F</a>).<br />
You have my vote!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9941</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Thu, 09 May 2013 22:43:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9941</guid>
					<description><![CDATA[Here is the proper way to use range based for loop.
emp need to be reference to avoid unnecessary copy.
[code]
string find_addr(const list&#060;employee&#062; &#038;emps,const string &#038;name ) {
	for(const auto&#038; emp : emps) {
		if( emp == name ) { return emp.addr; } //copy of addr will be made.
	}
	return string(); //default empty constructor will be called.
}
[/code]

Please use &quot;[&quot;code&quot;]&quot; &quot;[&quot;/code&quot;]&quot; tags.]]></description>
		<content:encoded><![CDATA[<p>Here is the proper way to use range based for loop.<br />
emp need to be reference to avoid unnecessary copy.</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt; &amp;emps,const string &amp;name ) {
	for(const auto&amp; emp : emps) {
		if( emp == name ) { return emp.addr; } //copy of addr will be made.
	}
	return string(); //default empty constructor will be called.
}
</pre>
<p>Please use &#8220;[&#8220;code&#8221;]&#8221; &#8220;[&#8220;/code&#8221;]&#8221; tags.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Masse Nicolas				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9939</link>
		<dc:creator><![CDATA[Masse Nicolas]]></dc:creator>
		<pubDate>Thu, 09 May 2013 22:05:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9939</guid>
					<description><![CDATA[Wow, seems my code was broken (probably due to the &#060;).
here again:
const string&#038; find_addr(const list&#038; emps, const string&#038; name ) 
{
    for(int i = 0; emps.size() &#062; i; ++i) {
        if( emps[i] == name ) { //here no copy happens
            return i-&#062;addr;
        }
   }
   return “”;
}]]></description>
		<content:encoded><![CDATA[<p>Wow, seems my code was broken (probably due to the &lt;).<br />
here again:<br />
const string&amp; find_addr(const list&amp; emps, const string&amp; name )<br />
{<br />
    for(int i = 0; emps.size() &gt; i; ++i) {<br />
        if( emps[i] == name ) { //here no copy happens<br />
            return i-&gt;addr;<br />
        }<br />
   }<br />
   return “”;<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Masse Nicolas				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9938</link>
		<dc:creator><![CDATA[Masse Nicolas]]></dc:creator>
		<pubDate>Thu, 09 May 2013 22:00:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9938</guid>
					<description><![CDATA[Something few people seems to note is the copy who happens when i is dereferenced :

string find_addr( list emps, string name ) {
    for( auto i = begin(emps); i != end(emps); i++ ) {
        if( *i == name ) { //here *i will create a copy of the employe contained in the vector.
            return i-&#062;addr;
        }
    }
    return &quot;&quot;;
}

Using a const iterator could fix this, but I suspect that this depend of the implementation of std::vector.
Another more reliable solution is to use the [] operator. Since it returns a reference, we are sure that no extra copies will be done.
So, the code becomes:

const string&#038; find_addr(const list&#038; emps, const string&#038; name ) {
    for( int i = 0; i addr;
        }
    }
    return &quot;&quot;;
}

Also Note that I do return a reference because I consider that it is up to the caller to know about the life time of the parameters he gives me and the return value, so it&#039;s up to him to know if a copy of the returned value is necessary or not.]]></description>
		<content:encoded><![CDATA[<p>Something few people seems to note is the copy who happens when i is dereferenced :</p>
<p>string find_addr( list emps, string name ) {<br />
    for( auto i = begin(emps); i != end(emps); i++ ) {<br />
        if( *i == name ) { //here *i will create a copy of the employe contained in the vector.<br />
            return i-&gt;addr;<br />
        }<br />
    }<br />
    return &#8220;&#8221;;<br />
}</p>
<p>Using a const iterator could fix this, but I suspect that this depend of the implementation of std::vector.<br />
Another more reliable solution is to use the [] operator. Since it returns a reference, we are sure that no extra copies will be done.<br />
So, the code becomes:</p>
<p>const string&amp; find_addr(const list&amp; emps, const string&amp; name ) {<br />
    for( int i = 0; i addr;<br />
        }<br />
    }<br />
    return &#8220;&#8221;;<br />
}</p>
<p>Also Note that I do return a reference because I consider that it is up to the caller to know about the life time of the parameters he gives me and the return value, so it&#8217;s up to him to know if a copy of the returned value is necessary or not.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9936</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Thu, 09 May 2013 21:22:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9936</guid>
					<description><![CDATA[How about this?

http://rise4fun.com/Vcpp/1F

[code]
string find_addr(const list&#060;employee&#062; &#038;emps,const string &#038;name ) {
	for( auto i = emps.cbegin(); i != emps.cend(); ++i ) {
		if( *i == name ) { return i-&#062;addr; }
	}
	return string();
}
[/code]

The funny thing is that this code call string destructor for every iteration at least if using VS2012CTP.
[code]
string find_addr(const list&#060;employee&#062; &#038;emps,const string &#038;name ) {
	for(auto emp : emps) {
		if( emp == name ) { return emp.addr; }
	}
	return string();
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>How about this?</p>
<p><a href="http://rise4fun.com/Vcpp/1F" rel="nofollow">http://rise4fun.com/Vcpp/1F</a></p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt; &amp;emps,const string &amp;name ) {
	for( auto i = emps.cbegin(); i != emps.cend(); ++i ) {
		if( *i == name ) { return i-&gt;addr; }
	}
	return string();
}
</pre>
<p>The funny thing is that this code call string destructor for every iteration at least if using VS2012CTP.</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr(const list&lt;employee&gt; &amp;emps,const string &amp;name ) {
	for(auto emp : emps) {
		if( emp == name ) { return emp.addr; }
	}
	return string();
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: muxecoid				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9934</link>
		<dc:creator><![CDATA[muxecoid]]></dc:creator>
		<pubDate>Thu, 09 May 2013 20:32:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9934</guid>
					<description><![CDATA[JG1:
Used by older ANSI C89 zealots to prove that C++ language is bad and only C (better asm) never does tricks behind the scenes.
2:
The list and the string should be passed with const reference. ANSI C89 zealots (when you force them to use STL) will use a pointer here because references are evil. 

The loop iteration could be better. prefix increment would help. Making iterator const with cbegin will help. Range based for loop is the recommended solution.

It is possible (see GotW#1) to use 
   return {};
to return default constructed string. This avoids running constructor that accepts const char*. This will aggravate ANSI C89 zealots seriously enough to make them never touch your C++14 project again.]]></description>
		<content:encoded><![CDATA[<p>JG1:<br />
Used by older ANSI C89 zealots to prove that C++ language is bad and only C (better asm) never does tricks behind the scenes.<br />
2:<br />
The list and the string should be passed with const reference. ANSI C89 zealots (when you force them to use STL) will use a pointer here because references are evil. </p>
<p>The loop iteration could be better. prefix increment would help. Making iterator const with cbegin will help. Range based for loop is the recommended solution.</p>
<p>It is possible (see GotW#1) to use<br />
   return {};<br />
to return default constructed string. This avoids running constructor that accepts const char*. This will aggravate ANSI C89 zealots seriously enough to make them never touch your C++14 project again.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: F. Almeida				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9929</link>
		<dc:creator><![CDATA[F. Almeida]]></dc:creator>
		<pubDate>Thu, 09 May 2013 19:40:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9929</guid>
					<description><![CDATA[string find_addr(const list&#038; emps, const string&#038; name ) {
    for( auto i = begin(emps); i != end(emps); ++i ) {
        if( *i == name )
        {
            return i-&#062;addr;
        }
    }
    return &quot;&quot;;
}

My vote also goes to passing const refs (not returning one), and simply turning the post-increment into a pre-increment (although the impact there should really be minimal).]]></description>
		<content:encoded><![CDATA[<p>string find_addr(const list&amp; emps, const string&amp; name ) {<br />
    for( auto i = begin(emps); i != end(emps); ++i ) {<br />
        if( *i == name )<br />
        {<br />
            return i-&gt;addr;<br />
        }<br />
    }<br />
    return &#8220;&#8221;;<br />
}</p>
<p>My vote also goes to passing const refs (not returning one), and simply turning the post-increment into a pre-increment (although the impact there should really be minimal).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roger				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9928</link>
		<dc:creator><![CDATA[Roger]]></dc:creator>
		<pubDate>Thu, 09 May 2013 19:34:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9928</guid>
					<description><![CDATA[@Klaim,

consider:
const string&#038; address = find_addr (employees, &quot;joe&quot;);
fire_employee (employees, &quot;joe&quot;); // deletes joe from employees
print_final_check (&quot;joe&quot;, address); // KABOOM

The problem is that what &#039;address&#039; is referring no longer exists after fire_employee is called, so it is no longer valid to refer to it. 

Besides, all decent compilers implement return copy optimization (http://en.wikipedia.org/wiki/Return_value_optimization), so in practice no temporary will be created.]]></description>
		<content:encoded><![CDATA[<p>@Klaim,</p>
<p>consider:<br />
const string&amp; address = find_addr (employees, &#8220;joe&#8221;);<br />
fire_employee (employees, &#8220;joe&#8221;); // deletes joe from employees<br />
print_final_check (&#8220;joe&#8221;, address); // KABOOM</p>
<p>The problem is that what &#8216;address&#8217; is referring no longer exists after fire_employee is called, so it is no longer valid to refer to it. </p>
<p>Besides, all decent compilers implement return copy optimization (<a href="http://en.wikipedia.org/wiki/Return_value_optimization" rel="nofollow">http://en.wikipedia.org/wiki/Return_value_optimization</a>), so in practice no temporary will be created.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Klaim - Joel Lamotte (@MJKlaim)				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9927</link>
		<dc:creator><![CDATA[Klaim - Joel Lamotte (@MJKlaim)]]></dc:creator>
		<pubDate>Thu, 09 May 2013 19:16:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9927</guid>
					<description><![CDATA[Oups, some did suggest for-range-loops, didn&#039;t see them with my cached page. My bad.]]></description>
		<content:encoded><![CDATA[<p>Oups, some did suggest for-range-loops, didn&#8217;t see them with my cached page. My bad.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Klaim - Joel Lamotte (@MJKlaim)				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9926</link>
		<dc:creator><![CDATA[Klaim - Joel Lamotte (@MJKlaim)]]></dc:creator>
		<pubDate>Thu, 09 May 2013 19:15:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9926</guid>
					<description><![CDATA[Why is nobody suggesting using a for-range-loop? AFAIK it&#039;s the exact same semantic but will make sure to avoid unnecessary copies.

Also, I am not sure about the const refs because in multi-threaded context it might be voluntary that the semantic of the function is to copy the list before working on it. I suppose Herb would answer that const suggests that the access is safe, but still I&#039;m not sure it doesn&#039;t change the semantic.]]></description>
		<content:encoded><![CDATA[<p>Why is nobody suggesting using a for-range-loop? AFAIK it&#8217;s the exact same semantic but will make sure to avoid unnecessary copies.</p>
<p>Also, I am not sure about the const refs because in multi-threaded context it might be voluntary that the semantic of the function is to copy the list before working on it. I suppose Herb would answer that const suggests that the access is safe, but still I&#8217;m not sure it doesn&#8217;t change the semantic.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pindragon				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9925</link>
		<dc:creator><![CDATA[pindragon]]></dc:creator>
		<pubDate>Thu, 09 May 2013 18:59:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9925</guid>
					<description><![CDATA[OK, one that REALLY keeps the operational semantics and DOES NOT produce any new temporary objects)))

string find_addr(const list&#038; emps, const string&#038; name ) {
for( const auto&#038; emp : emps) {
if( emp.name == name ) {
return emp.addr;
}
}
static const string empty; // I usually have one of these already somewhere in util.hpp
return empty;
}

I would also suggest a version based on find_if and for_each, but I’m really lazy.]]></description>
		<content:encoded><![CDATA[<p>OK, one that REALLY keeps the operational semantics and DOES NOT produce any new temporary objects)))</p>
<p>string find_addr(const list&amp; emps, const string&amp; name ) {<br />
for( const auto&amp; emp : emps) {<br />
if( emp.name == name ) {<br />
return emp.addr;<br />
}<br />
}<br />
static const string empty; // I usually have one of these already somewhere in util.hpp<br />
return empty;<br />
}</p>
<p>I would also suggest a version based on find_if and for_each, but I’m really lazy.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pindragon				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9924</link>
		<dc:creator><![CDATA[pindragon]]></dc:creator>
		<pubDate>Thu, 09 May 2013 18:57:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9924</guid>
					<description><![CDATA[OK, one that REALLY keeps the operational semantics

string find_addr(const list&#038; emps, const string&#038; name ) {
     for( auto emp : emps) {
        if( emp.name == name ) {
           return emp.addr;
        }
}
static const string empty; // I usually have one of these already somewhere in util.hpp
      return empty;
}

I would also suggest a version based on find_if and for_each, but I&#039;m really lazy.]]></description>
		<content:encoded><![CDATA[<p>OK, one that REALLY keeps the operational semantics</p>
<p>string find_addr(const list&amp; emps, const string&amp; name ) {<br />
     for( auto emp : emps) {<br />
        if( emp.name == name ) {<br />
           return emp.addr;<br />
        }<br />
}<br />
static const string empty; // I usually have one of these already somewhere in util.hpp<br />
      return empty;<br />
}</p>
<p>I would also suggest a version based on find_if and for_each, but I&#8217;m really lazy.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: kyle				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9923</link>
		<dc:creator><![CDATA[kyle]]></dc:creator>
		<pubDate>Thu, 09 May 2013 18:33:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9923</guid>
					<description><![CDATA[Guys, please ... dont return by reference from this function. It DOES change operational semantics of this function and _will_ lead to UB.]]></description>
		<content:encoded><![CDATA[<p>Guys, please &#8230; dont return by reference from this function. It DOES change operational semantics of this function and _will_ lead to UB.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: kjellkod				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9922</link>
		<dc:creator><![CDATA[kjellkod]]></dc:creator>
		<pubDate>Thu, 09 May 2013 18:32:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9922</guid>
					<description><![CDATA[1) i++
2) employee == string (see why below)
3) return value can be written {&quot;&quot;}
4) const reference to the arguments 
5) why not just use for(auto&#038; employee : emps) instead of for(begin, !=end, ++) to avoid temp iterators
  
see code example at: http://ideone.com/d54ARz
   

Explanation of operator ==
---------------------------------------------------------------------------------------
This depends a little on employee: if it for example is defined as


struct employee {
  string addr;
  // no explicit keyword makes the implicit conversion possible
  employee(std::string str) : addr(str) {} 
  bool operator==(const employee&#038; other) const { return (addr.compare(other.addr) == 0); }
};

In this case the == operator will trigger an implicit conversion to a temporary employee object]]></description>
		<content:encoded><![CDATA[<p>1) i++<br />
2) employee == string (see why below)<br />
3) return value can be written {&#8220;&#8221;}<br />
4) const reference to the arguments<br />
5) why not just use for(auto&amp; employee : emps) instead of for(begin, !=end, ++) to avoid temp iterators</p>
<p>see code example at: <a href="http://ideone.com/d54ARz" rel="nofollow">http://ideone.com/d54ARz</a></p>
<p>Explanation of operator ==<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />
This depends a little on employee: if it for example is defined as</p>
<p>struct employee {<br />
  string addr;<br />
  // no explicit keyword makes the implicit conversion possible<br />
  employee(std::string str) : addr(str) {}<br />
  bool operator==(const employee&amp; other) const { return (addr.compare(other.addr) == 0); }<br />
};</p>
<p>In this case the == operator will trigger an implicit conversion to a temporary employee object</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roger				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9921</link>
		<dc:creator><![CDATA[Roger]]></dc:creator>
		<pubDate>Thu, 09 May 2013 18:24:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9921</guid>
					<description><![CDATA[Returning const string&#038; seems like a very bad idea. We have no guarantee on the lifetime of the emps data that is passed in. Returning a reference could end up with the caller trying to use a reference to data that has been deleted.]]></description>
		<content:encoded><![CDATA[<p>Returning const string&amp; seems like a very bad idea. We have no guarantee on the lifetime of the emps data that is passed in. Returning a reference could end up with the caller trying to use a reference to data that has been deleted.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Laurent				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9919</link>
		<dc:creator><![CDATA[Laurent]]></dc:creator>
		<pubDate>Thu, 09 May 2013 18:12:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9919</guid>
					<description><![CDATA[I&#039;m not sure that returning a const ref to a static string is a good idea: it removes the temporary value that is returned from the function but also introduce a test in the function to ensure that the string is initialized only the first time the function is called, but I maybe wrong...
I would write:

string find_addr(const list&#038; emps, const string&#038; name) {
    for(auto emp: emps) {
        if(emp.name == name) {
            return emp.addr;
        }
    }
    return string();
}]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not sure that returning a const ref to a static string is a good idea: it removes the temporary value that is returned from the function but also introduce a test in the function to ensure that the string is initialized only the first time the function is called, but I maybe wrong&#8230;<br />
I would write:</p>
<p>string find_addr(const list&amp; emps, const string&amp; name) {<br />
    for(auto emp: emps) {<br />
        if(emp.name == name) {<br />
            return emp.addr;<br />
        }<br />
    }<br />
    return string();<br />
}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Vivek Na				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9916</link>
		<dc:creator><![CDATA[Vivek Na]]></dc:creator>
		<pubDate>Thu, 09 May 2013 17:56:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9916</guid>
					<description><![CDATA[Caching the end() iterator or returning a static string seem like things that are of dubious value. Any decent compiler will recognize that end() cannot change since no non-const functions on emps are called within the loop, and emps is not volatile.
Similarly returning a string by value, even a C++98 compiler will optimize out a copy by RVO

The only semantically guaranteed improvements are by using const&#038; and preincrement.

If any compiler makes a foreach loop faster than a regular loop, the compiler writers need to change their line of work.]]></description>
		<content:encoded><![CDATA[<p>Caching the end() iterator or returning a static string seem like things that are of dubious value. Any decent compiler will recognize that end() cannot change since no non-const functions on emps are called within the loop, and emps is not volatile.<br />
Similarly returning a string by value, even a C++98 compiler will optimize out a copy by RVO</p>
<p>The only semantically guaranteed improvements are by using const&amp; and preincrement.</p>
<p>If any compiler makes a foreach loop faster than a regular loop, the compiler writers need to change their line of work.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9912</link>
		<dc:creator><![CDATA[David]]></dc:creator>
		<pubDate>Thu, 09 May 2013 17:35:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9912</guid>
					<description><![CDATA[[code]
struct employee {
	string name;
	string addr;
};
const string&#038; find_addr(const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
	auto emps_end   = emps.cend();
	for( auto i = emps.cbegin(); i != emps_end; ++i ) {
		if( i-&#062;name == name ) { return i-&#062;addr; }
	}
	static const string s_empty_string;
	return s_empty_string;
}
[/code]]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">
struct employee {
	string name;
	string addr;
};
const string&amp; find_addr(const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
	auto emps_end   = emps.cend();
	for( auto i = emps.cbegin(); i != emps_end; ++i ) {
		if( i-&gt;name == name ) { return i-&gt;addr; }
	}
	static const string s_empty_string;
	return s_empty_string;
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David				</title>
				<link>https://herbsutter.com/2013/05/09/gotw-2-temporary-objects-510/#comment-9911</link>
		<dc:creator><![CDATA[David]]></dc:creator>
		<pubDate>Thu, 09 May 2013 17:33:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1855#comment-9911</guid>
					<description><![CDATA[ok another try:

struct employee {
	string name;
	string addr;
};

const string&#038; find_addr(const list&#038; emps, const string&#038; name )  {
	auto emps_end   = cend(emps);
	for( auto i = emps.cbegin(); i != emps_end; ++i ) {
		if( i-&#062;name == name ) { return i-&#062;addr; }
	}
	static const string s_empty_string;
	return s_empty_string;
}]]></description>
		<content:encoded><![CDATA[<p>ok another try:</p>
<p>struct employee {<br />
	string name;<br />
	string addr;<br />
};</p>
<p>const string&amp; find_addr(const list&amp; emps, const string&amp; name )  {<br />
	auto emps_end   = cend(emps);<br />
	for( auto i = emps.cbegin(); i != emps_end; ++i ) {<br />
		if( i-&gt;name == name ) { return i-&gt;addr; }<br />
	}<br />
	static const string s_empty_string;<br />
	return s_empty_string;<br />
}</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
