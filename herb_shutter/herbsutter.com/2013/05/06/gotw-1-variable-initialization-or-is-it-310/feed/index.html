<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #1: Variable Initialization—or Is It? (3/10)	</title>
	<atom:link href="https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Return of the Guru: Sutter Back for C++14 &#124; Art &#38; Logic Blog				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-10101</link>
		<dc:creator><![CDATA[Return of the Guru: Sutter Back for C++14 &#124; Art &#38; Logic Blog]]></dc:creator>
		<pubDate>Wed, 15 May 2013 18:22:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-10101</guid>
					<description><![CDATA[[&#8230;] GotW #1 [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] GotW #1 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: sehe (@sehetw)				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9906</link>
		<dc:creator><![CDATA[sehe (@sehetw)]]></dc:creator>
		<pubDate>Thu, 09 May 2013 17:19:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9906</guid>
					<description><![CDATA[@bittermanandy Thanks for the clarification. 

Now that I typed your @handle to start a response, I can see you probably chose that name to match your sentiment? I get the impression that you are bitter that C++ isn&#039;t a better &quot;general purpose language&quot;. 

It may not be what you expected it to be: it&#039;s a language amenable to all tasks, but not necessarily eminent for all tasks. 

The point of C++11 is not that it should correct all the shortcomings of C++&#039;s legacy. In my opinion, the point of C++11 is that IFF C++ is the right choice of tool for your particular job, you&#039;ll be an order of magnitude more empowered and productive using it.

I&#039;m willing to say that roughly 50% (or probably, more) of the stuff that populates (More) Effective C++, STL etc. is no longer essential knowledge to survive: C++11 no longer needs to be the minefield C++ used to be. This is major news if you need to be using C++. 

Of course, if you don&#039;t need to be using C++, the news is ... &quot;meh&quot; (under the hood, it&#039;s still the same minefield, right?!). But perhaps that says more about the audience than about the quality of the news.

I&#039;m certainly thinking C++11 is becoming a _more viable_ choice for my own future work. And the trends are certainly making the choice relevant.]]></description>
		<content:encoded><![CDATA[<p>@bittermanandy Thanks for the clarification. </p>
<p>Now that I typed your @handle to start a response, I can see you probably chose that name to match your sentiment? I get the impression that you are bitter that C++ isn&#8217;t a better &#8220;general purpose language&#8221;. </p>
<p>It may not be what you expected it to be: it&#8217;s a language amenable to all tasks, but not necessarily eminent for all tasks. </p>
<p>The point of C++11 is not that it should correct all the shortcomings of C++&#8217;s legacy. In my opinion, the point of C++11 is that IFF C++ is the right choice of tool for your particular job, you&#8217;ll be an order of magnitude more empowered and productive using it.</p>
<p>I&#8217;m willing to say that roughly 50% (or probably, more) of the stuff that populates (More) Effective C++, STL etc. is no longer essential knowledge to survive: C++11 no longer needs to be the minefield C++ used to be. This is major news if you need to be using C++. </p>
<p>Of course, if you don&#8217;t need to be using C++, the news is &#8230; &#8220;meh&#8221; (under the hood, it&#8217;s still the same minefield, right?!). But perhaps that says more about the audience than about the quality of the news.</p>
<p>I&#8217;m certainly thinking C++11 is becoming a _more viable_ choice for my own future work. And the trends are certainly making the choice relevant.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrzej Krzemieński				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9889</link>
		<dc:creator><![CDATA[Andrzej Krzemieński]]></dc:creator>
		<pubDate>Thu, 09 May 2013 07:05:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9889</guid>
					<description><![CDATA[@bames53: This is in fact a very good observation. Constructors that just take some (random) parameters are typically confusing. 

[code]
vector&#060;string&#062; v(10); 
[/code]

What does it mean? Set capacity to 10? Set size to 10? Create a single-element vector? I can of course look it up in the docs, But why force me to do that if the meaning could be made obvious:

[code]
vector&#060;string&#062; v(with_size, 10); // some tag
vector&#060;string&#062; v(size := 10); // if we had named parameters
[/code]

Worse, what if I know (incorrectly) that v(10) reserves capacity, because this is what vector did in the other library I used? I wouldn&#039;t be looking up something i already (think I) know.

Especially for constructors (as opposed to normal functions) I believe we are missing the feature that would help us to express what particular arguments mean.]]></description>
		<content:encoded><![CDATA[<p>@bames53: This is in fact a very good observation. Constructors that just take some (random) parameters are typically confusing. </p>
<pre class="brush: plain; title: ; notranslate">
vector&lt;string&gt; v(10); 
</pre>
<p>What does it mean? Set capacity to 10? Set size to 10? Create a single-element vector? I can of course look it up in the docs, But why force me to do that if the meaning could be made obvious:</p>
<pre class="brush: plain; title: ; notranslate">
vector&lt;string&gt; v(with_size, 10); // some tag
vector&lt;string&gt; v(size := 10); // if we had named parameters
</pre>
<p>Worse, what if I know (incorrectly) that v(10) reserves capacity, because this is what vector did in the other library I used? I wouldn&#8217;t be looking up something i already (think I) know.</p>
<p>Especially for constructors (as opposed to normal functions) I believe we are missing the feature that would help us to express what particular arguments mean.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gregory				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9885</link>
		<dc:creator><![CDATA[Gregory]]></dc:creator>
		<pubDate>Wed, 08 May 2013 10:52:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9885</guid>
					<description><![CDATA[My bad. In first example, always a default constructor is chosen. It actually should be

Widget w{};

and

Widget w{{}};

That is, there should be no difference between initializing with empty initializer_list and default initialization.]]></description>
		<content:encoded><![CDATA[<p>My bad. In first example, always a default constructor is chosen. It actually should be</p>
<p>Widget w{};</p>
<p>and</p>
<p>Widget w{{}};</p>
<p>That is, there should be no difference between initializing with empty initializer_list and default initialization.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Gregory				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9884</link>
		<dc:creator><![CDATA[Gregory]]></dc:creator>
		<pubDate>Wed, 08 May 2013 09:16:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9884</guid>
					<description><![CDATA[My take on 4.
In the presence of initializer-list constructor and default constructor an author of a class should care that 

Widget w; 

and

Widget w{};

are doing essentially the same thing. Moreover, IMHO if a class has initializer-list constructor then it should not have any other constructors except special ones (default, copy, move constructors). Clearly, STL already breaks those assumptions, so standard collections should be thought as exceptions to the rule.

Also, if we have some Composite with initializer-list constructor then an author of a class should think about interaction of initializer-list constructor and copy/move constructor:

CompositeWidget w;
CompositeWidget w2{w};

and

CompositeWidget w;
CompositeWidget w2(w);

should do the same thing. Initializer-list constructor should not be provided if it&#039;s not desirable for these two statements to be semantically the same. 

If these rules are followed then we can say that brace-initialization should be used in all cases (except when dealing with standard collections or with unknown types in template code that may happen to be standard collections).]]></description>
		<content:encoded><![CDATA[<p>My take on 4.<br />
In the presence of initializer-list constructor and default constructor an author of a class should care that </p>
<p>Widget w; </p>
<p>and</p>
<p>Widget w{};</p>
<p>are doing essentially the same thing. Moreover, IMHO if a class has initializer-list constructor then it should not have any other constructors except special ones (default, copy, move constructors). Clearly, STL already breaks those assumptions, so standard collections should be thought as exceptions to the rule.</p>
<p>Also, if we have some Composite with initializer-list constructor then an author of a class should think about interaction of initializer-list constructor and copy/move constructor:</p>
<p>CompositeWidget w;<br />
CompositeWidget w2{w};</p>
<p>and</p>
<p>CompositeWidget w;<br />
CompositeWidget w2(w);</p>
<p>should do the same thing. Initializer-list constructor should not be provided if it&#8217;s not desirable for these two statements to be semantically the same. </p>
<p>If these rules are followed then we can say that brace-initialization should be used in all cases (except when dealing with standard collections or with unknown types in template code that may happen to be standard collections).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: klementor				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9882</link>
		<dc:creator><![CDATA[klementor]]></dc:creator>
		<pubDate>Wed, 08 May 2013 01:05:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9882</guid>
					<description><![CDATA[(a) widget w; 
If w is of static or thread_local storage duration, it is zero-initialized. Otherwise, it is default-initialized.

(b) widget w();
This is a function declaration.

(c) widget w{};
w is direct-initialized.

(d) widget w(x);
If x is a type, w is a function declaration. Otherwise, w is direct-initialized.

(e) widget w{x};
w is direct-list-initialized.

(f) widget w = x;
w is copy-initialized.

(g) widget w = {x};
w is copy-initialized.

(h) auto w = x;
w is copy-initialized.

(i) auto w = widget{x};
w is copy-initialized.]]></description>
		<content:encoded><![CDATA[<p>(a) widget w;<br />
If w is of static or thread_local storage duration, it is zero-initialized. Otherwise, it is default-initialized.</p>
<p>(b) widget w();<br />
This is a function declaration.</p>
<p>(c) widget w{};<br />
w is direct-initialized.</p>
<p>(d) widget w(x);<br />
If x is a type, w is a function declaration. Otherwise, w is direct-initialized.</p>
<p>(e) widget w{x};<br />
w is direct-list-initialized.</p>
<p>(f) widget w = x;<br />
w is copy-initialized.</p>
<p>(g) widget w = {x};<br />
w is copy-initialized.</p>
<p>(h) auto w = x;<br />
w is copy-initialized.</p>
<p>(i) auto w = widget{x};<br />
w is copy-initialized.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Homero				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9881</link>
		<dc:creator><![CDATA[Homero]]></dc:creator>
		<pubDate>Tue, 07 May 2013 15:58:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9881</guid>
					<description><![CDATA[Ok, let&#039;s play:

1. (a) and (c) create an object of type widget and assign it to variable w calling the default constructor. (b) declares a function of name w which returns a widget and takes no parameters. (d) and (e) are equivalent and create an object of type widget calling a constructor that can take an object of the same type as x as argument. (f) creates a widget by calling the overloaded assignment operator that can take x as argument OR casting x to a widget and assigning it to w through the copy constructor. (g) tries to initialize w by using a initialization list with x. (h) Creates a variable of type w with the same type as x calling the proper copy constructor or assignment operator. (i) Creates an object of type widget using x as parameter for the propper constructor and calls the move constructor to assign it to w.

2. (a) creates a vector of 10 elements and initialize all its elements with the value 20. (b) Creates a vector with two elements, with value 10 and 20.

3. {} offers more clear declaration of intent and is consistent with array initialization at declaration time.

4. The curly brackets style should be used whenever possible in modern C++ code, falling back to () only if you intend to write code that should be backwards compatible with older compilers.]]></description>
		<content:encoded><![CDATA[<p>Ok, let&#8217;s play:</p>
<p>1. (a) and (c) create an object of type widget and assign it to variable w calling the default constructor. (b) declares a function of name w which returns a widget and takes no parameters. (d) and (e) are equivalent and create an object of type widget calling a constructor that can take an object of the same type as x as argument. (f) creates a widget by calling the overloaded assignment operator that can take x as argument OR casting x to a widget and assigning it to w through the copy constructor. (g) tries to initialize w by using a initialization list with x. (h) Creates a variable of type w with the same type as x calling the proper copy constructor or assignment operator. (i) Creates an object of type widget using x as parameter for the propper constructor and calls the move constructor to assign it to w.</p>
<p>2. (a) creates a vector of 10 elements and initialize all its elements with the value 20. (b) Creates a vector with two elements, with value 10 and 20.</p>
<p>3. {} offers more clear declaration of intent and is consistent with array initialization at declaration time.</p>
<p>4. The curly brackets style should be used whenever possible in modern C++ code, falling back to () only if you intend to write code that should be backwards compatible with older compilers.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bittermanandy				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9880</link>
		<dc:creator><![CDATA[bittermanandy]]></dc:creator>
		<pubDate>Tue, 07 May 2013 13:25:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9880</guid>
					<description><![CDATA[sehe: yes, I realise the C++ standards committee is balancing a lot of different things; and I realise other languages are an option. The point is, people *are taking* the other option. In droves. The C++ standards committee might not have nice syntax and usability of the language high on their list of priorities. That&#039;s fine. It just means people won&#039;t use it (...even when compiler writers finally implement it). I can&#039;t personally see the point in spending sixteen-plus year&#039;s worth of time and effort on something that barely anybody is going to use, that&#039;s all.

Herb&#039;s books and GotW are fascinating things, and a decade or so ago I used to read them avidly, excited by how much more I was learning about a language I thought I already knew. In that decade I&#039;ve realised that knowing the difference between widget w() and widget w{} isn&#039;t a badge of honour to wear proudly to prove one&#039;s coding credentials; it&#039;s a syntax disaster that means people are going to write buggy code... in part because the Standards Committee didn&#039;t prioritize &quot;prettyness&quot; and &quot;consistency&quot;.

I mean, clearly there&#039;s nothing I can write here that will change it now. I just think it&#039;s a real shame that the new version(s) of C++ has/have left it &quot;the same as before only more so&quot;, when it could have made it a modern, usable language instead. You are quite right though, there are other options, for which we can all be thankful. I suppose there&#039;s not much point in me continuing to bang this particular drum so I&#039;ll leave this discussion to actually answering the questions in the post... sorry for the digression.]]></description>
		<content:encoded><![CDATA[<p>sehe: yes, I realise the C++ standards committee is balancing a lot of different things; and I realise other languages are an option. The point is, people *are taking* the other option. In droves. The C++ standards committee might not have nice syntax and usability of the language high on their list of priorities. That&#8217;s fine. It just means people won&#8217;t use it (&#8230;even when compiler writers finally implement it). I can&#8217;t personally see the point in spending sixteen-plus year&#8217;s worth of time and effort on something that barely anybody is going to use, that&#8217;s all.</p>
<p>Herb&#8217;s books and GotW are fascinating things, and a decade or so ago I used to read them avidly, excited by how much more I was learning about a language I thought I already knew. In that decade I&#8217;ve realised that knowing the difference between widget w() and widget w{} isn&#8217;t a badge of honour to wear proudly to prove one&#8217;s coding credentials; it&#8217;s a syntax disaster that means people are going to write buggy code&#8230; in part because the Standards Committee didn&#8217;t prioritize &#8220;prettyness&#8221; and &#8220;consistency&#8221;.</p>
<p>I mean, clearly there&#8217;s nothing I can write here that will change it now. I just think it&#8217;s a real shame that the new version(s) of C++ has/have left it &#8220;the same as before only more so&#8221;, when it could have made it a modern, usable language instead. You are quite right though, there are other options, for which we can all be thankful. I suppose there&#8217;s not much point in me continuing to bang this particular drum so I&#8217;ll leave this discussion to actually answering the questions in the post&#8230; sorry for the digression.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: sehe (@sehetw)				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9879</link>
		<dc:creator><![CDATA[sehe (@sehetw)]]></dc:creator>
		<pubDate>Tue, 07 May 2013 12:00:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9879</guid>
					<description><![CDATA[@bittermanandy welcome to c++. Similarity to any language other than C is not a driving design force. Rather, it is the other way around (referring to the C# case. ::global anyone?)

Another key driving force is backwards code compatibility (using `var` over `auto` would have been nice. For a green-field language!).

Also, the difference between a non-vexing parse and a most-vexing parse used to be 0 (zero) pixels, so actually, extending the lead to 2 (non-ugly) pixels is quite an improvement.

Just a few quick shots. The C++ standards committee is balancing a **lot** more goals than just &quot;prettyness&quot; or even &quot;consistency&quot;. Feel free to use D, Boo, Go or C# if it pleases you more.]]></description>
		<content:encoded><![CDATA[<p>@bittermanandy welcome to c++. Similarity to any language other than C is not a driving design force. Rather, it is the other way around (referring to the C# case. ::global anyone?)</p>
<p>Another key driving force is backwards code compatibility (using `var` over `auto` would have been nice. For a green-field language!).</p>
<p>Also, the difference between a non-vexing parse and a most-vexing parse used to be 0 (zero) pixels, so actually, extending the lead to 2 (non-ugly) pixels is quite an improvement.</p>
<p>Just a few quick shots. The C++ standards committee is balancing a **lot** more goals than just &#8220;prettyness&#8221; or even &#8220;consistency&#8221;. Feel free to use D, Boo, Go or C# if it pleases you more.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Redl				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9878</link>
		<dc:creator><![CDATA[Sebastian Redl]]></dc:creator>
		<pubDate>Tue, 07 May 2013 10:14:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9878</guid>
					<description><![CDATA[&#062; Consistency with other languages would be nice too. Why “auto” and not “var”, for example?
I don&#039;t see any reason to be consistent with &quot;other languages&quot; - especially when you&#039;ll have a hard time being consistent with more than one at the same time. Using &quot;var&quot; would be consistent with C#. JavaScript also uses &quot;var&quot;, but modern JavaScript is moving away from that to &quot;let&quot;. Java doesn&#039;t have type deduction and won&#039;t get it, but the RFE that was rejected asked for &quot;let&quot;.
&quot;auto&quot; has the big advantage that it was already a keyword, and so you don&#039;t get the enormous code breakage that you would get from introducing something as common as &quot;var&quot; as a new keyword. (C# can afford this due to differences in general parsing strategy from C++ and stronger restrictions on where &quot;var&quot; can appear.)]]></description>
		<content:encoded><![CDATA[<p>&gt; Consistency with other languages would be nice too. Why “auto” and not “var”, for example?<br />
I don&#8217;t see any reason to be consistent with &#8220;other languages&#8221; &#8211; especially when you&#8217;ll have a hard time being consistent with more than one at the same time. Using &#8220;var&#8221; would be consistent with C#. JavaScript also uses &#8220;var&#8221;, but modern JavaScript is moving away from that to &#8220;let&#8221;. Java doesn&#8217;t have type deduction and won&#8217;t get it, but the RFE that was rejected asked for &#8220;let&#8221;.<br />
&#8220;auto&#8221; has the big advantage that it was already a keyword, and so you don&#8217;t get the enormous code breakage that you would get from introducing something as common as &#8220;var&#8221; as a new keyword. (C# can afford this due to differences in general parsing strategy from C++ and stronger restrictions on where &#8220;var&#8221; can appear.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Redl				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9877</link>
		<dc:creator><![CDATA[Sebastian Redl]]></dc:creator>
		<pubDate>Tue, 07 May 2013 10:08:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9877</guid>
					<description><![CDATA[One thing that nobody has pointed out yet is the difference between 1e and 1g. Specifically, the former is direct-list-initialization, while the latter is copy-list-initialization. The difference being that only 1e will select explicit constructors. In other words, given a widget:

struct widget {
  explicit widget(X x);
};

1e will compile, 1g will not. That&#039;s the same as the difference between 1d and 1f.]]></description>
		<content:encoded><![CDATA[<p>One thing that nobody has pointed out yet is the difference between 1e and 1g. Specifically, the former is direct-list-initialization, while the latter is copy-list-initialization. The difference being that only 1e will select explicit constructors. In other words, given a widget:</p>
<p>struct widget {<br />
  explicit widget(X x);<br />
};</p>
<p>1e will compile, 1g will not. That&#8217;s the same as the difference between 1d and 1f.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bittermanandy				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9874</link>
		<dc:creator><![CDATA[bittermanandy]]></dc:creator>
		<pubDate>Tue, 07 May 2013 07:44:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9874</guid>
					<description><![CDATA[I started answering these fairly confidently, then I assumed that the difference between () and {} was broadly the same as in C#, and I realise I&#039;m not actually sure that&#039;s the case. With that in mind, I think the latter zero-initialises types without a default constructor of their own, otherwise acts like a constructor, unless it&#039;s an initialiser list, in which case it&#039;s like C#.

What I am sure of is that this is a syntactic disaster area. You know what the *visual* difference between () and {} is, in a typical font in a typical IDE? Two pixels. If there&#039;s any meaningful difference between them - if the difference between them could ever cause a bug - it&#039;s going to be a nightmare to actually *notice* it when it happens.

(To illustrate, just look at the two vector examples. One is a vector with 10 elements with all the same value, the other is a vector with 2 elements with different values... and yet you have to look at it twice to even realise there&#039;s a difference between them. When reading the code in an actual codebase, you probably wouldn&#039;t spot it).

It&#039;s great that C++ is adding some new stuff, and all; but the syntax and usability are dreadful, two years after a major release there aren&#039;t any fully conforming compilers (and VS, the one I use by far the most often, is *way* off), and an update is already being planned, suggesting C++11 wasn&#039;t even properly finished. I have to say that the Standards Committee are doing a fantastic job up of creating a theoretically better C++ up there in their ivory tower, but if nobody can use it (and of those that can, few do - witness the guy above who doesn&#039;t even know what &quot;auto&quot; does, and he is *far* from alone) it&#039;s no use to anybody.

That&#039;s not to say it shouldn&#039;t be tried, of course. Seeking to improve C++ may well be a worthwhile endeavour (though taking sixteen years to do it just means everyone will have moved on). But when the &quot;improvement&quot; involves a two-pixel difference in syntax that totally changes how something behaves, that should be a massive red flag that something has gone badly wrong. Syntax matters, and the syntax of all the new stuff is universally fugly. (Consistency with other languages would be nice too. Why &quot;auto&quot; and not &quot;var&quot;, for example? And the syntax for lambdas - just why?) Too little, much too late, and klunky syntax. Sadly.]]></description>
		<content:encoded><![CDATA[<p>I started answering these fairly confidently, then I assumed that the difference between () and {} was broadly the same as in C#, and I realise I&#8217;m not actually sure that&#8217;s the case. With that in mind, I think the latter zero-initialises types without a default constructor of their own, otherwise acts like a constructor, unless it&#8217;s an initialiser list, in which case it&#8217;s like C#.</p>
<p>What I am sure of is that this is a syntactic disaster area. You know what the *visual* difference between () and {} is, in a typical font in a typical IDE? Two pixels. If there&#8217;s any meaningful difference between them &#8211; if the difference between them could ever cause a bug &#8211; it&#8217;s going to be a nightmare to actually *notice* it when it happens.</p>
<p>(To illustrate, just look at the two vector examples. One is a vector with 10 elements with all the same value, the other is a vector with 2 elements with different values&#8230; and yet you have to look at it twice to even realise there&#8217;s a difference between them. When reading the code in an actual codebase, you probably wouldn&#8217;t spot it).</p>
<p>It&#8217;s great that C++ is adding some new stuff, and all; but the syntax and usability are dreadful, two years after a major release there aren&#8217;t any fully conforming compilers (and VS, the one I use by far the most often, is *way* off), and an update is already being planned, suggesting C++11 wasn&#8217;t even properly finished. I have to say that the Standards Committee are doing a fantastic job up of creating a theoretically better C++ up there in their ivory tower, but if nobody can use it (and of those that can, few do &#8211; witness the guy above who doesn&#8217;t even know what &#8220;auto&#8221; does, and he is *far* from alone) it&#8217;s no use to anybody.</p>
<p>That&#8217;s not to say it shouldn&#8217;t be tried, of course. Seeking to improve C++ may well be a worthwhile endeavour (though taking sixteen years to do it just means everyone will have moved on). But when the &#8220;improvement&#8221; involves a two-pixel difference in syntax that totally changes how something behaves, that should be a massive red flag that something has gone badly wrong. Syntax matters, and the syntax of all the new stuff is universally fugly. (Consistency with other languages would be nice too. Why &#8220;auto&#8221; and not &#8220;var&#8221;, for example? And the syntax for lambdas &#8211; just why?) Too little, much too late, and klunky syntax. Sadly.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: juanchopanza				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9873</link>
		<dc:creator><![CDATA[juanchopanza]]></dc:creator>
		<pubDate>Tue, 07 May 2013 06:16:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9873</guid>
					<description><![CDATA[Concerning the first question, besides what already applied in C++03, the main subtlety is brace or &quot;uniform&quot; initialization. What happens in all cases of w{....} depends on whether widget had an std::initializer_list constructor or is an aggregate. So a partial answer is &quot;we can&#039;t really know for sure what will happen without knowing more about widget&quot;.

Concerning the guru question, std::vector has an initializer_list constructor and that one trumps the others. So the first vector has size 10 and is full of 20s, the second one has size 2 and contains values 10 and 20.]]></description>
		<content:encoded><![CDATA[<p>Concerning the first question, besides what already applied in C++03, the main subtlety is brace or &#8220;uniform&#8221; initialization. What happens in all cases of w{&#8230;.} depends on whether widget had an std::initializer_list constructor or is an aggregate. So a partial answer is &#8220;we can&#8217;t really know for sure what will happen without knowing more about widget&#8221;.</p>
<p>Concerning the guru question, std::vector has an initializer_list constructor and that one trumps the others. So the first vector has size 10 and is full of 20s, the second one has size 2 and contains values 10 and 20.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: germinolegrand				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9872</link>
		<dc:creator><![CDATA[germinolegrand]]></dc:creator>
		<pubDate>Mon, 06 May 2013 23:47:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9872</guid>
					<description><![CDATA[@Chris Chiesa: The *auto* keyword is part of the C++11 standard, whitch brings lots of new features, you should have look at it, it&#039;s been in use since nov 2011. You can find more infos on http://isocpp.org/tour . Have a good C++11 update ;) !]]></description>
		<content:encoded><![CDATA[<p>@Chris Chiesa: The *auto* keyword is part of the C++11 standard, whitch brings lots of new features, you should have look at it, it&#8217;s been in use since nov 2011. You can find more infos on <a href="http://isocpp.org/tour" rel="nofollow">http://isocpp.org/tour</a> . Have a good C++11 update ;) !</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris Chiesa				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9871</link>
		<dc:creator><![CDATA[Chris Chiesa]]></dc:creator>
		<pubDate>Mon, 06 May 2013 23:35:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9871</guid>
					<description><![CDATA[Interesting.  When I click the &quot;comment&quot; link, I am taken to a snarky version of a 404 page, that asks &quot;Where did you get such a link?&quot;  Got it from yer own danged email, is where, just this morning! 

The comment I was *going *to post would have been something like, &quot;I&#039;ve been a C++ programmer for years, and while I know I&#039;ve never been &#039;world class&#039; at it, I must *really *be out of the loop; I don&#039;t recognize the *auto *keyword; what does that do?&quot; 

Cheers,     Chris Chiesa]]></description>
		<content:encoded><![CDATA[<p>Interesting.  When I click the &#8220;comment&#8221; link, I am taken to a snarky version of a 404 page, that asks &#8220;Where did you get such a link?&#8221;  Got it from yer own danged email, is where, just this morning! </p>
<p>The comment I was *going *to post would have been something like, &#8220;I&#8217;ve been a C++ programmer for years, and while I know I&#8217;ve never been &#8216;world class&#8217; at it, I must *really *be out of the loop; I don&#8217;t recognize the *auto *keyword; what does that do?&#8221; </p>
<p>Cheers,     Chris Chiesa</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Glen				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9870</link>
		<dc:creator><![CDATA[Glen]]></dc:creator>
		<pubDate>Mon, 06 May 2013 21:47:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9870</guid>
					<description><![CDATA[@Loghorn: I just spat my coffee over my desk! lol]]></description>
		<content:encoded><![CDATA[<p>@Loghorn: I just spat my coffee over my desk! lol</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mikhail Belyaev				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9868</link>
		<dc:creator><![CDATA[Mikhail Belyaev]]></dc:creator>
		<pubDate>Mon, 06 May 2013 20:27:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9868</guid>
					<description><![CDATA[Having thought it through, my comment has at least two obvious mistakes.

b is illegal altogether because of this kind of syntax being a function declaration returning widget. It makes me cry every time almost as much as having to place &quot;typename&quot; and &quot;template&quot; because of compiler warnings. It gives another benefit to using {}: if such a call is created by macro or vararg template expansion, it can be very troublesome to find out why this w() thingie does not work. A function declaration is of course legal C++, but among the other pieces of code it is an obvious typo.

f and g of course use move-assignment (or copy assignment if move is not available) after construction and not move-construct. That&#039;s just my typo. These will be almost always be optimized to using copy construction, but compilers are not obligated to do it.]]></description>
		<content:encoded><![CDATA[<p>Having thought it through, my comment has at least two obvious mistakes.</p>
<p>b is illegal altogether because of this kind of syntax being a function declaration returning widget. It makes me cry every time almost as much as having to place &#8220;typename&#8221; and &#8220;template&#8221; because of compiler warnings. It gives another benefit to using {}: if such a call is created by macro or vararg template expansion, it can be very troublesome to find out why this w() thingie does not work. A function declaration is of course legal C++, but among the other pieces of code it is an obvious typo.</p>
<p>f and g of course use move-assignment (or copy assignment if move is not available) after construction and not move-construct. That&#8217;s just my typo. These will be almost always be optimized to using copy construction, but compilers are not obligated to do it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brandon				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9867</link>
		<dc:creator><![CDATA[Brandon]]></dc:creator>
		<pubDate>Mon, 06 May 2013 19:00:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9867</guid>
					<description><![CDATA[Widget x = y; // if Widget has a constructor that takes decltype( y ), the compiler will optimize to call that instead of op=()]]></description>
		<content:encoded><![CDATA[<p>Widget x = y; // if Widget has a constructor that takes decltype( y ), the compiler will optimize to call that instead of op=()</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bames53				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9866</link>
		<dc:creator><![CDATA[bames53]]></dc:creator>
		<pubDate>Mon, 06 May 2013 16:29:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9866</guid>
					<description><![CDATA[@MichalMocny

I think this would have been very bad. &#039;a&#039; should be the same as &#039;c&#039;, should be the same as &#039;d&#039;. And I don&#039;t want to see &#039;b&#039;. The non-uniformity imposed by having {} prefer initializer_list constructors is far less than the non-uniformity you&#039;re suggesting here:

Although the rule could be worded simply &quot;always use {}&quot;, the actual usage would be more complicated; &quot;use {} sometimes, use = {} sometimes, use {{}} sometimes,&quot; etc. The exception when non-brace initialization is required is relatively rare compared to when you would require different kinds of brace initialization.

Additionally, components designed with brace initialization in mind can and should avoid the problem by not having any constructors that might collide with list_initializer constructors. For example a `vector` designed today might have a third dummy parameter to disambiguate.]]></description>
		<content:encoded><![CDATA[<p>@MichalMocny</p>
<p>I think this would have been very bad. &#8216;a&#8217; should be the same as &#8216;c&#8217;, should be the same as &#8216;d&#8217;. And I don&#8217;t want to see &#8216;b&#8217;. The non-uniformity imposed by having {} prefer initializer_list constructors is far less than the non-uniformity you&#8217;re suggesting here:</p>
<p>Although the rule could be worded simply &#8220;always use {}&#8221;, the actual usage would be more complicated; &#8220;use {} sometimes, use = {} sometimes, use {{}} sometimes,&#8221; etc. The exception when non-brace initialization is required is relatively rare compared to when you would require different kinds of brace initialization.</p>
<p>Additionally, components designed with brace initialization in mind can and should avoid the problem by not having any constructors that might collide with list_initializer constructors. For example a `vector` designed today might have a third dummy parameter to disambiguate.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: zahirtezcan (@zahirtezcan)				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9865</link>
		<dc:creator><![CDATA[zahirtezcan (@zahirtezcan)]]></dc:creator>
		<pubDate>Mon, 06 May 2013 16:25:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9865</guid>
					<description><![CDATA[I just want to make an addition for question 3. As far as I know, for incoming C++14 there is a use for {} &quot;lambda capture by move&quot;]]></description>
		<content:encoded><![CDATA[<p>I just want to make an addition for question 3. As far as I know, for incoming C++14 there is a use for {} &#8220;lambda capture by move&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jmckesson				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9864</link>
		<dc:creator><![CDATA[jmckesson]]></dc:creator>
		<pubDate>Mon, 06 May 2013 15:37:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9864</guid>
					<description><![CDATA[1) These are pretty easy. Let `X` be whatever type `x` is.

a) default constructs `w` via default initialization. The contents of `widget` will be default-initialized if `widget` does not have a user-provided default constructor. Otherwise, they will be value-initialized.

b) declares a function named `w` that takes no parameters and returns a `widget`.

c) default constructs `w` via value initialization. The contents of `widget` will always be value-initialized.

d) constructs `w` by calling a `widget` constructor that can takes a single `X` value either by value or by l-value reference.

e) this depends. If there is an initializer-list constructor of `widget` who’s initializer_list is the type of `x`, then that constructor will be called with an initializer_list that is one element long. Otherwise, it will call a constructor that can takes a single `X` value either by value or by l-value reference.

f) Implicit conversion is attempted on the value `x`. If `X` has a non-explicit `operator widget()` overload, then that will be used to convert `x` into `w`. Otherwise, if `widget` has a non-explicit constructor that can takes a single `X` by value or by l-value reference, then that constructor will be called. If any of these result in finding an explicit function, an error will result.

g) If there is an initializer-list constructor of `widget` who’s initializer_list is the type of `x`, then that constructor will be called with an initializer_list that is one element long. Otherwise, it will attempt implicit conversion as in f) above.

h) Constructs a `w`, of type `X`, via copy initialization from `x`. If no copy constructor is accessible (ie: has been deleted or otherwise cannot be called), a compiler error will result.

i) Constructs a `w` of type `widget`, via copy initialization from a temporary. The temporary will be constructed in accord with e) above. Note that the actual copy of the temporary to `w` may be elided.

2)

a) Constructs a 20-element `vector`, where each element is initialized to 10.

b) Constructs a 2-element `vector`. The first element is 20, the second is 10.

3)

This is kind of a difficult question. I say because because #2 is not a benefit of {} syntax at all. It’s a detriment, because you *cannot* use {} syntax to access the two-element constructor of `vector`. You could if you used `vector{20, 10}`; that would attempt to create `20` widgets, with the widgets being copy-constructed from a `widget` that was implicitly constructed from `10`.

It is not a benefit that `vector{20, 10}` is *completely ambiguous* without knowing what `T` is. That `T=int` resolves to *completely* different code from `T=widget`. That’s not an advantage; that’s a detriment.

The main benefit to using {}, to me, is to not have to use the typename of a variable type so often. For example:

std::string GetLuaString(lua_State *L)
{
size_t len = 0;
const char *str = lua_tolstring(L, -1, &#038;len);
return {str, len};
}

I don’t need to repeat `std::string` here. The compiler knows what I’m returning, so it figures it out.

This also works for calling functions:

void SomeFunc(std::string str);

SomeFunc({“stuff”, 5});

That’s not the most useful example, but you get the idea. It’s like a form of `auto` for parameters and return values. Though return values won’t be as important in C++14 since we can auto-deduce them and thus stick the type in the return statement. But it’ll still be important for those non-inline functions where we can’t auto-deduce them.

4)

Only if both of the following conditions are met:

A) If you are ABSOLUTELY certain of the type you’re trying to initialize. That means you know exactly what it is and what constructors are available. This includes any template parameters of that type. So if you’re in some template code, and you have a `vector`, you can’t use {}.

B) If the constructor you’re trying to call is reachable with {}. This ties into A; since you know the type, and you know the arguments, you can therefore know if the horrible {} ambiguity rules hide the constructor you want to call or not. If they don’t hide it, you can use {}. If they do, you can’t; you have to use ().

Personally, I love uniform initialization, as a concept. But the ambiguity rules are so terrible that you can’t really trust it. If I were to give a professional opinion, I would say that, until the standards committee fixes them (and no formal proposals have been provided that do so. Though I have worked on a preliminary one: https://groups.google.com/a/isocpp.org/forum/#!searchin/std-proposals/More$20uniform$20initialization/std-proposals/hfDHD0GyfqI/xwTMNI276-kJ), there is only one time you should ever use it:

To resolve the Most Vexing Parse. That is, case `1.b` above: `widget w()`. That’s the only time you can trust it to work, and even then, you can only use it if A and B are satisfied. Otherwise, you have to use extra parenthesis like we do now.

I would love to be able to recommend you always use {}. Or even that you should use it whenever possible. But I cannot in good conscious do so. Not until the standard is fixed.]]></description>
		<content:encoded><![CDATA[<p>1) These are pretty easy. Let `X` be whatever type `x` is.</p>
<p>a) default constructs `w` via default initialization. The contents of `widget` will be default-initialized if `widget` does not have a user-provided default constructor. Otherwise, they will be value-initialized.</p>
<p>b) declares a function named `w` that takes no parameters and returns a `widget`.</p>
<p>c) default constructs `w` via value initialization. The contents of `widget` will always be value-initialized.</p>
<p>d) constructs `w` by calling a `widget` constructor that can takes a single `X` value either by value or by l-value reference.</p>
<p>e) this depends. If there is an initializer-list constructor of `widget` who’s initializer_list is the type of `x`, then that constructor will be called with an initializer_list that is one element long. Otherwise, it will call a constructor that can takes a single `X` value either by value or by l-value reference.</p>
<p>f) Implicit conversion is attempted on the value `x`. If `X` has a non-explicit `operator widget()` overload, then that will be used to convert `x` into `w`. Otherwise, if `widget` has a non-explicit constructor that can takes a single `X` by value or by l-value reference, then that constructor will be called. If any of these result in finding an explicit function, an error will result.</p>
<p>g) If there is an initializer-list constructor of `widget` who’s initializer_list is the type of `x`, then that constructor will be called with an initializer_list that is one element long. Otherwise, it will attempt implicit conversion as in f) above.</p>
<p>h) Constructs a `w`, of type `X`, via copy initialization from `x`. If no copy constructor is accessible (ie: has been deleted or otherwise cannot be called), a compiler error will result.</p>
<p>i) Constructs a `w` of type `widget`, via copy initialization from a temporary. The temporary will be constructed in accord with e) above. Note that the actual copy of the temporary to `w` may be elided.</p>
<p>2)</p>
<p>a) Constructs a 20-element `vector`, where each element is initialized to 10.</p>
<p>b) Constructs a 2-element `vector`. The first element is 20, the second is 10.</p>
<p>3)</p>
<p>This is kind of a difficult question. I say because because #2 is not a benefit of {} syntax at all. It’s a detriment, because you *cannot* use {} syntax to access the two-element constructor of `vector`. You could if you used `vector{20, 10}`; that would attempt to create `20` widgets, with the widgets being copy-constructed from a `widget` that was implicitly constructed from `10`.</p>
<p>It is not a benefit that `vector{20, 10}` is *completely ambiguous* without knowing what `T` is. That `T=int` resolves to *completely* different code from `T=widget`. That’s not an advantage; that’s a detriment.</p>
<p>The main benefit to using {}, to me, is to not have to use the typename of a variable type so often. For example:</p>
<p>std::string GetLuaString(lua_State *L)<br />
{<br />
size_t len = 0;<br />
const char *str = lua_tolstring(L, -1, &amp;len);<br />
return {str, len};<br />
}</p>
<p>I don’t need to repeat `std::string` here. The compiler knows what I’m returning, so it figures it out.</p>
<p>This also works for calling functions:</p>
<p>void SomeFunc(std::string str);</p>
<p>SomeFunc({“stuff”, 5});</p>
<p>That’s not the most useful example, but you get the idea. It’s like a form of `auto` for parameters and return values. Though return values won’t be as important in C++14 since we can auto-deduce them and thus stick the type in the return statement. But it’ll still be important for those non-inline functions where we can’t auto-deduce them.</p>
<p>4)</p>
<p>Only if both of the following conditions are met:</p>
<p>A) If you are ABSOLUTELY certain of the type you’re trying to initialize. That means you know exactly what it is and what constructors are available. This includes any template parameters of that type. So if you’re in some template code, and you have a `vector`, you can’t use {}.</p>
<p>B) If the constructor you’re trying to call is reachable with {}. This ties into A; since you know the type, and you know the arguments, you can therefore know if the horrible {} ambiguity rules hide the constructor you want to call or not. If they don’t hide it, you can use {}. If they do, you can’t; you have to use ().</p>
<p>Personally, I love uniform initialization, as a concept. But the ambiguity rules are so terrible that you can’t really trust it. If I were to give a professional opinion, I would say that, until the standards committee fixes them (and no formal proposals have been provided that do so. Though I have worked on a preliminary one: <a href="https://groups.google.com/a/isocpp.org/forum/#!searchin/std-proposals/More$20uniform$20initialization/std-proposals/hfDHD0GyfqI/xwTMNI276-kJ" rel="nofollow">https://groups.google.com/a/isocpp.org/forum/#!searchin/std-proposals/More$20uniform$20initialization/std-proposals/hfDHD0GyfqI/xwTMNI276-kJ</a>), there is only one time you should ever use it:</p>
<p>To resolve the Most Vexing Parse. That is, case `1.b` above: `widget w()`. That’s the only time you can trust it to work, and even then, you can only use it if A and B are satisfied. Otherwise, you have to use extra parenthesis like we do now.</p>
<p>I would love to be able to recommend you always use {}. Or even that you should use it whenever possible. But I cannot in good conscious do so. Not until the standard is fixed.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9862</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 06 May 2013 15:15:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9862</guid>
					<description><![CDATA[@Loghorn: :) All but (i) work on http://rise4fun.com/vcpp . As promised in November, more info coming in the first half of 2013 (i.e., no later than end of next month).]]></description>
		<content:encoded><![CDATA[<p>@Loghorn: :) All but (i) work on <a href="http://rise4fun.com/vcpp" rel="nofollow">http://rise4fun.com/vcpp</a> . As promised in November, more info coming in the first half of 2013 (i.e., no later than end of next month).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michal Mocny				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9861</link>
		<dc:creator><![CDATA[Michal Mocny]]></dc:creator>
		<pubDate>Mon, 06 May 2013 14:26:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9861</guid>
					<description><![CDATA[Brace initialization binding tighter to initializer_list initialization is, I consider, an unfortunate language wart.  (Please do correct me if I am mistaken.)

Specifically, looking at Guru Question 2 example(b), that will create a vector with 2 int values 10,20.  If you wanted to initialize 10 elements with the value 20, you *must* use regular bracket initialization (Question 2 example(a) notation).

Much like leaving out make_unique meant we could not teach novices to not use &quot;new&quot; any more, this brace initialization decision means we cannot teach &quot;always initialize with {}&quot;.  Instead we have to consider the implications of each initialization and peer inside class constructor details (e.g. I know this class has blah constructor, but hmm does it also have an initializer_list constructor?  I&#039;ll just stick to using brackets, oops vexing parse).

What makes this seem more unfortunate, is that I think living with the reverse decision would have been totally fine:

// Not true in real C++, alternative reality
vector a{ 10, 20 }; // a.size() == 10
vector b{{ 10, 20 }}; // b.size() == 2
vector c = { 10, 20 }; // c.size() == 2
vector d = vector{ 10, 20 }; // d.size() == 10

What it would also mean, is that auto brace initialization would be less awkward:

// Not true in real C++, alternative reality
auto a{1}; // a is int
auto b{{1}}; // b is initializer_list

Thoughts?  Am I wrong, is there some reason for which initializer_list being the default is a great choice?]]></description>
		<content:encoded><![CDATA[<p>Brace initialization binding tighter to initializer_list initialization is, I consider, an unfortunate language wart.  (Please do correct me if I am mistaken.)</p>
<p>Specifically, looking at Guru Question 2 example(b), that will create a vector with 2 int values 10,20.  If you wanted to initialize 10 elements with the value 20, you *must* use regular bracket initialization (Question 2 example(a) notation).</p>
<p>Much like leaving out make_unique meant we could not teach novices to not use &#8220;new&#8221; any more, this brace initialization decision means we cannot teach &#8220;always initialize with {}&#8221;.  Instead we have to consider the implications of each initialization and peer inside class constructor details (e.g. I know this class has blah constructor, but hmm does it also have an initializer_list constructor?  I&#8217;ll just stick to using brackets, oops vexing parse).</p>
<p>What makes this seem more unfortunate, is that I think living with the reverse decision would have been totally fine:</p>
<p>// Not true in real C++, alternative reality<br />
vector a{ 10, 20 }; // a.size() == 10<br />
vector b{{ 10, 20 }}; // b.size() == 2<br />
vector c = { 10, 20 }; // c.size() == 2<br />
vector d = vector{ 10, 20 }; // d.size() == 10</p>
<p>What it would also mean, is that auto brace initialization would be less awkward:</p>
<p>// Not true in real C++, alternative reality<br />
auto a{1}; // a is int<br />
auto b{{1}}; // b is initializer_list</p>
<p>Thoughts?  Am I wrong, is there some reason for which initializer_list being the default is a great choice?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pindragon				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9860</link>
		<dc:creator><![CDATA[pindragon]]></dc:creator>
		<pubDate>Mon, 06 May 2013 14:25:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9860</guid>
					<description><![CDATA[Just an on-the-spot non-pro opinion:

1. 

* a,b,c --- no real difference;
* d, e --- no real difference, but:
  * if widget is a struct (or a class with public fields), e can initialize its fields directly whilst d needs a constructor;
  * implicit-casting of x will not work in d;
  * if widget has an initializer-list-based constructor, it can be called with a one-element list in e, but not in d;
* f, g --- the same differences between &#039;em as for d and e, but they first create an object as in d and e, and after that move-construct it into a new object of class widget, the other difference is that f can result in an operator-based implicit cast rather than calling the single-arg constructor;
* h --- same as f (?), but cannot call operator-based cast as there is no cast happening anyhow, i --- same as g (?);

2. a creates a vector of type int, size 10, filled with 10 twenties; b creates a vector of type int, size 2, with elements 10 and 20.
3. The main benefit is a uniform initialization manner for sequences, pairs, tuples and structures (it has its flaws, but still). This can help template programming a lot as it makes types more interchangeable. You can replace a tuple-based proof-of-concept code with a struct-based (giving it names) or class-constructor-based (giving it everything else) in no time if every piece of your initialization is using curly braces only.
4. As far as I understand it, it is better to initialize objects with {} if you really mean &quot;take this pile&#039;o&#039;data and put it there&quot; and use () when you create more complex objects whose initialization is not about data, but about more complex things (like vector&#039;s size-based constructor above). To put it simple, you should use {} to create std::pairs, but it&#039;s not a good thing to use when initializing your SettingsManagerFactoryVisitor object with it&#039;s 12 runtime polymorphic Strategy classes.]]></description>
		<content:encoded><![CDATA[<p>Just an on-the-spot non-pro opinion:</p>
<p>1. </p>
<p>* a,b,c &#8212; no real difference;<br />
* d, e &#8212; no real difference, but:<br />
  * if widget is a struct (or a class with public fields), e can initialize its fields directly whilst d needs a constructor;<br />
  * implicit-casting of x will not work in d;<br />
  * if widget has an initializer-list-based constructor, it can be called with a one-element list in e, but not in d;<br />
* f, g &#8212; the same differences between &#8217;em as for d and e, but they first create an object as in d and e, and after that move-construct it into a new object of class widget, the other difference is that f can result in an operator-based implicit cast rather than calling the single-arg constructor;<br />
* h &#8212; same as f (?), but cannot call operator-based cast as there is no cast happening anyhow, i &#8212; same as g (?);</p>
<p>2. a creates a vector of type int, size 10, filled with 10 twenties; b creates a vector of type int, size 2, with elements 10 and 20.<br />
3. The main benefit is a uniform initialization manner for sequences, pairs, tuples and structures (it has its flaws, but still). This can help template programming a lot as it makes types more interchangeable. You can replace a tuple-based proof-of-concept code with a struct-based (giving it names) or class-constructor-based (giving it everything else) in no time if every piece of your initialization is using curly braces only.<br />
4. As far as I understand it, it is better to initialize objects with {} if you really mean &#8220;take this pile&#8217;o&#8217;data and put it there&#8221; and use () when you create more complex objects whose initialization is not about data, but about more complex things (like vector&#8217;s size-based constructor above). To put it simple, you should use {} to create std::pairs, but it&#8217;s not a good thing to use when initializing your SettingsManagerFactoryVisitor object with it&#8217;s 12 runtime polymorphic Strategy classes.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: alexmatto				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9858</link>
		<dc:creator><![CDATA[alexmatto]]></dc:creator>
		<pubDate>Mon, 06 May 2013 14:08:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9858</guid>
					<description><![CDATA[1.a) Creates a widget calling the default constructor
1.b) A function receiving void and returning a Widget
1.c) Creates a widget calling the default constructor
1.d) Creates a widget calling a constructor receiving X
1.e) Creates a widget calling a constructor with an initializer list parameter
1.f) Creates a widget calling the copy-assignement constructor
1.g) Creates a widget calling a constructor with an initializer list parameter
1.h) Creates a variable of the same type of X, and copy X to it
1.i) Creates a variable of type Widget and calls the move-assignment constructor with an initializer list parameter

2.a) Creates a vector with 10 elements, all of value 20
2.b) Creates a vector with 2 elements, 10 and 20

3. It&#039;s uniform, and avoid ambiguities.

4. When you do not want to use an initializer list constructor. (Like the question 2.a, if you really want to create 10 elements of value 20 then it&#039;s best to use &quot;()&quot; instead of writing ten &quot;20&quot; inside bracers)]]></description>
		<content:encoded><![CDATA[<p>1.a) Creates a widget calling the default constructor<br />
1.b) A function receiving void and returning a Widget<br />
1.c) Creates a widget calling the default constructor<br />
1.d) Creates a widget calling a constructor receiving X<br />
1.e) Creates a widget calling a constructor with an initializer list parameter<br />
1.f) Creates a widget calling the copy-assignement constructor<br />
1.g) Creates a widget calling a constructor with an initializer list parameter<br />
1.h) Creates a variable of the same type of X, and copy X to it<br />
1.i) Creates a variable of type Widget and calls the move-assignment constructor with an initializer list parameter</p>
<p>2.a) Creates a vector with 10 elements, all of value 20<br />
2.b) Creates a vector with 2 elements, 10 and 20</p>
<p>3. It&#8217;s uniform, and avoid ambiguities.</p>
<p>4. When you do not want to use an initializer list constructor. (Like the question 2.a, if you really want to create 10 elements of value 20 then it&#8217;s best to use &#8220;()&#8221; instead of writing ten &#8220;20&#8221; inside bracers)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Klaim - Joel Lamotte (@MJKlaim)				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9857</link>
		<dc:creator><![CDATA[Klaim - Joel Lamotte (@MJKlaim)]]></dc:creator>
		<pubDate>Mon, 06 May 2013 14:04:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9857</guid>
					<description><![CDATA[I&#039;m not an expert but let&#039;s see if my current knowledge match the standard:

1)
a) w is a default-initialized widget;
b) w is a free function returning a widget;
c) w is a default-initialized widget;
d) w is a widget constructed using x, which have to be a compatible type with the constructor argument, with implicit cast allowed;
e) w is a widget constructed using x, which have to be exactly the type with the constructor argument, with no implicit cast allowed OR if widget have an initializer-list constructor, it will be constructed using it.
f) w is a widget constructed using x exactly like in d)
g) this one I&#039;m not sure, I guess it depends on the available widget constructors. It might be either
 1. w is a widget contructed using a constructor taking an initializer list as argument
 2. w is a widget contructed using a copy constructor using a temporary widget constructed using x as non-implicitely-cast constructor argument;
 3. same as 2. but the compiler is allowed to not construct the temporary, which would make it the same as d)
h) w is of the same type as x and is constructed by copying x value;
g) w is a widget constructed by constructor with argument taking exactly the type of x (with no implicit cast allowed);

Damn I&#039;m not totally confident in the g) case even if I use it sometime in my current projects.

2) 
a) v1 is a vector of 10 int all initalized with the value 20;
b) v2 is a vector of  2 elements: v2[0] == 10 &#038;&#038; v2[0] == 20;

This is because vector have an initializer-list constructor;

3) Mainly to force type checking on constructor arguments as no implicit cast is allowed (between float and int for example) using this syntaxe.

4) If the type don&#039;t have an initializer-list constructor, then just use {}; otherwise, use {} until you want to call a specific constructor in which case use ();


I can&#039;t wait for the answers because the more I think about some cases, the more doubts I&#039;m getting....]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not an expert but let&#8217;s see if my current knowledge match the standard:</p>
<p>1)<br />
a) w is a default-initialized widget;<br />
b) w is a free function returning a widget;<br />
c) w is a default-initialized widget;<br />
d) w is a widget constructed using x, which have to be a compatible type with the constructor argument, with implicit cast allowed;<br />
e) w is a widget constructed using x, which have to be exactly the type with the constructor argument, with no implicit cast allowed OR if widget have an initializer-list constructor, it will be constructed using it.<br />
f) w is a widget constructed using x exactly like in d)<br />
g) this one I&#8217;m not sure, I guess it depends on the available widget constructors. It might be either<br />
 1. w is a widget contructed using a constructor taking an initializer list as argument<br />
 2. w is a widget contructed using a copy constructor using a temporary widget constructed using x as non-implicitely-cast constructor argument;<br />
 3. same as 2. but the compiler is allowed to not construct the temporary, which would make it the same as d)<br />
h) w is of the same type as x and is constructed by copying x value;<br />
g) w is a widget constructed by constructor with argument taking exactly the type of x (with no implicit cast allowed);</p>
<p>Damn I&#8217;m not totally confident in the g) case even if I use it sometime in my current projects.</p>
<p>2)<br />
a) v1 is a vector of 10 int all initalized with the value 20;<br />
b) v2 is a vector of  2 elements: v2[0] == 10 &amp;&amp; v2[0] == 20;</p>
<p>This is because vector have an initializer-list constructor;</p>
<p>3) Mainly to force type checking on constructor arguments as no implicit cast is allowed (between float and int for example) using this syntaxe.</p>
<p>4) If the type don&#8217;t have an initializer-list constructor, then just use {}; otherwise, use {} until you want to call a specific constructor in which case use ();</p>
<p>I can&#8217;t wait for the answers because the more I think about some cases, the more doubts I&#8217;m getting&#8230;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9856</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Mon, 06 May 2013 14:03:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9856</guid>
					<description><![CDATA[Junior Guru
1.
a) initializes widget with the default widget ctor.  If widget is a typedef to something like an int, then widget is unintialized.
b) This is a function prototype, and is a closs relative of the &quot;most vexing parse&quot;.
c) I think this is the same as a), except if widget is a primitive type.  In that case, widget will be zero initialized.
d) initializes widget with a one arg constructor taking x.
e) this could be two different things, depending on widget&#039;s definition.  It could either be the same as d, or it could use widget&#039;s initializer list constructor, if it has one.  Even for the &quot;same as d&quot; case, you get slightly better behavior in the face of float -&#062; int conversions.
f) This is copy initialization.  Widget(x) is invoked, and the temporary is moved or copied to the target ( w ).  In release mode, this move / copy is likely elided.
g) same as e
h) copy initializes a w, with the same type as x
i) copy initialization, and w is going to be of type x

Guru
2.
a) Creates a vector of size 10, with each element set to 20
b) Creates a vector of size 2, with element 0 set to 10 and element 1 set to 20
3. {} helps in generic code.  {} makes it easier to initialize containers. {} avoids narrowing conversions.  {} ensures that everything gets initialized, even primitives.
4. Use {} when you can, use () when you must?]]></description>
		<content:encoded><![CDATA[<p>Junior Guru<br />
1.<br />
a) initializes widget with the default widget ctor.  If widget is a typedef to something like an int, then widget is unintialized.<br />
b) This is a function prototype, and is a closs relative of the &#8220;most vexing parse&#8221;.<br />
c) I think this is the same as a), except if widget is a primitive type.  In that case, widget will be zero initialized.<br />
d) initializes widget with a one arg constructor taking x.<br />
e) this could be two different things, depending on widget&#8217;s definition.  It could either be the same as d, or it could use widget&#8217;s initializer list constructor, if it has one.  Even for the &#8220;same as d&#8221; case, you get slightly better behavior in the face of float -&gt; int conversions.<br />
f) This is copy initialization.  Widget(x) is invoked, and the temporary is moved or copied to the target ( w ).  In release mode, this move / copy is likely elided.<br />
g) same as e<br />
h) copy initializes a w, with the same type as x<br />
i) copy initialization, and w is going to be of type x</p>
<p>Guru<br />
2.<br />
a) Creates a vector of size 10, with each element set to 20<br />
b) Creates a vector of size 2, with element 0 set to 10 and element 1 set to 20<br />
3. {} helps in generic code.  {} makes it easier to initialize containers. {} avoids narrowing conversions.  {} ensures that everything gets initialized, even primitives.<br />
4. Use {} when you can, use () when you must?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Loghorn				</title>
				<link>https://herbsutter.com/2013/05/06/gotw-1-variable-initialization-or-is-it-310/#comment-9855</link>
		<dc:creator><![CDATA[Loghorn]]></dc:creator>
		<pubDate>Mon, 06 May 2013 13:54:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1828#comment-9855</guid>
					<description><![CDATA[The main difference between (a, b, d, f, h) and (c, e, g, i) is that the former group is supported by Visual Studio and the latter is not.
I know I&#039;m trolling a little here, but there is no news since November about a more conforming Visual C++ and it&#039;s been said to keep knocking until the door opens... :-)]]></description>
		<content:encoded><![CDATA[<p>The main difference between (a, b, d, f, h) and (c, e, g, i) is that the former group is supported by Visual Studio and the latter is not.<br />
I know I&#8217;m trolling a little here, but there is no news since November about a more conforming Visual C++ and it&#8217;s been said to keep knocking until the door opens&#8230; :-)</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
