<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #3 Solution: Using the Standard Library (or, Temporaries Revisited)	</title>
	<atom:link href="https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Tim				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-18219</link>
		<dc:creator><![CDATA[Tim]]></dc:creator>
		<pubDate>Sun, 06 Apr 2014 15:13:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-18219</guid>
					<description><![CDATA[Hello.
&#062;If you mean auto as a lambda parameter type

yes exactly! Thanks for the answer, I have to refresh my knowledge of auto now :)]]></description>
		<content:encoded><![CDATA[<p>Hello.<br />
&gt;If you mean auto as a lambda parameter type</p>
<p>yes exactly! Thanks for the answer, I have to refresh my knowledge of auto now :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-18066</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 03 Apr 2014 15:39:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-18066</guid>
					<description><![CDATA[@Tim: If you mean auto as a lambda parameter type, such as [](auto&#038; s){ use(s); }, good question! That&#039;s a new feature in C++14. I&#039;ve written a longer answer here as a new post so everyone will see the question and the answer: https://herbsutter.com/2014/04/03/reader-qa-generic-lambdas/ .]]></description>
		<content:encoded><![CDATA[<p>@Tim: If you mean auto as a lambda parameter type, such as [](auto&amp; s){ use(s); }, good question! That&#8217;s a new feature in C++14. I&#8217;ve written a longer answer here as a new post so everyone will see the question and the answer: <a href="https://herbsutter.com/2014/04/03/reader-qa-generic-lambdas/" rel="nofollow">https://herbsutter.com/2014/04/03/reader-qa-generic-lambdas/</a> .</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Reader Q&#38;A: Generic lambdas &#124; Sutter’s Mill				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-18065</link>
		<dc:creator><![CDATA[Reader Q&#38;A: Generic lambdas &#124; Sutter’s Mill]]></dc:creator>
		<pubDate>Thu, 03 Apr 2014 15:36:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-18065</guid>
					<description><![CDATA[[&#8230;] Tim just added this comment on the GotW #3 Solution blog post from last year: [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Tim just added this comment on the GotW #3 Solution blog post from last year: [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tim				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-18063</link>
		<dc:creator><![CDATA[Tim]]></dc:creator>
		<pubDate>Thu, 03 Apr 2014 14:19:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-18063</guid>
					<description><![CDATA[Are you sure you can use auto in lambda like this?
I can not compile the code and I&#039;m pretty sure auto does not work here.]]></description>
		<content:encoded><![CDATA[<p>Are you sure you can use auto in lambda like this?<br />
I can not compile the code and I&#8217;m pretty sure auto does not work here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sorting Localized Strings &#124; Khuram Ali				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10351</link>
		<dc:creator><![CDATA[Sorting Localized Strings &#124; Khuram Ali]]></dc:creator>
		<pubDate>Thu, 23 May 2013 10:33:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10351</guid>
					<description><![CDATA[[&#8230;] GotW #3 Solution: Using the Standard Library (or, Temporaries Revisited) (herbsutter.com) [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] GotW #3 Solution: Using the Standard Library (or, Temporaries Revisited) (herbsutter.com) [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Collier				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10305</link>
		<dc:creator><![CDATA[David Collier]]></dc:creator>
		<pubDate>Wed, 22 May 2013 08:44:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10305</guid>
					<description><![CDATA[Sorry for the digression, but from that concepts@isocpp thread it seems a big part of the objections is the ambiguity whereby [](e) { ... } could mean a function taking an unnamed parameter of type e. Which looks like a fair point.

I was wondering whether it had been considered to have a specific exception for ref and const-ref parameters, so that you could write

[](&#038;e) { use(e) }

but if you wanted pass-by-value, or if you wanted something more complicated like a parameter of type function-taking-auto-returning-bool, you&#039;d have to use the auto placeholder.

I&#039;d have thought that reference parameters are more useful than by-value parameters in a generic context, so this doesn&#039;t seem to lose much.]]></description>
		<content:encoded><![CDATA[<p>Sorry for the digression, but from that concepts@isocpp thread it seems a big part of the objections is the ambiguity whereby [](e) { &#8230; } could mean a function taking an unnamed parameter of type e. Which looks like a fair point.</p>
<p>I was wondering whether it had been considered to have a specific exception for ref and const-ref parameters, so that you could write</p>
<p>[](&amp;e) { use(e) }</p>
<p>but if you wanted pass-by-value, or if you wanted something more complicated like a parameter of type function-taking-auto-returning-bool, you&#8217;d have to use the auto placeholder.</p>
<p>I&#8217;d have thought that reference parameters are more useful than by-value parameters in a generic context, so this doesn&#8217;t seem to lose much.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10250</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 20 May 2013 18:18:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10250</guid>
					<description><![CDATA[@Leo: This is an interesting observation, especially if instead of deducing const auto&#038; we deduce the constraint more generally. I&#039;ve started a thread based on your example at concepts@isocpp.org here: https://groups.google.com/a/isocpp.org/d/msg/concepts/mUlJ3D1VGVE/41JYIKu_004J . I don&#039;t know if it&#039;ll go anywhere, but it could address the concerns about the nice &quot;[](e){ use(e); }&quot; syntax too...]]></description>
		<content:encoded><![CDATA[<p>@Leo: This is an interesting observation, especially if instead of deducing const auto&amp; we deduce the constraint more generally. I&#8217;ve started a thread based on your example at <a href="mailto:concepts@isocpp.org">concepts@isocpp.org</a> here: <a href="https://groups.google.com/a/isocpp.org/d/msg/concepts/mUlJ3D1VGVE/41JYIKu_004J" rel="nofollow">https://groups.google.com/a/isocpp.org/d/msg/concepts/mUlJ3D1VGVE/41JYIKu_004J</a> . I don&#8217;t know if it&#8217;ll go anywhere, but it could address the concerns about the nice &#8220;[](e){ use(e); }&#8221; syntax too&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Leo				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10241</link>
		<dc:creator><![CDATA[Leo]]></dc:creator>
		<pubDate>Sun, 19 May 2013 20:22:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10241</guid>
					<description><![CDATA[Herb, if Bjarne&#039;s expectations for C++14 (https://www.informit.com/articles/article.aspx?p=2080042) are fulfilled wouldn&#039;t the STL provide an overload like the following (if it would work):
[code]
template&#060;Container Cont, Predicate Pred&#062;
requires Input_iterator&#060;Iterator&#060;Cont&#062;&#062;()
Iterator&#060;Cont&#062; find_if(Cont&#038; c, Pred p);
[/code]
If then the fact could be taken into account that a Predicate is not supposed to change its argument, the type of e could default to const auto&#038;. Then one could write:
[code]
const auto i = find_if(emps, [&#038;](e) { return e.name() == name; });
[/code]]]></description>
		<content:encoded><![CDATA[<p>Herb, if Bjarne&#8217;s expectations for C++14 (<a href="https://www.informit.com/articles/article.aspx?p=2080042" rel="nofollow">https://www.informit.com/articles/article.aspx?p=2080042</a>) are fulfilled wouldn&#8217;t the STL provide an overload like the following (if it would work):</p>
<pre class="brush: plain; title: ; notranslate">
template&lt;Container Cont, Predicate Pred&gt;
requires Input_iterator&lt;Iterator&lt;Cont&gt;&gt;()
Iterator&lt;Cont&gt; find_if(Cont&amp; c, Pred p);
</pre>
<p>If then the fact could be taken into account that a Predicate is not supposed to change its argument, the type of e could default to const auto&amp;. Then one could write:</p>
<pre class="brush: plain; title: ; notranslate">
const auto i = find_if(emps, [&amp;](e) { return e.name() == name; });
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roger				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10238</link>
		<dc:creator><![CDATA[Roger]]></dc:creator>
		<pubDate>Sun, 19 May 2013 17:05:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10238</guid>
					<description><![CDATA[With lambdas now available, I use the built in functions as much as I can. I often find I cannot because relationships between elements in a list are often important (remember the index to something, or whatever). 

But the code is still so frustrating to type, and ugly. We have ranges now, wouldn&#039;t it be nice to add it into the standard library for all things that take ranges? We also have auto, it would be nice if we didn&#039;t have to keep typing the names of types that we already know. Consider:
[code]const auto i = find_if (e:emps, [&#038;](auto) {return e.name() == name});[/code]

I&#039;m sure that syntax would break something in C++, but this is along the lines of what I want in a modern language. Herb said something in a talk about C++11 not being your dad&#039;s C++ (or a metaphor to that effect). Well, it still is, albeit  better. I don&#039;t want to type begin(x), end(x) anymore. I don&#039;t want to type types for a lambda when they can be figured out. More importantly, I don&#039;t want to parse through tons of boilerplate code that somebody else typed (or that I typed 6 months ago) to try to figure out what is being done.I find myself moving back to using simple for loops, I find them clearer to read and a heck of a lot easier to type. I don&#039;t want to have to keep in my mental stack the iterator that the find_if introduces. I don&#039;t want to have to parse the ? operator code to see which value is returned in each case. Range based for is readable, the last solution is just a mess.

Actually, i would love to write something like:
[code]
string find_addr (emps,name) {
   return e.addr if e.name == name in e:emps;
   return &#034;&#034;;
}
[/code]


and just have the compiler figure out things like name can be passed by const reference, that emps needs to be something that supports ranges and has addr and name fields, and that the auto is implied. That&#039;s true information density. 

C++ has become so unreadable. &#039;const std::shared_ptr&#060;std::vector&#062;&#038;&#039; is a typical signature for a single parameter in my code. (I would love a GotW that focused on using managed pointers in a readable way, btw). 

Sorry if this comes off as a rant, but I think conciseness and readability is far more important than removing any possible creation of a temporary variable, and more important than following a (generally good) rule like use the standard library. Try reading code where a default parameter like less is used, and search through all the headers, and headers included by headers, to figure out what version of less is being used by the standard library call for a user defined struct. A for loop makes it all explicit, often with far fewer characters. Explicit is good. Readability is good. I would not want my engineers writing code like Herb&#039;s last example unless this function was so critical that efficiency came before anything else. It&#039;s horrible, ugly code IMO.]]></description>
		<content:encoded><![CDATA[<p>With lambdas now available, I use the built in functions as much as I can. I often find I cannot because relationships between elements in a list are often important (remember the index to something, or whatever). </p>
<p>But the code is still so frustrating to type, and ugly. We have ranges now, wouldn&#8217;t it be nice to add it into the standard library for all things that take ranges? We also have auto, it would be nice if we didn&#8217;t have to keep typing the names of types that we already know. Consider:</p>
<pre class="brush: plain; title: ; notranslate">const auto i = find_if (e:emps, [&amp;](auto) {return e.name() == name});</pre>
<p>I&#8217;m sure that syntax would break something in C++, but this is along the lines of what I want in a modern language. Herb said something in a talk about C++11 not being your dad&#8217;s C++ (or a metaphor to that effect). Well, it still is, albeit  better. I don&#8217;t want to type begin(x), end(x) anymore. I don&#8217;t want to type types for a lambda when they can be figured out. More importantly, I don&#8217;t want to parse through tons of boilerplate code that somebody else typed (or that I typed 6 months ago) to try to figure out what is being done.I find myself moving back to using simple for loops, I find them clearer to read and a heck of a lot easier to type. I don&#8217;t want to have to keep in my mental stack the iterator that the find_if introduces. I don&#8217;t want to have to parse the ? operator code to see which value is returned in each case. Range based for is readable, the last solution is just a mess.</p>
<p>Actually, i would love to write something like:</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr (emps,name) {
   return e.addr if e.name == name in e:emps;
   return &quot;&quot;;
}
</pre>
<p>and just have the compiler figure out things like name can be passed by const reference, that emps needs to be something that supports ranges and has addr and name fields, and that the auto is implied. That&#8217;s true information density. </p>
<p>C++ has become so unreadable. &#8216;const std::shared_ptr&lt;std::vector&gt;&amp;&#8217; is a typical signature for a single parameter in my code. (I would love a GotW that focused on using managed pointers in a readable way, btw). </p>
<p>Sorry if this comes off as a rant, but I think conciseness and readability is far more important than removing any possible creation of a temporary variable, and more important than following a (generally good) rule like use the standard library. Try reading code where a default parameter like less is used, and search through all the headers, and headers included by headers, to figure out what version of less is being used by the standard library call for a user defined struct. A for loop makes it all explicit, often with far fewer characters. Explicit is good. Readability is good. I would not want my engineers writing code like Herb&#8217;s last example unless this function was so critical that efficiency came before anything else. It&#8217;s horrible, ugly code IMO.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10226</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 19 May 2013 16:22:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10226</guid>
					<description><![CDATA[@Ran: cppreference.com seems to have it correct: http://en.cppreference.com/w/cpp/language/range-for]]></description>
		<content:encoded><![CDATA[<p>@Ran: cppreference.com seems to have it correct: <a href="http://en.cppreference.com/w/cpp/language/range-for" rel="nofollow">http://en.cppreference.com/w/cpp/language/range-for</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ran				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10220</link>
		<dc:creator><![CDATA[Ran]]></dc:creator>
		<pubDate>Sun, 19 May 2013 06:48:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10220</guid>
					<description><![CDATA[Herb, can you please elaborate on the underneath work that is done in ranged-based loops? As getting higher in the abstraction we also loose contact with the ground. And though we KNOW we are on the safe side and performance is taken into consideration, still, can you please explain more on what the standard says to implementers of range based loops?]]></description>
		<content:encoded><![CDATA[<p>Herb, can you please elaborate on the underneath work that is done in ranged-based loops? As getting higher in the abstraction we also loose contact with the ground. And though we KNOW we are on the safe side and performance is taken into consideration, still, can you please explain more on what the standard says to implementers of range based loops?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Thomas				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10206</link>
		<dc:creator><![CDATA[David Thomas]]></dc:creator>
		<pubDate>Sat, 18 May 2013 00:29:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10206</guid>
					<description><![CDATA[Since employee supports find(..., name), instead of e.name() == name the lambda could contain e == name.  If name() returns a reference to const string, then I suspect it won&#039;t matter.  If name() returns a string, then I suspect we are paying price greater than e == name (on each iteration).  Writing the lambda to avoid the potential temporaries yeidlds:

[code]
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    const auto i = find_if( begin(emps), end(emps),
                      [&#038;](const auto&#038; e) { return e == name; } );
    return i != end(emps) ? i-&#062;addr : &#034;&#034;;
}
[/code]

On the compiler that I checked, if name() returns a const string&#038;, then e == name optimizes to the same code as e.name() == name. No penalty here.  However, if name() returns a string, then the impact is significant (the complexity prevented inlining and temporaries were created).]]></description>
		<content:encoded><![CDATA[<p>Since employee supports find(&#8230;, name), instead of e.name() == name the lambda could contain e == name.  If name() returns a reference to const string, then I suspect it won&#8217;t matter.  If name() returns a string, then I suspect we are paying price greater than e == name (on each iteration).  Writing the lambda to avoid the potential temporaries yeidlds:</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    const auto i = find_if( begin(emps), end(emps),
                      [&amp;](const auto&amp; e) { return e == name; } );
    return i != end(emps) ? i-&gt;addr : &quot;&quot;;
}
</pre>
<p>On the compiler that I checked, if name() returns a const string&amp;, then e == name optimizes to the same code as e.name() == name. No penalty here.  However, if name() returns a string, then the impact is significant (the complexity prevented inlining and temporaries were created).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10200</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Fri, 17 May 2013 21:42:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10200</guid>
					<description><![CDATA[Dave, I asked the strlen question in GoTW #1, and Herb assures me that it&#039;s not there is a &quot;good&quot; string library.  It checks for the first character being 0 before it calls strlen.

While equality may feel simpler than inequality, I generally prefer to check for success rather than failure when the two options are basically equivalent.]]></description>
		<content:encoded><![CDATA[<p>Dave, I asked the strlen question in GoTW #1, and Herb assures me that it&#8217;s not there is a &#8220;good&#8221; string library.  It checks for the first character being 0 before it calls strlen.</p>
<p>While equality may feel simpler than inequality, I generally prefer to check for success rather than failure when the two options are basically equivalent.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Dave Harris				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10195</link>
		<dc:creator><![CDATA[Dave Harris]]></dc:creator>
		<pubDate>Fri, 17 May 2013 20:19:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10195</guid>
					<description><![CDATA[Am I the only person who would prefer:[code]
return i == end(emps) ? &#034;&#034; : i-&#062;addr;
[/code]
Equality feels slightly simpler than inequality. I&#039;d also prefer to avoid converting the c-string to a std::string:[code]
return i == end(emps) ? string() : i-&#062;addr;
[/code]
The conversion probably won&#039;t allocate memory, but it&#039;s still doing unnecessary work - possibly including a call to strlen(), for example.]]></description>
		<content:encoded><![CDATA[<p>Am I the only person who would prefer:</p>
<pre class="brush: plain; title: ; notranslate">
return i == end(emps) ? &quot;&quot; : i-&gt;addr;
</pre>
<p>Equality feels slightly simpler than inequality. I&#8217;d also prefer to avoid converting the c-string to a std::string:</p>
<pre class="brush: plain; title: ; notranslate">
return i == end(emps) ? string() : i-&gt;addr;
</pre>
<p>The conversion probably won&#8217;t allocate memory, but it&#8217;s still doing unnecessary work &#8211; possibly including a call to strlen(), for example.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10194</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 17 May 2013 20:02:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10194</guid>
					<description><![CDATA[@Olaf: OK, clarified (in GotW #2) along the lines that “I’m assuming something like .name() is available and .name() == name has the same semantics.”

@Sam: Good point, noted.

@Adrian: A program that does that has undefined behavior and could achieve the same effect by dereferencing a random int cast to a pointer. Within defined behavior, the range-for can iterate only one way, from the front in order visiting every element exactly once, and the only possibly variation in behavior is that it could stop early if there&#039;s a break or return inside vs. visiting all elements.]]></description>
		<content:encoded><![CDATA[<p>@Olaf: OK, clarified (in GotW #2) along the lines that “I’m assuming something like .name() is available and .name() == name has the same semantics.”</p>
<p>@Sam: Good point, noted.</p>
<p>@Adrian: A program that does that has undefined behavior and could achieve the same effect by dereferencing a random int cast to a pointer. Within defined behavior, the range-for can iterate only one way, from the front in order visiting every element exactly once, and the only possibly variation in behavior is that it could stop early if there&#8217;s a break or return inside vs. visiting all elements.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10189</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Fri, 17 May 2013 16:34:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10189</guid>
					<description><![CDATA[&quot;When you see B [the range-based for loop], you know for certain without inspecting the body of the loop that it is a loop that visits the element of emps in order.&quot;  Certainly there are some things the body _might_ do that would contradict that.  For example, if the body modifies the container in a way that would invalidate outstanding iterators, you no longer can be sure that the loop will proceed normally. Consider:

[code]
for (const auto &#038; e : emps) {
  if (e.name == &#034;Herb&#034;) {
    emps.push_front(employee(&#034;Bjarne&#034;));
  }
}
[/code]

Obviously, this isn&#039;t an advisable thing to do in the loop, but the compiler isn&#039;t likely to notice.  Thus a range-based for loop might give you more confidence that it visits each element in order, but, unless emps is const, you cannot be absolutely certain without looking inside the body and without knowing the type of container and that container type&#039;s iterator invalidation rules.  Right?]]></description>
		<content:encoded><![CDATA[<p>&#8220;When you see B [the range-based for loop], you know for certain without inspecting the body of the loop that it is a loop that visits the element of emps in order.&#8221;  Certainly there are some things the body _might_ do that would contradict that.  For example, if the body modifies the container in a way that would invalidate outstanding iterators, you no longer can be sure that the loop will proceed normally. Consider:</p>
<pre class="brush: plain; title: ; notranslate">
for (const auto &amp; e : emps) {
  if (e.name == &quot;Herb&quot;) {
    emps.push_front(employee(&quot;Bjarne&quot;));
  }
}
</pre>
<p>Obviously, this isn&#8217;t an advisable thing to do in the loop, but the compiler isn&#8217;t likely to notice.  Thus a range-based for loop might give you more confidence that it visits each element in order, but, unless emps is const, you cannot be absolutely certain without looking inside the body and without knowing the type of container and that container type&#8217;s iterator invalidation rules.  Right?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sam Kramer				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10185</link>
		<dc:creator><![CDATA[Sam Kramer]]></dc:creator>
		<pubDate>Fri, 17 May 2013 15:32:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10185</guid>
					<description><![CDATA[The astute reader will have noticed that the guidance from this tip is derived directly from the book Effective STL, Item 43: Prefer algorithm calls to hand-written loops. It&#039;s good to know that best practices from C++98 are still largely relevant in C++11.]]></description>
		<content:encoded><![CDATA[<p>The astute reader will have noticed that the guidance from this tip is derived directly from the book Effective STL, Item 43: Prefer algorithm calls to hand-written loops. It&#8217;s good to know that best practices from C++98 are still largely relevant in C++11.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Barry				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10176</link>
		<dc:creator><![CDATA[Barry]]></dc:creator>
		<pubDate>Fri, 17 May 2013 11:46:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10176</guid>
					<description><![CDATA[This extra branch;
[code]return i != end(emps) ? i-&#062;addr : &#034;&#034;;[/code]

Find just returns an iterator that you still have to check. The range-for version just returns.]]></description>
		<content:encoded><![CDATA[<p>This extra branch;</p>
<pre class="brush: plain; title: ; notranslate">return i != end(emps) ? i-&gt;addr : &quot;&quot;;</pre>
<p>Find just returns an iterator that you still have to check. The range-for version just returns.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10173</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Fri, 17 May 2013 08:56:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10173</guid>
					<description><![CDATA[One important thing is that abstraction does not always equate to better or more readable code.  The use of more familiar constructs is often a better overall solution, errors are more likely to be seen by the casual reader etc. Although the examples are fairly trivial some are certainly more comfortable and easier to read  and Jay gets it about right with his comment. The important thing to remember is that code is just a means to an end! If we are thinking at this level of trivia is there something else wrong?]]></description>
		<content:encoded><![CDATA[<p>One important thing is that abstraction does not always equate to better or more readable code.  The use of more familiar constructs is often a better overall solution, errors are more likely to be seen by the casual reader etc. Although the examples are fairly trivial some are certainly more comfortable and easier to read  and Jay gets it about right with his comment. The important thing to remember is that code is just a means to an end! If we are thinking at this level of trivia is there something else wrong?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10172</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Fri, 17 May 2013 08:04:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10172</guid>
					<description><![CDATA[@Herb Sure. IMO you disregarded this note: &quot;Note: As with GotW #2, don’t change the semantics of the function, even though they could be improved.&quot;
Whether employee == string is valid and has the same semantics as employee::name() == string isn&#039;t given, so you shouldn&#039;t assume it is.]]></description>
		<content:encoded><![CDATA[<p>@Herb Sure. IMO you disregarded this note: &#8220;Note: As with GotW #2, don’t change the semantics of the function, even though they could be improved.&#8221;<br />
Whether employee == string is valid and has the same semantics as employee::name() == string isn&#8217;t given, so you shouldn&#8217;t assume it is.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lars Viklund				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10166</link>
		<dc:creator><![CDATA[Lars Viklund]]></dc:creator>
		<pubDate>Fri, 17 May 2013 06:57:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10166</guid>
					<description><![CDATA[Aren&#039;t generic lambdas C++1y?]]></description>
		<content:encoded><![CDATA[<p>Aren&#8217;t generic lambdas C++1y?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Balakrishnan B				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10164</link>
		<dc:creator><![CDATA[Balakrishnan B]]></dc:creator>
		<pubDate>Fri, 17 May 2013 04:57:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10164</guid>
					<description><![CDATA[I dont understand what does an extra branch mean in the find_if version. Does everyone refer to a function call? I guess algorithms like find_if would be most likely be inlined as it takes template arguments.]]></description>
		<content:encoded><![CDATA[<p>I dont understand what does an extra branch mean in the find_if version. Does everyone refer to a function call? I guess algorithms like find_if would be most likely be inlined as it takes template arguments.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Barry				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10155</link>
		<dc:creator><![CDATA[Barry]]></dc:creator>
		<pubDate>Thu, 16 May 2013 22:51:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10155</guid>
					<description><![CDATA[Yes, in this specific example the fact that we&#039;re returning a string by-value dwarfs the extra branch after the find(), but I am more interested in the general case, where we do call some function lots of times, and its return is very light (say it returns a pointer to the found element or 0).]]></description>
		<content:encoded><![CDATA[<p>Yes, in this specific example the fact that we&#8217;re returning a string by-value dwarfs the extra branch after the find(), but I am more interested in the general case, where we do call some function lots of times, and its return is very light (say it returns a pointer to the found element or 0).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: TheMatto				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10154</link>
		<dc:creator><![CDATA[TheMatto]]></dc:creator>
		<pubDate>Thu, 16 May 2013 22:35:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10154</guid>
					<description><![CDATA[Minor point. The range-for loop can be written [code]for ( auto &#038; e : emps ) {...}[/code] given that emps is const.]]></description>
		<content:encoded><![CDATA[<p>Minor point. The range-for loop can be written </p>
<pre class="brush: plain; title: ; notranslate">for ( auto &amp; e : emps ) {...}</pre>
<p> given that emps is const.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10152</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Thu, 16 May 2013 22:27:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10152</guid>
					<description><![CDATA[@Jay imao both of your code blocks are uglier than Herbs find version because you have std function that is designed to (tadaaaam) find element in a range. Period. :)
Beside I would guesstimate all this talk about perf is unrealistic... I mean if you really call this method like a mad man you probably want to go to the dark side and return a reference, also kill std::list with fire . :)]]></description>
		<content:encoded><![CDATA[<p>@Jay imao both of your code blocks are uglier than Herbs find version because you have std function that is designed to (tadaaaam) find element in a range. Period. :)<br />
Beside I would guesstimate all this talk about perf is unrealistic&#8230; I mean if you really call this method like a mad man you probably want to go to the dark side and return a reference, also kill std::list with fire . :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: austinwiltshire				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10151</link>
		<dc:creator><![CDATA[austinwiltshire]]></dc:creator>
		<pubDate>Thu, 16 May 2013 22:14:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10151</guid>
					<description><![CDATA[@Jay
Are you confusing readability for familiarity? :)]]></description>
		<content:encoded><![CDATA[<p>@Jay<br />
Are you confusing readability for familiarity? :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jay Miller				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10149</link>
		<dc:creator><![CDATA[Jay Miller]]></dc:creator>
		<pubDate>Thu, 16 May 2013 21:42:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10149</guid>
					<description><![CDATA[Two issues.  One is that I think Barry&#039;s point is relevant even though, in this case, an extra branch is swamped out by dynamic memory allocation.  Similarly to using prefix increment, doing things in a consistent manner every time that yields better performance in a subset of cases is a Good Thing if it doesn&#039;t make readability worse (though sometimes being consistent makes for better readability even if it&#039;s slightly more complex).

That brings us to the second issue, which is that I can&#039;t in good conscience say that

[code]
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    const auto i = find_if( begin(emps), end(emps),
                      [&#038;](const auto&#038; e) { return e.name() == name; } );
    return i != end(emps) ? i-&#062;addr : &#034;&#034;;
}
[/code]

is more readable than

[code]
string find_addr( const list&#060;employee&#062;&#038; emps, const string&#038; name ) {
    for (const auto&#038; e : emps) {
        if (e.name() == name) {
            return e.addr;
        }
    }
    return string(); 
}
[/code]

Granted it&#039;s fewer lines, but I can reason very intuitively about the bottom.  The difference is small, so if the find_if case were faster then I&#039;d use it.  But an extra branch /and/ not as readable?]]></description>
		<content:encoded><![CDATA[<p>Two issues.  One is that I think Barry&#8217;s point is relevant even though, in this case, an extra branch is swamped out by dynamic memory allocation.  Similarly to using prefix increment, doing things in a consistent manner every time that yields better performance in a subset of cases is a Good Thing if it doesn&#8217;t make readability worse (though sometimes being consistent makes for better readability even if it&#8217;s slightly more complex).</p>
<p>That brings us to the second issue, which is that I can&#8217;t in good conscience say that</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    const auto i = find_if( begin(emps), end(emps),
                      [&amp;](const auto&amp; e) { return e.name() == name; } );
    return i != end(emps) ? i-&gt;addr : &quot;&quot;;
}
</pre>
<p>is more readable than</p>
<pre class="brush: plain; title: ; notranslate">
string find_addr( const list&lt;employee&gt;&amp; emps, const string&amp; name ) {
    for (const auto&amp; e : emps) {
        if (e.name() == name) {
            return e.addr;
        }
    }
    return string(); 
}
</pre>
<p>Granted it&#8217;s fewer lines, but I can reason very intuitively about the bottom.  The difference is small, so if the find_if case were faster then I&#8217;d use it.  But an extra branch /and/ not as readable?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10146</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 16 May 2013 21:26:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10146</guid>
					<description><![CDATA[@Olaf: Can you elaborate?]]></description>
		<content:encoded><![CDATA[<p>@Olaf: Can you elaborate?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Olaf van der Spek				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10141</link>
		<dc:creator><![CDATA[Olaf van der Spek]]></dc:creator>
		<pubDate>Thu, 16 May 2013 21:08:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10141</guid>
					<description><![CDATA[Herb, you&#039;re cheating by using find instead of find_if. :p]]></description>
		<content:encoded><![CDATA[<p>Herb, you&#8217;re cheating by using find instead of find_if. :p</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10140</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Thu, 16 May 2013 21:04:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10140</guid>
					<description><![CDATA[find_if is worse for readability than find because beside being linger find_if says im checking for predicate(aka name.size()&#062;123) not value...  btw I wonder if there is any diff in IRL perf between find and find_if]]></description>
		<content:encoded><![CDATA[<p>find_if is worse for readability than find because beside being linger find_if says im checking for predicate(aka name.size()&gt;123) not value&#8230;  btw I wonder if there is any diff in IRL perf between find and find_if</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Stephan				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10139</link>
		<dc:creator><![CDATA[Stephan]]></dc:creator>
		<pubDate>Thu, 16 May 2013 20:57:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10139</guid>
					<description><![CDATA[@Barry find_addr returns a string (that needs to be constructed and likely requires dynamic memory allocation), so the extra branch doesn&#039;t matter even if find_if isn&#039;t inlined.]]></description>
		<content:encoded><![CDATA[<p>@Barry find_addr returns a string (that needs to be constructed and likely requires dynamic memory allocation), so the extra branch doesn&#8217;t matter even if find_if isn&#8217;t inlined.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Barry				</title>
				<link>https://herbsutter.com/2013/05/16/gotw-3-solution-using-the-standard-library-or-temporaries-revisited/#comment-10136</link>
		<dc:creator><![CDATA[Barry]]></dc:creator>
		<pubDate>Thu, 16 May 2013 20:27:21 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1912#comment-10136</guid>
					<description><![CDATA[When using find or find_if, doesn&#039;t that incur an extra branch over the normal range-for loop implementation? I&#039;m not sure the algorithm solution is necessarily cleaner enough to merit the hit.]]></description>
		<content:encoded><![CDATA[<p>When using find or find_if, doesn&#8217;t that incur an extra branch over the normal range-for loop implementation? I&#8217;m not sure the algorithm solution is necessarily cleaner enough to merit the hit.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
