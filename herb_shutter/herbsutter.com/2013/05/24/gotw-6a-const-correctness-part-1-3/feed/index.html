<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #6a Solution: Const-Correctness, Part 1	</title>
	<atom:link href="https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Writing min function, part 4: Const-Correctness &#124; Components Programming				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-27936</link>
		<dc:creator><![CDATA[Writing min function, part 4: Const-Correctness &#124; Components Programming]]></dc:creator>
		<pubDate>Wed, 24 Sep 2014 15:10:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-27936</guid>
					<description><![CDATA[[&#8230;] The &#8220;Guru of the Week&#8221; (GotW) articles about Const-Correctness (the original and the new one), from Herb Sutter: http://www.gotw.ca/gotw/006.htm https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/ [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] The &#8220;Guru of the Week&#8221; (GotW) articles about Const-Correctness (the original and the new one), from Herb Sutter: <a href="http://www.gotw.ca/gotw/006.htm" rel="nofollow">http://www.gotw.ca/gotw/006.htm</a> <a href="https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/" rel="nofollow">https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/</a> [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ Const-correctness with volatile and external datat acess &#124; BlogoSfera				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-12022</link>
		<dc:creator><![CDATA[C++ Const-correctness with volatile and external datat acess &#124; BlogoSfera]]></dc:creator>
		<pubDate>Mon, 22 Jul 2013 15:02:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-12022</guid>
					<description><![CDATA[[&#8230;] method const for the reason stated in the question. This is especially true after stumbling upon this GotW article, which states that the meaning of const is changing to mean &#8220;able to read [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] method const for the reason stated in the question. This is especially true after stumbling upon this GotW article, which states that the meaning of const is changing to mean &#8220;able to read [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: artur				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10646</link>
		<dc:creator><![CDATA[artur]]></dc:creator>
		<pubDate>Wed, 29 May 2013 17:34:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10646</guid>
					<description><![CDATA[gcc 4.8 -std=gnu++11

http://en.cppreference.com/w/cpp/locale/locale
static const locale &#038; classic();

std::isdigit( jakis_znak, std::locale::classic() );

valgrind:
Possible data race during write of size 8 at 0xB9B9E20 by thread #5
==62666== Locks held: none
==62666==    at 0xB921980: std::locale::locale(std::locale::_Impl*) (in
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)
==62666==    by 0xB923E4E: std::locale::classic() (in
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)

==62666== This conflicts with a previous write of size 8 by thread #3
==62666== Locks held: none
==62666==    at 0xB921980: std::locale::locale(std::locale::_Impl*) (in
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)
==62666==    by 0xB923E4E: std::locale::classic() (in
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)]]></description>
		<content:encoded><![CDATA[<p>gcc 4.8 -std=gnu++11</p>
<p><a href="http://en.cppreference.com/w/cpp/locale/locale" rel="nofollow">http://en.cppreference.com/w/cpp/locale/locale</a><br />
static const locale &amp; classic();</p>
<p>std::isdigit( jakis_znak, std::locale::classic() );</p>
<p>valgrind:<br />
Possible data race during write of size 8 at 0xB9B9E20 by thread #5<br />
==62666== Locks held: none<br />
==62666==    at 0xB921980: std::locale::locale(std::locale::_Impl*) (in<br />
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)<br />
==62666==    by 0xB923E4E: std::locale::classic() (in<br />
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)</p>
<p>==62666== This conflicts with a previous write of size 8 by thread #3<br />
==62666== Locks held: none<br />
==62666==    at 0xB921980: std::locale::locale(std::locale::_Impl*) (in<br />
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)<br />
==62666==    by 0xB923E4E: std::locale::classic() (in<br />
/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.18)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alexander Kramer				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10537</link>
		<dc:creator><![CDATA[Alexander Kramer]]></dc:creator>
		<pubDate>Tue, 28 May 2013 09:04:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10537</guid>
					<description><![CDATA[If const is not bitwise const anymore why not give it some new meaning, e.g. &quot;CONSistenT&quot; in terms of safe to be called from multiple threads.
Then our compiler will check for us whether we mixiung up thread safe and not thread safe methods.

Below is an example of using Lock class (based on pthread mutex), class SafeData which uses lock for implement thread safe access to some data and class UseSafeData which shows possible usage of SafeData. 

At the first glance making all methods const seems ridiculous, but the benefit is that compiler will disallow calls of unsafe methods from safe methods.
The guidelines here are slightly different from above:

* all thread safe methods and members are defined using &quot;const&quot;
* define members which are not thread safe and must be synchronized as &quot;mutable&quot; 

This implies that synchronization primitives (locks, critical sections, ...) are themselves thread safe and should provide &quot;const&quot; interface. For Lock class below methods lock() and unlock() are const. They also should be declared as const in other classes to restrict the usage to thread safe methods. 

The class SafeData provides two methods for data manipulation, one is thread safe and one is not: setDataSafe() and setData(). 

The class UseSafeData has two instances of SafeData and again two methods useSafe() and useUnsafe() (first is meant to be thread safe, second not). 
Now the compiler will check for incorrect using of SafeData&#039;s unsafe methods inside useSafe() method thus preventing us from accidently calling not thread safe method from a thread safe one. (See content of methods useSafe() and useUnsafe() ).

What do You think about this approach? Are there any pitfalls with new C++11?

[code]
#include &#060;pthread.h&#062;

/// Basic locking class
/// const=thread safe
class Lock
{
protected:	
	mutable pthread_mutex_t mutex;	///&#060; pthread mutex must be mutable
public :
	
	Lock()
	{
		 pthread_mutex_init(&#038;mutex, NULL);
	}
	virtual ~Lock()
	{
		pthread_mutex_destroy(&#038;mutex);
	}
	
	/// this method is thread safe and thus const
	void lock() const
	{
		 pthread_mutex_lock(&#038;mutex);
	}
	
	/// this method is thread safe and thus const
	void unlock() const
	{
		 pthread_mutex_unlock(&#038;mutex);
	}
};

/// Example of class which is used in multi-threading context and has some non atomic data which requires locking.
/// const = thread safe
class  SafeData
{
	const Lock lock; ///&#060; const will restrict interface of Lock to const methods 
	
	mutable int dataA; ///&#060; members which want to be protected by locks. Must be mutable.
	mutable int dataB; 
public:

	/// this method is thread safe (is const)
	void setDataSafe(int d) const
	{
		lock.lock();
		printf(&#034;setDataSafe(%d) const\n&#034;,d);
		dataA = d;
		dataB = d*d;
		lock.unlock();
	}
	
	/// this method is not thread safe 
	void setData(int d)
	{
		printf(&#034;setData(%d)\n&#034;,d);
		dataA = d;
		dataB = d*d;
	}
};


/// This class is also used by multiple threads and is using other thread-safe classes
/// const = thread safe
class UseSafeData
{
	
	/// Const will restrict interface to safe methods
	const SafeData dataConst;
	
	/// Non-const will allow unsafe methods to be called from unsafe methods only
	SafeData data;
	
public:

	/// thread safe method (has const)
	void useSafe() const
	{
		// following two lines are OK: calling safe methods from safe methods.
		dataConst.setDataSafe(1);
		data.setDataSafe(2);
		
		// following will be prevented by compiler
		// dataConst.setData(3);
		
		// following will be prevented by compiler because we are trying to call unsafe method from safe method.
		// data.setData(4);
	}
	
	/// not thread safe method (has no const)
	void useUnsafe()
	{
		
		dataConst.setDataSafe(5);
		data.setDataSafe(6);
		
		// following will be prevented by compiler because we declared dataConst as const thus restricting usage to safe methods
		// dataConst.setData(7);

		// this is allowed because we are not in safe method and data&#039;s interface allows unsafe calles
		data.setData(8);		

	}

};


[/code]]]></description>
		<content:encoded><![CDATA[<p>If const is not bitwise const anymore why not give it some new meaning, e.g. &#8220;CONSistenT&#8221; in terms of safe to be called from multiple threads.<br />
Then our compiler will check for us whether we mixiung up thread safe and not thread safe methods.</p>
<p>Below is an example of using Lock class (based on pthread mutex), class SafeData which uses lock for implement thread safe access to some data and class UseSafeData which shows possible usage of SafeData. </p>
<p>At the first glance making all methods const seems ridiculous, but the benefit is that compiler will disallow calls of unsafe methods from safe methods.<br />
The guidelines here are slightly different from above:</p>
<p>* all thread safe methods and members are defined using &#8220;const&#8221;<br />
* define members which are not thread safe and must be synchronized as &#8220;mutable&#8221; </p>
<p>This implies that synchronization primitives (locks, critical sections, &#8230;) are themselves thread safe and should provide &#8220;const&#8221; interface. For Lock class below methods lock() and unlock() are const. They also should be declared as const in other classes to restrict the usage to thread safe methods. </p>
<p>The class SafeData provides two methods for data manipulation, one is thread safe and one is not: setDataSafe() and setData(). </p>
<p>The class UseSafeData has two instances of SafeData and again two methods useSafe() and useUnsafe() (first is meant to be thread safe, second not).<br />
Now the compiler will check for incorrect using of SafeData&#8217;s unsafe methods inside useSafe() method thus preventing us from accidently calling not thread safe method from a thread safe one. (See content of methods useSafe() and useUnsafe() ).</p>
<p>What do You think about this approach? Are there any pitfalls with new C++11?</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;pthread.h&gt;

/// Basic locking class
/// const=thread safe
class Lock
{
protected:	
	mutable pthread_mutex_t mutex;	///&lt; pthread mutex must be mutable
public :
	
	Lock()
	{
		 pthread_mutex_init(&amp;mutex, NULL);
	}
	virtual ~Lock()
	{
		pthread_mutex_destroy(&amp;mutex);
	}
	
	/// this method is thread safe and thus const
	void lock() const
	{
		 pthread_mutex_lock(&amp;mutex);
	}
	
	/// this method is thread safe and thus const
	void unlock() const
	{
		 pthread_mutex_unlock(&amp;mutex);
	}
};

/// Example of class which is used in multi-threading context and has some non atomic data which requires locking.
/// const = thread safe
class  SafeData
{
	const Lock lock; ///&lt; const will restrict interface of Lock to const methods 
	
	mutable int dataA; ///&lt; members which want to be protected by locks. Must be mutable.
	mutable int dataB; 
public:

	/// this method is thread safe (is const)
	void setDataSafe(int d) const
	{
		lock.lock();
		printf(&quot;setDataSafe(%d) const\n&quot;,d);
		dataA = d;
		dataB = d*d;
		lock.unlock();
	}
	
	/// this method is not thread safe 
	void setData(int d)
	{
		printf(&quot;setData(%d)\n&quot;,d);
		dataA = d;
		dataB = d*d;
	}
};


/// This class is also used by multiple threads and is using other thread-safe classes
/// const = thread safe
class UseSafeData
{
	
	/// Const will restrict interface to safe methods
	const SafeData dataConst;
	
	/// Non-const will allow unsafe methods to be called from unsafe methods only
	SafeData data;
	
public:

	/// thread safe method (has const)
	void useSafe() const
	{
		// following two lines are OK: calling safe methods from safe methods.
		dataConst.setDataSafe(1);
		data.setDataSafe(2);
		
		// following will be prevented by compiler
		// dataConst.setData(3);
		
		// following will be prevented by compiler because we are trying to call unsafe method from safe method.
		// data.setData(4);
	}
	
	/// not thread safe method (has no const)
	void useUnsafe()
	{
		
		dataConst.setDataSafe(5);
		data.setDataSafe(6);
		
		// following will be prevented by compiler because we declared dataConst as const thus restricting usage to safe methods
		// dataConst.setData(7);

		// this is allowed because we are not in safe method and data's interface allows unsafe calles
		data.setData(8);		

	}

};


</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter GotW6: Const and Mutable &#124; musingstudio				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10536</link>
		<dc:creator><![CDATA[Herb Sutter GotW6: Const and Mutable &#124; musingstudio]]></dc:creator>
		<pubDate>Tue, 28 May 2013 07:49:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10536</guid>
					<description><![CDATA[[&#8230;] This item covers ground Herb already presented in this video. He recommends that const member functions must be one of: [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] This item covers ground Herb already presented in this video. He recommends that const member functions must be one of: [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Marcin				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10448</link>
		<dc:creator><![CDATA[Michael Marcin]]></dc:creator>
		<pubDate>Sun, 26 May 2013 07:29:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10448</guid>
					<description><![CDATA[&quot;Concurrent const operations on the same object are required to be safe without the calling code doing external synchronization.&quot;

This is the sentence that was missing from the original you don&#039;t know const and mutable video/discussion.
Everything makes sense now and this is a great feature of const.]]></description>
		<content:encoded><![CDATA[<p>&#8220;Concurrent const operations on the same object are required to be safe without the calling code doing external synchronization.&#8221;</p>
<p>This is the sentence that was missing from the original you don&#8217;t know const and mutable video/discussion.<br />
Everything makes sense now and this is a great feature of const.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10438</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 25 May 2013 22:47:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10438</guid>
					<description><![CDATA[@Chris: Thanks. I figured that was implicit, but it can&#039;t hurt to be explicit. I&#039;ve rewritten the first part of #2 to make this clearer (I hope).]]></description>
		<content:encoded><![CDATA[<p>@Chris: Thanks. I figured that was implicit, but it can&#8217;t hurt to be explicit. I&#8217;ve rewritten the first part of #2 to make this clearer (I hope).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Chris Vine				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10418</link>
		<dc:creator><![CDATA[Chris Vine]]></dc:creator>
		<pubDate>Fri, 24 May 2013 22:32:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10418</guid>
					<description><![CDATA[&quot;Starting with C++11, const on a variable that is possibly shared means read-only, safe to read concurrently without external synchronization.&quot;

This is only true if no threads have access to the shared object in a non-const context.  If a non-const shared object is passed to a library function by reference to const, without synchronization that function&#039;s read on the object is not safe if  another thread might modify it.

What I think this should say is that &quot;const means read-only, and safe to read concurrently without external synchronization if no other thread has write access to the shared object concerned in a non-const context&quot;.]]></description>
		<content:encoded><![CDATA[<p>&#8220;Starting with C++11, const on a variable that is possibly shared means read-only, safe to read concurrently without external synchronization.&#8221;</p>
<p>This is only true if no threads have access to the shared object in a non-const context.  If a non-const shared object is passed to a library function by reference to const, without synchronization that function&#8217;s read on the object is not safe if  another thread might modify it.</p>
<p>What I think this should say is that &#8220;const means read-only, and safe to read concurrently without external synchronization if no other thread has write access to the shared object concerned in a non-const context&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthew Fioravante				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10415</link>
		<dc:creator><![CDATA[Matthew Fioravante]]></dc:creator>
		<pubDate>Fri, 24 May 2013 19:56:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10415</guid>
					<description><![CDATA[Suppose you have a container like std::map and you want to populate it once at startup and then have multiple threads do lookups later.

This is easy enough to accomplish with the new definition of const. Just create the map, add stuff to it, start your threads, and then expose only a const reference to it to the threads. Since the threads only use const methods, the lookups are guaranteed to be thread safe without requiring the callers to use mutexes or any other external synchronization. One could imagine an implementation of std::map possibly moving nodes around the tree during lookup as an optimization. With const, this behavior would either be prohibitied or would have to be internally synchronized.

But what if you want the threads to be able to modify the widgets? Assuming the widgets modify operations themselves are properly synchronized in some other way, this is perfectly safe as the internal operations of the std::map (or any other key/value mapping data structure) depends only on the keys, not the values.

Unfortunately the const version of find() returns a const_iterator which only provides access to a const version of the widget. The only way around this problem is to either do a const_cast on the const widget&#038; or do some kind of indirection by storing Widget* in the container or some other iterator/index into another storage container for the widgets. 

It seems like const is a little too strong here, in that the constness of the container also &quot;infects&quot; the elements of the container. Sometimes this is what you want, sometimes not. I think in C++98 it made a little more sense but now that const has also gained &quot;thread safe&quot; semantics this weaker form of const may be desirable.

Was this usage pattern ever considered for std::map/unordered_map and other containers? One could even imagine doing the same with a vector, where you wanted to allocate a bunch of object contigously in memory beforehand and then read and modify them later without being able to insert or remove anything from the vector. I don&#039;t think any sane implementation of vector::operator[]/vector::at() would do anything more than a bounds check and array reference but it still would be technically not standards compliant to read from a std::vector without either using a mutex or a const method.

I&#039;m thinking the best solution for this problem for now would be to wrap the container in another class which calls the const methods for lookup and const_cast&#039;s the values to non-const before returning them. Any thoughts?]]></description>
		<content:encoded><![CDATA[<p>Suppose you have a container like std::map and you want to populate it once at startup and then have multiple threads do lookups later.</p>
<p>This is easy enough to accomplish with the new definition of const. Just create the map, add stuff to it, start your threads, and then expose only a const reference to it to the threads. Since the threads only use const methods, the lookups are guaranteed to be thread safe without requiring the callers to use mutexes or any other external synchronization. One could imagine an implementation of std::map possibly moving nodes around the tree during lookup as an optimization. With const, this behavior would either be prohibitied or would have to be internally synchronized.</p>
<p>But what if you want the threads to be able to modify the widgets? Assuming the widgets modify operations themselves are properly synchronized in some other way, this is perfectly safe as the internal operations of the std::map (or any other key/value mapping data structure) depends only on the keys, not the values.</p>
<p>Unfortunately the const version of find() returns a const_iterator which only provides access to a const version of the widget. The only way around this problem is to either do a const_cast on the const widget&amp; or do some kind of indirection by storing Widget* in the container or some other iterator/index into another storage container for the widgets. </p>
<p>It seems like const is a little too strong here, in that the constness of the container also &#8220;infects&#8221; the elements of the container. Sometimes this is what you want, sometimes not. I think in C++98 it made a little more sense but now that const has also gained &#8220;thread safe&#8221; semantics this weaker form of const may be desirable.</p>
<p>Was this usage pattern ever considered for std::map/unordered_map and other containers? One could even imagine doing the same with a vector, where you wanted to allocate a bunch of object contigously in memory beforehand and then read and modify them later without being able to insert or remove anything from the vector. I don&#8217;t think any sane implementation of vector::operator[]/vector::at() would do anything more than a bounds check and array reference but it still would be technically not standards compliant to read from a std::vector without either using a mutex or a const method.</p>
<p>I&#8217;m thinking the best solution for this problem for now would be to wrap the container in another class which calls the const methods for lookup and const_cast&#8217;s the values to non-const before returning them. Any thoughts?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10413</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 24 May 2013 19:43:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10413</guid>
					<description><![CDATA[Incidentally, my second comment is a nice example of Muphry&#039;s law (spelling intentional) in action ;-)
// this CONCEPT; IT&#039;S used; ...good grief :D

@Herb: any chance for an edit-own-comments feature? :-)]]></description>
		<content:encoded><![CDATA[<p>Incidentally, my second comment is a nice example of Muphry&#8217;s law (spelling intentional) in action ;-)<br />
// this CONCEPT; IT&#8217;S used; &#8230;good grief :D</p>
<p>@Herb: any chance for an edit-own-comments feature? :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10411</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 24 May 2013 19:36:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10411</guid>
					<description><![CDATA[@mttpd, @jlehrer: Fixed, thanks.]]></description>
		<content:encoded><![CDATA[<p>@mttpd, @jlehrer: Fixed, thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10408</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Fri, 24 May 2013 18:03:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10408</guid>
					<description><![CDATA[One more typo: const now really does [mean] “read-only, or safe to read concurrently”]]></description>
		<content:encoded><![CDATA[<p>One more typo: const now really does [mean] “read-only, or safe to read concurrently”</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10407</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Fri, 24 May 2013 17:59:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10407</guid>
					<description><![CDATA[Typo: “can use used safely by multiple concurrent const operations.”]]></description>
		<content:encoded><![CDATA[<p>Typo: “can use used safely by multiple concurrent const operations.”</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10401</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 24 May 2013 16:33:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10401</guid>
					<description><![CDATA[Regarding the shared variable question--the following note from the standard (17.6.4.10/[res.on.objects) may also be of help in underscoring the importance of this concepts:
&quot;Modifying an object of a standard library type that is shared between threads risks undefined behavior unless objects of that type are explicitly specified as being sharable without data races or the user supplies a locking mechanism.&quot;

// Personally, I also like to think in terms of the shared-vs.-private distinction in the sense its used in OpenMP, but perhaps this is somewhat too API-specific for this question.]]></description>
		<content:encoded><![CDATA[<p>Regarding the shared variable question&#8211;the following note from the standard (17.6.4.10/[res.on.objects) may also be of help in underscoring the importance of this concepts:<br />
&#8220;Modifying an object of a standard library type that is shared between threads risks undefined behavior unless objects of that type are explicitly specified as being sharable without data races or the user supplies a locking mechanism.&#8221;</p>
<p>// Personally, I also like to think in terms of the shared-vs.-private distinction in the sense its used in OpenMP, but perhaps this is somewhat too API-specific for this question.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/05/24/gotw-6a-const-correctness-part-1-3/#comment-10399</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 24 May 2013 16:23:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2000#comment-10399</guid>
					<description><![CDATA[Just a small fix:

s/&quot;const now really does “read-only, or safe to read concurrently”—either truly physically/bitwise const, or internally synchronized so that any actual writes a synchronized with any possible concurrent non-const accesses so the callers can’t tell the difference&quot;/&quot;const now really does *MEAN* “read-only, or safe to read concurrently”—either truly physically/bitwise const, or internally synchronized so that any actual writes *ARE* synchronized with any possible concurrent non-const accesses so the callers can’t tell the difference&quot;
// emphasis only to be helpful, no shouting intended ;-)

Incidentally, any comments on constexpr-correctness (or is that reserved for the next part? :])?

// BTW, there seems to be a few copies of this post.]]></description>
		<content:encoded><![CDATA[<p>Just a small fix:</p>
<p>s/&#8221;const now really does “read-only, or safe to read concurrently”—either truly physically/bitwise const, or internally synchronized so that any actual writes a synchronized with any possible concurrent non-const accesses so the callers can’t tell the difference&#8221;/&#8221;const now really does *MEAN* “read-only, or safe to read concurrently”—either truly physically/bitwise const, or internally synchronized so that any actual writes *ARE* synchronized with any possible concurrent non-const accesses so the callers can’t tell the difference&#8221;<br />
// emphasis only to be helpful, no shouting intended ;-)</p>
<p>Incidentally, any comments on constexpr-correctness (or is that reserved for the next part? :])?</p>
<p>// BTW, there seems to be a few copies of this post.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
