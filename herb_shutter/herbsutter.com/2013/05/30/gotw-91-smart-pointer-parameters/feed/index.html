<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #91: Smart Pointer Parameters	</title>
	<atom:link href="https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: C++的未来和指针 &#124; 闻之山				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-14211</link>
		<dc:creator><![CDATA[C++的未来和指针 &#124; 闻之山]]></dc:creator>
		<pubDate>Mon, 27 Jan 2014 02:07:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-14211</guid>
					<description><![CDATA[[&#8230;] Sutter写了一篇非常好的文章:《GotW about this in May》。Eric Niebler 在他的Meeting [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter写了一篇非常好的文章:《GotW about this in May》。Eric Niebler 在他的Meeting [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lelala				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10898</link>
		<dc:creator><![CDATA[Lelala]]></dc:creator>
		<pubDate>Tue, 04 Jun 2013 20:35:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10898</guid>
					<description><![CDATA[Even if i&#039;m away a few years of C++ hardcore programming, i&#039;d guess the first one (#1) has implications due fact that it&#039;s a template, thus you do not now (first) how many cocmplex stuff is created in the templated class&#039; constructor, second because its a parameter-by-value, resulting in bad stuff in the C++ universe, depending on deep/flat copy of the object?
Nontheless, a good interview questsion :-)]]></description>
		<content:encoded><![CDATA[<p>Even if i&#8217;m away a few years of C++ hardcore programming, i&#8217;d guess the first one (#1) has implications due fact that it&#8217;s a template, thus you do not now (first) how many cocmplex stuff is created in the templated class&#8217; constructor, second because its a parameter-by-value, resulting in bad stuff in the C++ universe, depending on deep/flat copy of the object?<br />
Nontheless, a good interview questsion :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10896</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 04 Jun 2013 19:39:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10896</guid>
					<description><![CDATA[@Tom: I have a talk at Build toward the end of this month where I&#039;ll answer that in detail. Stay tuned.]]></description>
		<content:encoded><![CDATA[<p>@Tom: I have a talk at Build toward the end of this month where I&#8217;ll answer that in detail. Stay tuned.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10869</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Tue, 04 Jun 2013 11:39:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10869</guid>
					<description><![CDATA[Sorry for off topic. 
But what about VS 2013  and C++11 support?
Does this mean that Nov. CTP C++ compiler is now part of VS 2013 and thre will be no update for VS 2012 ?
 *dreaming* Or will VS 2013 finally get full C++11 support ?]]></description>
		<content:encoded><![CDATA[<p>Sorry for off topic.<br />
But what about VS 2013  and C++11 support?<br />
Does this mean that Nov. CTP C++ compiler is now part of VS 2013 and thre will be no update for VS 2012 ?<br />
 *dreaming* Or will VS 2013 finally get full C++11 support ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GotW #91 &#124; Crazy Eddie&#039;s Crazy C++				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10782</link>
		<dc:creator><![CDATA[GotW #91 &#124; Crazy Eddie&#039;s Crazy C++]]></dc:creator>
		<pubDate>Fri, 31 May 2013 19:34:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10782</guid>
					<description><![CDATA[[&#8230;] my answer to GotW 91 [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] my answer to GotW 91 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10776</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 31 May 2013 18:16:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10776</guid>
					<description><![CDATA[@David Thornley: &quot;If the idea is to make sure the Widget goes away, it might be just as useful to have the unique_ptr in the calling function, and call f using (a) or (b), since this will save the small amount of time to copy the unique_ptr.&quot;

If you do that, you delay the destruction of widget after the end of the calling scope, what might not be what you wanted, and also, you save nothing, as a unique_ptr is just a zero overhead wrapper around a plain old pointer, copying (or rather, moving/creating, as the whole idea is to disable copy) costs exactly the same as copying the plain pointer. You might say that &quot;but I also need to set the source to nullptr on move!&quot; Well, check the disassembly after an optimized build, you probably will see this being skipped.]]></description>
		<content:encoded><![CDATA[<p>@David Thornley: &#8220;If the idea is to make sure the Widget goes away, it might be just as useful to have the unique_ptr in the calling function, and call f using (a) or (b), since this will save the small amount of time to copy the unique_ptr.&#8221;</p>
<p>If you do that, you delay the destruction of widget after the end of the calling scope, what might not be what you wanted, and also, you save nothing, as a unique_ptr is just a zero overhead wrapper around a plain old pointer, copying (or rather, moving/creating, as the whole idea is to disable copy) costs exactly the same as copying the plain pointer. You might say that &#8220;but I also need to set the source to nullptr on move!&#8221; Well, check the disassembly after an optimized build, you probably will see this being skipped.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Thornley				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10772</link>
		<dc:creator><![CDATA[David Thornley]]></dc:creator>
		<pubDate>Fri, 31 May 2013 15:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10772</guid>
					<description><![CDATA[3.  (a) and (b) are the simplest ways to pass the Widget in.  Since this is a required read-only parameter, the ability of (a) [code]void f(const Widget const *)[/code] to pass [code]nullptr[/code] in is irrelevant, and its only advantage is making it very obvious that there&#039;s indirection going on, which is usually not all that important.  It might be useful as a reminder if the programmer wants to be reminded to microoptimize memory references, but this is almost always pointless.  One potential disadvantage is that somebody could put a [code]delete widget;[/code] in the function, but if the shop uses the coding standard that a raw pointer never owns, that should be caught in code review.  (b)[code]void f(const &#038; Widget)[/code] reads better, captures the fact that the Widget is required, and doesn&#039;t lend itself to accidental deletion.

I have been unable to imagine any use for (d) and (f).  Semantically, a reference is another name for something, and (without bothering to try figuring it out) it seems to me that having two names for a unique_ptr or a shared_ptr is a bad idea.  Over the years, I&#039;ve learned to stay out of the dark corners of the C++ standard, because things lurk there that bite.

(c) [code]void f(unique_ptr&#060;const Widget&#062;)[/code] unequivocally transfers ownership.  This is the right thing to use if and only if that&#039;s what&#039;s desired.  For example, we may want to create a Widget and transfer it to a wrapper that is the Widget&#039;s only link to the outside world, possibly if we&#039;re writing a multiplatform interface or otherwise need consistent calls to inconsistent Widgets.  If the idea is to make sure the Widget goes away, it might be just as useful to have the unique_ptr in the calling function, and call f using (a) or (b), since this will save the small amount of time to copy the unique_ptr.

(e) [code] void f(shared_ptr&#060;const Widget&#062;)[/code] gives f shared ownership.  This is useful if and only if the Widget might go away while the Widget is still in use.  The obvious example would be f copying the Widget to a class data member, since the class may well outlive the calling function.

If the program is single-threaded, or the calling function calls f in a thread that it later necessarily joins, f&#039;s execution is going to be over before the calling function returns, and there&#039;s no real need to pass a unique_ptr or shared_ptr unless f transfers its ownership share to a longer-lasting variable or object.  If f is called in a thread that may outlive the calling function, then it needs at least partial ownership, and so (c) or (e) is necessary.

Since the Widget is an input parameter, it should not be changed, and therefore every example of Widget should be replaced by [code]const Widget[/code] or [code]Widget const[/code].  This means that the calling function can pass a const Widget to f, and serves as a reminder that the Widget should not be changed.  In (a), the pointer itself can be a const, and that establishes the pointer itself as input-only.]]></description>
		<content:encoded><![CDATA[<p>3.  (a) and (b) are the simplest ways to pass the Widget in.  Since this is a required read-only parameter, the ability of (a) </p>
<pre class="brush: plain; title: ; notranslate">void f(const Widget const *)</pre>
<p> to pass </p>
<pre class="brush: plain; title: ; notranslate">nullptr</pre>
<p> in is irrelevant, and its only advantage is making it very obvious that there&#8217;s indirection going on, which is usually not all that important.  It might be useful as a reminder if the programmer wants to be reminded to microoptimize memory references, but this is almost always pointless.  One potential disadvantage is that somebody could put a </p>
<pre class="brush: plain; title: ; notranslate">delete widget;</pre>
<p> in the function, but if the shop uses the coding standard that a raw pointer never owns, that should be caught in code review.  (b)</p>
<pre class="brush: plain; title: ; notranslate">void f(const &amp; Widget)</pre>
<p> reads better, captures the fact that the Widget is required, and doesn&#8217;t lend itself to accidental deletion.</p>
<p>I have been unable to imagine any use for (d) and (f).  Semantically, a reference is another name for something, and (without bothering to try figuring it out) it seems to me that having two names for a unique_ptr or a shared_ptr is a bad idea.  Over the years, I&#8217;ve learned to stay out of the dark corners of the C++ standard, because things lurk there that bite.</p>
<p>(c) </p>
<pre class="brush: plain; title: ; notranslate">void f(unique_ptr&lt;const Widget&gt;)</pre>
<p> unequivocally transfers ownership.  This is the right thing to use if and only if that&#8217;s what&#8217;s desired.  For example, we may want to create a Widget and transfer it to a wrapper that is the Widget&#8217;s only link to the outside world, possibly if we&#8217;re writing a multiplatform interface or otherwise need consistent calls to inconsistent Widgets.  If the idea is to make sure the Widget goes away, it might be just as useful to have the unique_ptr in the calling function, and call f using (a) or (b), since this will save the small amount of time to copy the unique_ptr.</p>
<p>(e) </p>
<pre class="brush: plain; title: ; notranslate"> void f(shared_ptr&lt;const Widget&gt;)</pre>
<p> gives f shared ownership.  This is useful if and only if the Widget might go away while the Widget is still in use.  The obvious example would be f copying the Widget to a class data member, since the class may well outlive the calling function.</p>
<p>If the program is single-threaded, or the calling function calls f in a thread that it later necessarily joins, f&#8217;s execution is going to be over before the calling function returns, and there&#8217;s no real need to pass a unique_ptr or shared_ptr unless f transfers its ownership share to a longer-lasting variable or object.  If f is called in a thread that may outlive the calling function, then it needs at least partial ownership, and so (c) or (e) is necessary.</p>
<p>Since the Widget is an input parameter, it should not be changed, and therefore every example of Widget should be replaced by </p>
<pre class="brush: plain; title: ; notranslate">const Widget</pre>
<p> or </p>
<pre class="brush: plain; title: ; notranslate">Widget const</pre>
<p>.  This means that the calling function can pass a const Widget to f, and serves as a reminder that the Widget should not be changed.  In (a), the pointer itself can be a const, and that establishes the pointer itself as input-only.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10764</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Fri, 31 May 2013 10:06:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10764</guid>
					<description><![CDATA[It would be (a) or (b) for no other reason than the need for compatibility with as many c++  compilers as possible. Maybe not the correct Guru/cool answer but one that is a practical real world answer! 

Even just targeting latest there is still the advantage of keeping things simple and familar unless there are overriding reasons for extra complexity. The KISS principle should be stamped on every engineers forehead.....]]></description>
		<content:encoded><![CDATA[<p>It would be (a) or (b) for no other reason than the need for compatibility with as many c++  compilers as possible. Maybe not the correct Guru/cool answer but one that is a practical real world answer! </p>
<p>Even just targeting latest there is still the advantage of keeping things simple and familar unless there are overriding reasons for extra complexity. The KISS principle should be stamped on every engineers forehead&#8230;..</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10763</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Fri, 31 May 2013 09:34:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10763</guid>
					<description><![CDATA[1. Performance: There&#039;s a little performance overhead of calling the function with [code] shared_ptr&#060;widget&#062; [\code] compared to using [code] const widget &#038; [/code] as parameter type. The function call is probably the most expensive thing for the caller here. However, passing a [code] shared_ptr [/code] requires a thread-safe counter increment and a decrement at destruction which is definite overhead. Also, if the caller has a widget reference, but no shared_ptr to that widget, then a shared_ptr with a null deleter must be created unnecessarily. This requires another memory allocation for the deleter and reference counter, which can be expensive on the calling side. 

2. Correctness: Usually a function with this signature would only need a [code] shared_ptr [/code], if it takes shared ownership of it or needs to pass shared ownership to someone else. This would only be useful, if the function stores a [code] shared_ptr [/code] or a [code] weak_ptr [/code] in some kind of global variable. If that isn&#039;t the case (and it most often isn&#039;t), the the function should prefer to take a [code] widget &#038; [/code] or [code] const widget &#038; [/code]. Even if there is a factory function like
[code]
shared_ptr&#060;widget&#062; load_widget( widget::id id );
[/code]
then a const reference would still make sense, since
[code]
f( *load_widget( id ) );
[/code]
would still work. The code would also still work and be correct, if the return type of the [code] load_widget() [/code] function would be changed to [code] unique_ptr&#060;widget&#062; [/code].

3. Since the parameter widget is an input-only parameter and hence should not be modified, the type [code] widget [/code] should be replaced by [code] const widget [/code] in all cases, including template argument types. Now to the question what each declaration would mean:
[code] 
void f( const widget* );              (a)
void f( const widget&#038; );              (b)
[/code]
This should be prefered, since the function does not need to take ownership of the widget (at least most typically). Still (a) and (b) differ in the fact that (a) can be passed a null pointer to. Yes, it is possible to pass null references with code like this
[code]
widget * p = nullptr;
f( *p );
[/code]
but normally people don&#039;t do that. Remember, we should write code that is easy to use correctly and hard to use incorrectly. Also (b) has the advantage, that a temporary object can be passed. For example
[code]
f( create_widget() );
[/code]
which wouldn&#039;t be possible with (a).

Now let&#039;s consider
[code]
void f( unique_ptr&#060;const widget&#062; );   (c)
void f( unique_ptr&#060;const widget&#062;&#038; );  (d)
[/code]
In case (c) the function [code] f [/code] will eat the widget. This unnessesarily restricts the caller, since the caller cannot do anything with the widget afterwards. The same effect could be accomplished with the function declaration (b) by writing
[code]
unique_ptr&#060;widget&#062; p = ...;
/* ... */
f( *p );
p.reset();
[/code]
The only advantage is that the callee (c) could use the unique_ptr to the const widget somehow where only a [code] unique_ptr&#060;const widget&#062; [/code] can be used. However this is highly unlikely. The same applies to (d) only that it MIGHT eat the unique_ptr to the const widget. That would be even worse, since it&#039;s not clear from the declaration when this happens. The most surprising thing yet is that the callee can change the pointer so that it points to another object afterwards. Ouch! Hence we need to add another const to the declaration to prevent this:
[code]
void f( const unique_ptr&#060;const widget&#062;&#038; );
[/code]
The unique_ptr cannot be moved then. But there&#039;s no advantage of passing a unique_ptr then over variant (a). It just makes the code a little more obscure. 

Last but not least, let&#039;s consider
[code]
void f( shared_ptr&#060;const widget&#062; );   (e)
void f( shared_ptr&#060;const widget&#062;&#038; );  (f)
[/code]
I already discussed (e) in 2. In (f) incrementing the reference counter can be prevented. However, as in (d), the callee may change the pointer, hence we should add another const:
[code] 
void f( const shared_ptr&#060;const widget&#062;&#038; );
[/code]
Now this is almost the same as (e). Again, shared_ptr implies that shared ownership is being used. That is almost never necessary for simple input arguments. It&#039;s unnecessarily demanding to the caller to create a shared_ptr, if the shared ownership isn&#039;t even used. The parameter type is much more complicated compared to (a) and (b) and there&#039;s no significant advantage to (a). And (b) is probably even better than (a). 

Bottom line: Prefer plain pointers and references as function paramter types unless unique or shared ownership must be transferred. If ownership should be transfered pass a unique_ptr or shared_ptr by value. This clearly states the intent in the declaration and it is easy to read and efficient. 

I would prefer to use (b) as a function declaration, if the parameter is not optional. Otherwise, I would use (a) and pass a nullptr, if I want to omit the argument.]]></description>
		<content:encoded><![CDATA[<p>1. Performance: There&#8217;s a little performance overhead of calling the function with </p>
<pre class="brush: plain; title: ; notranslate"> shared_ptr&lt;widget&gt; [\code] compared to using [code] const widget &amp; </pre>
<p> as parameter type. The function call is probably the most expensive thing for the caller here. However, passing a </p>
<pre class="brush: plain; title: ; notranslate"> shared_ptr </pre>
<p> requires a thread-safe counter increment and a decrement at destruction which is definite overhead. Also, if the caller has a widget reference, but no shared_ptr to that widget, then a shared_ptr with a null deleter must be created unnecessarily. This requires another memory allocation for the deleter and reference counter, which can be expensive on the calling side. </p>
<p>2. Correctness: Usually a function with this signature would only need a </p>
<pre class="brush: plain; title: ; notranslate"> shared_ptr </pre>
<p>, if it takes shared ownership of it or needs to pass shared ownership to someone else. This would only be useful, if the function stores a </p>
<pre class="brush: plain; title: ; notranslate"> shared_ptr </pre>
<p> or a </p>
<pre class="brush: plain; title: ; notranslate"> weak_ptr </pre>
<p> in some kind of global variable. If that isn't the case (and it most often isn't), the the function should prefer to take a </p>
<pre class="brush: plain; title: ; notranslate"> widget &amp; </pre>
<p> or </p>
<pre class="brush: plain; title: ; notranslate"> const widget &amp; </pre>
<p>. Even if there is a factory function like</p>
<pre class="brush: plain; title: ; notranslate">
shared_ptr&lt;widget&gt; load_widget( widget::id id );
</pre>
<p>then a const reference would still make sense, since</p>
<pre class="brush: plain; title: ; notranslate">
f( *load_widget( id ) );
</pre>
<p>would still work. The code would also still work and be correct, if the return type of the </p>
<pre class="brush: plain; title: ; notranslate"> load_widget() </pre>
<p> function would be changed to </p>
<pre class="brush: plain; title: ; notranslate"> unique_ptr&lt;widget&gt; </pre>
<p>.</p>
<p>3. Since the parameter widget is an input-only parameter and hence should not be modified, the type </p>
<pre class="brush: plain; title: ; notranslate"> widget </pre>
<p> should be replaced by </p>
<pre class="brush: plain; title: ; notranslate"> const widget </pre>
<p> in all cases, including template argument types. Now to the question what each declaration would mean:</p>
<pre class="brush: plain; title: ; notranslate"> 
void f( const widget* );              (a)
void f( const widget&amp; );              (b)
</pre>
<p>This should be prefered, since the function does not need to take ownership of the widget (at least most typically). Still (a) and (b) differ in the fact that (a) can be passed a null pointer to. Yes, it is possible to pass null references with code like this</p>
<pre class="brush: plain; title: ; notranslate">
widget * p = nullptr;
f( *p );
</pre>
<p>but normally people don't do that. Remember, we should write code that is easy to use correctly and hard to use incorrectly. Also (b) has the advantage, that a temporary object can be passed. For example</p>
<pre class="brush: plain; title: ; notranslate">
f( create_widget() );
</pre>
<p>which wouldn't be possible with (a).</p>
<p>Now let's consider</p>
<pre class="brush: plain; title: ; notranslate">
void f( unique_ptr&lt;const widget&gt; );   (c)
void f( unique_ptr&lt;const widget&gt;&amp; );  (d)
</pre>
<p>In case (c) the function </p>
<pre class="brush: plain; title: ; notranslate"> f </pre>
<p> will eat the widget. This unnessesarily restricts the caller, since the caller cannot do anything with the widget afterwards. The same effect could be accomplished with the function declaration (b) by writing</p>
<pre class="brush: plain; title: ; notranslate">
unique_ptr&lt;widget&gt; p = ...;
/* ... */
f( *p );
p.reset();
</pre>
<p>The only advantage is that the callee (c) could use the unique_ptr to the const widget somehow where only a </p>
<pre class="brush: plain; title: ; notranslate"> unique_ptr&lt;const widget&gt; </pre>
<p> can be used. However this is highly unlikely. The same applies to (d) only that it MIGHT eat the unique_ptr to the const widget. That would be even worse, since it's not clear from the declaration when this happens. The most surprising thing yet is that the callee can change the pointer so that it points to another object afterwards. Ouch! Hence we need to add another const to the declaration to prevent this:</p>
<pre class="brush: plain; title: ; notranslate">
void f( const unique_ptr&lt;const widget&gt;&amp; );
</pre>
<p>The unique_ptr cannot be moved then. But there's no advantage of passing a unique_ptr then over variant (a). It just makes the code a little more obscure. </p>
<p>Last but not least, let's consider</p>
<pre class="brush: plain; title: ; notranslate">
void f( shared_ptr&lt;const widget&gt; );   (e)
void f( shared_ptr&lt;const widget&gt;&amp; );  (f)
</pre>
<p>I already discussed (e) in 2. In (f) incrementing the reference counter can be prevented. However, as in (d), the callee may change the pointer, hence we should add another const:</p>
<pre class="brush: plain; title: ; notranslate"> 
void f( const shared_ptr&lt;const widget&gt;&amp; );
</pre>
<p>Now this is almost the same as (e). Again, shared_ptr implies that shared ownership is being used. That is almost never necessary for simple input arguments. It's unnecessarily demanding to the caller to create a shared_ptr, if the shared ownership isn't even used. The parameter type is much more complicated compared to (a) and (b) and there's no significant advantage to (a). And (b) is probably even better than (a). </p>
<p>Bottom line: Prefer plain pointers and references as function paramter types unless unique or shared ownership must be transferred. If ownership should be transfered pass a unique_ptr or shared_ptr by value. This clearly states the intent in the declaration and it is easy to read and efficient. </p>
<p>I would prefer to use (b) as a function declaration, if the parameter is not optional. Otherwise, I would use (a) and pass a nullptr, if I want to omit the argument.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: borishr				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10762</link>
		<dc:creator><![CDATA[borishr]]></dc:creator>
		<pubDate>Fri, 31 May 2013 09:04:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10762</guid>
					<description><![CDATA[There&#039;s extra shared count manipulation in [code]void f( shared_ptr&#060;widget&#062; );[/code]. C++98 way would be to use [code]void f( const shared_ptr&#060;widget&#062;&#038; );[/code]. I&#039;m still not familiar with C++11, but I suspect it will be something with two ampersands :-), like [code]void f( shared_ptr&#060;widget&#062;&#038;&#038; );[/code]. That would handle possible extra copy and shared count update in [code] f( make_shared&#060;widget&#062;() ) [/code] 

I would think of [code]void f( shared_ptr&#060;widget&#062; );[/code] variants as equivalent to [code] void f( widget* );[/code] whereas [code]void f( unique_ptr&#060;widget&#062; );[/code] is equivalent to [code]void f( widget*&#038; pw ) {...; delete pw; pw=nullptr;} ;[/code]. So, for the question 3, I would use [code] f( unique_ptr&#060;widget&#062; ); [/code] if f is a sink, ie we will not use that pointer again, and variant from question 1 otherwise. Also, I think that it only makes sense passing unique_ptr parameter by value.]]></description>
		<content:encoded><![CDATA[<p>There&#8217;s extra shared count manipulation in </p>
<pre class="brush: plain; title: ; notranslate">void f( shared_ptr&lt;widget&gt; );</pre>
<p>. C++98 way would be to use </p>
<pre class="brush: plain; title: ; notranslate">void f( const shared_ptr&lt;widget&gt;&amp; );</pre>
<p>. I&#8217;m still not familiar with C++11, but I suspect it will be something with two ampersands :-), like </p>
<pre class="brush: plain; title: ; notranslate">void f( shared_ptr&lt;widget&gt;&amp;&amp; );</pre>
<p>. That would handle possible extra copy and shared count update in </p>
<pre class="brush: plain; title: ; notranslate"> f( make_shared&lt;widget&gt;() ) </pre>
<p>I would think of </p>
<pre class="brush: plain; title: ; notranslate">void f( shared_ptr&lt;widget&gt; );</pre>
<p> variants as equivalent to </p>
<pre class="brush: plain; title: ; notranslate"> void f( widget* );</pre>
<p> whereas </p>
<pre class="brush: plain; title: ; notranslate">void f( unique_ptr&lt;widget&gt; );</pre>
<p> is equivalent to </p>
<pre class="brush: plain; title: ; notranslate">void f( widget*&amp; pw ) {...; delete pw; pw=nullptr;} ;</pre>
<p>. So, for the question 3, I would use </p>
<pre class="brush: plain; title: ; notranslate"> f( unique_ptr&lt;widget&gt; ); </pre>
<p> if f is a sink, ie we will not use that pointer again, and variant from question 1 otherwise. Also, I think that it only makes sense passing unique_ptr parameter by value.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Thanks				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10761</link>
		<dc:creator><![CDATA[Thanks]]></dc:creator>
		<pubDate>Fri, 31 May 2013 07:28:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10761</guid>
					<description><![CDATA[Maybe this should be renamed to GotD (for Guru of the Day). I can&#039;t almost keep up with so much good material. Thanks!]]></description>
		<content:encoded><![CDATA[<p>Maybe this should be renamed to GotD (for Guru of the Day). I can&#8217;t almost keep up with so much good material. Thanks!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: decourse				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10758</link>
		<dc:creator><![CDATA[decourse]]></dc:creator>
		<pubDate>Fri, 31 May 2013 06:26:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10758</guid>
					<description><![CDATA[The difference between (c) and (d) is that (c) MUST take ownership of the object (or possibly destroy it), whereas (d) might not touch it. Use (d) if the function needs to think about whether or not to take ownership.

There is a similar difference between (e) and (f). (e) says that f will own a copy, and (f) says it might or might not.]]></description>
		<content:encoded><![CDATA[<p>The difference between (c) and (d) is that (c) MUST take ownership of the object (or possibly destroy it), whereas (d) might not touch it. Use (d) if the function needs to think about whether or not to take ownership.</p>
<p>There is a similar difference between (e) and (f). (e) says that f will own a copy, and (f) says it might or might not.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: paercebal				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10755</link>
		<dc:creator><![CDATA[paercebal]]></dc:creator>
		<pubDate>Fri, 31 May 2013 06:05:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10755</guid>
					<description><![CDATA[&lt;blockquote&gt;1. [code]void f( shared_ptr&#038;lt;widget&#038;gt; );[/code]&lt;/blockquote&gt;

This will make a copy of the shared_ptr, which will only increment the reference counter, which is, unless I&#039;m wrong, an atomic variable (to make sure two threads could safely copy shared_ptrs pointing to the same object, as they would copy raw pointers).

The thing is, we usually don&#039;t even want to pay this cost, so, as we know the object is owned by the previous stack level, we can instead pass the shared_ptr object by const reference, which changes (almost... see below) nothing to the semantics, and makes the parameter passing costless.


&lt;blockquote&gt;2. What are the correctness implications of the function declaration in #1? Explain with clear examples.&lt;/blockquote&gt;

The pointed widget object is owned by the stack at two levels: f, and its caller, which can be overkill in most codes.

Also, as f has shared ownership, it means it is ok for this function to share it again with other parts of the code (which opens the way to ownership cycles if not monitored).


&lt;blockquote&gt;3.

[code]void f( widget* ); (a)
void f( widget&#038;amp; ); (b)
void f( unique_ptr&#038;lt;widget&#038;gt; ); (c)
void f( unique_ptr&#038;lt;widget&#038;gt;&#038;amp; ); (d)
void f( shared_ptr&#038;lt;widget&#038;gt; ); (e)
void f( shared_ptr&#038;lt;widget&#038;gt;&#038;amp; ); (f)[/code]&lt;/blockquote&gt;


(a) and (b) are cases where f is not given ownership to the widget parameter, so it can&#039;t, in turn, give or share it.

(a) means the parameter being nullptr is a valid value, so f is expected to behave.
(b) means the parameter is supposed to always exist, so in case of playing with pointers, the caller is supposed to verify that before dereferencing the pointer and calling f.

(c) has a pure ownership transfer semantic: f will take over the resource, no negociations. The caller must know that its own unique_ptr (or resource) won&#039;t be owned by it anymore the moment f is called.

(d) has conditional ownhership transfer IF the unique_ptr is not const. That is, the function fa can decide (or not) to take ownership of the resource, and thus empty the pointer. IF the unique_ptr is const, then this is just passing a smart pointer parameter, without transfer of ownerhisp (similar to case a)

(e) has ownership sharing semantics. This means that both the caller and f will share the resource... And potentially other parts of the code, as f can freely share it, too. Having this kind of prototypes means your object is out in the wild... Isn&#039;t that where we should wonder about potential ownership cycles that will leak memory? (and where weak_ptr could help break them?) IF the shared_ptr is const, it changes nothing (I see right now the copy constructor of shared_ptr accepts &quot;const shared_ptr &#038;&quot;). Unless I&#039;m wrong, the shared_ptr could be constructed from another shared_ptr of a compatible type (derived-to-base conversion)

(f) IF the shared_ptr is const, this is like e, but we avoid one counter increment. The const reference means that, the shared_ptr have again derived-to-base conversion. If the parameter is passed as non-const reference, then no conversion is possible... and we fall back into e&#039;s case.]]></description>
		<content:encoded><![CDATA[<blockquote><p>1. </p>
<pre class="brush: plain; title: ; notranslate">void f( shared_ptr&amp;lt;widget&amp;gt; );</pre>
</blockquote>
<p>This will make a copy of the shared_ptr, which will only increment the reference counter, which is, unless I&#8217;m wrong, an atomic variable (to make sure two threads could safely copy shared_ptrs pointing to the same object, as they would copy raw pointers).</p>
<p>The thing is, we usually don&#8217;t even want to pay this cost, so, as we know the object is owned by the previous stack level, we can instead pass the shared_ptr object by const reference, which changes (almost&#8230; see below) nothing to the semantics, and makes the parameter passing costless.</p>
<blockquote><p>2. What are the correctness implications of the function declaration in #1? Explain with clear examples.</p></blockquote>
<p>The pointed widget object is owned by the stack at two levels: f, and its caller, which can be overkill in most codes.</p>
<p>Also, as f has shared ownership, it means it is ok for this function to share it again with other parts of the code (which opens the way to ownership cycles if not monitored).</p>
<blockquote><p>3.</p>
<pre class="brush: plain; title: ; notranslate">void f( widget* ); (a)
void f( widget&amp;amp; ); (b)
void f( unique_ptr&amp;lt;widget&amp;gt; ); (c)
void f( unique_ptr&amp;lt;widget&amp;gt;&amp;amp; ); (d)
void f( shared_ptr&amp;lt;widget&amp;gt; ); (e)
void f( shared_ptr&amp;lt;widget&amp;gt;&amp;amp; ); (f)</pre>
</blockquote>
<p>(a) and (b) are cases where f is not given ownership to the widget parameter, so it can&#8217;t, in turn, give or share it.</p>
<p>(a) means the parameter being nullptr is a valid value, so f is expected to behave.<br />
(b) means the parameter is supposed to always exist, so in case of playing with pointers, the caller is supposed to verify that before dereferencing the pointer and calling f.</p>
<p>(c) has a pure ownership transfer semantic: f will take over the resource, no negociations. The caller must know that its own unique_ptr (or resource) won&#8217;t be owned by it anymore the moment f is called.</p>
<p>(d) has conditional ownhership transfer IF the unique_ptr is not const. That is, the function fa can decide (or not) to take ownership of the resource, and thus empty the pointer. IF the unique_ptr is const, then this is just passing a smart pointer parameter, without transfer of ownerhisp (similar to case a)</p>
<p>(e) has ownership sharing semantics. This means that both the caller and f will share the resource&#8230; And potentially other parts of the code, as f can freely share it, too. Having this kind of prototypes means your object is out in the wild&#8230; Isn&#8217;t that where we should wonder about potential ownership cycles that will leak memory? (and where weak_ptr could help break them?) IF the shared_ptr is const, it changes nothing (I see right now the copy constructor of shared_ptr accepts &#8220;const shared_ptr &amp;&#8221;). Unless I&#8217;m wrong, the shared_ptr could be constructed from another shared_ptr of a compatible type (derived-to-base conversion)</p>
<p>(f) IF the shared_ptr is const, this is like e, but we avoid one counter increment. The const reference means that, the shared_ptr have again derived-to-base conversion. If the parameter is passed as non-const reference, then no conversion is possible&#8230; and we fall back into e&#8217;s case.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Craig				</title>
				<link>https://herbsutter.com/2013/05/30/gotw-91-smart-pointer-parameters/#comment-10751</link>
		<dc:creator><![CDATA[Ben Craig]]></dc:creator>
		<pubDate>Fri, 31 May 2013 00:52:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2070#comment-10751</guid>
					<description><![CDATA[(a) and (b) are likely to cause holy wars.  If there is any kind of transfer of ownership (including passing off to other threads), then (a) and (b) are not appropriate.  If (a) and (b) don&#039;t change ownership, then either can be fine.  Many people prefer (a) to (b), because it makes it more obvious at the call site that a level of indirection is involved.  Other people will prefer (b), because it makes it very difficult to have NULL pointers.

If f() is a &quot;sink&quot; function, then (c) is appropriate.  By &quot;sink&quot;, I mean a function that accepts a resource, and destroys it as part of its execution.  const unique_ptr ref doesn&#039;t buy much, but if your code stores the resource as a unique_ptr, and you have lots of calls to f(), then you can avoid some syntactic overhead by passing const unique_ptr &#038; instead of widget*.

Similar arguments for (c) and (d) apply to (e) and (f), except instead of discussing &quot;sinks&quot;, we get to discuss extra owners.  If f() needs to become an additional owner for the widget, then (e) is appropriate.  Taking the shared_ptr by value here is preferable to taking a const shared_ptr ref and copy constructing a shared_ptr, as the value parameter may get to take advantage of move semantics (perhaps from a make_shared call).  (f) has roughly the same semantics as (a) and (b), and like const unique_ptr &#038;, it can make sense when you have lots of callers of your function.  (f) makes a little more sense than (d) though, as you can decide several layers down that you need a copy / additional owner of your widget, and (f) permits that.  With a unique_ptr, you can&#039;t really decide several layers down that you should move from your const unique_ptr &#038;.

One of the downsides of (d) and (f) is that these signatures often overspecify your needs.  (a) and (b) can accept widgets from unique_ptr and shared_ptr, but (d) can only (easily) accept widgets from unique_ptr.  (f) can accept a widget from a unique_ptr, but it &quot;steals&quot; the widget, so it only works well with other shared_ptrs.

There was a &quot;dumb_ptr&quot; spec at one point, but I haven&#039;t followed standardization enough to know if it got accepted to C++14.  I&#039;m guessing not, as it would probably be mentioned by now if it had.]]></description>
		<content:encoded><![CDATA[<p>(a) and (b) are likely to cause holy wars.  If there is any kind of transfer of ownership (including passing off to other threads), then (a) and (b) are not appropriate.  If (a) and (b) don&#8217;t change ownership, then either can be fine.  Many people prefer (a) to (b), because it makes it more obvious at the call site that a level of indirection is involved.  Other people will prefer (b), because it makes it very difficult to have NULL pointers.</p>
<p>If f() is a &#8220;sink&#8221; function, then (c) is appropriate.  By &#8220;sink&#8221;, I mean a function that accepts a resource, and destroys it as part of its execution.  const unique_ptr ref doesn&#8217;t buy much, but if your code stores the resource as a unique_ptr, and you have lots of calls to f(), then you can avoid some syntactic overhead by passing const unique_ptr &amp; instead of widget*.</p>
<p>Similar arguments for (c) and (d) apply to (e) and (f), except instead of discussing &#8220;sinks&#8221;, we get to discuss extra owners.  If f() needs to become an additional owner for the widget, then (e) is appropriate.  Taking the shared_ptr by value here is preferable to taking a const shared_ptr ref and copy constructing a shared_ptr, as the value parameter may get to take advantage of move semantics (perhaps from a make_shared call).  (f) has roughly the same semantics as (a) and (b), and like const unique_ptr &amp;, it can make sense when you have lots of callers of your function.  (f) makes a little more sense than (d) though, as you can decide several layers down that you need a copy / additional owner of your widget, and (f) permits that.  With a unique_ptr, you can&#8217;t really decide several layers down that you should move from your const unique_ptr &amp;.</p>
<p>One of the downsides of (d) and (f) is that these signatures often overspecify your needs.  (a) and (b) can accept widgets from unique_ptr and shared_ptr, but (d) can only (easily) accept widgets from unique_ptr.  (f) can accept a widget from a unique_ptr, but it &#8220;steals&#8221; the widget, so it only works well with other shared_ptrs.</p>
<p>There was a &#8220;dumb_ptr&#8221; spec at one point, but I haven&#8217;t followed standardization enough to know if it got accepted to C++14.  I&#8217;m guessing not, as it would probably be mentioned by now if it had.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
