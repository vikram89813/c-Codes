<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #5 Solution: Overriding Virtual Functions	</title>
	<atom:link href="https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Heterogeneous vector in c++ - overview of common approaches &#124; Мои IT-заметки				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-29001</link>
		<dc:creator><![CDATA[Heterogeneous vector in c++ - overview of common approaches &#124; Мои IT-заметки]]></dc:creator>
		<pubDate>Fri, 03 Oct 2014 16:25:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-29001</guid>
					<description><![CDATA[[&#8230;] First, read about differences between overriding and hiding of methods in inheritance hierarchy here or here. It is a great source of confusion, especially during investigation of fresh bug-reports. [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] First, read about differences between overriding and hiding of methods in inheritance hierarchy here or here. It is a great source of confusion, especially during investigation of fresh bug-reports. [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: suppressingfire				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-20430</link>
		<dc:creator><![CDATA[suppressingfire]]></dc:creator>
		<pubDate>Wed, 21 May 2014 21:58:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-20430</guid>
					<description><![CDATA[Hmm... I like using final like this:

[code]
class base {
 public:
  virtual ~base() = default;
  virtual void foo() = 0;
 protected:
  base() = default;
}

class derived final : public base {
 public:
  derived() = default;
  ~derived() = default;
  void foo() override { /* do foo */ }
}

and then use it like this:

std::unique_ptr&#060;base&#062; bar = make_unique&#060;derived&#062;();
bar-&#062;foo();
[/code]

Am I evil/misguided/leading my codebase down the primrose path?]]></description>
		<content:encoded><![CDATA[<p>Hmm&#8230; I like using final like this:</p>
<pre class="brush: plain; title: ; notranslate">
class base {
 public:
  virtual ~base() = default;
  virtual void foo() = 0;
 protected:
  base() = default;
}

class derived final : public base {
 public:
  derived() = default;
  ~derived() = default;
  void foo() override { /* do foo */ }
}

and then use it like this:

std::unique_ptr&lt;base&gt; bar = make_unique&lt;derived&gt;();
bar-&gt;foo();
</pre>
<p>Am I evil/misguided/leading my codebase down the primrose path?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Use cases for final classes &#124; Technology &#38; Programming				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-13218</link>
		<dc:creator><![CDATA[Use cases for final classes &#124; Technology &#38; Programming]]></dc:creator>
		<pubDate>Wed, 13 Nov 2013 11:24:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-13218</guid>
					<description><![CDATA[[&#8230;] was reading comments on Herb Sutter&#8217;s Guru of the Week redux about virtual functions, and finally saw him [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] was reading comments on Herb Sutter&#8217;s Guru of the Week redux about virtual functions, and finally saw him [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Overloading base method in derived class &#124; Technology &#38; Programming				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-13206</link>
		<dc:creator><![CDATA[Overloading base method in derived class &#124; Technology &#38; Programming]]></dc:creator>
		<pubDate>Tue, 12 Nov 2013 09:20:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-13206</guid>
					<description><![CDATA[[&#8230;] I was playing with C# to see if it matched C++ behavior from this post: https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/ when I came across this very strange [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] I was playing with C# to see if it matched C++ behavior from this post: <a href="https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/" rel="nofollow">https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/</a> when I came across this very strange [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10657</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Wed, 29 May 2013 19:22:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10657</guid>
					<description><![CDATA[or else it isn’t, in which case the function has to be protected (private is not allowed because the derived destructor must be able to invoke the base destructor) and would naturally also be nonvirtual (when the derived destructor invokes the base destructor, it does so nonvirtually whether declared virtual or not).

why it cant be public ? Doesnt placement new/delete require that(lets pretend that some crazy person wants to put polymorphic object in char[compile_time_max(sizeof (Base), sizeof (Der1),sizeof (Der2)...]
 :P]]></description>
		<content:encoded><![CDATA[<p>or else it isn’t, in which case the function has to be protected (private is not allowed because the derived destructor must be able to invoke the base destructor) and would naturally also be nonvirtual (when the derived destructor invokes the base destructor, it does so nonvirtually whether declared virtual or not).</p>
<p>why it cant be public ? Doesnt placement new/delete require that(lets pretend that some crazy person wants to put polymorphic object in char[compile_time_max(sizeof (Base), sizeof (Der1),sizeof (Der2)&#8230;]<br />
 :P</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Urman				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10591</link>
		<dc:creator><![CDATA[Michael Urman]]></dc:creator>
		<pubDate>Wed, 29 May 2013 01:55:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10591</guid>
					<description><![CDATA[@rhalbersma as an example of such a scoped guard see GotW 6b, part 6, option 1. 
[code]
{
    auto lock = std::unique_lock&#060;mutex&#062;{mutables};
    ::: // no further references to lock
    // lock destroyed; mutables released
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>@rhalbersma as an example of such a scoped guard see GotW 6b, part 6, option 1. </p>
<pre class="brush: plain; title: ; notranslate">
{
    auto lock = std::unique_lock&lt;mutex&gt;{mutables};
    ::: // no further references to lock
    // lock destroyed; mutables released
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Rick Yorgason				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10581</link>
		<dc:creator><![CDATA[Rick Yorgason]]></dc:creator>
		<pubDate>Wed, 29 May 2013 00:08:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10581</guid>
					<description><![CDATA[The one thing I&#039;ve found final useful for is for marking when functions in base classes have been renamed or are otherwise obsolete. For instance:

[code]
class Foo
{
protected:
  virtual void bar() final {}; // Don&#039;t use this anymore. Use baz() instead.
  virtual void baz();
};
[/code]]]></description>
		<content:encoded><![CDATA[<p>The one thing I&#8217;ve found final useful for is for marking when functions in base classes have been renamed or are otherwise obsolete. For instance:</p>
<pre class="brush: plain; title: ; notranslate">
class Foo
{
protected:
  virtual void bar() final {}; // Don't use this anymore. Use baz() instead.
  virtual void baz();
};
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bhupesh Pant				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10575</link>
		<dc:creator><![CDATA[Bhupesh Pant]]></dc:creator>
		<pubDate>Tue, 28 May 2013 20:34:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10575</guid>
					<description><![CDATA[@Herb,
I am talking with reference to what Rhalbersma said. Well the suggested way by Rhalbersma is something that is also adopted by modern languages and compilers. We just do x=y or as Herb said, by mistake z=y, it will create a variable of type same as y. Then compiler can use some smart, not at all sweating mechanism to figure out whether it is a correct assignment or not...
We can take example of python, we do similar stuff in python, though its entirely differently implemented at language level but point is the ease we have with that..

@Alok &#038; Sil,

I totally agree with what you are saying  but remember Rome was  not build in a day and so will your dream language. One thing I am sure you could feel the change. Some very smart people is constantly working hard for this change, probably we could see some major changes in C++14 or C++(yet to come) ... :)]]></description>
		<content:encoded><![CDATA[<p>@Herb,<br />
I am talking with reference to what Rhalbersma said. Well the suggested way by Rhalbersma is something that is also adopted by modern languages and compilers. We just do x=y or as Herb said, by mistake z=y, it will create a variable of type same as y. Then compiler can use some smart, not at all sweating mechanism to figure out whether it is a correct assignment or not&#8230;<br />
We can take example of python, we do similar stuff in python, though its entirely differently implemented at language level but point is the ease we have with that..</p>
<p>@Alok &amp; Sil,</p>
<p>I totally agree with what you are saying  but remember Rome was  not build in a day and so will your dream language. One thing I am sure you could feel the change. Some very smart people is constantly working hard for this change, probably we could see some major changes in C++14 or C++(yet to come) &#8230; :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10523</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Tue, 28 May 2013 01:35:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10523</guid>
					<description><![CDATA[@Ricardo Costa: thanks for the link.  It&#039;s actually quite apt for me.  I do already have a decimal type created (using the decNumber C library) with the intention it could be cut over to built-in types eventually - so I do now see the possible applicability of &quot;final&quot; for library code.]]></description>
		<content:encoded><![CDATA[<p>@Ricardo Costa: thanks for the link.  It&#8217;s actually quite apt for me.  I do already have a decimal type created (using the decNumber C library) with the intention it could be cut over to built-in types eventually &#8211; so I do now see the possible applicability of &#8220;final&#8221; for library code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Why initialize unique_ptr with a make_unique call? &#124; BlogoSfera				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10501</link>
		<dc:creator><![CDATA[Why initialize unique_ptr with a make_unique call? &#124; BlogoSfera]]></dc:creator>
		<pubDate>Mon, 27 May 2013 15:02:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10501</guid>
					<description><![CDATA[[&#8230;] Taken from: https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/ [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Taken from: <a href="https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/" rel="nofollow">https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/</a> [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10475</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Sun, 26 May 2013 20:38:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10475</guid>
					<description><![CDATA[I hope I don&#039;t :) I just want to point out (to Herb) that instead of the verbosity of
auto pb = unique_ptr{ make_unique() };
I find it better to have a guideline to use auto if there is no conversion during initialization, and write the type if there is. Or rephrasing:
Use auto whenever you can, write the type only if you must.

(&quot;meh&quot; is no english word, try to read it with some disapproval in your voice :) )]]></description>
		<content:encoded><![CDATA[<p>I hope I don&#8217;t :) I just want to point out (to Herb) that instead of the verbosity of<br />
auto pb = unique_ptr{ make_unique() };<br />
I find it better to have a guideline to use auto if there is no conversion during initialization, and write the type if there is. Or rephrasing:<br />
Use auto whenever you can, write the type only if you must.</p>
<p>(&#8220;meh&#8221; is no english word, try to read it with some disapproval in your voice :) )</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Pelliccioni				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10470</link>
		<dc:creator><![CDATA[Fernando Pelliccioni]]></dc:creator>
		<pubDate>Sun, 26 May 2013 18:32:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10470</guid>
					<description><![CDATA[@Róbert Dávid:

&quot;Meh&quot;? Sorry, I am not native English speaker.

I know that. You didn&#039;t need to explain. :)

I was just trying to simplify the code of Herb.

[code]
auto pb = unique_ptr&#060;Base&#062;{ make_unique&#060;Derived&#062;() };
[/code]]]></description>
		<content:encoded><![CDATA[<p>@Róbert Dávid:</p>
<p>&#8220;Meh&#8221;? Sorry, I am not native English speaker.</p>
<p>I know that. You didn&#8217;t need to explain. :)</p>
<p>I was just trying to simplify the code of Herb.</p>
<pre class="brush: plain; title: ; notranslate">
auto pb = unique_ptr&lt;Base&gt;{ make_unique&lt;Derived&gt;() };
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10435</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Sat, 25 May 2013 15:30:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10435</guid>
					<description><![CDATA[@Fernando Pelliccioni:
Meh. Just use the plain old
[code]std::unique_ptr&#060;Base&#062; pb = std::make_unique&#060;Derived&#062;();[/code]
If you are using &#039;auto&#039; for variables that have the same type as the initializer consistently, it will be obvious that there is a conversion here, and 
[code]auto pd = std::make_unique&#060;Derived&#062;();[/code]
has no conversion.]]></description>
		<content:encoded><![CDATA[<p>@Fernando Pelliccioni:<br />
Meh. Just use the plain old</p>
<pre class="brush: plain; title: ; notranslate">std::unique_ptr&lt;Base&gt; pb = std::make_unique&lt;Derived&gt;();</pre>
<p>If you are using &#8216;auto&#8217; for variables that have the same type as the initializer consistently, it will be obvious that there is a conversion here, and </p>
<pre class="brush: plain; title: ; notranslate">auto pd = std::make_unique&lt;Derived&gt;();</pre>
<p>has no conversion.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ricardo Costa				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10425</link>
		<dc:creator><![CDATA[Ricardo Costa]]></dc:creator>
		<pubDate>Sat, 25 May 2013 10:03:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10425</guid>
					<description><![CDATA[@GeoffW You may want to check this article http://akrzemi1.wordpress.com/2012/09/30/why-make-your-classes-final/ and especially the discussion in the comments section.

@rhalbersma As jhasse pointed out, you wouldn&#039;t be able to shadow variables:

[code]
auto x = 1;
{
    auto x = 2;
}
// x == 1 again
[/code]]]></description>
		<content:encoded><![CDATA[<p>@GeoffW You may want to check this article <a href="http://akrzemi1.wordpress.com/2012/09/30/why-make-your-classes-final/" rel="nofollow">http://akrzemi1.wordpress.com/2012/09/30/why-make-your-classes-final/</a> and especially the discussion in the comments section.</p>
<p>@rhalbersma As jhasse pointed out, you wouldn&#8217;t be able to shadow variables:</p>
<pre class="brush: plain; title: ; notranslate">
auto x = 1;
{
    auto x = 2;
}
// x == 1 again
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando Pelliccioni				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10414</link>
		<dc:creator><![CDATA[Fernando Pelliccioni]]></dc:creator>
		<pubDate>Fri, 24 May 2013 19:44:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10414</guid>
					<description><![CDATA[Hi Herb,

I think

[code]
auto pb = std::unique_ptr&#060;Base&#062;{ std::make_unique&#060;Derived&#062;() };
[/code]

is too verbose. Unique is repeated...

How about this library solution for C++14 or C++17 ?

[code]
auto pb = make_unique_poly&#060;base, derived&#062;();
[/code]

Regards,
Fernando.]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>I think</p>
<pre class="brush: plain; title: ; notranslate">
auto pb = std::unique_ptr&lt;Base&gt;{ std::make_unique&lt;Derived&gt;() };
</pre>
<p>is too verbose. Unique is repeated&#8230;</p>
<p>How about this library solution for C++14 or C++17 ?</p>
<pre class="brush: plain; title: ; notranslate">
auto pb = make_unique_poly&lt;base, derived&gt;();
</pre>
<p>Regards,<br />
Fernando.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10406</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Fri, 24 May 2013 17:59:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10406</guid>
					<description><![CDATA[@Michael Urman: can you give a code example on how this scoped guard variable would occur?]]></description>
		<content:encoded><![CDATA[<p>@Michael Urman: can you give a code example on how this scoped guard variable would occur?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: S. Colcord				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10403</link>
		<dc:creator><![CDATA[S. Colcord]]></dc:creator>
		<pubDate>Fri, 24 May 2013 16:44:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10403</guid>
					<description><![CDATA[@Herb:  &quot;No, you still need a tag&quot;

I wonder, though, if there might be some specific contexts in which the &#039;auto&#039; could be inferred if omitted, because you already know it&#039;s a declaration.  For example, within a &#039;for-range&#039;declaration&#039;.  This would allow the nicely concise syntax:

for ( i : mycontainer) {}]]></description>
		<content:encoded><![CDATA[<p>@Herb:  &#8220;No, you still need a tag&#8221;</p>
<p>I wonder, though, if there might be some specific contexts in which the &#8216;auto&#8217; could be inferred if omitted, because you already know it&#8217;s a declaration.  For example, within a &#8216;for-range&#8217;declaration&#8217;.  This would allow the nicely concise syntax:</p>
<p>for ( i : mycontainer) {}</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Michael Urman				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10400</link>
		<dc:creator><![CDATA[Michael Urman]]></dc:creator>
		<pubDate>Fri, 24 May 2013 16:32:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10400</guid>
					<description><![CDATA[@rhalsbersma how would you differentiate between an unreferenced variable whose implicit declaration was due to a typo and an unreferenced variable whose lack of later reference is due to it being a scoped guard?]]></description>
		<content:encoded><![CDATA[<p>@rhalsbersma how would you differentiate between an unreferenced variable whose implicit declaration was due to a typo and an unreferenced variable whose lack of later reference is due to it being a scoped guard?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: javierestrada				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10397</link>
		<dc:creator><![CDATA[javierestrada]]></dc:creator>
		<pubDate>Fri, 24 May 2013 16:01:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10397</guid>
					<description><![CDATA[Herb, 

In the guideline:

Guideline: Prefer to have a class contain only public virtual functions, or no public virtual functions (other than the destructor which is special).

It is unclear that protected virtual functions are possible and useful (protected interface) common in streams and a design pattern itself.  Now, &quot;no public virtual functions&quot; can cover this usage of virtual functions, but it&#039;s subtle.

When you say:

&quot;A pure abstract base class should have only public virtual functions. …&quot;

Section 10.4 [class.abstract] only goes as far as defining an abstract class (neither pure nor &quot;impure&quot;) as a class with at least one pure virtual function. Since you can&#039;t instantiate them, it follows that they can only be used as base classes.  I think the sentence could be clearer if it were reworded as:

&quot;An abstract class with only pure virtual functions should have those functions be public.&quot;

This leaves open cases where you want an abstract class to have a public interface where it can control pre/post conditions and then call a protected virtual function on a derived class (I use this technique extensively in large telephony frameworks in C++ and C#):

[code]
class Call
{
  public:
    Drop()  { 
      // check preconditions, acquire locks, etc.,
      OnDrop();
     // check postconditions, release locks, etc.
    }

  protected:
    virtual void OnDrop() = 0;
...
};

class MyCall : public Call
{
...
protected:
  override void OnDrop() { ...}
};
[/code]

Regards,

--Javier Estrada]]></description>
		<content:encoded><![CDATA[<p>Herb, </p>
<p>In the guideline:</p>
<p>Guideline: Prefer to have a class contain only public virtual functions, or no public virtual functions (other than the destructor which is special).</p>
<p>It is unclear that protected virtual functions are possible and useful (protected interface) common in streams and a design pattern itself.  Now, &#8220;no public virtual functions&#8221; can cover this usage of virtual functions, but it&#8217;s subtle.</p>
<p>When you say:</p>
<p>&#8220;A pure abstract base class should have only public virtual functions. …&#8221;</p>
<p>Section 10.4 [class.abstract] only goes as far as defining an abstract class (neither pure nor &#8220;impure&#8221;) as a class with at least one pure virtual function. Since you can&#8217;t instantiate them, it follows that they can only be used as base classes.  I think the sentence could be clearer if it were reworded as:</p>
<p>&#8220;An abstract class with only pure virtual functions should have those functions be public.&#8221;</p>
<p>This leaves open cases where you want an abstract class to have a public interface where it can control pre/post conditions and then call a protected virtual function on a derived class (I use this technique extensively in large telephony frameworks in C++ and C#):</p>
<pre class="brush: plain; title: ; notranslate">
class Call
{
  public:
    Drop()  { 
      // check preconditions, acquire locks, etc.,
      OnDrop();
     // check postconditions, release locks, etc.
    }

  protected:
    virtual void OnDrop() = 0;
...
};

class MyCall : public Call
{
...
protected:
  override void OnDrop() { ...}
};
</pre>
<p>Regards,</p>
<p>&#8211;Javier Estrada</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sil				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10390</link>
		<dc:creator><![CDATA[Sil]]></dc:creator>
		<pubDate>Fri, 24 May 2013 08:25:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10390</guid>
					<description><![CDATA[@Alok I tend to agree with you that c++ can be extremely hard to understand and to program correctly and as expected without a very sizeable time investment. I also wonder how and if it could be made even simpler and safer than the progresses in 11.

On the other hand isn&#039;t it because it is used to design and architect a solution? i.e. if not in the C++ language itself there is still hard thinking to do and to implement for non trivial solutions, notably for modules or libraries, and this hard thinking has to be translated somehow, in guidelines or coding patterns or APIs for example, that will also have to be understood, implemented, checked and that will probably have pitfalls and tricky parts.

Is auto pb = unique_ptr{ make_unique() }; a trivial statement? No but should it be used very often in a real life scenario? Probably not.]]></description>
		<content:encoded><![CDATA[<p>@Alok I tend to agree with you that c++ can be extremely hard to understand and to program correctly and as expected without a very sizeable time investment. I also wonder how and if it could be made even simpler and safer than the progresses in 11.</p>
<p>On the other hand isn&#8217;t it because it is used to design and architect a solution? i.e. if not in the C++ language itself there is still hard thinking to do and to implement for non trivial solutions, notably for modules or libraries, and this hard thinking has to be translated somehow, in guidelines or coding patterns or APIs for example, that will also have to be understood, implemented, checked and that will probably have pitfalls and tricky parts.</p>
<p>Is auto pb = unique_ptr{ make_unique() }; a trivial statement? No but should it be used very often in a real life scenario? Probably not.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alok				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10389</link>
		<dc:creator><![CDATA[Alok]]></dc:creator>
		<pubDate>Fri, 24 May 2013 05:38:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10389</guid>
					<description><![CDATA[C++ really needs fixing.

While it makes sense to use things from the standard library when it provides one, the amount of thought process that needs to go into C++ programming (whether writing C++ standard library or own code) only shows the weaknesses of the language that blocks the programmer from going into higher level reasoning fast enough.  I do not believe that the programmer (of own code or the library) has to think this hard (were the language design optimal) to express some simple concepts like this.

Just look at this:  &quot;auto pb = unique_ptr{ make_unique() };&quot;, and oh, this is after use of the auto keyword.  There are things in C++ that need to be a part of the language itself which are a part of the library instead, and vice versa.

I am waiting for the day when some other language like Go or Julia takes over.]]></description>
		<content:encoded><![CDATA[<p>C++ really needs fixing.</p>
<p>While it makes sense to use things from the standard library when it provides one, the amount of thought process that needs to go into C++ programming (whether writing C++ standard library or own code) only shows the weaknesses of the language that blocks the programmer from going into higher level reasoning fast enough.  I do not believe that the programmer (of own code or the library) has to think this hard (were the language design optimal) to express some simple concepts like this.</p>
<p>Just look at this:  &#8220;auto pb = unique_ptr{ make_unique() };&#8221;, and oh, this is after use of the auto keyword.  There are things in C++ that need to be a part of the language itself which are a part of the library instead, and vice versa.</p>
<p>I am waiting for the day when some other language like Go or Julia takes over.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jhasse				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10381</link>
		<dc:creator><![CDATA[jhasse]]></dc:creator>
		<pubDate>Thu, 23 May 2013 22:57:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10381</guid>
					<description><![CDATA[@rhalbersma
auto would make a difference since you wouldnt write it before assignments.

Also what about shadowing a variable?]]></description>
		<content:encoded><![CDATA[<p>@rhalbersma<br />
auto would make a difference since you wouldnt write it before assignments.</p>
<p>Also what about shadowing a variable?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10375</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Thu, 23 May 2013 21:01:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10375</guid>
					<description><![CDATA[@Herb: I&#039;m not really convinced by the off-by-one keyboard error. If you never reuse that variable z again, the compiler would warn (and give an error with warnings-as-errors) about an unused variable, and if you would use z again, then it might indeed silently compile and do the wrong thing, but auto wouldn&#039;t make a difference. Can you give an example of any real compiler ambiguity?]]></description>
		<content:encoded><![CDATA[<p>@Herb: I&#8217;m not really convinced by the off-by-one keyboard error. If you never reuse that variable z again, the compiler would warn (and give an error with warnings-as-errors) about an unused variable, and if you would use z again, then it might indeed silently compile and do the wrong thing, but auto wouldn&#8217;t make a difference. Can you give an example of any real compiler ambiguity?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10374</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 23 May 2013 20:43:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10374</guid>
					<description><![CDATA[@rhalbersma: No, you still need a tag, just as Pascal uses &quot;var&quot; and other languages use other tags. Otherwise, it&#039;s ambiguous or worse. For example, if &quot;x = y;&quot; could be a variable declaration, what if you mistyped x with an off-by-one keyboard error and typed &quot;z = y;&quot; instead? Then anytime you misspelled a variable on the left of an assignment the compiler would happily introduce a new variable and silently compile. Seems like a large trap. Variable declarations do need to be tagged, and four characters is very minimalistic... and unlike Pascal you can declare them anywhere in a scope.]]></description>
		<content:encoded><![CDATA[<p>@rhalbersma: No, you still need a tag, just as Pascal uses &#8220;var&#8221; and other languages use other tags. Otherwise, it&#8217;s ambiguous or worse. For example, if &#8220;x = y;&#8221; could be a variable declaration, what if you mistyped x with an off-by-one keyboard error and typed &#8220;z = y;&#8221; instead? Then anytime you misspelled a variable on the left of an assignment the compiler would happily introduce a new variable and silently compile. Seems like a large trap. Variable declarations do need to be tagged, and four characters is very minimalistic&#8230; and unlike Pascal you can declare them anywhere in a scope.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10373</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Thu, 23 May 2013 20:29:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10373</guid>
					<description><![CDATA[@Herb If **every** initialization is written in the form [code]auto x = Type { expr }; [/code], isn&#039;t that the same as saying that the auto keyword itself could be left out altogether? What parsing ambiguities could arise if it were? The compiler would only have to check if the lhs of any = token had been seen in the same scope before. Or are there some name lookup issues that would interfere with this?]]></description>
		<content:encoded><![CDATA[<p>@Herb If **every** initialization is written in the form </p>
<pre class="brush: plain; title: ; notranslate">auto x = Type { expr }; </pre>
<p>, isn&#8217;t that the same as saying that the auto keyword itself could be left out altogether? What parsing ambiguities could arise if it were? The compiler would only have to check if the lhs of any = token had been seen in the same scope before. Or are there some name lookup issues that would interfere with this?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10367</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Thu, 23 May 2013 17:03:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10367</guid>
					<description><![CDATA[Yuck! That looks messed up, seems I&#039;m too used to SO. Are there in-line code tags for comments like in the blog post itself?]]></description>
		<content:encoded><![CDATA[<p>Yuck! That looks messed up, seems I&#8217;m too used to SO. Are there in-line code tags for comments like in the blog post itself?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10366</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Thu, 23 May 2013 16:48:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10366</guid>
					<description><![CDATA[On the [code]pb-&#062;f(1.0);[/code] you stress that overload resolution is done on the static type. I think the more surprising part for at least some people will be that having declared [code]f[/code] virtual has no effect on the result because as you stated earlier [code]f[/code] is not overridden but only hidden in [code]derived[/code], so the virtual function dispatch will still call [code]base::f(double)[/code].]]></description>
		<content:encoded><![CDATA[<p>On the </p>
<pre class="brush: plain; title: ; notranslate">pb-&gt;f(1.0);</pre>
<p> you stress that overload resolution is done on the static type. I think the more surprising part for at least some people will be that having declared </p>
<pre class="brush: plain; title: ; notranslate">f</pre>
<p> virtual has no effect on the result because as you stated earlier </p>
<pre class="brush: plain; title: ; notranslate">f</pre>
<p> is not overridden but only hidden in </p>
<pre class="brush: plain; title: ; notranslate">derived</pre>
<p>, so the virtual function dispatch will still call </p>
<pre class="brush: plain; title: ; notranslate">base::f(double)</pre>
<p>.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Caleb Huitt				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10361</link>
		<dc:creator><![CDATA[Caleb Huitt]]></dc:creator>
		<pubDate>Thu, 23 May 2013 14:49:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10361</guid>
					<description><![CDATA[@Simon, @Arthur, and @Herb: You are all correct that I missed the slight change in semantics.

For the learning purposes, then, I like Herb&#039;s modified line, because it is more explicit about what is happening as well as a) reinforcing that auto should be used for things like this, and b) points out that a conversion is happening.  I admit my eyes glazed over the first template specification, assuming a compatible result with make_unique.

If I was actually reviewing a similar line in code, I&#039;d expect auto to be used (or possibly to be assigned to a class member variable, which opens up different typing considerations).]]></description>
		<content:encoded><![CDATA[<p>@Simon, @Arthur, and @Herb: You are all correct that I missed the slight change in semantics.</p>
<p>For the learning purposes, then, I like Herb&#8217;s modified line, because it is more explicit about what is happening as well as a) reinforcing that auto should be used for things like this, and b) points out that a conversion is happening.  I admit my eyes glazed over the first template specification, assuming a compatible result with make_unique.</p>
<p>If I was actually reviewing a similar line in code, I&#8217;d expect auto to be used (or possibly to be assigned to a class member variable, which opens up different typing considerations).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10359</link>
		<dc:creator><![CDATA[Mike]]></dc:creator>
		<pubDate>Thu, 23 May 2013 14:25:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10359</guid>
					<description><![CDATA[[code]Guideline: Avoid default arguments on virtual functions in general.[/code]

This needs to be more than just a guideline.  It needs to be a _rule_.  

It&#039;s just never a good idea.  This is why function overloading exists.]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">Guideline: Avoid default arguments on virtual functions in general.</pre>
<p>This needs to be more than just a guideline.  It needs to be a _rule_.  </p>
<p>It&#8217;s just never a good idea.  This is why function overloading exists.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10358</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 23 May 2013 14:25:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10358</guid>
					<description><![CDATA[@GeoffW: Re “uses of final are rarer” – well, they sort of are. I don’t know of many, and during standardization Bjarne repeatedly asked for examples of problems it solved and patterns where it should be used, and I don’t recall any major ones that stood out. The only one I know of offhand is that if you’re defining a library module (which isn’t a Standard concept yet) then making leaf classes final can give the compiler more information to devirtualize calls because of knowing code outside the library won’t further derive, but I’m not sure how important that is these days in the presence of whole program optimization including aggressive devirtualization.

@Johan: Okay, you guys are convincing me that maybe I&#039;m worrying too much about acceptance of &#039;auto everywhere.&#039; The reason I worried is because it&#039;s a lightning rod issue that takes an amazing amount of energy in most C++11 overview sessions. Even on this blog when I announced I was restarting GotW and XC++, NEARLY EVERY comment on Reddit was about auto, which was mentioned only once in passing deep in the middle of the post. That&#039;s all they could talk about. So I was leaning toward easing people into it, with a view of &quot;you really need to get used to using auto frequently or at least consider it&quot; while trying to avoid a brusque &quot;this is the new way, get over it&quot;... but okay, I&#039;ve gone ahead with this change. Thanks for the feedback.]]></description>
		<content:encoded><![CDATA[<p>@GeoffW: Re “uses of final are rarer” – well, they sort of are. I don’t know of many, and during standardization Bjarne repeatedly asked for examples of problems it solved and patterns where it should be used, and I don’t recall any major ones that stood out. The only one I know of offhand is that if you’re defining a library module (which isn’t a Standard concept yet) then making leaf classes final can give the compiler more information to devirtualize calls because of knowing code outside the library won’t further derive, but I’m not sure how important that is these days in the presence of whole program optimization including aggressive devirtualization.</p>
<p>@Johan: Okay, you guys are convincing me that maybe I&#8217;m worrying too much about acceptance of &#8216;auto everywhere.&#8217; The reason I worried is because it&#8217;s a lightning rod issue that takes an amazing amount of energy in most C++11 overview sessions. Even on this blog when I announced I was restarting GotW and XC++, NEARLY EVERY comment on Reddit was about auto, which was mentioned only once in passing deep in the middle of the post. That&#8217;s all they could talk about. So I was leaning toward easing people into it, with a view of &#8220;you really need to get used to using auto frequently or at least consider it&#8221; while trying to avoid a brusque &#8220;this is the new way, get over it&#8221;&#8230; but okay, I&#8217;ve gone ahead with this change. Thanks for the feedback.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johan Oudinet				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10352</link>
		<dc:creator><![CDATA[Johan Oudinet]]></dc:creator>
		<pubDate>Thu, 23 May 2013 11:27:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10352</guid>
					<description><![CDATA[I vote for 
[code]auto pb = unique_ptr&#060;base&#062;{ make_unique&#060;derived&#062;() };[/code]

I also like the improvement in both being conformed to the style of using auto as much as possible and seeing, in a more obvious way, the &quot;conversion&quot; from derived to base.
Besides, since you are rewritting all GotW with the C++14 style, you shouldn&#039;t be afraid by being unusual to most people&#039;s eyes (i.e., people familiar with pre-C++14 style). On the contrary, not using auto to declare a variable seems unusual to me now.]]></description>
		<content:encoded><![CDATA[<p>I vote for </p>
<pre class="brush: plain; title: ; notranslate">auto pb = unique_ptr&lt;base&gt;{ make_unique&lt;derived&gt;() };</pre>
<p>I also like the improvement in both being conformed to the style of using auto as much as possible and seeing, in a more obvious way, the &#8220;conversion&#8221; from derived to base.<br />
Besides, since you are rewritting all GotW with the C++14 style, you shouldn&#8217;t be afraid by being unusual to most people&#8217;s eyes (i.e., people familiar with pre-C++14 style). On the contrary, not using auto to declare a variable seems unusual to me now.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Overloading base method in derived class &#124; BlogoSfera				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10350</link>
		<dc:creator><![CDATA[Overloading base method in derived class &#124; BlogoSfera]]></dc:creator>
		<pubDate>Thu, 23 May 2013 10:02:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10350</guid>
					<description><![CDATA[[&#8230;] I was playing with C# to see if it matched C++ behavior from this post: https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/ when I came across this very strange [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] I was playing with C# to see if it matched C++ behavior from this post: <a href="https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/" rel="nofollow">https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/</a> when I came across this very strange [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GeoffW				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10340</link>
		<dc:creator><![CDATA[GeoffW]]></dc:creator>
		<pubDate>Thu, 23 May 2013 01:39:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10340</guid>
					<description><![CDATA[I don&#039;t mean to be picky (well, maybe I do), but is &quot;uses for final are rarer&quot; the most that can be said for &quot;final&quot;?  On seeing the original JG question I had sort of hoped for more (the question did ask: &quot;Why are they useful?&quot;).  Maybe something about the sort of design situations that it was intended to aid - it must have been introduced into the standard for a reason.]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t mean to be picky (well, maybe I do), but is &#8220;uses for final are rarer&#8221; the most that can be said for &#8220;final&#8221;?  On seeing the original JG question I had sort of hoped for more (the question did ask: &#8220;Why are they useful?&#8221;).  Maybe something about the sort of design situations that it was intended to aid &#8211; it must have been introduced into the standard for a reason.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lachlan Brad Easton				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10339</link>
		<dc:creator><![CDATA[Lachlan Brad Easton]]></dc:creator>
		<pubDate>Thu, 23 May 2013 00:19:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10339</guid>
					<description><![CDATA[Yeah it was mentioned in an earlier post that C++14 would be targeted.]]></description>
		<content:encoded><![CDATA[<p>Yeah it was mentioned in an earlier post that C++14 would be targeted.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: TheMatto				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10338</link>
		<dc:creator><![CDATA[TheMatto]]></dc:creator>
		<pubDate>Thu, 23 May 2013 00:01:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10338</guid>
					<description><![CDATA[make_unique: are we using C++1y here?]]></description>
		<content:encoded><![CDATA[<p>make_unique: are we using C++1y here?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: TheMatto				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10336</link>
		<dc:creator><![CDATA[TheMatto]]></dc:creator>
		<pubDate>Wed, 22 May 2013 23:58:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10336</guid>
					<description><![CDATA[Clarification: Where did make_unique come from? C++1y?]]></description>
		<content:encoded><![CDATA[<p>Clarification: Where did make_unique come from? C++1y?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bjarke Hammersholt Roune				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10335</link>
		<dc:creator><![CDATA[Bjarke Hammersholt Roune]]></dc:creator>
		<pubDate>Wed, 22 May 2013 23:49:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10335</guid>
					<description><![CDATA[When you are using NVI for a base class A with a function foo(), and a sub class B wants to call foo() on itself, does B call the public or private version of foo()? It seems to me that the answer to that depends on what A is doing in the public foo() and the needs of B - if B needs A to do what it does in the public interface, then B should call the public interface and otherwise B should call the private interface. If that is true, then NVI creates a new source of bugs where sub class writers now have the option of calling the wrong interface. Is NVI normally done in some way that side-steps this issue?]]></description>
		<content:encoded><![CDATA[<p>When you are using NVI for a base class A with a function foo(), and a sub class B wants to call foo() on itself, does B call the public or private version of foo()? It seems to me that the answer to that depends on what A is doing in the public foo() and the needs of B &#8211; if B needs A to do what it does in the public interface, then B should call the public interface and otherwise B should call the private interface. If that is true, then NVI creates a new source of bugs where sub class writers now have the option of calling the wrong interface. Is NVI normally done in some way that side-steps this issue?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10332</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 22 May 2013 23:33:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10332</guid>
					<description><![CDATA[Yep, at least three times I had to stop myself from &quot;fixing&quot; that line to say [code]auto pb = make_unique&#060;derived&#062;();[/code] which would actually have resolved a few problems (or at least changed them) but wouldn&#039;t have preserved the semantics of the question. To preserve the semantics, I stuck with [code] unique_ptr&#060;base&#062; pb = make_unique&#060;derived&#062;(); [/code]

However, I was actually _this_ close to applying the style I currently prefer of &quot;auto var = Type{ expr };&quot; for conversions, which in this case would be only very slightly more wordy

[code] auto pb = unique_ptr&#060;base&#062;{ make_unique&#060;derived&#062;() }; [/code]

I held back mainly because that style is still unusual to most people&#039;s eyes and seeing the unique_ptr and the make_unique strung that close together might take some getting used to for readers... but now that I look at it, it does have the advantage of being very nice and explicit about what&#039;s going on! Hmm. The more I look at it, the more I&#039;m liking it...]]></description>
		<content:encoded><![CDATA[<p>Yep, at least three times I had to stop myself from &#8220;fixing&#8221; that line to say </p>
<pre class="brush: plain; title: ; notranslate">auto pb = make_unique&lt;derived&gt;();</pre>
<p> which would actually have resolved a few problems (or at least changed them) but wouldn&#8217;t have preserved the semantics of the question. To preserve the semantics, I stuck with </p>
<pre class="brush: plain; title: ; notranslate"> unique_ptr&lt;base&gt; pb = make_unique&lt;derived&gt;(); </pre>
<p>However, I was actually _this_ close to applying the style I currently prefer of &#8220;auto var = Type{ expr };&#8221; for conversions, which in this case would be only very slightly more wordy</p>
<pre class="brush: plain; title: ; notranslate"> auto pb = unique_ptr&lt;base&gt;{ make_unique&lt;derived&gt;() }; </pre>
<p>I held back mainly because that style is still unusual to most people&#8217;s eyes and seeing the unique_ptr and the make_unique strung that close together might take some getting used to for readers&#8230; but now that I look at it, it does have the advantage of being very nice and explicit about what&#8217;s going on! Hmm. The more I look at it, the more I&#8217;m liking it&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10330</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 22 May 2013 23:12:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10330</guid>
					<description><![CDATA[@KrzaQ: Yup, : should be :: -- fixed, thanks.

@mttpd: Yup, fixed. The original GotW had &quot;void main()&quot; and made a pedantic point about its conformance, and I decided it was a distraction and removed it by changing it to &quot;int main()&quot; in the question, but forgot to also update the solution.]]></description>
		<content:encoded><![CDATA[<p>@KrzaQ: Yup, : should be :: &#8212; fixed, thanks.</p>
<p>@mttpd: Yup, fixed. The original GotW had &#8220;void main()&#8221; and made a pedantic point about its conformance, and I decided it was a distraction and removed it by changing it to &#8220;int main()&#8221; in the question, but forgot to also update the solution.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10328</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Wed, 22 May 2013 21:08:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10328</guid>
					<description><![CDATA[[code]void main()[/code] -- ouch! I don&#039;t think this was really intended here! ;-)]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">void main()</pre>
<p> &#8212; ouch! I don&#8217;t think this was really intended here! ;-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arthur Langereis				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10325</link>
		<dc:creator><![CDATA[Arthur Langereis]]></dc:creator>
		<pubDate>Wed, 22 May 2013 20:24:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10325</guid>
					<description><![CDATA[@Caleb, he&#039;s explicit here as make_unique would return a unique_ptr to derived, not to base, which is what he wants here and which is the equivalent of the original code.]]></description>
		<content:encoded><![CDATA[<p>@Caleb, he&#8217;s explicit here as make_unique would return a unique_ptr to derived, not to base, which is what he wants here and which is the equivalent of the original code.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: KrzaQ				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10323</link>
		<dc:creator><![CDATA[KrzaQ]]></dc:creator>
		<pubDate>Wed, 22 May 2013 20:04:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10323</guid>
					<description><![CDATA[I&#039;m pretty sure that [code]base:f;[/code] should be [code]base::f;[/code] in &quot;Well, remember that derived doesn’t declare using base:f; to bring the base functions named f into scope&quot;. I&#039;m sorry if this isn&#039;t the way to report typos.

While I&#039;m at it, let me thank you for restarting  GotW, I find your challenges stimulating.]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m pretty sure that </p>
<pre class="brush: plain; title: ; notranslate">base:f;</pre>
<p> should be </p>
<pre class="brush: plain; title: ; notranslate">base::f;</pre>
<p> in &#8220;Well, remember that derived doesn’t declare using base:f; to bring the base functions named f into scope&#8221;. I&#8217;m sorry if this isn&#8217;t the way to report typos.</p>
<p>While I&#8217;m at it, let me thank you for restarting  GotW, I find your challenges stimulating.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon L				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10319</link>
		<dc:creator><![CDATA[Simon L]]></dc:creator>
		<pubDate>Wed, 22 May 2013 19:39:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10319</guid>
					<description><![CDATA[Apologies, that was meant to read that on the second line pb&#039;s type will be

[code]unique_ptr&#060;derived&#062;[/code]]]></description>
		<content:encoded><![CDATA[<p>Apologies, that was meant to read that on the second line pb&#8217;s type will be</p>
<pre class="brush: plain; title: ; notranslate">unique_ptr&lt;derived&gt;</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Simon L				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10318</link>
		<dc:creator><![CDATA[Simon L]]></dc:creator>
		<pubDate>Wed, 22 May 2013 19:38:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10318</guid>
					<description><![CDATA[Caleb, in your two lines the type of pb will be different. in the second line it will be a unique_ptr. If that&#039;s what you want, fine, but it&#039;s not the same as the first line, which includes an implicit conversion.]]></description>
		<content:encoded><![CDATA[<p>Caleb, in your two lines the type of pb will be different. in the second line it will be a unique_ptr. If that&#8217;s what you want, fine, but it&#8217;s not the same as the first line, which includes an implicit conversion.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Caleb Huitt				</title>
				<link>https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/#comment-10317</link>
		<dc:creator><![CDATA[Caleb Huitt]]></dc:creator>
		<pubDate>Wed, 22 May 2013 19:27:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=1984#comment-10317</guid>
					<description><![CDATA[Surely given your previous comments (and my own lazy inclinations), this line:
[code] unique_ptr&#060;base&#062; pb = make_unique&#060;derived&#062;();[/code]
could become:
[code] auto pb = make_unique&#060;derived&#062;();[/code]]]></description>
		<content:encoded><![CDATA[<p>Surely given your previous comments (and my own lazy inclinations), this line:</p>
<pre class="brush: plain; title: ; notranslate"> unique_ptr&lt;base&gt; pb = make_unique&lt;derived&gt;();</pre>
<p>could become:</p>
<pre class="brush: plain; title: ; notranslate"> auto pb = make_unique&lt;derived&gt;();</pre>
]]></content:encoded>
					</item>
			</channel>
</rss>
