<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Visual C++ Compiler November 2013 CTP	</title>
	<atom:link href="https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: &#22825;&#40857;&#20843;&#37096;&#24320;&#31169;&#26381;&#19968;&#26465;&#40857;&#26381;&#21153;				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-36675</link>
		<dc:creator><![CDATA[&#22825;&#40857;&#20843;&#37096;&#24320;&#31169;&#26381;&#19968;&#26465;&#40857;&#26381;&#21153;]]></dc:creator>
		<pubDate>Tue, 17 Mar 2015 14:52:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-36675</guid>
					<description><![CDATA[&#39118;&#20113;&#38596;&#38712;&#22825;&#19979;&#26381;&#21153;&#31471;&#22825;&#20043;&#28860;&#29425;&#19968;&#26465;&#40857;&#22823;&#35805;&#35199;&#28216;&#26381;&#21153;&#31471;&#31934;&#28789;&#22797;&#20852;&#26381;&#21153;&#31471;
&#21170;&#33310;&#22242;&#31169;&#26381;&#24320;&#26381;&#28909;&#34880;&#27743;&#28246;&#31169;&#26381;&#24320;&#26381;&#20506;&#22825;I&#31169;&#26381;&#24320;&#26381;&#32593;&#39029;&#28216;&#25103;&#31169;&#26381;&#24320;&#26381;&#22825;&#22530;2&#31169;&#26381;&#24320;&#26381;
&#39569;&#22763;&#24320;&#21306;&#19968;&#26465;&#40857;&#22825;&#19978;&#30865;&#24320;&#21306;&#19968;&#26465;&#40857;&#32654;&#20029;&#19990;&#30028;&#24320;&#21306;&#19968;&#26465;&#40857;&#31185;&#27931;&#26031;&#24320;&#21306;&#19968;&#26465;&#40857;&#30707;&#22120;&#26102;&#20195;&#24320;&#21306;&#19968;&#26465;&#40857;
&#22825;&#40857;&#20843;&#37096;&#24320;&#31169;&#26381;&#19968;&#26465;&#40857;&#26381;&#21153; http://www.e7if.com/]]></description>
		<content:encoded><![CDATA[<p>&#39118;&#20113;&#38596;&#38712;&#22825;&#19979;&#26381;&#21153;&#31471;&#22825;&#20043;&#28860;&#29425;&#19968;&#26465;&#40857;&#22823;&#35805;&#35199;&#28216;&#26381;&#21153;&#31471;&#31934;&#28789;&#22797;&#20852;&#26381;&#21153;&#31471;<br />
&#21170;&#33310;&#22242;&#31169;&#26381;&#24320;&#26381;&#28909;&#34880;&#27743;&#28246;&#31169;&#26381;&#24320;&#26381;&#20506;&#22825;I&#31169;&#26381;&#24320;&#26381;&#32593;&#39029;&#28216;&#25103;&#31169;&#26381;&#24320;&#26381;&#22825;&#22530;2&#31169;&#26381;&#24320;&#26381;<br />
&#39569;&#22763;&#24320;&#21306;&#19968;&#26465;&#40857;&#22825;&#19978;&#30865;&#24320;&#21306;&#19968;&#26465;&#40857;&#32654;&#20029;&#19990;&#30028;&#24320;&#21306;&#19968;&#26465;&#40857;&#31185;&#27931;&#26031;&#24320;&#21306;&#19968;&#26465;&#40857;&#30707;&#22120;&#26102;&#20195;&#24320;&#21306;&#19968;&#26465;&#40857;<br />
&#22825;&#40857;&#20843;&#37096;&#24320;&#31169;&#26381;&#19968;&#26465;&#40857;&#26381;&#21153; <a href="http://www.e7if.com/" rel="nofollow">http://www.e7if.com/</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ref-qualifiers in Visual C++ &#124; 我爱源码网				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-36539</link>
		<dc:creator><![CDATA[Ref-qualifiers in Visual C++ &#124; 我爱源码网]]></dc:creator>
		<pubDate>Thu, 05 Mar 2015 04:40:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-36539</guid>
					<description><![CDATA[[&#8230;] the other hand, this says they made it into a CTP back in [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] the other hand, this says they made it into a CTP back in [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Karl Niu				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-33070</link>
		<dc:creator><![CDATA[Karl Niu]]></dc:creator>
		<pubDate>Wed, 03 Dec 2014 00:45:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-33070</guid>
					<description><![CDATA[@Christian:

The bug you described here (defaulted move constructors don&#039;t get generated if the class member doesn&#039;t implement move semantics) has been fixed and the fix will be included in a future release of Visual Studio. Thanks for bringing the issue to our attention.]]></description>
		<content:encoded><![CDATA[<p>@Christian:</p>
<p>The bug you described here (defaulted move constructors don&#8217;t get generated if the class member doesn&#8217;t implement move semantics) has been fixed and the fix will be included in a future release of Visual Studio. Thanks for bringing the issue to our attention.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-20351</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 20 May 2014 14:37:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-20351</guid>
					<description><![CDATA[This CTP is a &quot;compiler-only&quot; CTP. As I mentioned in my past couple of Build talks, it&#039;s intended to give a &quot;P&quot;review of new features but is primarily about the batch compiler. You&#039;ll see oddities/discrepancies in the IDE, such as that Intellisense will be unchanged so the batch compiler using the CTP toolset will accept code that the IDE still gives red squigglies for.]]></description>
		<content:encoded><![CDATA[<p>This CTP is a &#8220;compiler-only&#8221; CTP. As I mentioned in my past couple of Build talks, it&#8217;s intended to give a &#8220;P&#8221;review of new features but is primarily about the batch compiler. You&#8217;ll see oddities/discrepancies in the IDE, such as that Intellisense will be unchanged so the batch compiler using the CTP toolset will accept code that the IDE still gives red squigglies for.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Javier Vera Gómez (@JVG_BCN)				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-19879</link>
		<dc:creator><![CDATA[Javier Vera Gómez (@JVG_BCN)]]></dc:creator>
		<pubDate>Mon, 12 May 2014 07:59:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-19879</guid>
					<description><![CDATA[Hi,
Is there any plan to make the debugger work properly with this CTP? I really like cool features of this CTP but its a pain trying to use the debugger. Visual Studio crashes always when deferencing a nullptr

Thanks]]></description>
		<content:encoded><![CDATA[<p>Hi,<br />
Is there any plan to make the debugger work properly with this CTP? I really like cool features of this CTP but its a pain trying to use the debugger. Visual Studio crashes always when deferencing a nullptr</p>
<p>Thanks</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: unituniverse2				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-18126</link>
		<dc:creator><![CDATA[unituniverse2]]></dc:creator>
		<pubDate>Fri, 04 Apr 2014 14:18:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-18126</guid>
					<description><![CDATA[Additional words of the previous post:
1. Using the &#039;forward&#039; in the previous post is only for convenient for discuss. Usually it should be a function that makes an rvalue-reference as the return value from itself.
2. When an rvalue-reference is actually a lvalue, it should be okay for all situation so far, let the coder fix any bad case he made. See the code bellow:
void ftest(C1 &#038;&#038; val)
{
    local1 &#038; a = val; // okay

    ...
    std::cout &#060;&#060; val.m &#060;&#060; std::endl;// OK. Access to the content of the &#039;val&#039; directly.
    std::cout &#060;&#060; a.m &#060;&#060; std::endl;// OK. Access to the content of the &#039;val&#039; through a reference to it.
}
The commented lines are different from the &#039;C1 &#038;&#038; i3 = std::forward(C1());&#039;.]]></description>
		<content:encoded><![CDATA[<p>Additional words of the previous post:<br />
1. Using the &#8216;forward&#8217; in the previous post is only for convenient for discuss. Usually it should be a function that makes an rvalue-reference as the return value from itself.<br />
2. When an rvalue-reference is actually a lvalue, it should be okay for all situation so far, let the coder fix any bad case he made. See the code bellow:<br />
void ftest(C1 &amp;&amp; val)<br />
{<br />
    local1 &amp; a = val; // okay</p>
<p>    &#8230;<br />
    std::cout &lt;&lt; val.m &lt;&lt; std::endl;// OK. Access to the content of the &#039;val&#039; directly.<br />
    std::cout &lt;&lt; a.m &lt;&lt; std::endl;// OK. Access to the content of the &#039;val&#039; through a reference to it.<br />
}<br />
The commented lines are different from the &#039;C1 &amp;&amp; i3 = std::forward(C1());&#039;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: unituniverse2				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-17872</link>
		<dc:creator><![CDATA[unituniverse2]]></dc:creator>
		<pubDate>Sat, 29 Mar 2014 21:52:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-17872</guid>
					<description><![CDATA[Sorry for bothering you after months your doc being posted, Sutter. May I ask several question here? Okay I just post my first question to see if it&#039;s noticed :) (and sorry about that again...)
Is it realy necessary to Allow the lifetime of the xvalue being expanded by allowing it to initialize a local rvalue reference? I think it may be the bad code formal in most of the time, isn&#039;t it?
See the code below:

C1 i1{ std::forward(C1()) }; //OK. xv to lv.
C1 &#038; i2 = std::forward(C1());//Error. Forbidden to initialize a lv-ref with rv-ref.

// Here is what i mention about[1]:
C1 &#038;&#038; i3 = std::forward(C1());//xv to named rv-ref. Allowed to compile but meaningless and cause UB.
// But this is NOT included:
C1 &#038;&#038; i4 = C1{} // prv to named rv-ref[2]. I think it&#039;s still fine. because the rv the i4 catched is available in the full scopes.
I think the [1] should have been rejected by the compiler.
You may ask me about that, well, if it was realy true, Would be many stuffs not work? Like, how about the &#039;forward&#039;/&#039;move&#039;/other bunch of things themselves? No no no, what i wrote before doesn&#039;t include these situations:
void_or_sth_2_ret foo(C1 &#038;&#038; val);
...

foo(C1());//OK.
foo(std::forward(C1()));// Note this. What I said DOESN&#039;T include this situation.
foo(std::forward(i4));// Note this. What I said DOESN&#039;T include this situation either.
foo(std::move(i1));// Note this. What I said DOESN&#039;T include this situation either.

Here is the point:
1. Comparison to the existing C++11 compiler, the only different is when an xvalue is to initialize an rvalue-reference, checks if that rv-ref(receiver) is a function&#039;s argument. if not, then:
2. Either one of the following solution: [Forbidden the project from being compiled] OR [Force to make a copy of the xvalue(to let it becomes to situation [2]), or report compiling error if the copy-constructor of the type has been disabled(=delete/made &#039;private&#039;/&#039;protected&#039;)].
The same solution can be applied to [When an xvalue is used to initialize a constant lvalue-reference].
Shortly word: An xvalue can be used to initialize an rvalue-reference without copy only when that rvalue-reference is an argument of a function.]]></description>
		<content:encoded><![CDATA[<p>Sorry for bothering you after months your doc being posted, Sutter. May I ask several question here? Okay I just post my first question to see if it&#8217;s noticed :) (and sorry about that again&#8230;)<br />
Is it realy necessary to Allow the lifetime of the xvalue being expanded by allowing it to initialize a local rvalue reference? I think it may be the bad code formal in most of the time, isn&#8217;t it?<br />
See the code below:</p>
<p>C1 i1{ std::forward(C1()) }; //OK. xv to lv.<br />
C1 &amp; i2 = std::forward(C1());//Error. Forbidden to initialize a lv-ref with rv-ref.</p>
<p>// Here is what i mention about[1]:<br />
C1 &amp;&amp; i3 = std::forward(C1());//xv to named rv-ref. Allowed to compile but meaningless and cause UB.<br />
// But this is NOT included:<br />
C1 &amp;&amp; i4 = C1{} // prv to named rv-ref[2]. I think it&#8217;s still fine. because the rv the i4 catched is available in the full scopes.<br />
I think the [1] should have been rejected by the compiler.<br />
You may ask me about that, well, if it was realy true, Would be many stuffs not work? Like, how about the &#8216;forward&#8217;/&#8217;move&#8217;/other bunch of things themselves? No no no, what i wrote before doesn&#8217;t include these situations:<br />
void_or_sth_2_ret foo(C1 &amp;&amp; val);<br />
&#8230;</p>
<p>foo(C1());//OK.<br />
foo(std::forward(C1()));// Note this. What I said DOESN&#8217;T include this situation.<br />
foo(std::forward(i4));// Note this. What I said DOESN&#8217;T include this situation either.<br />
foo(std::move(i1));// Note this. What I said DOESN&#8217;T include this situation either.</p>
<p>Here is the point:<br />
1. Comparison to the existing C++11 compiler, the only different is when an xvalue is to initialize an rvalue-reference, checks if that rv-ref(receiver) is a function&#8217;s argument. if not, then:<br />
2. Either one of the following solution: [Forbidden the project from being compiled] OR [Force to make a copy of the xvalue(to let it becomes to situation [2]), or report compiling error if the copy-constructor of the type has been disabled(=delete/made &#8216;private&#8217;/&#8217;protected&#8217;)].<br />
The same solution can be applied to [When an xvalue is used to initialize a constant lvalue-reference].<br />
Shortly word: An xvalue can be used to initialize an rvalue-reference without copy only when that rvalue-reference is an argument of a function.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-17228</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 19 Mar 2014 00:44:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-17228</guid>
					<description><![CDATA[@xmllmx: Yes, that&#039;s a bug and we do intend to fix it. I&#039;ll see if we can say so better on the Connect bug itself. Thanks.]]></description>
		<content:encoded><![CDATA[<p>@xmllmx: Yes, that&#8217;s a bug and we do intend to fix it. I&#8217;ll see if we can say so better on the Connect bug itself. Thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: xmllmx				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-17183</link>
		<dc:creator><![CDATA[xmllmx]]></dc:creator>
		<pubDate>Tue, 18 Mar 2014 07:13:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-17183</guid>
					<description><![CDATA[Hi, Sutter, The following code cannot be compiled by VC++ 2013 CTP, but it can be corretly compiled by GCC and CLang. struct A
{
    // error C2216: &#039;explicit&#039; cannot be used with &#039;virtual&#039;
    virtual explicit operator bool() const 
    {
        return true;
    }
};

struct B : A
{
    // error C2216: &#039;explicit&#039; cannot be used with &#039;override&#039;
    explicit operator bool() const override 
    {
        return false;
    }
};

int main()
{
    if (A())
    {}

    if (B())
    {}
}

I have submitted a bug at connect.microsoft.com; however, the handler seemed not considering this as a bug and ignored it. I eagerly hope VC++ can become more robust.]]></description>
		<content:encoded><![CDATA[<p>Hi, Sutter, The following code cannot be compiled by VC++ 2013 CTP, but it can be corretly compiled by GCC and CLang. struct A<br />
{<br />
    // error C2216: &#8216;explicit&#8217; cannot be used with &#8216;virtual&#8217;<br />
    virtual explicit operator bool() const<br />
    {<br />
        return true;<br />
    }<br />
};</p>
<p>struct B : A<br />
{<br />
    // error C2216: &#8216;explicit&#8217; cannot be used with &#8216;override&#8217;<br />
    explicit operator bool() const override<br />
    {<br />
        return false;<br />
    }<br />
};</p>
<p>int main()<br />
{<br />
    if (A())<br />
    {}</p>
<p>    if (B())<br />
    {}<br />
}</p>
<p>I have submitted a bug at connect.microsoft.com; however, the handler seemed not considering this as a bug and ignored it. I eagerly hope VC++ can become more robust.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ISO CPP Meeting Report &#124; Stephan Garbin				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-16027</link>
		<dc:creator><![CDATA[ISO CPP Meeting Report &#124; Stephan Garbin]]></dc:creator>
		<pubDate>Sat, 01 Mar 2014 00:07:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-16027</guid>
					<description><![CDATA[[&#8230;] Herb Sutter has just posted these awesome news about C++ 14&#8230; the proposals look VERY exciting! Cannot wait for polymorphic Lambdas:)And its awesome that everyone can try out that stuff already! [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Herb Sutter has just posted these awesome news about C++ 14&#8230; the proposals look VERY exciting! Cannot wait for polymorphic Lambdas:)And its awesome that everyone can try out that stuff already! [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Petter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13896</link>
		<dc:creator><![CDATA[Petter]]></dc:creator>
		<pubDate>Sat, 21 Dec 2013 16:12:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13896</guid>
					<description><![CDATA[The generic lambdas are great! They allow really cool interfaces to optimizers. For example:
[code]
auto lambda =
	[](auto x)
	{
		auto d0 =  x[1] - x[0]*x[0];
		auto d1 =  1 - x[0];
		return 100 * d0*d0 + d1*d1;
	};

auto differentiable = make_differentiable&#060;2&#062;(lambda);
[/code]
This was not possible before,because the automatic differentiation must be able to pass different types into the lambda. This works very well.]]></description>
		<content:encoded><![CDATA[<p>The generic lambdas are great! They allow really cool interfaces to optimizers. For example:</p>
<pre class="brush: plain; title: ; notranslate">
auto lambda =
	[](auto x)
	{
		auto d0 =  x[1] - x[0]*x[0];
		auto d1 =  1 - x[0];
		return 100 * d0*d0 + d1*d1;
	};

auto differentiable = make_differentiable&lt;2&gt;(lambda);
</pre>
<p>This was not possible before,because the automatic differentiation must be able to pass different types into the lambda. This works very well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Raman Sharma (@rasharm_)				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13863</link>
		<dc:creator><![CDATA[Raman Sharma (@rasharm_)]]></dc:creator>
		<pubDate>Tue, 17 Dec 2013 06:11:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13863</guid>
					<description><![CDATA[Here is an example of using resumable/await in a C++ Windows Store app while using SQLite:

http://stackoverflow.com/questions/19309508/using-sqlite-winrt-from-a-c-windows-store-app]]></description>
		<content:encoded><![CDATA[<p>Here is an example of using resumable/await in a C++ Windows Store app while using SQLite:</p>
<p><a href="http://stackoverflow.com/questions/19309508/using-sqlite-winrt-from-a-c-windows-store-app" rel="nofollow">http://stackoverflow.com/questions/19309508/using-sqlite-winrt-from-a-c-windows-store-app</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13734</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 08 Dec 2013 15:29:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13734</guid>
					<description><![CDATA[@Aaron: See http://isocpp.org/std/submit-a-proposal.]]></description>
		<content:encoded><![CDATA[<p>@Aaron: See <a href="http://isocpp.org/std/submit-a-proposal" rel="nofollow">http://isocpp.org/std/submit-a-proposal</a>.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Aaron				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13732</link>
		<dc:creator><![CDATA[Aaron]]></dc:creator>
		<pubDate>Sun, 08 Dec 2013 15:23:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13732</guid>
					<description><![CDATA[@JC_Yang: Until recently, the standard didn&#039;t acknowledge the existence of threads either - hence my query.  &quot;Thanks for the standard thread support!  Can we please get a little love for processes?&quot;  &quot;...Just a teeny, tiny bit?&quot;  

I&#039;m fairly certain I&#039;m not the guy to submit a proposal.  I just don&#039;t know the right place to make a suggestion/request, or to add my voice to those which must certainly have already been made.]]></description>
		<content:encoded><![CDATA[<p>@JC_Yang: Until recently, the standard didn&#8217;t acknowledge the existence of threads either &#8211; hence my query.  &#8220;Thanks for the standard thread support!  Can we please get a little love for processes?&#8221;  &#8220;&#8230;Just a teeny, tiny bit?&#8221;  </p>
<p>I&#8217;m fairly certain I&#8217;m not the guy to submit a proposal.  I just don&#8217;t know the right place to make a suggestion/request, or to add my voice to those which must certainly have already been made.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JC_Yang				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13670</link>
		<dc:creator><![CDATA[JC_Yang]]></dc:creator>
		<pubDate>Thu, 05 Dec 2013 14:40:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13670</guid>
					<description><![CDATA[@Aaron: forget to mention Boost::Interprocess, it probably can help you atm.]]></description>
		<content:encoded><![CDATA[<p>@Aaron: forget to mention Boost::Interprocess, it probably can help you atm.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JC_Yang				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13669</link>
		<dc:creator><![CDATA[JC_Yang]]></dc:creator>
		<pubDate>Thu, 05 Dec 2013 14:36:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13669</guid>
					<description><![CDATA[@Aaron: I haven&#039;t read the C++ standard through, but IIRC, process as a term does not exist in the standard. One C++ program as a whole running in the abstract machine described by the standard might be somehow resemble a process, but still, it&#039;s not process.
So adding any cross-process/multi-process stuff require significant change in the standard, wording, terms...etc and many subtle details.
Yes, I&#039;d like to see some standardized IPC library, too. but probably not in the near future afaik.]]></description>
		<content:encoded><![CDATA[<p>@Aaron: I haven&#8217;t read the C++ standard through, but IIRC, process as a term does not exist in the standard. One C++ program as a whole running in the abstract machine described by the standard might be somehow resemble a process, but still, it&#8217;s not process.<br />
So adding any cross-process/multi-process stuff require significant change in the standard, wording, terms&#8230;etc and many subtle details.<br />
Yes, I&#8217;d like to see some standardized IPC library, too. but probably not in the near future afaik.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Aaron				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13665</link>
		<dc:creator><![CDATA[Aaron]]></dc:creator>
		<pubDate>Thu, 05 Dec 2013 12:23:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13665</guid>
					<description><![CDATA[Sorry I haven&#039;t found a better place/way to ask but...

Is there (or can there please be) a plan for standard C++ *process* synchronization?  I&#039;m thinking something like Windows&#039; Mutex (cross-process, create locked, released by OS on process termination), but supporting shared locking as well.]]></description>
		<content:encoded><![CDATA[<p>Sorry I haven&#8217;t found a better place/way to ask but&#8230;</p>
<p>Is there (or can there please be) a plan for standard C++ *process* synchronization?  I&#8217;m thinking something like Windows&#8217; Mutex (cross-process, create locked, released by OS on process termination), but supporting shared locking as well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pachesantiago				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13617</link>
		<dc:creator><![CDATA[pachesantiago]]></dc:creator>
		<pubDate>Tue, 03 Dec 2013 12:16:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13617</guid>
					<description><![CDATA[Can somebody give me an example of how await/resumable work? I cant find any example that compiles]]></description>
		<content:encoded><![CDATA[<p>Can somebody give me an example of how await/resumable work? I cant find any example that compiles</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: henrikvallgrenHenrik Vallgren				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13591</link>
		<dc:creator><![CDATA[henrikvallgrenHenrik Vallgren]]></dc:creator>
		<pubDate>Mon, 02 Dec 2013 09:49:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13591</guid>
					<description><![CDATA[It&#039;s great to be able to use the C++ compiler for C++ AMP. How about using C++ AMP for the C++ compiler?]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s great to be able to use the C++ compiler for C++ AMP. How about using C++ AMP for the C++ compiler?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13558</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 20:54:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13558</guid>
					<description><![CDATA[C++11. Note that in the roadmap update C++14 generalized constexpr is a separate box on the right.]]></description>
		<content:encoded><![CDATA[<p>C++11. Note that in the roadmap update C++14 generalized constexpr is a separate box on the right.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13557</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 20:05:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13557</guid>
					<description><![CDATA[But inside those free functions, is the full C++14 relaxed constexpr syntax available (i.e for-loop and switch-statement) or only the single-return C++11 subset (i.e. recursion and ternary operator)?]]></description>
		<content:encoded><![CDATA[<p>But inside those free functions, is the full C++14 relaxed constexpr syntax available (i.e for-loop and switch-statement) or only the single-return C++11 subset (i.e. recursion and ternary operator)?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13556</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 17:03:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13556</guid>
					<description><![CDATA[@tomasu82: You should be able to use constexpr on variable declarations and free functions, but not on member functions yet. That will be implemented eventually but did not make it into this CTP.]]></description>
		<content:encoded><![CDATA[<p>@tomasu82: You should be able to use constexpr on variable declarations and free functions, but not on member functions yet. That will be implemented eventually but did not make it into this CTP.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: tomasu82				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13555</link>
		<dc:creator><![CDATA[tomasu82]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 08:15:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13555</guid>
					<description><![CDATA[With the new constexpr support, what exactly /is/ supported? I have some code that uses constexpr on some static class methods and const static member variables. Would that be supported? And if so, is there a way I can check that it is supported? say with a macro #if VER &#062; ?? 

Thanks.]]></description>
		<content:encoded><![CDATA[<p>With the new constexpr support, what exactly /is/ supported? I have some code that uses constexpr on some static class methods and const static member variables. Would that be supported? And if so, is there a way I can check that it is supported? say with a macro #if VER &gt; ?? </p>
<p>Thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Devid				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13544</link>
		<dc:creator><![CDATA[Devid]]></dc:creator>
		<pubDate>Fri, 29 Nov 2013 01:43:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13544</guid>
					<description><![CDATA[Great that we have 2013 CPT already.
It would be even better if  http://rise4fun.com/Vcpp  will support VS 2013 RTM and CTP them too.]]></description>
		<content:encoded><![CDATA[<p>Great that we have 2013 CPT already.<br />
It would be even better if  <a href="http://rise4fun.com/Vcpp" rel="nofollow">http://rise4fun.com/Vcpp</a>  will support VS 2013 RTM and CTP them too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13395</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sun, 24 Nov 2013 19:41:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13395</guid>
					<description><![CDATA[@HGH: Good questions, see http://channel9.msdn.com/Events/Build/2013/2-306.

Summarizing: There are two streams, release and CTP, and by default you should expect new features to show up in the CTP stream and then in the next major release, not in Updates which are more about stability improvements. We do ship other kinds of features in Updates, such as IDE features that don&#039;t break customers, but the compiler is widely depended upon and changes there can cause source breaking changes, so we normally do not ship compiler changes in Updates. This is especially true now as the source base is undergoing high rate of change both for new features and for AST and other rejuvenation; shipping constexpr would require shipping a major compiler source diff which is fine on a major release when people are expecting to tweak their sources in adopting a new compiler, but it would likely surprise a lot of people that they have to treat an Update that way.

Re date: We have not announced a date by which we&#039;ll be fully compliant, in part because we don&#039;t know :), and because we think reporting actual progress regularly is probably better than promises. So we have published a roadmap and have been updating it (most recently on the linked post) to share what we know when we know it. This way, you can extrapolate speed and expectations yourself based on the rate at which we actually ship features.]]></description>
		<content:encoded><![CDATA[<p>@HGH: Good questions, see <a href="http://channel9.msdn.com/Events/Build/2013/2-306" rel="nofollow">http://channel9.msdn.com/Events/Build/2013/2-306</a>.</p>
<p>Summarizing: There are two streams, release and CTP, and by default you should expect new features to show up in the CTP stream and then in the next major release, not in Updates which are more about stability improvements. We do ship other kinds of features in Updates, such as IDE features that don&#8217;t break customers, but the compiler is widely depended upon and changes there can cause source breaking changes, so we normally do not ship compiler changes in Updates. This is especially true now as the source base is undergoing high rate of change both for new features and for AST and other rejuvenation; shipping constexpr would require shipping a major compiler source diff which is fine on a major release when people are expecting to tweak their sources in adopting a new compiler, but it would likely surprise a lot of people that they have to treat an Update that way.</p>
<p>Re date: We have not announced a date by which we&#8217;ll be fully compliant, in part because we don&#8217;t know :), and because we think reporting actual progress regularly is probably better than promises. So we have published a roadmap and have been updating it (most recently on the linked post) to share what we know when we know it. This way, you can extrapolate speed and expectations yourself based on the rate at which we actually ship features.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: HGH				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13327</link>
		<dc:creator><![CDATA[HGH]]></dc:creator>
		<pubDate>Thu, 21 Nov 2013 12:22:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13327</guid>
					<description><![CDATA[Interesting but.. Will all these features and the full C++11/14 support you&#039;ve talked about be as a VS 2013 update or they will be released as VS2014/VS2015?
Will complete support for the specifications (compiler and library support) happen in 2014 or the year after?]]></description>
		<content:encoded><![CDATA[<p>Interesting but.. Will all these features and the full C++11/14 support you&#8217;ve talked about be as a VS 2013 update or they will be released as VS2014/VS2015?<br />
Will complete support for the specifications (compiler and library support) happen in 2014 or the year after?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13314</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 20 Nov 2013 18:13:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13314</guid>
					<description><![CDATA[@Christian: In the CTP, =default should now work for move special member functions, and generate what the compiler would have generated implicitly had the implicit generation not been suppressed (for example by declaring a copy operation or a destructor). In VS2013 RTM we didn&#039;t yet allow =default for move ctor/op= because that compiler didn&#039;t have the compiler-generated ones yet, so there was nothing for =default to do -- now that the CTP has the compiler-generated ones, this also let us finish =default for move ctor/op=.

Edited to add: Your example is a bug in our compiler, logged. Thanks for the repro! As a workaround, you can =default the move operations of class Y (but you shouldn&#039;t have to, we&#039;ll fix it, just giving one possible workaround in the meantime).]]></description>
		<content:encoded><![CDATA[<p>@Christian: In the CTP, =default should now work for move special member functions, and generate what the compiler would have generated implicitly had the implicit generation not been suppressed (for example by declaring a copy operation or a destructor). In VS2013 RTM we didn&#8217;t yet allow =default for move ctor/op= because that compiler didn&#8217;t have the compiler-generated ones yet, so there was nothing for =default to do &#8212; now that the CTP has the compiler-generated ones, this also let us finish =default for move ctor/op=.</p>
<p>Edited to add: Your example is a bug in our compiler, logged. Thanks for the repro! As a workaround, you can =default the move operations of class Y (but you shouldn&#8217;t have to, we&#8217;ll fix it, just giving one possible workaround in the meantime).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Christian				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13313</link>
		<dc:creator><![CDATA[Christian]]></dc:creator>
		<pubDate>Wed, 20 Nov 2013 17:06:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13313</guid>
					<description><![CDATA[This demonstrated the issue. Works with e.g. GCC 4.8.0, but not CTP.

[code]
#include &#060;vector&#062;

int main()
{
   class Y
   {
   public:
      Y() {};

      Y(const Y&#038;) {};
      Y&#038; operator=(const Y&#038;) 
      {
         return *this;
      };
   };

   class X
   {
   public:
      Y y;

      X() {};

      // Not copyable
      X(const X&#038;) = delete;
      X&#038; operator=(const X&#038;) = delete;

#if 1
      // Doesn&#039;t compile
      X(X&#038;&#038;) = default;
      X&#038; operator=(X&#038;&#038; rhs) = default;
#else
      // Compiles
      X(X&#038;&#038; rhs)
      {
         y = std::move(rhs.y);
      };
      X&#038; operator=(X&#038;&#038; rhs)
      {
         y = std::move(rhs.y);
         return *this;
      };
#endif
   };

   std::vector&#060;X&#062; cs;
   cs.push_back(X());

   return 0;
}
[/code]

If CTP is right, what is the best way to avoid having to explicitly maintain the move constructor/assignment functions as new members are added to the class? Having to do this explicitly seems like a potential source for bugs (easy to forget to amend the move constructor/assignment).]]></description>
		<content:encoded><![CDATA[<p>This demonstrated the issue. Works with e.g. GCC 4.8.0, but not CTP.</p>
<pre class="brush: plain; title: ; notranslate">
#include &lt;vector&gt;

int main()
{
   class Y
   {
   public:
      Y() {};

      Y(const Y&amp;) {};
      Y&amp; operator=(const Y&amp;) 
      {
         return *this;
      };
   };

   class X
   {
   public:
      Y y;

      X() {};

      // Not copyable
      X(const X&amp;) = delete;
      X&amp; operator=(const X&amp;) = delete;

#if 1
      // Doesn't compile
      X(X&amp;&amp;) = default;
      X&amp; operator=(X&amp;&amp; rhs) = default;
#else
      // Compiles
      X(X&amp;&amp; rhs)
      {
         y = std::move(rhs.y);
      };
      X&amp; operator=(X&amp;&amp; rhs)
      {
         y = std::move(rhs.y);
         return *this;
      };
#endif
   };

   std::vector&lt;X&gt; cs;
   cs.push_back(X());

   return 0;
}
</pre>
<p>If CTP is right, what is the best way to avoid having to explicitly maintain the move constructor/assignment functions as new members are added to the class? Having to do this explicitly seems like a potential source for bugs (easy to forget to amend the move constructor/assignment).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Christian				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13312</link>
		<dc:creator><![CDATA[Christian]]></dc:creator>
		<pubDate>Wed, 20 Nov 2013 16:03:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13312</guid>
					<description><![CDATA[Hi Herb,

Could you clarify this for me: what is the behaviour of the =default move constructor/assignment operator? The CTP seems to silently not generate them if one of the class members doesn&#039;t implement move semantics (i.e. has C(C&#038;&#038;) and/or C&#038; operator=(C&#038;&#038;)), whereas GCC-4.8.0 appears to do this (and instead copies the members in question).

[1] says &quot;For a move, =default means member-wise move of each element, if possible, otherwise a compile-time 
error is immediately given&quot; but I have no idea if that document is current/official. This seems to match the CTP&#039;s behaviour, but not GCC&#039;s. Which one is right?

I was hoping to be able to use =default move-constructors/assignment instead of writing my own (where I have to move/copy each member in turn, and remember to also add any new members added later), but since some of the types I use doesn&#039;t implement move semantics (they are from a library) it doesn&#039;t appear I&#039;m able to do this using the CTP -- whereas GCC handles this fine.

Thanks in advance.

[1] http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2904.pdf]]></description>
		<content:encoded><![CDATA[<p>Hi Herb,</p>
<p>Could you clarify this for me: what is the behaviour of the =default move constructor/assignment operator? The CTP seems to silently not generate them if one of the class members doesn&#8217;t implement move semantics (i.e. has C(C&amp;&amp;) and/or C&amp; operator=(C&amp;&amp;)), whereas GCC-4.8.0 appears to do this (and instead copies the members in question).</p>
<p>[1] says &#8220;For a move, =default means member-wise move of each element, if possible, otherwise a compile-time<br />
error is immediately given&#8221; but I have no idea if that document is current/official. This seems to match the CTP&#8217;s behaviour, but not GCC&#8217;s. Which one is right?</p>
<p>I was hoping to be able to use =default move-constructors/assignment instead of writing my own (where I have to move/copy each member in turn, and remember to also add any new members added later), but since some of the types I use doesn&#8217;t implement move semantics (they are from a library) it doesn&#8217;t appear I&#8217;m able to do this using the CTP &#8212; whereas GCC handles this fine.</p>
<p>Thanks in advance.</p>
<p>[1] <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2904.pdf" rel="nofollow">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2904.pdf</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: faisalvali				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13306</link>
		<dc:creator><![CDATA[faisalvali]]></dc:creator>
		<pubDate>Wed, 20 Nov 2013 06:30:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13306</guid>
					<description><![CDATA[wow – generic lambdas in VC++ already – yay!! What a fun time to be a C++ programmer :)
Thanks Herb (and of course to the VC++ Team)!]]></description>
		<content:encoded><![CDATA[<p>wow – generic lambdas in VC++ already – yay!! What a fun time to be a C++ programmer :)<br />
Thanks Herb (and of course to the VC++ Team)!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Source-based distros are awful (tipsy blog post)				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13300</link>
		<dc:creator><![CDATA[Source-based distros are awful (tipsy blog post)]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 21:24:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13300</guid>
					<description><![CDATA[[&#8230;] up pretty good. The current release (CTP) is going to cover roughly 70% of C++11/14 (source: Visual C++ Compiler November 2013 CTP &#124; Sutter’s Mill). C++ is accelerating. There is no doubt about [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] up pretty good. The current release (CTP) is going to cover roughly 70% of C++11/14 (source: Visual C++ Compiler November 2013 CTP | Sutter’s Mill). C++ is accelerating. There is no doubt about [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fabio				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13297</link>
		<dc:creator><![CDATA[Fabio]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 16:00:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13297</guid>
					<description><![CDATA[Is there any ETA on a SP for the RTM? It contains a bunch of reproduceble ICEs (8 that I am aware of at connect) This really hinders us moving on to 2013]]></description>
		<content:encoded><![CDATA[<p>Is there any ETA on a SP for the RTM? It contains a bunch of reproduceble ICEs (8 that I am aware of at connect) This really hinders us moving on to 2013</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13296</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 15:20:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13296</guid>
					<description><![CDATA[@Pal: It is a separate stream, think of it as (usually) an early preview of the next major release that&#039;s worked on in a different branch from the current release&#039;s servicing branch. Then it&#039;s the usual decision for each bug fix as to whether to apply it to the current release via Updates, to the next release which would appear in CTP, or both branches. HTH]]></description>
		<content:encoded><![CDATA[<p>@Pal: It is a separate stream, think of it as (usually) an early preview of the next major release that&#8217;s worked on in a different branch from the current release&#8217;s servicing branch. Then it&#8217;s the usual decision for each bug fix as to whether to apply it to the current release via Updates, to the next release which would appear in CTP, or both branches. HTH</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Balog Pal				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13292</link>
		<dc:creator><![CDATA[Balog Pal]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 10:51:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13292</guid>
					<description><![CDATA[Please clarify the update thing. I get it&#039;s a separate stream, but that leaves the update policy open. If the RTM gets a service pack released fixing bugs will the relevant changes merged over to the CTP stream creating an update of that too within some reasonable time? Or we can consider it isolated from mainstream fixes?]]></description>
		<content:encoded><![CDATA[<p>Please clarify the update thing. I get it&#8217;s a separate stream, but that leaves the update policy open. If the RTM gets a service pack released fixing bugs will the relevant changes merged over to the CTP stream creating an update of that too within some reasonable time? Or we can consider it isolated from mainstream fixes?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Petter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13290</link>
		<dc:creator><![CDATA[Petter]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 08:08:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13290</guid>
					<description><![CDATA[Congratulations! It is great to see rapid progress!]]></description>
		<content:encoded><![CDATA[<p>Congratulations! It is great to see rapid progress!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ricardo Costa				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13287</link>
		<dc:creator><![CDATA[Ricardo Costa]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 06:34:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13287</guid>
					<description><![CDATA[Great news, Herb.

Does operator new return memory aligned in accordance to the alignas specification? The MSDN documentation for __declspec(align()) explicitly states that it doesn&#039;t, but __declspec(align()) is not a real language feature, unlike alignas, so I&#039;m wondering if that restriction has changed. Thanks.]]></description>
		<content:encoded><![CDATA[<p>Great news, Herb.</p>
<p>Does operator new return memory aligned in accordance to the alignas specification? The MSDN documentation for __declspec(align()) explicitly states that it doesn&#8217;t, but __declspec(align()) is not a real language feature, unlike alignas, so I&#8217;m wondering if that restriction has changed. Thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13283</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 01:30:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13283</guid>
					<description><![CDATA[@JC_Yang: Bug fixes will go into Updates as they are available. The CTP is a separate stream.]]></description>
		<content:encoded><![CDATA[<p>@JC_Yang: Bug fixes will go into Updates as they are available. The CTP is a separate stream.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: JC_Yang				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13282</link>
		<dc:creator><![CDATA[JC_Yang]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 01:05:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13282</guid>
					<description><![CDATA[Are there any bugfixes for the VS2013 RTM compiler included in this CTP or they will be only available in the coming VS2013 supported-updates? There&#039;re 6 bugs I know of(I&#039;m tracking 5 of them, 1 is reported by me which is about wrong template instantiation point).]]></description>
		<content:encoded><![CDATA[<p>Are there any bugfixes for the VS2013 RTM compiler included in this CTP or they will be only available in the coming VS2013 supported-updates? There&#8217;re 6 bugs I know of(I&#8217;m tracking 5 of them, 1 is reported by me which is about wrong template instantiation point).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13280</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 00:10:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13280</guid>
					<description><![CDATA[@anon: Thanks for the pointer!

@Sometime: This is a compiler-only CTP to give a preview of new compiler features, it does not include library updates. Of course, when these features hit the full product in a future release, they&#039;ll be complete including library support (among other library updates).]]></description>
		<content:encoded><![CDATA[<p>@anon: Thanks for the pointer!</p>
<p>@Sometime: This is a compiler-only CTP to give a preview of new compiler features, it does not include library updates. Of course, when these features hit the full product in a future release, they&#8217;ll be complete including library support (among other library updates).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: SometimeSomewhere				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13279</link>
		<dc:creator><![CDATA[SometimeSomewhere]]></dc:creator>
		<pubDate>Tue, 19 Nov 2013 00:03:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13279</guid>
					<description><![CDATA[@Herb: Thats excellent news and it&#039;s nice to see a more rapid release schedule from the C++ visual studio team.

That said will there be any library updates along with the CTP, my understanding/experience is that there are a number areas that need tending to with regards to the most recent VS2013 release.]]></description>
		<content:encoded><![CDATA[<p>@Herb: Thats excellent news and it&#8217;s nice to see a more rapid release schedule from the C++ visual studio team.</p>
<p>That said will there be any library updates along with the CTP, my understanding/experience is that there are a number areas that need tending to with regards to the most recent VS2013 release.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: anonymous				</title>
				<link>https://herbsutter.com/2013/11/18/visual-c-compiler-november-2013-ctp/#comment-13278</link>
		<dc:creator><![CDATA[anonymous]]></dc:creator>
		<pubDate>Mon, 18 Nov 2013 23:58:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2361#comment-13278</guid>
					<description><![CDATA[clang has had &quot;some&quot; generic lambdas support for a while but since a couple of weeks it seems like really robust. They are awesome, in particular when combined with boost fusion:

[code]
auto tuple = std::make_tuple(1, 2.0, &#034;hello!&#034;);
boost::fusion::for_each(tuple, [](auto i) { std::out &#060;&#060; i &#060;&#060; &#034;, &#034;; });  // 1, 2.0, hello! :) 
[/code]]]></description>
		<content:encoded><![CDATA[<p>clang has had &#8220;some&#8221; generic lambdas support for a while but since a couple of weeks it seems like really robust. They are awesome, in particular when combined with boost fusion:</p>
<pre class="brush: plain; title: ; notranslate">
auto tuple = std::make_tuple(1, 2.0, &quot;hello!&quot;);
boost::fusion::for_each(tuple, [](auto i) { std::out &lt;&lt; i &lt;&lt; &quot;, &quot;; });  // 1, 2.0, hello! :) 
</pre>
]]></content:encoded>
					</item>
			</channel>
</rss>
