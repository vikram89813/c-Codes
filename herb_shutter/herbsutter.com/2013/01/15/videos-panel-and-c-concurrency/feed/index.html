<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: Videos: Panel, and C++ Concurrency	</title>
	<atom:link href="https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: aclassifier				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-12471</link>
		<dc:creator><![CDATA[aclassifier]]></dc:creator>
		<pubDate>Wed, 11 Sep 2013 18:57:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-12471</guid>
					<description><![CDATA[Some months ago this talk inspired me to write a blog note, &quot;Pike &#038; Sutter: Concurrency vs. Concurrency&quot;, see http://www.teigfam.net/oyvind/home/technology/072-pike-sutter-concurrency-vs-concurrency

(Herb Sutter, you have already posted comments in my blog note, so you are aware of it. But I would of course like to attract new readers!-) I have written a naïve follow-up called &quot;Block play for blockers&quot;. I am now reading myself up with a goal to try do a note on event-loop concurrency vs. CSP-type concurrency/parallelism with channels.)

Oyvind Teig, Trondheim, Norway]]></description>
		<content:encoded><![CDATA[<p>Some months ago this talk inspired me to write a blog note, &#8220;Pike &amp; Sutter: Concurrency vs. Concurrency&#8221;, see <a href="http://www.teigfam.net/oyvind/home/technology/072-pike-sutter-concurrency-vs-concurrency" rel="nofollow">http://www.teigfam.net/oyvind/home/technology/072-pike-sutter-concurrency-vs-concurrency</a></p>
<p>(Herb Sutter, you have already posted comments in my blog note, so you are aware of it. But I would of course like to attract new readers!-) I have written a naïve follow-up called &#8220;Block play for blockers&#8221;. I am now reading myself up with a goal to try do a note on event-loop concurrency vs. CSP-type concurrency/parallelism with channels.)</p>
<p>Oyvind Teig, Trondheim, Norway</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++ videos &#124; en.dorinlazar.ro				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-12372</link>
		<dc:creator><![CDATA[C++ videos &#124; en.dorinlazar.ro]]></dc:creator>
		<pubDate>Wed, 04 Sep 2013 08:21:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-12372</guid>
					<description><![CDATA[[&#8230;] While looking over some older links, I found these gems on Herb Sutter&#8217;s blog, from C++ and beyond. [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] While looking over some older links, I found these gems on Herb Sutter&#8217;s blog, from C++ and beyond. [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike Marcin				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8343</link>
		<dc:creator><![CDATA[Mike Marcin]]></dc:creator>
		<pubDate>Fri, 25 Jan 2013 01:02:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8343</guid>
					<description><![CDATA[The talk was great.

Is a thread per concurrent object the right pattern?

I thought we were supposed to be moving away from directly dealing with threads and towards something more like submitting tasks to run on a thread pool which runs as many threads as is optimal on the executing system and no more.]]></description>
		<content:encoded><![CDATA[<p>The talk was great.</p>
<p>Is a thread per concurrent object the right pattern?</p>
<p>I thought we were supposed to be moving away from directly dealing with threads and towards something more like submitting tasks to run on a thread pool which runs as many threads as is optimal on the executing system and no more.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8256</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 22 Jan 2013 00:39:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8256</guid>
					<description><![CDATA[@Fernando: I just remembered the other reason why .then(x).then(y) is useful -- yes you could write it as .then(x+y) but that burns/occupies a thread, whereas .then(x).then(y) does not. I&#039;ll go back and update the previous note to include that.]]></description>
		<content:encoded><![CDATA[<p>@Fernando: I just remembered the other reason why .then(x).then(y) is useful &#8212; yes you could write it as .then(x+y) but that burns/occupies a thread, whereas .then(x).then(y) does not. I&#8217;ll go back and update the previous note to include that.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: davidofirvine				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8185</link>
		<dc:creator><![CDATA[davidofirvine]]></dc:creator>
		<pubDate>Sat, 19 Jan 2013 09:34:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8185</guid>
					<description><![CDATA[@Herb: The .then() template you show would compile as you say, but does not appear like it would work as it’s relying on shared futures by the looks of it, I have a SO question on it here http://stackoverflow.com/questions/14200678/c11-async-continuations-or-attempt-at-then-semantics If you have other ideas in this regard them brilliant as .then or then() would be a great pattern till the standard provides these implementations (never mind await which would really alter the landscape of many codebases)

On the wrapper class there is a nice gotcha for non msvc compilers in this SO question as well http://stackoverflow.com/questions/14188535/clang-access-modifier-order-and-decltype Looks like msvc is non-conformant here as well as with the future blocking discussed earlier.

I think it would be good to have working examples of some of the code in a couple of compilers as msvc seems to not be to concerned with template errors (missing typenames etc.) at compile time, so a ‘compiling’ template example, particularly one not instantiated is limited in value (in some compilers).

It would be extremely helpful if you had non conforming implementations of std:: clearly available in a public forum or web page and perhaps even a warning that can be switched of to let devs know they were implementing non cross platform behaviour or similar as this is a key part of the standard as far as I believe (cross platform compliance).

Great talk (as ever) though and mixed with the const/mutable it’s fantastic to get people thinking c++11 proper and not just using auto and lambdas, there is a lot more and this is great. Cheers again.]]></description>
		<content:encoded><![CDATA[<p>@Herb: The .then() template you show would compile as you say, but does not appear like it would work as it’s relying on shared futures by the looks of it, I have a SO question on it here <a href="http://stackoverflow.com/questions/14200678/c11-async-continuations-or-attempt-at-then-semantics" rel="nofollow">http://stackoverflow.com/questions/14200678/c11-async-continuations-or-attempt-at-then-semantics</a> If you have other ideas in this regard them brilliant as .then or then() would be a great pattern till the standard provides these implementations (never mind await which would really alter the landscape of many codebases)</p>
<p>On the wrapper class there is a nice gotcha for non msvc compilers in this SO question as well <a href="http://stackoverflow.com/questions/14188535/clang-access-modifier-order-and-decltype" rel="nofollow">http://stackoverflow.com/questions/14188535/clang-access-modifier-order-and-decltype</a> Looks like msvc is non-conformant here as well as with the future blocking discussed earlier.</p>
<p>I think it would be good to have working examples of some of the code in a couple of compilers as msvc seems to not be to concerned with template errors (missing typenames etc.) at compile time, so a ‘compiling’ template example, particularly one not instantiated is limited in value (in some compilers).</p>
<p>It would be extremely helpful if you had non conforming implementations of std:: clearly available in a public forum or web page and perhaps even a warning that can be switched of to let devs know they were implementing non cross platform behaviour or similar as this is a key part of the standard as far as I believe (cross platform compliance).</p>
<p>Great talk (as ever) though and mixed with the const/mutable it’s fantastic to get people thinking c++11 proper and not just using auto and lambdas, there is a lot more and this is great. Cheers again.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adam H				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8137</link>
		<dc:creator><![CDATA[Adam H]]></dc:creator>
		<pubDate>Fri, 18 Jan 2013 09:01:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8137</guid>
					<description><![CDATA[&lt;blockquote&gt;&lt;i&gt;[ ... ] doofuses&lt;/i&gt;&lt;/blockquote&gt;

Gotta love the English language! And I agree with you, that the bug is in the standard.]]></description>
		<content:encoded><![CDATA[<blockquote><p><i>[ &#8230; ] doofuses</i></p></blockquote>
<p>Gotta love the English language! And I agree with you, that the bug is in the standard.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8132</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 17 Jan 2013 23:21:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8132</guid>
					<description><![CDATA[@Fernando: You asked why not just write w.then(x+y+z) instead of w.then(x).then(y).then(z). Two reasons: 1. Writing w.then(x+y+z) burns/occupies a thread while waiting for y and z, while w.then(x).then(y).then(z) does not. 2. An important key is composability: The different .then() calls may be in different code, such as one function doing w.then(x) and returning the future, the separately authored caller tacking on .then(y) and storing it on the heap for multiple threads to observe, and then a helper thread authored by still someone else tacking on .then(z).]]></description>
		<content:encoded><![CDATA[<p>@Fernando: You asked why not just write w.then(x+y+z) instead of w.then(x).then(y).then(z). Two reasons: 1. Writing w.then(x+y+z) burns/occupies a thread while waiting for y and z, while w.then(x).then(y).then(z) does not. 2. An important key is composability: The different .then() calls may be in different code, such as one function doing w.then(x) and returning the future, the separately authored caller tacking on .then(y) and storing it on the heap for multiple threads to observe, and then a helper thread authored by still someone else tacking on .then(z).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8131</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 17 Jan 2013 23:15:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8131</guid>
					<description><![CDATA[@Adam H: Right, VS 2012 is knowingly (temporarily) non-conforming on the ~future blocking issue in part because we knew this question is being actively reviewed in the committee and we feel the status quo is harmful to our customers. Of course, if the committee&#039;s decision is to stay with the C++11 rules we&#039;ll change our implementation to conform and have to do more to educate customers about the issue.

If the view that this should be fixed prevails in the committee, we&#039;ll look like geniuses for getting it &quot;right&quot; sooner, otherwise we&#039;ll conform and look like doofuses for shipping with another bug we had to go back and fix.

(We don&#039;t do this often! Usually the right thing to do is just conform to the standard, perceived bugs and all. But this bug is bad and under discussion at the last two SG1 meetings...)]]></description>
		<content:encoded><![CDATA[<p>@Adam H: Right, VS 2012 is knowingly (temporarily) non-conforming on the ~future blocking issue in part because we knew this question is being actively reviewed in the committee and we feel the status quo is harmful to our customers. Of course, if the committee&#8217;s decision is to stay with the C++11 rules we&#8217;ll change our implementation to conform and have to do more to educate customers about the issue.</p>
<p>If the view that this should be fixed prevails in the committee, we&#8217;ll look like geniuses for getting it &#8220;right&#8221; sooner, otherwise we&#8217;ll conform and look like doofuses for shipping with another bug we had to go back and fix.</p>
<p>(We don&#8217;t do this often! Usually the right thing to do is just conform to the standard, perceived bugs and all. But this bug is bad and under discussion at the last two SG1 meetings&#8230;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matze				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8115</link>
		<dc:creator><![CDATA[Matze]]></dc:creator>
		<pubDate>Thu, 17 Jan 2013 16:07:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8115</guid>
					<description><![CDATA[Thanks for making these available, Herb! I enjoyed both talks very much. Always interesting listening your words (and of course Andrei&#039;s and Scott&#039;s :D)]]></description>
		<content:encoded><![CDATA[<p>Thanks for making these available, Herb! I enjoyed both talks very much. Always interesting listening your words (and of course Andrei&#8217;s and Scott&#8217;s :D)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adam H				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8100</link>
		<dc:creator><![CDATA[Adam H]]></dc:creator>
		<pubDate>Thu, 17 Jan 2013 13:22:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8100</guid>
					<description><![CDATA[Hi, and thanks for making C++ an even more awesome language, and thanks a lot for your work in &lt;i&gt;enabling&lt;/i&gt; further improvements!

Sorry for this OT question, but I did not know where else to post it...
In September 2012 you posted a paper discussing the problems in the present standard, with a blocking &lt;b&gt;~future()&lt;/b&gt;. In my experiments I have found that it does no block! (VS 2012 - update 1)
Has the standard already been revised? Nice, but I would&#039;ve thought that the standard was already carved into stone? Shed some light, anyone?

For those of you who wonder what on Earth I am talking about, here&#039;s what:

void DoWork( const std::wstring&#038; s, unsigned int wait )
{
	std::wcout &#060;&#060; s &#060;&#060; L&#034; Begin:&#034; &#060;&#060; std::endl;
	std::this_thread::sleep_for( std::chrono::milliseconds ( wait ) );
	std::wcout &#060;&#060; s &#060;&#060; L&#034; Done.&#034; &#060;&#060; std::endl;
}

void SimpleAsyncTest()
{
&lt;b&gt;	// Test Herb Sutter&#039;s blocking ~future 
	// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf&lt;/b&gt;
	std::async( std::launch::async, [](){ DoWork( L&quot;Slow Work&quot;, 400 ); } );
	std::async( std::launch::async, [](){ DoWork( L&quot;Fast Work&quot;, 200 ); } );
}

// &quot;Slow work&quot; completes last, as intuitively expected, but contrary to paper above]]></description>
		<content:encoded><![CDATA[<p>Hi, and thanks for making C++ an even more awesome language, and thanks a lot for your work in <i>enabling</i> further improvements!</p>
<p>Sorry for this OT question, but I did not know where else to post it&#8230;<br />
In September 2012 you posted a paper discussing the problems in the present standard, with a blocking <b>~future()</b>. In my experiments I have found that it does no block! (VS 2012 &#8211; update 1)<br />
Has the standard already been revised? Nice, but I would&#8217;ve thought that the standard was already carved into stone? Shed some light, anyone?</p>
<p>For those of you who wonder what on Earth I am talking about, here&#8217;s what:</p>
<p>void DoWork( const std::wstring&amp; s, unsigned int wait )<br />
{<br />
	std::wcout &lt;&lt; s &lt;&lt; L&quot; Begin:&quot; &lt;&lt; std::endl;<br />
	std::this_thread::sleep_for( std::chrono::milliseconds ( wait ) );<br />
	std::wcout &lt;&lt; s &lt;&lt; L&quot; Done.&quot; &lt;&lt; std::endl;<br />
}</p>
<p>void SimpleAsyncTest()<br />
{<br />
<b>	// Test Herb Sutter&#8217;s blocking ~future<br />
	// <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf</a></b><br />
	std::async( std::launch::async, [](){ DoWork( L&#8221;Slow Work&#8221;, 400 ); } );<br />
	std::async( std::launch::async, [](){ DoWork( L&#8221;Fast Work&#8221;, 200 ); } );<br />
}</p>
<p>// &#8220;Slow work&#8221; completes last, as intuitively expected, but contrary to paper above</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Zenju				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8045</link>
		<dc:creator><![CDATA[Zenju]]></dc:creator>
		<pubDate>Wed, 16 Jan 2013 11:50:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8045</guid>
					<description><![CDATA[The concurrency talks are great! But there is one single unanswered question in the air:

What about race-conditions?

In C++ there is no compile-time help to notify when I&#039;m using a non-thread-safe function. This proliferation of new concurrency abstractions increases the probability of accidentally calling such a function. I have no idea how this works in C++/CX, but seemingly nobody is giving a thought about race-conditions in any of these talks.

Am I missing something? Is concurrency now simple and the problem with race conditions has been solved in the meantime? :D]]></description>
		<content:encoded><![CDATA[<p>The concurrency talks are great! But there is one single unanswered question in the air:</p>
<p>What about race-conditions?</p>
<p>In C++ there is no compile-time help to notify when I&#8217;m using a non-thread-safe function. This proliferation of new concurrency abstractions increases the probability of accidentally calling such a function. I have no idea how this works in C++/CX, but seemingly nobody is giving a thought about race-conditions in any of these talks.</p>
<p>Am I missing something? Is concurrency now simple and the problem with race conditions has been solved in the meantime? :D</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Fernando				</title>
				<link>https://herbsutter.com/2013/01/15/videos-panel-and-c-concurrency/#comment-8039</link>
		<dc:creator><![CDATA[Fernando]]></dc:creator>
		<pubDate>Wed, 16 Jan 2013 08:53:13 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.wordpress.com/?p=1707#comment-8039</guid>
					<description><![CDATA[(Re-posting the channel9 question here for context)

@HerbSutter: Thanks for sharing another great presentation.

I have one question that has been bothering me since the first time I read your enthusiasm about &quot;future.then&quot;: 
i.e. consider async(task1preparation)
.then(task2continuation)
.then(task3cleanup)
.then(task4notifyUI)

isn&#039;t that the same as async([]() -&#062; void {task1preparation(); task2continuation(); task3cleanup(); task4notifyUI();}); ?

What would be the benefit of using future.then as proposed?

I&#039;d see more benefit if instead of a chain of actions, I could get a tree than depending on the result of the first task (or exception) and could have custom continuations. Also It would be useful (not sure if that is already proposed) to specify that a given continuation task should run in the current thread or in a specific thread (i.e. UI thread).

Thanks in advance for your clarification

Fernando]]></description>
		<content:encoded><![CDATA[<p>(Re-posting the channel9 question here for context)</p>
<p>@HerbSutter: Thanks for sharing another great presentation.</p>
<p>I have one question that has been bothering me since the first time I read your enthusiasm about &#8220;future.then&#8221;:<br />
i.e. consider async(task1preparation)<br />
.then(task2continuation)<br />
.then(task3cleanup)<br />
.then(task4notifyUI)</p>
<p>isn&#8217;t that the same as async([]() -&gt; void {task1preparation(); task2continuation(); task3cleanup(); task4notifyUI();}); ?</p>
<p>What would be the benefit of using future.then as proposed?</p>
<p>I&#8217;d see more benefit if instead of a chain of actions, I could get a tree than depending on the result of the first task (or exception) and could have custom continuations. Also It would be useful (not sure if that is already proposed) to specify that a given continuation task should run in the current thread or in a specific thread (i.e. UI thread).</p>
<p>Thanks in advance for your clarification</p>
<p>Fernando</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
