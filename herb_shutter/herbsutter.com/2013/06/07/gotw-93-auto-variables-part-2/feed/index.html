<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #93: Auto Variables, Part 2	</title>
	<atom:link href="https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11289</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Thu, 13 Jun 2013 19:51:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11289</guid>
					<description><![CDATA[@Unsigned Int:

(How odd name you got :) )

Come on, it&#039;s the textbook case of the new hammer. Not everything is a nail - you don&#039;t have to use auto for everything. auto is for the case of storing the result of a function/expression, with the appropriate type - you don&#039;t want to do that here, rather you want to define a cycle variable, of a given type (size_t), initialized to zero.

Auto is for when you want a variable of a &#039;meh, idontcare&#039; type. If you want a given type, declare with the given type.]]></description>
		<content:encoded><![CDATA[<p>@Unsigned Int:</p>
<p>(How odd name you got :) )</p>
<p>Come on, it&#8217;s the textbook case of the new hammer. Not everything is a nail &#8211; you don&#8217;t have to use auto for everything. auto is for the case of storing the result of a function/expression, with the appropriate type &#8211; you don&#8217;t want to do that here, rather you want to define a cycle variable, of a given type (size_t), initialized to zero.</p>
<p>Auto is for when you want a variable of a &#8216;meh, idontcare&#8217; type. If you want a given type, declare with the given type.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Unsigned Int				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11273</link>
		<dc:creator><![CDATA[Unsigned Int]]></dc:creator>
		<pubDate>Thu, 13 Jun 2013 13:54:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11273</guid>
					<description><![CDATA[@mttpd:
[code]// STILL WRONG: using `int` for size is bad and you should feel bad
for (auto iWRONG = 0; iWRONG &#060; v.size(); i += 2)[/code]

How about this:

[code] auto i = 0u;[/code]]]></description>
		<content:encoded><![CDATA[<p>@mttpd:</p>
<pre class="brush: plain; title: ; notranslate">// STILL WRONG: using `int` for size is bad and you should feel bad
for (auto iWRONG = 0; iWRONG &lt; v.size(); i += 2)</pre>
<p>How about this:</p>
<pre class="brush: plain; title: ; notranslate"> auto i = 0u;</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johan Oudinet				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11166</link>
		<dc:creator><![CDATA[Johan Oudinet]]></dc:creator>
		<pubDate>Mon, 10 Jun 2013 11:51:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11166</guid>
					<description><![CDATA[@mttpd: Thanks for your comment. I&#039;ve learnt a lot by reading it ;-)
To come back on David&#039;s suggestion, instead of:
auto w = get_gadget();
I would have used:
auto w = widget { get_gadget() };
making then explicit that I want w to be a widget object. This is similar to what have been done in 2a.1 from https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/
However, I don&#039;t have a good example why it might be important to force w to be of type widget instead of gadget. As you said, if gadget IS-A widget, we are still safe in using the gadget object with anything that wants a widget. The only reason could be if there is no implicit conversion from gadget to widget but then the original code won&#039;t compile.]]></description>
		<content:encoded><![CDATA[<p>@mttpd: Thanks for your comment. I&#8217;ve learnt a lot by reading it ;-)<br />
To come back on David&#8217;s suggestion, instead of:<br />
auto w = get_gadget();<br />
I would have used:<br />
auto w = widget { get_gadget() };<br />
making then explicit that I want w to be a widget object. This is similar to what have been done in 2a.1 from <a href="https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/" rel="nofollow">https://herbsutter.com/2013/05/22/gotw-5-solution-overriding-virtual-functions/</a><br />
However, I don&#8217;t have a good example why it might be important to force w to be of type widget instead of gadget. As you said, if gadget IS-A widget, we are still safe in using the gadget object with anything that wants a widget. The only reason could be if there is no implicit conversion from gadget to widget but then the original code won&#8217;t compile.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11147</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Sun, 09 Jun 2013 18:09:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11147</guid>
					<description><![CDATA[Correction: no, &lt;code&gt;std::cbegin&lt;/code&gt; or &lt;code&gt;std::cend&lt;/code&gt; won&#039;t be necessary here, since the argument&#039;s type is already &lt;code&gt;const&lt;/code&gt; and thus the right, &lt;code&gt;const&lt;/code&gt;-correct overloads of &lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::end&lt;/code&gt; shall be chosen.]]></description>
		<content:encoded><![CDATA[<p>Correction: no, <code>std::cbegin</code> or <code>std::cend</code> won&#8217;t be necessary here, since the argument&#8217;s type is already <code>const</code> and thus the right, <code>const</code>-correct overloads of <code>std::begin</code> and <code>std::end</code> shall be chosen.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11146</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Sun, 09 Jun 2013 17:49:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11146</guid>
					<description><![CDATA[That&#039;s a good catch, afrantzis!

After thinking about it, this makes me tend to prefer the index-based solution (with std::size_t) or even better Boost.Range one (it&#039;s better and IMO is to be preferred since it&#039;s less error-prone and more expressive, analogously to how using STL algorithms is less error-prone &#038; more expressive than hand-coded loops in general) -- since, in addition to &lt;code&gt;auto&lt;/code&gt;, I think we should also use &lt;code&gt;std::cbegin&lt;/code&gt; and &lt;code&gt;std::cend&lt;/code&gt; (from C++14) instead of their non-const counterparts.]]></description>
		<content:encoded><![CDATA[<p>That&#8217;s a good catch, afrantzis!</p>
<p>After thinking about it, this makes me tend to prefer the index-based solution (with std::size_t) or even better Boost.Range one (it&#8217;s better and IMO is to be preferred since it&#8217;s less error-prone and more expressive, analogously to how using STL algorithms is less error-prone &amp; more expressive than hand-coded loops in general) &#8212; since, in addition to <code>auto</code>, I think we should also use <code>std::cbegin</code> and <code>std::cend</code> (from C++14) instead of their non-const counterparts.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: afrantzis				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11143</link>
		<dc:creator><![CDATA[afrantzis]]></dc:creator>
		<pubDate>Sun, 09 Jun 2013 15:44:54 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11143</guid>
					<description><![CDATA[1(a) The code is incorrect, since we are trying to get a non-const iterator to a const container. By using auto we would have avoided this programming error; the expected (and safe) const_iterator type would have been chosen.]]></description>
		<content:encoded><![CDATA[<p>1(a) The code is incorrect, since we are trying to get a non-const iterator to a const container. By using auto we would have avoided this programming error; the expected (and safe) const_iterator type would have been chosen.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11089</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 21:58:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11089</guid>
					<description><![CDATA[David: it&#039;s not necessarily less safe, since the following assumption may not hold (it is not guaranteed): &quot;presumably then `w` is a functioning `widget`.&quot;
If the `gadget` &#038; `widget` types are in the IS-A relationship, we&#039;re facing the so-called slicing problem, see:
http://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c

That being said, your &quot;As long,,,&quot; explanation also applies to the object slicing problem and is a nice description :-)]]></description>
		<content:encoded><![CDATA[<p>David: it&#8217;s not necessarily less safe, since the following assumption may not hold (it is not guaranteed): &#8220;presumably then `w` is a functioning `widget`.&#8221;<br />
If the `gadget` &amp; `widget` types are in the IS-A relationship, we&#8217;re facing the so-called slicing problem, see:<br />
<a href="http://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c" rel="nofollow">http://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c</a></p>
<p>That being said, your &#8220;As long,,,&#8221; explanation also applies to the object slicing problem and is a nice description :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David Thornley				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11088</link>
		<dc:creator><![CDATA[David Thornley]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 21:43:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11088</guid>
					<description><![CDATA[1.  In [code]
// (c)
gadget get_gadget();
// ...
widget w = get_gadget();
[/code]
changing the variable declaration to
[code]
auto w = get_gadget();
[/code]
could be less safe.  In the first case, we get a compile error unless we have an automatic conversion from gadget to widget.  If we have one, there is no error, but presumably then w is a functioning widget.  If we write w.Foo(), we know we&#039;re using widget::Foo().  Either there&#039;s a compiler error or there are no surprises.

In the second case, the type of w is gadget, but we don&#039;t realize that.  We&#039;re presumably assuming the type of w is widget.  As long as we don&#039;t call any function that doesn&#039;t have a counterpart of the same name in gadget, we&#039;re not going to get a compile error, and we&#039;re going to be mistaken in what we&#039;re calling.  If we write w.Foo(), we&#039;re calling gadget::Foo(), which may do something unexpected if we&#039;re unlucky.]]></description>
		<content:encoded><![CDATA[<p>1.  In </p>
<pre class="brush: plain; title: ; notranslate">
// (c)
gadget get_gadget();
// ...
widget w = get_gadget();
</pre>
<p>changing the variable declaration to</p>
<pre class="brush: plain; title: ; notranslate">
auto w = get_gadget();
</pre>
<p>could be less safe.  In the first case, we get a compile error unless we have an automatic conversion from gadget to widget.  If we have one, there is no error, but presumably then w is a functioning widget.  If we write w.Foo(), we know we&#8217;re using widget::Foo().  Either there&#8217;s a compiler error or there are no surprises.</p>
<p>In the second case, the type of w is gadget, but we don&#8217;t realize that.  We&#8217;re presumably assuming the type of w is widget.  As long as we don&#8217;t call any function that doesn&#8217;t have a counterpart of the same name in gadget, we&#8217;re not going to get a compile error, and we&#8217;re going to be mistaken in what we&#8217;re calling.  If we write w.Foo(), we&#8217;re calling gadget::Foo(), which may do something unexpected if we&#8217;re unlucky.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11087</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 21:38:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11087</guid>
					<description><![CDATA[Again, assuming C++14 with polymorphic lambdas supporting universal references, let&#039;s change the code in 1.(d) to: [code]auto get_size = [](auto &#038;&#038; x) { return x.size(); };[/code] (for the reasons see my previous comment).]]></description>
		<content:encoded><![CDATA[<p>Again, assuming C++14 with polymorphic lambdas supporting universal references, let&#8217;s change the code in 1.(d) to: </p>
<pre class="brush: plain; title: ; notranslate">auto get_size = [](auto &amp;&amp; x) { return x.size(); };</pre>
<p> (for the reasons see my previous comment).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11086</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 21:34:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11086</guid>
					<description><![CDATA[Come to think of it, I&#039;d also replace the lambda in 1.(a) with the following (still C++14):
[code][](const auto &#038; value) { /* std::cout &#060;&#060; value; */ }[/code]
or, if the C++14 polymorphic lambdas support universal references (which they hopefully do), simply:
[code][](auto &#038;&#038; value) { /* std::cout &#060;&#060; value; */ }[/code]
(for automatic const-correctness with less typing; and to handle a certain nasty proxy case ;]).]]></description>
		<content:encoded><![CDATA[<p>Come to think of it, I&#8217;d also replace the lambda in 1.(a) with the following (still C++14):</p>
<pre class="brush: plain; title: ; notranslate">[](const auto &amp; value) { /* std::cout &lt;&lt; value; */ }</pre>
<p>or, if the C++14 polymorphic lambdas support universal references (which they hopefully do), simply:</p>
<pre class="brush: plain; title: ; notranslate">[](auto &amp;&amp; value) { /* std::cout &lt;&lt; value; */ }</pre>
<p>(for automatic const-correctness with less typing; and to handle a certain nasty proxy case ;]).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11085</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 21:28:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11085</guid>
					<description><![CDATA[Sigh... one more typo :-) This time, in the code in &quot;1.(a)&quot;, which instead of
[code]for( std::size_t i = 0; i &#060; 0; i += 2 )[/code]
should say
[code]for( std::size_t i = 0; i &#060; v.size(); i += 2 )[/code]

Giving how easy it is to make typos in this context, I&#039;m becoming more and more inclined toward recommending the Boost.Range solution here :-)

Let me use this opportunity to make one more note on the genericity -- the Boost.Range solution in fact only requires a type that is a model of Single Pass Range. This corresponds to an iterator type being a model of Single Pass Iterator (which has even less requirements than a Forward Traversal iterator, let alone a Random Access Iterator).

One could ask then, isn&#039;t requiring a RandomAccessContainer an over-specification?
Well, this is similar to considering whether we should replace `it += 2` with `std::advance(it, 2)`.
After thinking about it, I&#039;d say that there are no good *general* answers here, since it depends on the use case; the trade-offs to consider are as follows:
- either: clear-cut complexity guarantees (`it += 2` is either O(1) or doesn&#039;t compile if we keep the requirement),
- or: increased level of genericity (dropping the requirement; the cost of `std::advance(it, 2)` depends on the iterator category, which depends on the container).

If we go down the road of increased genericity, we&#039;d have to use a `SinglePassRange` concept instead (or `SinglePassContainer` / `SinglePassIterator` where applicable) and carefully document the performance impact of having types modeling a different levels of refinement of this concept.]]></description>
		<content:encoded><![CDATA[<p>Sigh&#8230; one more typo :-) This time, in the code in &#8220;1.(a)&#8221;, which instead of</p>
<pre class="brush: plain; title: ; notranslate">for( std::size_t i = 0; i &lt; 0; i += 2 )</pre>
<p>should say</p>
<pre class="brush: plain; title: ; notranslate">for( std::size_t i = 0; i &lt; v.size(); i += 2 )</pre>
<p>Giving how easy it is to make typos in this context, I&#8217;m becoming more and more inclined toward recommending the Boost.Range solution here :-)</p>
<p>Let me use this opportunity to make one more note on the genericity &#8212; the Boost.Range solution in fact only requires a type that is a model of Single Pass Range. This corresponds to an iterator type being a model of Single Pass Iterator (which has even less requirements than a Forward Traversal iterator, let alone a Random Access Iterator).</p>
<p>One could ask then, isn&#8217;t requiring a RandomAccessContainer an over-specification?<br />
Well, this is similar to considering whether we should replace `it += 2` with `std::advance(it, 2)`.<br />
After thinking about it, I&#8217;d say that there are no good *general* answers here, since it depends on the use case; the trade-offs to consider are as follows:<br />
&#8211; either: clear-cut complexity guarantees (`it += 2` is either O(1) or doesn&#8217;t compile if we keep the requirement),<br />
&#8211; or: increased level of genericity (dropping the requirement; the cost of `std::advance(it, 2)` depends on the iterator category, which depends on the container).</p>
<p>If we go down the road of increased genericity, we&#8217;d have to use a `SinglePassRange` concept instead (or `SinglePassContainer` / `SinglePassIterator` where applicable) and carefully document the performance impact of having types modeling a different levels of refinement of this concept.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-93-auto-variables-part-2/#comment-11073</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 16:07:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2119#comment-11073</guid>
					<description><![CDATA[// Note: posting _once_ again (I *really* wish there was an &quot;edit&quot; option at this point), feel free to remove my previous comments (and this note), was hoping to avoid the hassle with URL formatting, obviously didn&#039;t work; also fixed a few typos and a bug; sorry for any inconvenience this might have caused :-)

1.(a) We can generalize the code from using `int` to other value_types stored in std::vector.

// On a side note: I usually prefer to use `it` for iterators and `i` for indexes for easy disambiguation.

However, since we&#039;re relying on the RandomAccessIterator concept when we do `it += 2`, we can&#039;t generalize beyond the types which model it (as long as we&#039;re talking about the Standard), `std::vector`, `std::array`. and `std::deque` (an old C-style array would work, too).
While we could replace `it += 2` by `std::advance(it, 2)`, this would have performance implications (no longer guaranteed O(1) on this op).

Overall, it&#039;s worth remembering Scott Meyers&#039; advice from &quot;Effective STL&quot;: &quot;Item 2: Beware the illusion of container-independent code.&quot;

However, given that there are multiple types modeling RandomAccessContainer for which `traverse` makes sense, there&#039;s a case for making our `traverse` a bit more generic:
[code]
template &#060;typename RandomAccessContainer&#062;
void traverser( const RandomAccessContainer &#038; v ) {
    using std::begin;
    using std::end;
    for( auto it = begin(v); it != end(v); it += 2 )
[/code]

First, the error part (easily tested for 1-sized vector): since we&#039;re traversing with non-unit stride, we have a potential out of bounds error here (stepping too far). First, we have to change the test condition (`it` relies on being `RandomAccessIterator` for this type of traversal anyway, so that&#039;s fine; see the aforementioned &quot;Item 2&quot;):
[code]for( auto it = begin(v); it &#060; end(v); it += 2 )[/code]

That&#039;s not the end of it -- advancing an iterator past the end is actually undefined behavior.
Credit goes to James McNellis for a solution in this case:
http://stackoverflow.com/questions/9387569/non-unit-iterator-stride-with-non-random-access-iterators

See also:
http://stackoverflow.com/questions/1057724/what-if-i-increment-an-iterator-by-2-when-it-points-onto-the-last-element-of-a-v

Now, let me explain the using declarations `using std::begin` and `using std::end`.
Note, that while `begin(v)` will work for `std::` containers thanks to ADL, it will not work for C-style arrays.
At the same time, simply replacing it with `std::begin` would be a bad idea, since it would prevent the user from applying `traverse` to user-defined containers (which obviously don&#039;t live in `std::`).
Hence, analogously to what we do with `using std::swap` and `swap` in the copy-and-swap idiom, we pull in the `std` namespace into consideration with the using declaration, and keep using unqualified `begin`.
Analogous considerations apply to `end`.

Given all these issues, I&#039;d actually *strongly* consider using indexes here -- note that we won&#039;t lose any genericity, since we&#039;re relying on having a `RandomAccessContainer` anyway -- again, to repeat Scott Meyers&#039; advice from &quot;Effective STL&quot;: &quot;Item 2: Beware the illusion of container-independent code.&quot;

Hence, after further consideration, I think I might possibly go against the grain here and suggest the following instead (together with including `cstddef`):
[code]for( std::size_t i = 0; i &#060; 0; i += 2 )[/code]

If one insists on using iterators here, I think we have to go Boost and use `boost::strided_range` / `boost::adaptors::strided`.
Example: http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/adaptors/reference/strided.html
[code]
// using C++14 polymorphic lambda

#include &#060;boost/range/adaptor/strided.hpp&#062;
#include &#060;boost/range/algorithm/for_each.hpp&#062; 

template &#060;typename RandomAccessContainer&#062;
void traverser( const RandomAccessContainer &#038; input ) {
    using namespace boost::adaptors;
    boost::for_each(
        input &#124; strided(2),
        [](auto value) { /* std::cout &#060;&#060; value; */ });
}
[/code]

To avoid unreadeable compiler diagnostics if our input cointainer&#039;s type doesn&#039;t model `RandomAccessContainer` concept:
- with concepts lite in C++14 we&#039;d constrain on `RandomAccessContainer` (and/or `RandomAccessIterator`) explicitly, instead of just typing out a name.
- in C++11 we could add `static_assert` relying on the `iterator_category` being a `std::random_access_iterator_tag` and providing a readable error message otherwise.

1.(b)
Simply use uniform initialization:
[code]vector&#060;int&#062; v1{5};[/code]
See also &quot;Intuitive interface — Part I&quot; on &quot;Andrzej&#039;s C++ blog&quot; :-)
http://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/

1.(c)
Here we see a case where the code using a hard-coded type has become more brittle -- it&#039;s not robust to changes in the return-type, which could lead to an unexpected object slicing.
Hence:
[code]auto w { get_gadget() };[/code]
On a side note, perhaps it&#039;s also a good idea to keep the standard convention of naming the factories &quot;make&quot;:
[code]auto w { make_gadget() };[/code]

1.(d)

`std::function` implies type-erasure and performance drop due to run-time operations, which is probably not what we want.
Lambda types are not specified, so to keep using these directly we _have_ to use auto:
[code]auto get_size = [](vector&#060;int&#062; x) { return x.size(); };[/code]
It&#039;s worth noting that beyond being unspecified, type names are also unique, so `decltype` wouldn&#039;t work either.
See &quot;Auto – A Necessary Evil?&quot; by Roger Orr in the ACCU&#039;s Overload Journal #115, June 2013.
[PDF] http://accu.org/var/uploads/journals/Overload115.pdf

On a side note, note that (for similar reasons) we&#039;d also prefer to use `auto` if our right-hand side object was a forwarding call wrapper returned by `std::bind` -- so, it&#039;s not just needed for lambdas :-)

2.(a)

Can&#039;t really see an application for `auto` here, I think `auto w { widget() }` might be going somewhat overboard (it&#039;s not even shorter to type, don&#039;t see any clarity gain).
// In either case, we&#039;re relying on the `widget` modeling the `DefaultConstructible` concept.

2.(b)

Problem #1: using an `int` for a variable storing the size is a horrid crime against humanity! :D

I would&#039;ve used `std::size_t` from `cstddef`, but I can see a case where `auto` could also work here.
Not to be too optimistic/complacent, however, there&#039;s a downside to using `auto` in a similar context:
[code]
// WRONG: using `int` for size is bad and you should feel bad
for (int iWRONG = 0; iWRONG &#060; v.size(); i += 2)
[/code]
now, let&#039;s say we&#039;d try to use `auto`:
[code]
// STILL WRONG: using `int` for size is bad and you should feel bad
for (auto iWRONG = 0; iWRONG &#060; v.size(); i += 2)
[/code]
The comment still stands, since the type of literal `0` is `int`!
Hence, here we&#039;d have to use a specific type:
[code]
for (std::size_t i = 0; i &#060; v.size(); i += 2)
[/code]

2.(c)

Hard-coding `int` ignores the integral promotion and the &quot;usual arithmetic conversions&quot; (UAC) rules.
The proper result-type is given by the type trait `std::common_type`, with `decltype`-obtained types of `x` and `y`.
Given that it&#039;s probably too much typing and explaining ;], let&#039;s just go with `auto` here:
[code]auto total = x + y;[/code]

2.(d)

This could get tricky, since the UAC could imply a promotion-to-unsigned, making the later predicate `diff &#060; 0` trivially always-false. To make this even more fun, it&#039;s actually implementation defined whether, say, `long int` or `unsigned int` &#034;wins&#034; in the promotion battle :-)

See Stephan T. Lavavej - Core C++, 7, Usual Arithmetic Conversions and Template Metaprogramming:
http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-7-of-n

See also:
http://kanooth.com/blog/2010/08/cpp-templates-usual-arithmetic-conversions.html

This won&#039;t do either:
[code]if (x &#060; y) { /*...*/ }[/code]

Compliant Solution from the CERT&#039;s INT02-CPP (which also explains how the above code is not robust to the integral promotion and UAC rules):
https://www.securecoding.cert.org/confluence/display/cplusplus/INT02-CPP.+Understand+integer+conversion+rules

Given the C++11&#039;s type traits, we can modify the above solution so that the argument to be given to `static_cast` is obtained using `std::make_signed`:
http://en.cppreference.com/w/cpp/types/make_signed

2.(e)

Well, here the intent is unclear, since the truncation from `double` (implied by the `42,0` literal) to `int` could possibly have been desired -- in this case, however, an explicit `static_cast` would be in order (for clarity).

If the truncation is undesired, we&#039;d be better off with the following:
[code]auto i = f(1,2,3) * 42.0;[/code]]]></description>
		<content:encoded><![CDATA[<p>// Note: posting _once_ again (I *really* wish there was an &#8220;edit&#8221; option at this point), feel free to remove my previous comments (and this note), was hoping to avoid the hassle with URL formatting, obviously didn&#8217;t work; also fixed a few typos and a bug; sorry for any inconvenience this might have caused :-)</p>
<p>1.(a) We can generalize the code from using `int` to other value_types stored in std::vector.</p>
<p>// On a side note: I usually prefer to use `it` for iterators and `i` for indexes for easy disambiguation.</p>
<p>However, since we&#8217;re relying on the RandomAccessIterator concept when we do `it += 2`, we can&#8217;t generalize beyond the types which model it (as long as we&#8217;re talking about the Standard), `std::vector`, `std::array`. and `std::deque` (an old C-style array would work, too).<br />
While we could replace `it += 2` by `std::advance(it, 2)`, this would have performance implications (no longer guaranteed O(1) on this op).</p>
<p>Overall, it&#8217;s worth remembering Scott Meyers&#8217; advice from &#8220;Effective STL&#8221;: &#8220;Item 2: Beware the illusion of container-independent code.&#8221;</p>
<p>However, given that there are multiple types modeling RandomAccessContainer for which `traverse` makes sense, there&#8217;s a case for making our `traverse` a bit more generic:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename RandomAccessContainer&gt;
void traverser( const RandomAccessContainer &amp; v ) {
    using std::begin;
    using std::end;
    for( auto it = begin(v); it != end(v); it += 2 )
</pre>
<p>First, the error part (easily tested for 1-sized vector): since we&#8217;re traversing with non-unit stride, we have a potential out of bounds error here (stepping too far). First, we have to change the test condition (`it` relies on being `RandomAccessIterator` for this type of traversal anyway, so that&#8217;s fine; see the aforementioned &#8220;Item 2&#8221;):</p>
<pre class="brush: plain; title: ; notranslate">for( auto it = begin(v); it &lt; end(v); it += 2 )</pre>
<p>That&#8217;s not the end of it &#8212; advancing an iterator past the end is actually undefined behavior.<br />
Credit goes to James McNellis for a solution in this case:<br />
<a href="http://stackoverflow.com/questions/9387569/non-unit-iterator-stride-with-non-random-access-iterators" rel="nofollow">http://stackoverflow.com/questions/9387569/non-unit-iterator-stride-with-non-random-access-iterators</a></p>
<p>See also:<br />
<a href="http://stackoverflow.com/questions/1057724/what-if-i-increment-an-iterator-by-2-when-it-points-onto-the-last-element-of-a-v" rel="nofollow">http://stackoverflow.com/questions/1057724/what-if-i-increment-an-iterator-by-2-when-it-points-onto-the-last-element-of-a-v</a></p>
<p>Now, let me explain the using declarations `using std::begin` and `using std::end`.<br />
Note, that while `begin(v)` will work for `std::` containers thanks to ADL, it will not work for C-style arrays.<br />
At the same time, simply replacing it with `std::begin` would be a bad idea, since it would prevent the user from applying `traverse` to user-defined containers (which obviously don&#8217;t live in `std::`).<br />
Hence, analogously to what we do with `using std::swap` and `swap` in the copy-and-swap idiom, we pull in the `std` namespace into consideration with the using declaration, and keep using unqualified `begin`.<br />
Analogous considerations apply to `end`.</p>
<p>Given all these issues, I&#8217;d actually *strongly* consider using indexes here &#8212; note that we won&#8217;t lose any genericity, since we&#8217;re relying on having a `RandomAccessContainer` anyway &#8212; again, to repeat Scott Meyers&#8217; advice from &#8220;Effective STL&#8221;: &#8220;Item 2: Beware the illusion of container-independent code.&#8221;</p>
<p>Hence, after further consideration, I think I might possibly go against the grain here and suggest the following instead (together with including `cstddef`):</p>
<pre class="brush: plain; title: ; notranslate">for( std::size_t i = 0; i &lt; 0; i += 2 )</pre>
<p>If one insists on using iterators here, I think we have to go Boost and use `boost::strided_range` / `boost::adaptors::strided`.<br />
Example: <a href="http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/adaptors/reference/strided.html" rel="nofollow">http://www.boost.org/doc/libs/release/libs/range/doc/html/range/reference/adaptors/reference/strided.html</a></p>
<pre class="brush: plain; title: ; notranslate">
// using C++14 polymorphic lambda

#include &lt;boost/range/adaptor/strided.hpp&gt;
#include &lt;boost/range/algorithm/for_each.hpp&gt; 

template &lt;typename RandomAccessContainer&gt;
void traverser( const RandomAccessContainer &amp; input ) {
    using namespace boost::adaptors;
    boost::for_each(
        input | strided(2),
        [](auto value) { /* std::cout &lt;&lt; value; */ });
}
</pre>
<p>To avoid unreadeable compiler diagnostics if our input cointainer&#8217;s type doesn&#8217;t model `RandomAccessContainer` concept:<br />
&#8211; with concepts lite in C++14 we&#8217;d constrain on `RandomAccessContainer` (and/or `RandomAccessIterator`) explicitly, instead of just typing out a name.<br />
&#8211; in C++11 we could add `static_assert` relying on the `iterator_category` being a `std::random_access_iterator_tag` and providing a readable error message otherwise.</p>
<p>1.(b)<br />
Simply use uniform initialization:</p>
<pre class="brush: plain; title: ; notranslate">vector&lt;int&gt; v1{5};</pre>
<p>See also &#8220;Intuitive interface — Part I&#8221; on &#8220;Andrzej&#8217;s C++ blog&#8221; :-)<br />
<a href="http://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/" rel="nofollow">http://akrzemi1.wordpress.com/2013/06/05/intuitive-interface-part-i/</a></p>
<p>1.(c)<br />
Here we see a case where the code using a hard-coded type has become more brittle &#8212; it&#8217;s not robust to changes in the return-type, which could lead to an unexpected object slicing.<br />
Hence:</p>
<pre class="brush: plain; title: ; notranslate">auto w { get_gadget() };</pre>
<p>On a side note, perhaps it&#8217;s also a good idea to keep the standard convention of naming the factories &#8220;make&#8221;:</p>
<pre class="brush: plain; title: ; notranslate">auto w { make_gadget() };</pre>
<p>1.(d)</p>
<p>`std::function` implies type-erasure and performance drop due to run-time operations, which is probably not what we want.<br />
Lambda types are not specified, so to keep using these directly we _have_ to use auto:</p>
<pre class="brush: plain; title: ; notranslate">auto get_size = [](vector&lt;int&gt; x) { return x.size(); };</pre>
<p>It&#8217;s worth noting that beyond being unspecified, type names are also unique, so `decltype` wouldn&#8217;t work either.<br />
See &#8220;Auto – A Necessary Evil?&#8221; by Roger Orr in the ACCU&#8217;s Overload Journal #115, June 2013.<br />
[PDF] <a href="http://accu.org/var/uploads/journals/Overload115.pdf" rel="nofollow">http://accu.org/var/uploads/journals/Overload115.pdf</a></p>
<p>On a side note, note that (for similar reasons) we&#8217;d also prefer to use `auto` if our right-hand side object was a forwarding call wrapper returned by `std::bind` &#8212; so, it&#8217;s not just needed for lambdas :-)</p>
<p>2.(a)</p>
<p>Can&#8217;t really see an application for `auto` here, I think `auto w { widget() }` might be going somewhat overboard (it&#8217;s not even shorter to type, don&#8217;t see any clarity gain).<br />
// In either case, we&#8217;re relying on the `widget` modeling the `DefaultConstructible` concept.</p>
<p>2.(b)</p>
<p>Problem #1: using an `int` for a variable storing the size is a horrid crime against humanity! :D</p>
<p>I would&#8217;ve used `std::size_t` from `cstddef`, but I can see a case where `auto` could also work here.<br />
Not to be too optimistic/complacent, however, there&#8217;s a downside to using `auto` in a similar context:</p>
<pre class="brush: plain; title: ; notranslate">
// WRONG: using `int` for size is bad and you should feel bad
for (int iWRONG = 0; iWRONG &lt; v.size(); i += 2)
</pre>
<p>now, let&#8217;s say we&#8217;d try to use `auto`:</p>
<pre class="brush: plain; title: ; notranslate">
// STILL WRONG: using `int` for size is bad and you should feel bad
for (auto iWRONG = 0; iWRONG &lt; v.size(); i += 2)
</pre>
<p>The comment still stands, since the type of literal `0` is `int`!<br />
Hence, here we&#8217;d have to use a specific type:</p>
<pre class="brush: plain; title: ; notranslate">
for (std::size_t i = 0; i &lt; v.size(); i += 2)
</pre>
<p>2.(c)</p>
<p>Hard-coding `int` ignores the integral promotion and the &#8220;usual arithmetic conversions&#8221; (UAC) rules.<br />
The proper result-type is given by the type trait `std::common_type`, with `decltype`-obtained types of `x` and `y`.<br />
Given that it&#8217;s probably too much typing and explaining ;], let&#8217;s just go with `auto` here:</p>
<pre class="brush: plain; title: ; notranslate">auto total = x + y;</pre>
<p>2.(d)</p>
<p>This could get tricky, since the UAC could imply a promotion-to-unsigned, making the later predicate `diff &lt; 0` trivially always-false. To make this even more fun, it&#039;s actually implementation defined whether, say, `long int` or `unsigned int` &quot;wins&quot; in the promotion battle :-)</p>
<p>See Stephan T. Lavavej &#8211; Core C++, 7, Usual Arithmetic Conversions and Template Metaprogramming:<br />
<a href="http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-7-of-n" rel="nofollow">http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-/Stephan-T-Lavavej-Core-C-7-of-n</a></p>
<p>See also:<br />
<a href="http://kanooth.com/blog/2010/08/cpp-templates-usual-arithmetic-conversions.html" rel="nofollow">http://kanooth.com/blog/2010/08/cpp-templates-usual-arithmetic-conversions.html</a></p>
<p>This won&#039;t do either:</p>
<pre class="brush: plain; title: ; notranslate">if (x &lt; y) { /*...*/ }</pre>
<p>Compliant Solution from the CERT&#039;s INT02-CPP (which also explains how the above code is not robust to the integral promotion and UAC rules):<br />
<a href="https://www.securecoding.cert.org/confluence/display/cplusplus/INT02-CPP.+Understand+integer+conversion+rules" rel="nofollow">https://www.securecoding.cert.org/confluence/display/cplusplus/INT02-CPP.+Understand+integer+conversion+rules</a></p>
<p>Given the C++11&#039;s type traits, we can modify the above solution so that the argument to be given to `static_cast` is obtained using `std::make_signed`:<br />
<a href="http://en.cppreference.com/w/cpp/types/make_signed" rel="nofollow">http://en.cppreference.com/w/cpp/types/make_signed</a></p>
<p>2.(e)</p>
<p>Well, here the intent is unclear, since the truncation from `double` (implied by the `42,0` literal) to `int` could possibly have been desired &#8212; in this case, however, an explicit `static_cast` would be in order (for clarity).</p>
<p>If the truncation is undesired, we&#039;d be better off with the following:</p>
<pre class="brush: plain; title: ; notranslate">auto i = f(1,2,3) * 42.0;</pre>
]]></content:encoded>
					</item>
			</channel>
</rss>
