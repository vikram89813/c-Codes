<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #92 Solution: Auto Variables, Part 1	</title>
	<atom:link href="https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: The C++ Ten Commandments &#124; Marius Bancila&#039;s Blog				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-28837</link>
		<dc:creator><![CDATA[The C++ Ten Commandments &#124; Marius Bancila&#039;s Blog]]></dc:creator>
		<pubDate>Wed, 01 Oct 2014 14:51:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-28837</guid>
					<description><![CDATA[[&#8230;] is a large and complex subject and I recommend some additional readings: Auto Variables, Part 1, Auto Variables, Part 2, AAA Style (Almost Always [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] is a large and complex subject and I recommend some additional readings: Auto Variables, Part 1, Auto Variables, Part 2, AAA Style (Almost Always [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++11语言扩展：常规特性 &#124; zengine				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-14136</link>
		<dc:creator><![CDATA[C++11语言扩展：常规特性 &#124; zengine]]></dc:creator>
		<pubDate>Wed, 15 Jan 2014 16:28:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-14136</guid>
					<description><![CDATA[[&#8230;] Herb Sutter: GotW #92: Auto Variables, Part 1 [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Herb Sutter: GotW #92: Auto Variables, Part 1 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Declaration and initialization with auto &#124; Feheren Fekete				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-13969</link>
		<dc:creator><![CDATA[Declaration and initialization with auto &#124; Feheren Fekete]]></dc:creator>
		<pubDate>Tue, 31 Dec 2013 13:57:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-13969</guid>
					<description><![CDATA[[&#8230;] https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/ [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] <a href="https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/" rel="nofollow">https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/</a> [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Maxim Yanchenko				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11574</link>
		<dc:creator><![CDATA[Maxim Yanchenko]]></dc:creator>
		<pubDate>Thu, 20 Jun 2013 23:00:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11574</guid>
					<description><![CDATA[@Herb, thanks for the article!
2 questions as I didn&#039;t chase it closely:
1) Will auto pick type attributes like alignment? The code I mean is smth like:
[code]
typedef float aligned_block[4] alignas(16);
aligned_block a{...};
auto b = a; // is b aligned on 16?
[/code]

2) what about explicit auto? Is there any protection for private classes that we don&#039;t want to expose (e.g. because it holds references to temporary objects from the enclosing full expression)?]]></description>
		<content:encoded><![CDATA[<p>@Herb, thanks for the article!<br />
2 questions as I didn&#8217;t chase it closely:<br />
1) Will auto pick type attributes like alignment? The code I mean is smth like:</p>
<pre class="brush: plain; title: ; notranslate">
typedef float aligned_block[4] alignas(16);
aligned_block a{...};
auto b = a; // is b aligned on 16?
</pre>
<p>2) what about explicit auto? Is there any protection for private classes that we don&#8217;t want to expose (e.g. because it holds references to temporary objects from the enclosing full expression)?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: monamimani				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11387</link>
		<dc:creator><![CDATA[monamimani]]></dc:creator>
		<pubDate>Sat, 15 Jun 2013 17:44:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11387</guid>
					<description><![CDATA[@Leo Sorry for being late to reply. It still doesn&#039;t make sense to me and I&#039;ll point out to that the template argument deduction rule doesn&#039;t either.

To me the type of cir it a reference to a int the type of cir is not a int. Ref to int a and int are 2 different types. Then it confuses me that the deduced type it not int&#038;.]]></description>
		<content:encoded><![CDATA[<p>@Leo Sorry for being late to reply. It still doesn&#8217;t make sense to me and I&#8217;ll point out to that the template argument deduction rule doesn&#8217;t either.</p>
<p>To me the type of cir it a reference to a int the type of cir is not a int. Ref to int a and int are 2 different types. Then it confuses me that the deduced type it not int&amp;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11255</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Wed, 12 Jun 2013 19:43:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11255</guid>
					<description><![CDATA[@Herb Hey, Overload Journal is still pretty good! :-)]]></description>
		<content:encoded><![CDATA[<p>@Herb Hey, Overload Journal is still pretty good! :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: abigagli				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11237</link>
		<dc:creator><![CDATA[abigagli]]></dc:creator>
		<pubDate>Wed, 12 Jun 2013 09:08:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11237</guid>
					<description><![CDATA[Great article as usual.
I just found a bit confusing the example for the case of &quot;h&quot;.
If I&#039;m correct, const T&#038; is not a case of top-level const, so in case &quot;h&quot; what happens is actually that reference is stripped off _AND THEN_ what remains is a top level const that gets stripped as such. Am I right?]]></description>
		<content:encoded><![CDATA[<p>Great article as usual.<br />
I just found a bit confusing the example for the case of &#8220;h&#8221;.<br />
If I&#8217;m correct, const T&amp; is not a case of top-level const, so in case &#8220;h&#8221; what happens is actually that reference is stripped off _AND THEN_ what remains is a top level const that gets stripped as such. Am I right?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11180</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 10 Jun 2013 17:29:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11180</guid>
					<description><![CDATA[@Phil: Fixed, thanks.

@Ralph: Good suggestion. I was trying to keep it simple, but volatile and &#038;&#038; should be mentioned up front. Updated.

@nosenseetal: That’s very kind, thank you, but I don’t accept donations. I’ve also never run any ads. I have always published my GotW and other articles for free online, and only the final print/e-book versions have been for sale as they’re done through a commercial magazine or book publisher. (Magazines, remember those? How quaint! We do miss C++ Report…)

@Marcel: Thanks, and I’ve adjusted the layout of the table to make things clearer.]]></description>
		<content:encoded><![CDATA[<p>@Phil: Fixed, thanks.</p>
<p>@Ralph: Good suggestion. I was trying to keep it simple, but volatile and &amp;&amp; should be mentioned up front. Updated.</p>
<p>@nosenseetal: That’s very kind, thank you, but I don’t accept donations. I’ve also never run any ads. I have always published my GotW and other articles for free online, and only the final print/e-book versions have been for sale as they’re done through a commercial magazine or book publisher. (Magazines, remember those? How quaint! We do miss C++ Report…)</p>
<p>@Marcel: Thanks, and I’ve adjusted the layout of the table to make things clearer.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marcel Wid				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11168</link>
		<dc:creator><![CDATA[Marcel Wid]]></dc:creator>
		<pubDate>Mon, 10 Jun 2013 13:10:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11168</guid>
					<description><![CDATA[I like to think about auto type deduction in terms of template argument deduction (@Herb: You should replace &quot;parameter&quot; by &quot;argument&quot; in the heading of the 2nd column). The above table may be extended to
[code]
auto         x = expr;    template&#060;class U&#062; void f(U t);         f(expr); //(1)
const auto   x = expr;    template&#060;class U&#062; void f(const U t);   f(expr); //(2)
auto&#038;        x = expr;    template&#060;class U&#062; void f(U&#038; t);        f(expr); //(3)
const auto&#038;  x = expr;    template&#060;class U&#062; void f(const U&#038; t);  f(expr); //(4)
auto&#038;&#038;       x = expr;    template&#060;class U&#062; void f(U&#038;&#038; t);       f(expr); //(5)
const auto&#038;&#038; x = expr;    template&#060;class U&#062; void f(const U&#038;&#038; t); f(expr); //(6)
[/code]
If expr has type &quot;reference to T&quot;, then this type is adjusted to &quot;T&quot; prior to any further analysis. This has nothing to do with auto, this is a general rule in C++. For auto type deduction this means that we can ignore any
reference-ness on expr. We denote this adjusted type of expr by A. To further analyse what&#039;s going on behind the scene, it is comfortable to denote the parameter type of f by P, for example
in case (4) above P is &quot;const U&#038;&quot;, in case (5) it is &quot;U&#038;&#038;&quot;. Now we have to distinguish between the following cases:
- P is not a reference type (cases (1) and (2) above):
1. If A is an array or function type, A is replaced by the pointer resulting from array-to-pointer or function-to-pointer conversion
[code]
int a[7];
const int b[7];
auto x = a;
auto y = b;
[/code]
then x is of type int* and y of type const int*.
2. If A is a cv-qualified type, the the cv-qualifiers are ignored.
[code]
const int&#038; cir = 0;
auto         h = cir;
[/code]
Here cir has type &quot;reference to const int&quot;. This is adjusted to &quot;const int&quot; (=A) and now const is ignored and the type of h is int.
- If P is cv-qualified the top-level cv-qualifiers are ignored for type deduction (case (2) above).
[code]
int&#038; ir      = 0;
const auto x = ir;
[/code]
Here again, &#038; is dropped from ir and const is ignored, so we have to determine U such that &quot;f(int) = f(U)&quot;, hence &quot;U = int&quot; and the type of x is const int.
Now it gets a bit more involved:
- If P is a reference type, type referred to by P is used for type deduction (and if this resulting type is cv-qualified, the cv-qualifiers are ignored). If P is an rvalue reference to a cv-unqualified template parameter
and the argument is an lvalue, the type “lvalue reference to A” is used in place of A for type deduction.
[code]
const double&#038; rd = 1.0;
int&#038;&#038;         ri = 0;
auto&#038;&#038;         x = rd;
auto&#038;&#038;         y = ri;
[/code]
Here we are in case (5). P is an rvalue reference to a cv-unqualified template parameter (U&#038;&#038;) and the argument is an lvalue (rd), so A (which is &quot;const int&quot;, note that here const is not dropped!)
gets replaced by &quot;const double&#038;&quot; and U is deduced to be &quot;const double&#038;&quot;. Now reference collapsing comes in (&#038; &#038;&#038; becomes &#038;) and x is of type const double&#038;. Similarly, y is of type int&#038; (note that ri is an lvalue).
[code]
int&#038;&#038;         ri = 0;
const auto&#038;&#038;   y = ri;
[/code]
Here we are in case (6) and get a compiler error. Why? P is an rvalue reference to a cv-QUALIFIED template parameter. After dropping &#038; and const from P (A is int), we have to find U such that &quot;f(U) = f(int)&quot;. Hence &quot;U = int&quot;.
The type of y becomes &quot;const int&#038;&#038;&quot;, but binding an lvalue (ri) to an rvalue reference is not allowed.
[code]
const int&#038; cir = 0;
auto&#038;        x = cir;
[/code]
Here we are in case (3). A is &quot;const int&quot; and we have to deduce U such that &quot;f(const int) = f(U)&quot;, thus &quot;U = const int&quot;. The type of x is const int&#038;. I hope, this helps clarifying how auto works.]]></description>
		<content:encoded><![CDATA[<p>I like to think about auto type deduction in terms of template argument deduction (@Herb: You should replace &#8220;parameter&#8221; by &#8220;argument&#8221; in the heading of the 2nd column). The above table may be extended to</p>
<pre class="brush: plain; title: ; notranslate">
auto         x = expr;    template&lt;class U&gt; void f(U t);         f(expr); //(1)
const auto   x = expr;    template&lt;class U&gt; void f(const U t);   f(expr); //(2)
auto&amp;        x = expr;    template&lt;class U&gt; void f(U&amp; t);        f(expr); //(3)
const auto&amp;  x = expr;    template&lt;class U&gt; void f(const U&amp; t);  f(expr); //(4)
auto&amp;&amp;       x = expr;    template&lt;class U&gt; void f(U&amp;&amp; t);       f(expr); //(5)
const auto&amp;&amp; x = expr;    template&lt;class U&gt; void f(const U&amp;&amp; t); f(expr); //(6)
</pre>
<p>If expr has type &#8220;reference to T&#8221;, then this type is adjusted to &#8220;T&#8221; prior to any further analysis. This has nothing to do with auto, this is a general rule in C++. For auto type deduction this means that we can ignore any<br />
reference-ness on expr. We denote this adjusted type of expr by A. To further analyse what&#8217;s going on behind the scene, it is comfortable to denote the parameter type of f by P, for example<br />
in case (4) above P is &#8220;const U&amp;&#8221;, in case (5) it is &#8220;U&amp;&amp;&#8221;. Now we have to distinguish between the following cases:<br />
&#8211; P is not a reference type (cases (1) and (2) above):<br />
1. If A is an array or function type, A is replaced by the pointer resulting from array-to-pointer or function-to-pointer conversion</p>
<pre class="brush: plain; title: ; notranslate">
int a[7];
const int b[7];
auto x = a;
auto y = b;
</pre>
<p>then x is of type int* and y of type const int*.<br />
2. If A is a cv-qualified type, the the cv-qualifiers are ignored.</p>
<pre class="brush: plain; title: ; notranslate">
const int&amp; cir = 0;
auto         h = cir;
</pre>
<p>Here cir has type &#8220;reference to const int&#8221;. This is adjusted to &#8220;const int&#8221; (=A) and now const is ignored and the type of h is int.<br />
&#8211; If P is cv-qualified the top-level cv-qualifiers are ignored for type deduction (case (2) above).</p>
<pre class="brush: plain; title: ; notranslate">
int&amp; ir      = 0;
const auto x = ir;
</pre>
<p>Here again, &amp; is dropped from ir and const is ignored, so we have to determine U such that &#8220;f(int) = f(U)&#8221;, hence &#8220;U = int&#8221; and the type of x is const int.<br />
Now it gets a bit more involved:<br />
&#8211; If P is a reference type, type referred to by P is used for type deduction (and if this resulting type is cv-qualified, the cv-qualifiers are ignored). If P is an rvalue reference to a cv-unqualified template parameter<br />
and the argument is an lvalue, the type “lvalue reference to A” is used in place of A for type deduction.</p>
<pre class="brush: plain; title: ; notranslate">
const double&amp; rd = 1.0;
int&amp;&amp;         ri = 0;
auto&amp;&amp;         x = rd;
auto&amp;&amp;         y = ri;
</pre>
<p>Here we are in case (5). P is an rvalue reference to a cv-unqualified template parameter (U&amp;&amp;) and the argument is an lvalue (rd), so A (which is &#8220;const int&#8221;, note that here const is not dropped!)<br />
gets replaced by &#8220;const double&amp;&#8221; and U is deduced to be &#8220;const double&amp;&#8221;. Now reference collapsing comes in (&amp; &amp;&amp; becomes &amp;) and x is of type const double&amp;. Similarly, y is of type int&amp; (note that ri is an lvalue).</p>
<pre class="brush: plain; title: ; notranslate">
int&amp;&amp;         ri = 0;
const auto&amp;&amp;   y = ri;
</pre>
<p>Here we are in case (6) and get a compiler error. Why? P is an rvalue reference to a cv-QUALIFIED template parameter. After dropping &amp; and const from P (A is int), we have to find U such that &#8220;f(U) = f(int)&#8221;. Hence &#8220;U = int&#8221;.<br />
The type of y becomes &#8220;const int&amp;&amp;&#8221;, but binding an lvalue (ri) to an rvalue reference is not allowed.</p>
<pre class="brush: plain; title: ; notranslate">
const int&amp; cir = 0;
auto&amp;        x = cir;
</pre>
<p>Here we are in case (3). A is &#8220;const int&#8221; and we have to deduce U such that &#8220;f(const int) = f(U)&#8221;, thus &#8220;U = const int&#8221;. The type of x is const int&amp;. I hope, this helps clarifying how auto works.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mathias Stearn				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11122</link>
		<dc:creator><![CDATA[Mathias Stearn]]></dc:creator>
		<pubDate>Sat, 08 Jun 2013 20:17:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11122</guid>
					<description><![CDATA[It might be worth adding the following examples. After reading this article I felt the need to test these cases since auto expands to &quot;const int&quot; which does have a top-level const even though the full types of g2 and h2 don&#039;t.

[code]
const int   ci  = val;
auto        g   = ci;
auto&#038;       g2  = ci;

const int&#038;  cir = val;
auto        h   = cir;
auto&#038;       h2  = cir;
[/code]

Also, I&#039;m curious about auto&#038;&#038;. I think it would only be an rvalue-ref when the right hand side was a value or rvalue-ref returned from a function. Is there any detail I&#039;m missing?]]></description>
		<content:encoded><![CDATA[<p>It might be worth adding the following examples. After reading this article I felt the need to test these cases since auto expands to &#8220;const int&#8221; which does have a top-level const even though the full types of g2 and h2 don&#8217;t.</p>
<pre class="brush: plain; title: ; notranslate">
const int   ci  = val;
auto        g   = ci;
auto&amp;       g2  = ci;

const int&amp;  cir = val;
auto        h   = cir;
auto&amp;       h2  = cir;
</pre>
<p>Also, I&#8217;m curious about auto&amp;&amp;. I think it would only be an rvalue-ref when the right hand side was a value or rvalue-ref returned from a function. Is there any detail I&#8217;m missing?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11112</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Sat, 08 Jun 2013 13:25:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11112</guid>
					<description><![CDATA[@Herb 
did you consider putting donate button on your site... I personally dont really buy books, but I appreciate your work with refresnihg GotW and new GotWs and I would like to have option to show my appreciation with my euros. :D
IDK if other ppl agree so this is just IMO :D]]></description>
		<content:encoded><![CDATA[<p>@Herb<br />
did you consider putting donate button on your site&#8230; I personally dont really buy books, but I appreciate your work with refresnihg GotW and new GotWs and I would like to have option to show my appreciation with my euros. :D<br />
IDK if other ppl agree so this is just IMO :D</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Amali				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11097</link>
		<dc:creator><![CDATA[Amali]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 23:19:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11097</guid>
					<description><![CDATA[The image was blocked in my system, now I can see the image.]]></description>
		<content:encoded><![CDATA[<p>The image was blocked in my system, now I can see the image.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Amali				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11093</link>
		<dc:creator><![CDATA[Amali]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 23:05:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11093</guid>
					<description><![CDATA[@Herb,
The table you mentioned for question 4 is only visible in this post in your website, but not in the post I received in my inbox. I wonder why?]]></description>
		<content:encoded><![CDATA[<p>@Herb,<br />
The table you mentioned for question 4 is only visible in this post in your website, but not in the post I received in my inbox. I wonder why?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11083</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 19:54:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11083</guid>
					<description><![CDATA[Maybe you should mention that volatile is also stripped from the right hand side type for completeness. This highlights the symmetry of const and volatile. Are there any other things that can be stripped? In the second section you say &quot;such as top-level const-ness and reference-ness&quot;. Instead you could say &quot;which are top-level const-ness, volatile-ness and reference-ness&quot;. Just a thought.]]></description>
		<content:encoded><![CDATA[<p>Maybe you should mention that volatile is also stripped from the right hand side type for completeness. This highlights the symmetry of const and volatile. Are there any other things that can be stripped? In the second section you say &#8220;such as top-level const-ness and reference-ness&#8221;. Instead you could say &#8220;which are top-level const-ness, volatile-ness and reference-ness&#8221;. Just a thought.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Leo				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11082</link>
		<dc:creator><![CDATA[Leo]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 19:48:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11082</guid>
					<description><![CDATA[@monamimani
Take a look at what Herb wrote about e. Similar reasoning applies to h. cir is a reference to val and it would not allow to change val. But
[code]
auto h = cir;
[/code]
is equivalent to
[code]
auto h = val;
[/code]

In the case of f ip is not a different name for val. It&#039;s a pointer to a location in memory, it contains an address.
[code]
auto f = ip;
[/code]
assigns to f the address contained in ip, not the integer contained in val.]]></description>
		<content:encoded><![CDATA[<p>@monamimani<br />
Take a look at what Herb wrote about e. Similar reasoning applies to h. cir is a reference to val and it would not allow to change val. But</p>
<pre class="brush: plain; title: ; notranslate">
auto h = cir;
</pre>
<p>is equivalent to</p>
<pre class="brush: plain; title: ; notranslate">
auto h = val;
</pre>
<p>In the case of f ip is not a different name for val. It&#8217;s a pointer to a location in memory, it contains an address.</p>
<pre class="brush: plain; title: ; notranslate">
auto f = ip;
</pre>
<p>assigns to f the address contained in ip, not the integer contained in val.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Phil Barila				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11076</link>
		<dc:creator><![CDATA[Phil Barila]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 17:14:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11076</guid>
					<description><![CDATA[The first letter of the explanatory paragraph after:
&quot;The type of i is const int*.&quot;
is a stray &#039;s&#039;.]]></description>
		<content:encoded><![CDATA[<p>The first letter of the explanatory paragraph after:<br />
&#8220;The type of i is const int*.&#8221;<br />
is a stray &#8216;s&#8217;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: monamimani				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11075</link>
		<dc:creator><![CDATA[monamimani]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 17:03:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11075</guid>
					<description><![CDATA[I really don&#039;t understand why f is a int* while h is int. That doesn&#039;t make sense to me. Anybody can explain? To me I don&#039;t see any common rule to this.

Thanks]]></description>
		<content:encoded><![CDATA[<p>I really don&#8217;t understand why f is a int* while h is int. That doesn&#8217;t make sense to me. Anybody can explain? To me I don&#8217;t see any common rule to this.</p>
<p>Thanks</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11067</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 14:39:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11067</guid>
					<description><![CDATA[@davidphilliposter: Fixed, thanks. I&#039;ll keep the comment, I like accountability and giving credit.]]></description>
		<content:encoded><![CDATA[<p>@davidphilliposter: Fixed, thanks. I&#8217;ll keep the comment, I like accountability and giving credit.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: davidphilliposter				</title>
				<link>https://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/#comment-11064</link>
		<dc:creator><![CDATA[davidphilliposter]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 14:32:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2109#comment-11064</guid>
					<description><![CDATA[typo &quot;you really are declaring a your own new local variable&quot; extra &quot;a&quot; (Feel free to delete this comment)]]></description>
		<content:encoded><![CDATA[<p>typo &#8220;you really are declaring a your own new local variable&#8221; extra &#8220;a&#8221; (Feel free to delete this comment)</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
