<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #93 Solution: Auto Variables, Part 2	</title>
	<atom:link href="https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: The C++ Ten Commandments &#124; Marius Bancila&#039;s Blog				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-28838</link>
		<dc:creator><![CDATA[The C++ Ten Commandments &#124; Marius Bancila&#039;s Blog]]></dc:creator>
		<pubDate>Wed, 01 Oct 2014 14:54:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-28838</guid>
					<description><![CDATA[[&#8230;] is a large and complex subject and I recommend some additional readings: Auto Variables, Part 1, Auto Variables, Part 2, AAA Style (Almost Always [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] is a large and complex subject and I recommend some additional readings: Auto Variables, Part 1, Auto Variables, Part 2, AAA Style (Almost Always [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Auto Pilot &#124; LightSleeper				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-14283</link>
		<dc:creator><![CDATA[Auto Pilot &#124; LightSleeper]]></dc:creator>
		<pubDate>Fri, 31 Jan 2014 16:25:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-14283</guid>
					<description><![CDATA[[&#8230;] For even more recommendations on why auto is a good idea (efficiency, guaranteed initialization, and correctness), see Herb&#8217;s GotW #93. [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] For even more recommendations on why auto is a good idea (efficiency, guaranteed initialization, and correctness), see Herb&#8217;s GotW #93. [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C++11语言扩展：常规特性 - 博客 - 伯乐在线				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-14115</link>
		<dc:creator><![CDATA[C++11语言扩展：常规特性 - 博客 - 伯乐在线]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 17:20:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-14115</guid>
					<description><![CDATA[[&#8230;] Herb Sutter: GotW #93: Auto Variables, Part 2 [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Herb Sutter: GotW #93: Auto Variables, Part 2 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-14041</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 15:19:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-14041</guid>
					<description><![CDATA[@PP: Fixed, thanks.]]></description>
		<content:encoded><![CDATA[<p>@PP: Fixed, thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: PP				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-14040</link>
		<dc:creator><![CDATA[PP]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 13:49:35 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-14040</guid>
					<description><![CDATA[Not sure where to send this, so feel free to remove this comment! There is a typo in: CHAR_BITS*izeof(int)-1]]></description>
		<content:encoded><![CDATA[<p>Not sure where to send this, so feel free to remove this comment! There is a typo in: CHAR_BITS*izeof(int)-1</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Declaration and initialization with auto &#124; Feheren Fekete				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-13970</link>
		<dc:creator><![CDATA[Declaration and initialization with auto &#124; Feheren Fekete]]></dc:creator>
		<pubDate>Tue, 31 Dec 2013 13:57:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-13970</guid>
					<description><![CDATA[[&#8230;] https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/ [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] <a href="https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/" rel="nofollow">https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/</a> [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Seungbeom Kim				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-13577</link>
		<dc:creator><![CDATA[Seungbeom Kim]]></dc:creator>
		<pubDate>Sun, 01 Dec 2013 07:56:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-13577</guid>
					<description><![CDATA[&#062; The first, again, is that &lt;code&gt;int&lt;/code&gt; may not be big enough to avoid truncating the result, so we might lose information if &lt;code&gt;x – y&lt;/code&gt; produces something larger than an &lt;code&gt;int&lt;/code&gt;. Using &lt;code&gt;auto&lt;/code&gt; can help with that.

My understanding is that, if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;int&lt;/code&gt;, then &lt;code&gt;x - y&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt; and is not converted automatically to a bigger type if the result does not fit in an &lt;code&gt;int&lt;/code&gt;, so overflow happens inside the expression &lt;code&gt;x - y&lt;/code&gt; and &lt;code&gt;auto&lt;/code&gt; doesn&#039;t help here. For example, with &lt;code&gt;int x = INT_MAX, y = INT_MIN;&lt;/code&gt;, &lt;code&gt;auto diff = x - y;&lt;/code&gt; will be the same as &lt;code&gt;int diff = x - y;&lt;/code&gt; and will overflow despite the &lt;code&gt;auto&lt;/code&gt;; you should have promoted an operand (or both) to a bigger type before the subtraction operation. Is my understanding correct?]]></description>
		<content:encoded><![CDATA[<p>&gt; The first, again, is that <code>int</code> may not be big enough to avoid truncating the result, so we might lose information if <code>x – y</code> produces something larger than an <code>int</code>. Using <code>auto</code> can help with that.</p>
<p>My understanding is that, if <code>x</code> and <code>y</code> are <code>int</code>, then <code>x - y</code> is <code>int</code> and is not converted automatically to a bigger type if the result does not fit in an <code>int</code>, so overflow happens inside the expression <code>x - y</code> and <code>auto</code> doesn&#8217;t help here. For example, with <code>int x = INT_MAX, y = INT_MIN;</code>, <code>auto diff = x - y;</code> will be the same as <code>int diff = x - y;</code> and will overflow despite the <code>auto</code>; you should have promoted an operand (or both) to a bigger type before the subtraction operation. Is my understanding correct?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anders Dalvander				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11865</link>
		<dc:creator><![CDATA[Anders Dalvander]]></dc:creator>
		<pubDate>Sat, 06 Jul 2013 16:12:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11865</guid>
					<description><![CDATA[It would be cute to be able to write:
[code]for (auto s = v.size(), i = {}; i &#060; s; i += 2)[/code]
But `auto` doesn&#039;t like {}, which is understandable in the simple case [code]auto i = {};[/code], but here the type can be implied by `s`.]]></description>
		<content:encoded><![CDATA[<p>It would be cute to be able to write:</p>
<pre class="brush: plain; title: ; notranslate">for (auto s = v.size(), i = {}; i &lt; s; i += 2)</pre>
<p>But `auto` doesn&#8217;t like {}, which is understandable in the simple case </p>
<pre class="brush: plain; title: ; notranslate">auto i = {};</pre>
<p>, but here the type can be implied by `s`.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andrei Alexandrescu				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11619</link>
		<dc:creator><![CDATA[Andrei Alexandrescu]]></dc:creator>
		<pubDate>Sun, 23 Jun 2013 18:32:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11619</guid>
					<description><![CDATA[Thanks Herb for bringing this to my attention. Replies @Sebastian within.

&#062;This doesn’t help much. The unexpected type conversion happens as part of integer_expr; all the “helper” does is afterwards cast it back. Yes, the behavior of unsigned to signed when not in range isn’t undefined, just implementation-defined, but that’s enough to make the code non-portable.

This seems to be a misunderstanding of the intent. You use as_xxx in lieu of a cast, and eliminates committal to the width of the type without eliminating committal to the consequences of changing signedness.

&#062;&#062; double f4 = f1 + f2; // … this might keep more bits of precision

&#062;This is incredibly obscure and would definitely not pass code review from me. If you want higher precision, cast the inputs to double. If you don’t want higher resolution, assign the result to a float. Everything else is just a maintenance nightmare.

Makes sense (especially for +, which would use ADDSS thus operating in single precision). My point here is that a common pattern in math code is:

* use float for input due to store size restrictions

* do intermediate computation in double because it costs just a little more for a big win in accuracy

* get back to float when writing results to the store

Due to this pattern, you want to actively cast to double early in the computation chain, sometimes as simple as

double x = array[k];

If auto were used, x and computations derived from it would be float. That&#039;s what I&#039;m saying.]]></description>
		<content:encoded><![CDATA[<p>Thanks Herb for bringing this to my attention. Replies @Sebastian within.</p>
<p>&gt;This doesn’t help much. The unexpected type conversion happens as part of integer_expr; all the “helper” does is afterwards cast it back. Yes, the behavior of unsigned to signed when not in range isn’t undefined, just implementation-defined, but that’s enough to make the code non-portable.</p>
<p>This seems to be a misunderstanding of the intent. You use as_xxx in lieu of a cast, and eliminates committal to the width of the type without eliminating committal to the consequences of changing signedness.</p>
<p>&gt;&gt; double f4 = f1 + f2; // … this might keep more bits of precision</p>
<p>&gt;This is incredibly obscure and would definitely not pass code review from me. If you want higher precision, cast the inputs to double. If you don’t want higher resolution, assign the result to a float. Everything else is just a maintenance nightmare.</p>
<p>Makes sense (especially for +, which would use ADDSS thus operating in single precision). My point here is that a common pattern in math code is:</p>
<p>* use float for input due to store size restrictions</p>
<p>* do intermediate computation in double because it costs just a little more for a big win in accuracy</p>
<p>* get back to float when writing results to the store</p>
<p>Due to this pattern, you want to actively cast to double early in the computation chain, sometimes as simple as</p>
<p>double x = array[k];</p>
<p>If auto were used, x and computations derived from it would be float. That&#8217;s what I&#8217;m saying.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11590</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 19:48:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11590</guid>
					<description><![CDATA[@Jon:  Yes, I&#039;m familiar with Bjarne&#039;s &quot;too pedantic&quot; comment, but I watched one of his presentations from 2012, and the examples in his slides used vector::size_type.

Having spent many blissful years with the compiler warning on reliably catching real bugs, and then a few years at another company with &quot;int i&quot; for loop (and therefore the warning disabled), I conclude that there&#039;s nothing pedantic about it.  Signed/unsigned bugs are insidious and hard to find.  I&#039;m not really worried about the for-loop indexes, but what we miss because those indexes force us to disable the warnings.]]></description>
		<content:encoded><![CDATA[<p>@Jon:  Yes, I&#8217;m familiar with Bjarne&#8217;s &#8220;too pedantic&#8221; comment, but I watched one of his presentations from 2012, and the examples in his slides used vector::size_type.</p>
<p>Having spent many blissful years with the compiler warning on reliably catching real bugs, and then a few years at another company with &#8220;int i&#8221; for loop (and therefore the warning disabled), I conclude that there&#8217;s nothing pedantic about it.  Signed/unsigned bugs are insidious and hard to find.  I&#8217;m not really worried about the for-loop indexes, but what we miss because those indexes force us to disable the warnings.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Pablo Halpern				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11519</link>
		<dc:creator><![CDATA[Pablo Halpern]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 15:29:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11519</guid>
					<description><![CDATA[In 1(d), the original version creates a function which, when invoked, returns void.  The alternative versions return size_type.  I think you meant something like [code]function&#060;size_t(vector&#060;int&#062;)&#062;[/code]
Nice overview of the benefits of auto.  It contained some things I had not thought of.  Note that there is at least one situation in which auto is [b]extremely[/b] dangerous: expressions that return proxy types.  Consider this problem: [code]
vector&#060;bool&#062; v = { ... };
auto b = v.back();   // Oops! b is of type vector&#060;bool&#062;::reference, which is NOT a bool
v.pop_back();
bool a = b;  // Oops! b has been invalidated!
[/code]
Some members of the standards committee have suggested ways to fix this in the language, but I am not familiar with specific proposals.]]></description>
		<content:encoded><![CDATA[<p>In 1(d), the original version creates a function which, when invoked, returns void.  The alternative versions return size_type.  I think you meant something like </p>
<pre class="brush: plain; title: ; notranslate">function&lt;size_t(vector&lt;int&gt;)&gt;</pre>
<p>Nice overview of the benefits of auto.  It contained some things I had not thought of.  Note that there is at least one situation in which auto is [b]extremely[/b] dangerous: expressions that return proxy types.  Consider this problem: </p>
<pre class="brush: plain; title: ; notranslate">
vector&lt;bool&gt; v = { ... };
auto b = v.back();   // Oops! b is of type vector&lt;bool&gt;::reference, which is NOT a bool
v.pop_back();
bool a = b;  // Oops! b has been invalidated!
</pre>
<p>Some members of the standards committee have suggested ways to fix this in the language, but I am not familiar with specific proposals.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11509</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 12:36:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11509</guid>
					<description><![CDATA[I just asked a question on StackOverflow about what the differences between template functions and name lambdas with auto parameters is. Some good answers are coming in. See http://stackoverflow.com/questions/17188485/template-functions-versus-named-lambdas-with-auto-parameters]]></description>
		<content:encoded><![CDATA[<p>I just asked a question on StackOverflow about what the differences between template functions and name lambdas with auto parameters is. Some good answers are coming in. See <a href="http://stackoverflow.com/questions/17188485/template-functions-versus-named-lambdas-with-auto-parameters" rel="nofollow">http://stackoverflow.com/questions/17188485/template-functions-versus-named-lambdas-with-auto-parameters</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11507</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 09:29:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11507</guid>
					<description><![CDATA[Just for your information: These named lambdas with auto parameters have a very interesting use-case which makes them more flexible than the template function alternative. For instance, if you have a template function
[code]
template &#060;typename T&#062;
void func( T t  ) { /*...*/ }
[/code]
and a generic template function
[code]
template &#060;typename F, typename T&#062;
void call( F f, T &#038;&#038; t ) { f(forward&#060;T&#062;(t)); }
[/code]
then the following code will not work
[code]
call( func, 42 );
[/code]
since I would have to write func instead of func here. However this code should work, because func(42) is a valid expression. I actually had this problem in real world code in a physics simulation software I wrote. I can fix it by manually inserting the  but with C++14 lambda with auto parameters it&#039;s much easier and even less code. I just have to replace the definition of the func template function by 
[code]
static const auto func = []( auto T) { /*...*/ }
[/code]
This is even less typing. It makes the code more flexibly usable. I also wondered, if it might be generally a good idea to write named lambdas with auto parameters instead of template functions where possible. This might be food for another GotW. ;) By the way, I posted this stuff on Stackoverflow: http://stackoverflow.com/questions/17169498/why-do-i-need-to-specify-the-template-argument-type-of-a-templated-function-here

It is possible to write this code in old C++ also, but it&#039;s a bit more verbose. It&#039;s gonna work with
[code]
struct { template &#060;typename T&#062; void operator()(T t) { /* ... */ } } func;
[/code]
This is what I&#039;m going to do for my code until C++14 is implemented.]]></description>
		<content:encoded><![CDATA[<p>Just for your information: These named lambdas with auto parameters have a very interesting use-case which makes them more flexible than the template function alternative. For instance, if you have a template function</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename T&gt;
void func( T t  ) { /*...*/ }
</pre>
<p>and a generic template function</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename F, typename T&gt;
void call( F f, T &amp;&amp; t ) { f(forward&lt;T&gt;(t)); }
</pre>
<p>then the following code will not work</p>
<pre class="brush: plain; title: ; notranslate">
call( func, 42 );
</pre>
<p>since I would have to write func instead of func here. However this code should work, because func(42) is a valid expression. I actually had this problem in real world code in a physics simulation software I wrote. I can fix it by manually inserting the  but with C++14 lambda with auto parameters it&#8217;s much easier and even less code. I just have to replace the definition of the func template function by </p>
<pre class="brush: plain; title: ; notranslate">
static const auto func = []( auto T) { /*...*/ }
</pre>
<p>This is even less typing. It makes the code more flexibly usable. I also wondered, if it might be generally a good idea to write named lambdas with auto parameters instead of template functions where possible. This might be food for another GotW. ;) By the way, I posted this stuff on Stackoverflow: <a href="http://stackoverflow.com/questions/17169498/why-do-i-need-to-specify-the-template-argument-type-of-a-templated-function-here" rel="nofollow">http://stackoverflow.com/questions/17169498/why-do-i-need-to-specify-the-template-argument-type-of-a-templated-function-here</a></p>
<p>It is possible to write this code in old C++ also, but it&#8217;s a bit more verbose. It&#8217;s gonna work with</p>
<pre class="brush: plain; title: ; notranslate">
struct { template &lt;typename T&gt; void operator()(T t) { /* ... */ } } func;
</pre>
<p>This is what I&#8217;m going to do for my code until C++14 is implemented.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Amali				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11504</link>
		<dc:creator><![CDATA[Amali]]></dc:creator>
		<pubDate>Wed, 19 Jun 2013 02:38:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11504</guid>
					<description><![CDATA[[code]
// best
auto get_size = [](const auto&#038; x) { return x.size(); };
[/code]
This code for auto lambda parameter types gives compiler error messages in gcc 4.8.0. Is there a compiler where it will work? 
Thanks,
Amali.]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">
// best
auto get_size = [](const auto&amp; x) { return x.size(); };
</pre>
<p>This code for auto lambda parameter types gives compiler error messages in gcc 4.8.0. Is there a compiler where it will work?<br />
Thanks,<br />
Amali.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11472</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Tue, 18 Jun 2013 02:11:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11472</guid>
					<description><![CDATA[@Adrian: I&#039;ve debugged far too many bugs caused by incorrect use of unsigned variables, and far fewer bugs related to using a signed int with a collection with more elements than MAX_INT. So my experience differs from yours, and I belong to the &quot;size_type should have been unsigned&quot; camp. 

I completely agree with you that mixing signed and unsigned is broken. So, perhaps casting the vector&#039;s size to a signed variable (with an exception if it would overflow) is a solution. This limits the size by half, but avoids mixing signed/unsigned and avoids unsigned-related bugs.

Note that Bjarne himself doesn&#039;t seem too fussed using a signed variable. See http://www.stroustrup.com/bs_faq2.html#simple-program: &quot;Yes, I know that I could declare i to be a vector::size_type rather than plain int to quiet warnings from some hyper-suspicious compilers, but in this case,I consider that too pedantic and distracting.&quot;]]></description>
		<content:encoded><![CDATA[<p>@Adrian: I&#8217;ve debugged far too many bugs caused by incorrect use of unsigned variables, and far fewer bugs related to using a signed int with a collection with more elements than MAX_INT. So my experience differs from yours, and I belong to the &#8220;size_type should have been unsigned&#8221; camp. </p>
<p>I completely agree with you that mixing signed and unsigned is broken. So, perhaps casting the vector&#8217;s size to a signed variable (with an exception if it would overflow) is a solution. This limits the size by half, but avoids mixing signed/unsigned and avoids unsigned-related bugs.</p>
<p>Note that Bjarne himself doesn&#8217;t seem too fussed using a signed variable. See <a href="http://www.stroustrup.com/bs_faq2.html#simple-program" rel="nofollow">http://www.stroustrup.com/bs_faq2.html#simple-program</a>: &#8220;Yes, I know that I could declare i to be a vector::size_type rather than plain int to quiet warnings from some hyper-suspicious compilers, but in this case,I consider that too pedantic and distracting.&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11467</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 20:01:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11467</guid>
					<description><![CDATA[@Herb:  C++ isn&#039;t just used on modern machines with 64-bit address spaces.  It&#039;s also used on 16-bit embedded processors, where it&#039;s reasonable to have containers with sizes that might peak in the 32K to 64K-element range.  I&#039;ve debugged far too many crashes in my career caused by someone using a signed 16-bit int instead of an unsigned one.  Even on 32-bit machines, there are too many programs that can&#039;t handle a 4GB file.

Regardless of whether vector::size_type _should_ have been unsigned, the fact that it _is_ unsigned.  Mixing signed and unsigned forces you to disable compiler warnings that can help catch hard-to-reproduce bugs in other parts of the code (including some of the ones where you should have used signed arithmetic instead of unsigned).  I&#039;ve also debugged far too many crashes caused by comparing an unsigned 32-bit millisecond counter to a signed timeout value.  Style guidelines that require disabling useful compiler warnings are broken.]]></description>
		<content:encoded><![CDATA[<p>@Herb:  C++ isn&#8217;t just used on modern machines with 64-bit address spaces.  It&#8217;s also used on 16-bit embedded processors, where it&#8217;s reasonable to have containers with sizes that might peak in the 32K to 64K-element range.  I&#8217;ve debugged far too many crashes in my career caused by someone using a signed 16-bit int instead of an unsigned one.  Even on 32-bit machines, there are too many programs that can&#8217;t handle a 4GB file.</p>
<p>Regardless of whether vector::size_type _should_ have been unsigned, the fact that it _is_ unsigned.  Mixing signed and unsigned forces you to disable compiler warnings that can help catch hard-to-reproduce bugs in other parts of the code (including some of the ones where you should have used signed arithmetic instead of unsigned).  I&#8217;ve also debugged far too many crashes caused by comparing an unsigned 32-bit millisecond counter to a signed timeout value.  Style guidelines that require disabling useful compiler warnings are broken.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11457</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 16:53:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11457</guid>
					<description><![CDATA[@Frederic, @Sebastian: I stomped on the similar sentence in GotW #2 when Ville pointed it out, but it resurfaced. Stomped again, thanks.]]></description>
		<content:encoded><![CDATA[<p>@Frederic, @Sebastian: I stomped on the similar sentence in GotW #2 when Ville pointed it out, but it resurfaced. Stomped again, thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Redl				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11453</link>
		<dc:creator><![CDATA[Sebastian Redl]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 16:40:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11453</guid>
					<description><![CDATA[&#062; Second, some people like line 2′s syntax better but have to switch to line 1 to get access to explicit constructors.

If the constructor is explicit, chances are that the = syntax is horribly misleading. Do you really think there&#039;s a programmer who would like &quot;vector v = 5;&quot; to create a 5-element vector? I don&#039;t.

&#062; By the way, if you’ve been wondering whether auto x { value }; would be more efficient than auto x = expr;, wonder no longer: They have identical semantics.

Watch out, it&#039;s the dreaded initializer_list deduction! In other words, they&#039;re completely different things. Also, you might want to use expr *or* value, not mix them.

&#062; Prefer to use auto x = as_signed(integer_expr); or auto x = as_unsigned(integer_expr); to store the result of an integer computation that should be signed or unsigned.

This doesn&#039;t help much. The unexpected type conversion happens as part of integer_expr; all the &quot;helper&quot; does is afterwards cast it back. Yes, the behavior of unsigned to signed when not in range isn&#039;t undefined, just implementation-defined, but that&#039;s enough to make the code non-portable.

&#062; double f4 = f1 + f2;   // ... this might keep more bits of precision

This is incredibly obscure and would definitely not pass code review from me. If you want higher precision, cast the inputs to double. If you don&#039;t want higher resolution, assign the result to a float. Everything else is just a maintenance nightmare.]]></description>
		<content:encoded><![CDATA[<p>&gt; Second, some people like line 2′s syntax better but have to switch to line 1 to get access to explicit constructors.</p>
<p>If the constructor is explicit, chances are that the = syntax is horribly misleading. Do you really think there&#8217;s a programmer who would like &#8220;vector v = 5;&#8221; to create a 5-element vector? I don&#8217;t.</p>
<p>&gt; By the way, if you’ve been wondering whether auto x { value }; would be more efficient than auto x = expr;, wonder no longer: They have identical semantics.</p>
<p>Watch out, it&#8217;s the dreaded initializer_list deduction! In other words, they&#8217;re completely different things. Also, you might want to use expr *or* value, not mix them.</p>
<p>&gt; Prefer to use auto x = as_signed(integer_expr); or auto x = as_unsigned(integer_expr); to store the result of an integer computation that should be signed or unsigned.</p>
<p>This doesn&#8217;t help much. The unexpected type conversion happens as part of integer_expr; all the &#8220;helper&#8221; does is afterwards cast it back. Yes, the behavior of unsigned to signed when not in range isn&#8217;t undefined, just implementation-defined, but that&#8217;s enough to make the code non-portable.</p>
<p>&gt; double f4 = f1 + f2;   // &#8230; this might keep more bits of precision</p>
<p>This is incredibly obscure and would definitely not pass code review from me. If you want higher precision, cast the inputs to double. If you don&#8217;t want higher resolution, assign the result to a float. Everything else is just a maintenance nightmare.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Frederic Dumont				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11419</link>
		<dc:creator><![CDATA[Frederic Dumont]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 08:47:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11419</guid>
					<description><![CDATA[But Gotw 92 question 4 states the opposite. In auto a { val }; auto b = { val }; both a and b are said to have the same type initializer_list.

The two compilers I have tried with (gcc 4.8 and clang 3.2) confirm this.]]></description>
		<content:encoded><![CDATA[<p>But Gotw 92 question 4 states the opposite. In auto a { val }; auto b = { val }; both a and b are said to have the same type initializer_list.</p>
<p>The two compilers I have tried with (gcc 4.8 and clang 3.2) confirm this.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Neil				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11417</link>
		<dc:creator><![CDATA[Neil]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 07:21:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11417</guid>
					<description><![CDATA[Re auto i = 0, how about a zero() non-member function akin to std::begin and std::end, like this:

[code]
template &#060;typename C&#062;
typename C::size_type zero(const C&#038; c)
{
	return 0;
}

for (auto i = zero(v); i &#060; v.size(); ++i) {}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Re auto i = 0, how about a zero() non-member function akin to std::begin and std::end, like this:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename C&gt;
typename C::size_type zero(const C&amp; c)
{
	return 0;
}

for (auto i = zero(v); i &lt; v.size(); ++i) {}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11416</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 06:35:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11416</guid>
					<description><![CDATA[@Frederic no, they are not identical. x{value} is just an initialization of x. x would be an initializer_list, if you wrote auto x = {value}; note that here you have both = and {}.]]></description>
		<content:encoded><![CDATA[<p>@Frederic no, they are not identical. x{value} is just an initialization of x. x would be an initializer_list, if you wrote auto x = {value}; note that here you have both = and {}.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Frederic Dumont				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11412</link>
		<dc:creator><![CDATA[Frederic Dumont]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 02:01:37 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11412</guid>
					<description><![CDATA[About auto x { value } vs auto x = expr: in what sense are they semantically identical? The types are different (std::initializer_list vs type), so they cannot be interchangeable, can they?]]></description>
		<content:encoded><![CDATA[<p>About auto x { value } vs auto x = expr: in what sense are they semantically identical? The types are different (std::initializer_list vs type), so they cannot be interchangeable, can they?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: ahbishop				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11410</link>
		<dc:creator><![CDATA[ahbishop]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 00:44:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11410</guid>
					<description><![CDATA[@khurshid: What compiler are you using? That code compiles and executes without issue using Clang 3.2.1 on 64-bit Linux.]]></description>
		<content:encoded><![CDATA[<p>@khurshid: What compiler are you using? That code compiles and executes without issue using Clang 3.2.1 on 64-bit Linux.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: khurshid				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11403</link>
		<dc:creator><![CDATA[khurshid]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 15:29:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11403</guid>
					<description><![CDATA[auto x  = widget{}; // doesn&#039;t  compiled with non-copyable  classes.

example:
struct widget{
    widget( const widget&#038; ) = delete;
    widget&#038; operator = (const widget&#038; ) = delete;
    widget() = default;
~widget() = default;
};

widget w; // compiled OK;
auto w = widget{}; // compile ERROR!]]></description>
		<content:encoded><![CDATA[<p>auto x  = widget{}; // doesn&#8217;t  compiled with non-copyable  classes.</p>
<p>example:<br />
struct widget{<br />
    widget( const widget&amp; ) = delete;<br />
    widget&amp; operator = (const widget&amp; ) = delete;<br />
    widget() = default;<br />
~widget() = default;<br />
};</p>
<p>widget w; // compiled OK;<br />
auto w = widget{}; // compile ERROR!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11362</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 22:19:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11362</guid>
					<description><![CDATA[@Tom, @Martin: Yup, I just realized I accidentally wrote ( ) instead of { } -- that should address at least the narrowing issues. My fingers mostly have the habit of writing { } committed to muscle memory now, but that one slipped by. Fixed, thanks.]]></description>
		<content:encoded><![CDATA[<p>@Tom, @Martin: Yup, I just realized I accidentally wrote ( ) instead of { } &#8212; that should address at least the narrowing issues. My fingers mostly have the habit of writing { } committed to muscle memory now, but that one slipped by. Fixed, thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11361</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 22:12:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11361</guid>
					<description><![CDATA[@Adrian: There are problems if you use an unsigned loop variable, and different problems if you use a signed one. This is one of those cases that&#039;s just problematic. 

Because of these issues, I once asked Bjarne if he felt that container.size() should have returned signed values, and IIRC he agreed. Of course, that wouldn&#039;t be consequence-free either -- you couldn&#039;t have a container of chars bigger than half the address space, but that doesn&#039;t matter on 64 bits today and might never matter, depending on whether we ever get a machine with RAM greater than 2^63 bytes -- wasn&#039;t there an urban legend that Bill Gates said 9.2 billion GB should be enough for anyone?]]></description>
		<content:encoded><![CDATA[<p>@Adrian: There are problems if you use an unsigned loop variable, and different problems if you use a signed one. This is one of those cases that&#8217;s just problematic. </p>
<p>Because of these issues, I once asked Bjarne if he felt that container.size() should have returned signed values, and IIRC he agreed. Of course, that wouldn&#8217;t be consequence-free either &#8212; you couldn&#8217;t have a container of chars bigger than half the address space, but that doesn&#8217;t matter on 64 bits today and might never matter, depending on whether we ever get a machine with RAM greater than 2^63 bytes &#8212; wasn&#8217;t there an urban legend that Bill Gates said 9.2 billion GB should be enough for anyone?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11360</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 22:03:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11360</guid>
					<description><![CDATA[@Juraj: IIUC it&#039;s implementation-defined, not undefined. From 4.7/2-3 [conv.integral]:

2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source
integer (modulo 2^n where n is the number of bits used to represent the unsigned type). [ Note: In a two’s
complement representation, this conversion is conceptual and there is no change in the bit pattern (if there
is no truncation). —end note ]
3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and
bit-field width); otherwise, the value is implementation-defined.]]></description>
		<content:encoded><![CDATA[<p>@Juraj: IIUC it&#8217;s implementation-defined, not undefined. From 4.7/2-3 [conv.integral]:</p>
<p>2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source<br />
integer (modulo 2^n where n is the number of bits used to represent the unsigned type). [ Note: In a two’s<br />
complement representation, this conversion is conceptual and there is no change in the bit pattern (if there<br />
is no truncation). —end note ]<br />
3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and<br />
bit-field width); otherwise, the value is implementation-defined.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Martin Ba				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11352</link>
		<dc:creator><![CDATA[Martin Ba]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 19:56:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11352</guid>
					<description><![CDATA[Following up on @Tom &quot;c-style cast vs. static_cast&quot; and @Herb&#039;s answer &quot;Actually those are function-style casts, and for a non-aggregate type will call a constructor etc&quot; -- this really deserves some more info.

I believe ... = int(expr); is 100% exactly the same as ... = (int)expr; so this is a c-style cast, meaning potential unsafe casting, or doesn&#039;t it?

That is:
[code]
	int ans = 42;
	int* p = &#038;ans;
	auto val1 = int(p); // compiles, loosing data if sizeof(ptr) GRT sizeof(int) - which may or may not be what we want
	auto val2 = static_cast&#060;int&#062;(p); // doesn&#039;t compile, conversion not allowed via static_cast 
[/code]]]></description>
		<content:encoded><![CDATA[<p>Following up on @Tom &#8220;c-style cast vs. static_cast&#8221; and @Herb&#8217;s answer &#8220;Actually those are function-style casts, and for a non-aggregate type will call a constructor etc&#8221; &#8212; this really deserves some more info.</p>
<p>I believe &#8230; = int(expr); is 100% exactly the same as &#8230; = (int)expr; so this is a c-style cast, meaning potential unsafe casting, or doesn&#8217;t it?</p>
<p>That is:</p>
<pre class="brush: plain; title: ; notranslate">
	int ans = 42;
	int* p = &amp;ans;
	auto val1 = int(p); // compiles, loosing data if sizeof(ptr) GRT sizeof(int) - which may or may not be what we want
	auto val2 = static_cast&lt;int&gt;(p); // doesn't compile, conversion not allowed via static_cast 
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11351</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 19:41:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11351</guid>
					<description><![CDATA[[code]for( auto i = 0L; i &#060; v.size(); i += 2 )[/code]

Noooo!  Now you&#039;re comparing a signed type to an unsigned type.  Worse, on an LLP64 system, i will be 32 bits and v.size() will be 64 bits.  This forces you to disable useful compiler warnings.

This is one of those cases you shouldn&#039;t use auto.  Just use std::size_t.  It&#039;s clear and correct and it won&#039;t force you to disable compiler warnings that might be useful in other parts of your code.

If there&#039;s a chance v will grow so large that i += 2 could overflow, then you have to deal with that explicitly.]]></description>
		<content:encoded><![CDATA[<pre class="brush: plain; title: ; notranslate">for( auto i = 0L; i &lt; v.size(); i += 2 )</pre>
<p>Noooo!  Now you&#8217;re comparing a signed type to an unsigned type.  Worse, on an LLP64 system, i will be 32 bits and v.size() will be 64 bits.  This forces you to disable useful compiler warnings.</p>
<p>This is one of those cases you shouldn&#8217;t use auto.  Just use std::size_t.  It&#8217;s clear and correct and it won&#8217;t force you to disable compiler warnings that might be useful in other parts of your code.</p>
<p>If there&#8217;s a chance v will grow so large that i += 2 could overflow, then you have to deal with that explicitly.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11349</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 19:04:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11349</guid>
					<description><![CDATA[@JohnSmith - pet peeve, it is not true that &quot;on 64-bit Windows long is still 32-bit&quot;.  It may be that on some compiler that you are using that is true, but that is not a requirement of Windows.  As long as they follow the standard, different compilers on the same OS may have different type sizes.]]></description>
		<content:encoded><![CDATA[<p>@JohnSmith &#8211; pet peeve, it is not true that &#8220;on 64-bit Windows long is still 32-bit&#8221;.  It may be that on some compiler that you are using that is true, but that is not a requirement of Windows.  As long as they follow the standard, different compilers on the same OS may have different type sizes.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John Smith				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11339</link>
		<dc:creator><![CDATA[John Smith]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 16:21:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11339</guid>
					<description><![CDATA[Using 0L is an improvement, but still does not quite fix it. For example, on 64-bit Windows long is still 32-bit, while void* and size_t is 64. The obvious solution would be to say &quot;use 0ULL everywhere&quot;, which would always be correct. However, this comes as a performance cost for tight loops, where index updates may now have to be done with a fairly high-latency add-with-carry. One solution which always works, but is *very* ugly, is

[code]
for(auto i = v.size()*0; i &#060; v.size(); i += 2)
[/code]]]></description>
		<content:encoded><![CDATA[<p>Using 0L is an improvement, but still does not quite fix it. For example, on 64-bit Windows long is still 32-bit, while void* and size_t is 64. The obvious solution would be to say &#8220;use 0ULL everywhere&#8221;, which would always be correct. However, this comes as a performance cost for tight loops, where index updates may now have to be done with a fairly high-latency add-with-carry. One solution which always works, but is *very* ugly, is</p>
<pre class="brush: plain; title: ; notranslate">
for(auto i = v.size()*0; i &lt; v.size(); i += 2)
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mcmcc				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11336</link>
		<dc:creator><![CDATA[mcmcc]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 16:14:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11336</guid>
					<description><![CDATA[Re: auto f5 = double{f1 + f2};

Is that statement identical to:  
[code]auto f5 = double{f1} + f2[/code]
?

I.e. in the second version, f2 must be promoted to higher precision before the add operation.  In the first version, it seems the compiler might be compelled (allowed) to only do the promotion to double *after* the add, rendering the double promotion somewhat pointless.]]></description>
		<content:encoded><![CDATA[<p>Re: auto f5 = double{f1 + f2};</p>
<p>Is that statement identical to:  </p>
<pre class="brush: plain; title: ; notranslate">auto f5 = double{f1} + f2</pre>
<p>?</p>
<p>I.e. in the second version, f2 must be promoted to higher precision before the add operation.  In the first version, it seems the compiler might be compelled (allowed) to only do the promotion to double *after* the add, rendering the double promotion somewhat pointless.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11335</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 15:45:31 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11335</guid>
					<description><![CDATA[@Yuri: I agree. Updated, thanks.

@John: Good point, quick fix: 1L. :)

@Arne: Argh, that one gets me all the time. Fixed, thanks.

@Tom: Actually those are function-style casts, and for a non-aggregate type will call a constructor etc.

@rhalbersma: Yes, uint64_t and a few others are optional but they’re in the standard and expected to be widely implemented so I used them. The “least” and “fast” ones are not optional, so if you don’t have uint64_t you can use uint_least64_t or uint_fast64_t. … Okay, you’ve now convinced me to mention it. :) Added, mostly to note [1].]]></description>
		<content:encoded><![CDATA[<p>@Yuri: I agree. Updated, thanks.</p>
<p>@John: Good point, quick fix: 1L. :)</p>
<p>@Arne: Argh, that one gets me all the time. Fixed, thanks.</p>
<p>@Tom: Actually those are function-style casts, and for a non-aggregate type will call a constructor etc.</p>
<p>@rhalbersma: Yes, uint64_t and a few others are optional but they’re in the standard and expected to be widely implemented so I used them. The “least” and “fast” ones are not optional, so if you don’t have uint64_t you can use uint_least64_t or uint_fast64_t. … Okay, you’ve now convinced me to mention it. :) Added, mostly to note [1].</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: FJW				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11319</link>
		<dc:creator><![CDATA[FJW]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 13:16:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11319</guid>
					<description><![CDATA[@Tom: exactly my thought. The knowledge of how these unpredictable “compiler, shut up!”-monsters are working is frightening.]]></description>
		<content:encoded><![CDATA[<p>@Tom: exactly my thought. The knowledge of how these unpredictable “compiler, shut up!”-monsters are working is frightening.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Juraj Blaho				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11308</link>
		<dc:creator><![CDATA[Juraj Blaho]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 08:18:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11308</guid>
					<description><![CDATA[Does the cast in as_signed not exhibit signed overflow? I thought that code like the following exhibits signed overflow which would be UB:

[code]
unsigned u = -1;// A large value not representable by signed int
auto i = int(u);// &#060;-- UB?
[/code]]]></description>
		<content:encoded><![CDATA[<p>Does the cast in as_signed not exhibit signed overflow? I thought that code like the following exhibits signed overflow which would be UB:</p>
<pre class="brush: plain; title: ; notranslate">
unsigned u = -1;// A large value not representable by signed int
auto i = int(u);// &lt;-- UB?
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Petter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11306</link>
		<dc:creator><![CDATA[Petter]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 06:45:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11306</guid>
					<description><![CDATA[John and Anders: that was my thought as well.]]></description>
		<content:encoded><![CDATA[<p>John and Anders: that was my thought as well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Anders Dalvander				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11305</link>
		<dc:creator><![CDATA[Anders Dalvander]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 06:22:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11305</guid>
					<description><![CDATA[You mention [code]for( auto i = 0; i &#060; v.size(); i += 2 )[/code] as a potential solution for 1 when you mention the silent narrowing conversion in 2b. Perhaps we should have a `std::vector::size_type std::vector::zero() const` member function?]]></description>
		<content:encoded><![CDATA[<p>You mention </p>
<pre class="brush: plain; title: ; notranslate">for( auto i = 0; i &lt; v.size(); i += 2 )</pre>
<p> as a potential solution for 1 when you mention the silent narrowing conversion in 2b. Perhaps we should have a `std::vector::size_type std::vector::zero() const` member function?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: rhalbersma				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11304</link>
		<dc:creator><![CDATA[rhalbersma]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 06:21:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11304</guid>
					<description><![CDATA[Last time I checked the Standard section 18.4.1, the fixed-size integer types from  were optional. Are there any proposals that make it mandatory to provide intN_t and uintN_t for platforms that compile for N-bits architectures?]]></description>
		<content:encoded><![CDATA[<p>Last time I checked the Standard section 18.4.1, the fixed-size integer types from  were optional. Are there any proposals that make it mandatory to provide intN_t and uintN_t for platforms that compile for N-bits architectures?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Tom				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11303</link>
		<dc:creator><![CDATA[Tom]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 06:19:05 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11303</guid>
					<description><![CDATA[How come we&#039;re back to using c-style casts?
   auto x = uint64_t(x + y);

Why not
   auto x = static_cast(x + y);]]></description>
		<content:encoded><![CDATA[<p>How come we&#8217;re back to using c-style casts?<br />
   auto x = uint64_t(x + y);</p>
<p>Why not<br />
   auto x = static_cast(x + y);</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arne Mertz				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11302</link>
		<dc:creator><![CDATA[Arne Mertz]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 06:16:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11302</guid>
					<description><![CDATA[In the last lines of 2(b) you write about vector sizes &#060; 2^(sizeof(int)-1). It should be 2^(CHAR_BIT*sizeof(int)-1). I ran into that pitfall some time ago ;-)]]></description>
		<content:encoded><![CDATA[<p>In the last lines of 2(b) you write about vector sizes &lt; 2^(sizeof(int)-1). It should be 2^(CHAR_BIT*sizeof(int)-1). I ran into that pitfall some time ago ;-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John Smith				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11300</link>
		<dc:creator><![CDATA[John Smith]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 04:27:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11300</guid>
					<description><![CDATA[Doesn&#039;t the indexed version for(auto i = 0; i &#060; v.size(); i += 2) set i to be of type int? If v.size() is (say) 64 bits while int is 32 the loop will never end, will it not?

The C++11 version of as_(un)signed is using make_signed_t, which is really C++14. It should be using typename make_(un)signed::type instead.]]></description>
		<content:encoded><![CDATA[<p>Doesn&#8217;t the indexed version for(auto i = 0; i &lt; v.size(); i += 2) set i to be of type int? If v.size() is (say) 64 bits while int is 32 the loop will never end, will it not?</p>
<p>The C++11 version of as_(un)signed is using make_signed_t, which is really C++14. It should be using typename make_(un)signed::type instead.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Yuri Khan				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/#comment-11298</link>
		<dc:creator><![CDATA[Yuri Khan]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 03:39:43 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2145#comment-11298</guid>
					<description><![CDATA[In Solution 1a, you suggest checking the iterator increment against distance(i, end) when writing strided loops. While this will work correctly (as opposed to just i += 2), it introduces a potential performance bug: It will compile even if the iterator does not provide random access. In this case, the loop becomes O(n^2).

I think the cleanest way to write a generic strided loop would be to write a helper template to use instead of the unchecked increment:

[code]
template &#060;typename Iter&#062;
void advance_up_to(Iter&#038; it, ptrdiff_t n, Iter&#038;&#038; end)
{
    while (n --&#062; 0 &#038;&#038; it != end) ++it;
}
[/code]

(suitably specialized for various iterator categories to handle negative counts and take advantage of random access where available).]]></description>
		<content:encoded><![CDATA[<p>In Solution 1a, you suggest checking the iterator increment against distance(i, end) when writing strided loops. While this will work correctly (as opposed to just i += 2), it introduces a potential performance bug: It will compile even if the iterator does not provide random access. In this case, the loop becomes O(n^2).</p>
<p>I think the cleanest way to write a generic strided loop would be to write a helper template to use instead of the unchecked increment:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename Iter&gt;
void advance_up_to(Iter&amp; it, ptrdiff_t n, Iter&amp;&amp; end)
{
    while (n --&gt; 0 &amp;&amp; it != end) ++it;
}
</pre>
<p>(suitably specialized for various iterator categories to handle negative counts and take advantage of random access where available).</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
