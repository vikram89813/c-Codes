<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #94 Special Edition: AAA Style (Almost Always Auto)	</title>
	<atom:link href="https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: André Müller				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11604</link>
		<dc:creator><![CDATA[André Müller]]></dc:creator>
		<pubDate>Sat, 22 Jun 2013 08:17:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11604</guid>
					<description><![CDATA[@jlehrer
g++ 4.7.3 says
[code]
auto i = 0, j = 1;   //does compile
auto i = 0, *j = &#038;i; //does compile
auto i = 0, j = 2.0; //error: inconsistent deduction for &#039;auto&#039;: &#039;int&#039; and then &#039;double&#039;
[/code]]]></description>
		<content:encoded><![CDATA[<p>@jlehrer<br />
g++ 4.7.3 says</p>
<pre class="brush: plain; title: ; notranslate">
auto i = 0, j = 1;   //does compile
auto i = 0, *j = &amp;i; //does compile
auto i = 0, j = 2.0; //error: inconsistent deduction for 'auto': 'int' and then 'double'
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11598</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 22:36:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11598</guid>
					<description><![CDATA[So this is well formed:

auto i=1,j=2;

but this is ill-formed:

auto i=1,j=2.0;

Okay.

What about this:

auto x=1,*j=&#038;x;

I&#039;m going to guess that is ill-formed as well.]]></description>
		<content:encoded><![CDATA[<p>So this is well formed:</p>
<p>auto i=1,j=2;</p>
<p>but this is ill-formed:</p>
<p>auto i=1,j=2.0;</p>
<p>Okay.</p>
<p>What about this:</p>
<p>auto x=1,*j=&amp;x;</p>
<p>I&#8217;m going to guess that is ill-formed as well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11597</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 22:33:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11597</guid>
					<description><![CDATA[@jlehrer: That&#039;s ill-formed, both have to deduce to the same type. I&#039;m not sure but as I remember GCC does allow it, and gives you an int and a float, but that&#039;s nonconforming behaviour.]]></description>
		<content:encoded><![CDATA[<p>@jlehrer: That&#8217;s ill-formed, both have to deduce to the same type. I&#8217;m not sure but as I remember GCC does allow it, and gives you an int and a float, but that&#8217;s nonconforming behaviour.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11589</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 19:24:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11589</guid>
					<description><![CDATA[I don&#039;t have an 11 compiler to play with right now or I&#039;d answer this question myself.

What does this do:

auto i=1,f=2.0;

Does that make two integers, an int and a float, or two floats?]]></description>
		<content:encoded><![CDATA[<p>I don&#8217;t have an 11 compiler to play with right now or I&#8217;d answer this question myself.</p>
<p>What does this do:</p>
<p>auto i=1,f=2.0;</p>
<p>Does that make two integers, an int and a float, or two floats?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11460</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 17:22:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11460</guid>
					<description><![CDATA[@Sebastian:   O:-)]]></description>
		<content:encoded><![CDATA[<p>@Sebastian:   O:-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sebastian Redl				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11456</link>
		<dc:creator><![CDATA[Sebastian Redl]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 16:52:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11456</guid>
					<description><![CDATA[&#062; While copy/move elision can probably optimize it, MSVC in particular is still bad in it, and misses quite a few cases

Herb&#039;s secret agenda: Teach programmers to use code MSVC is bad at (unsupported C++11 and 14 features, stuff that triggers bugs) to force the compiler team to fix everything.

Hey Herb, can you write an article about how our source files should be UTF-8-encoded without a BOM, and we should use std::codecvt_utf8 to convert from our narrow string literals to wide strings?]]></description>
		<content:encoded><![CDATA[<p>&gt; While copy/move elision can probably optimize it, MSVC in particular is still bad in it, and misses quite a few cases</p>
<p>Herb&#8217;s secret agenda: Teach programmers to use code MSVC is bad at (unsupported C++11 and 14 features, stuff that triggers bugs) to force the compiler team to fix everything.</p>
<p>Hey Herb, can you write an article about how our source files should be UTF-8-encoded without a BOM, and we should use std::codecvt_utf8 to convert from our narrow string literals to wide strings?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: André Müller				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11449</link>
		<dc:creator><![CDATA[André Müller]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 15:25:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11449</guid>
					<description><![CDATA[@Johan: Good point. All the more reason to use -Wfloat-equal.

Apart from beeing explicit about conversions and symmetry I find the AAA style more pleasant to read. Variable names are always at the beginning of a line:
[code]
auto a = type_name{args};
auto b = long_type_name{args};
auto ccc = even_longer_type_name::subtype_name{args};
[/code]
vs.
[code]
type_name a {args};
long_type_name bb{args};
even_longer_type_name::subtype_name ccc{args};
[/code]]]></description>
		<content:encoded><![CDATA[<p>@Johan: Good point. All the more reason to use -Wfloat-equal.</p>
<p>Apart from beeing explicit about conversions and symmetry I find the AAA style more pleasant to read. Variable names are always at the beginning of a line:</p>
<pre class="brush: plain; title: ; notranslate">
auto a = type_name{args};
auto b = long_type_name{args};
auto ccc = even_longer_type_name::subtype_name{args};
</pre>
<p>vs.</p>
<pre class="brush: plain; title: ; notranslate">
type_name a {args};
long_type_name bb{args};
even_longer_type_name::subtype_name ccc{args};
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johan				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11427</link>
		<dc:creator><![CDATA[Johan]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 12:21:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11427</guid>
					<description><![CDATA[3. When a function is modified to return a different data type, it may silently cause problems if auto was used. For example, if some return types are changed from integer to float or double:

[code]
auto a = c.GetValue();
auto b = d.GetValue();

if( a == b )
{
  // Comparing integers are fine, but should not compare float numbers like this.
}
[/code]

Unit tests might detect this, but anyway you need to be extra careful when using auto.

Declaring a and b as integers should at least cause the compiler to show a warning about the conversion to int.

Also, sometimes readability can suffer because you need to stop and think what the type is, instead of just reading the explicit type. However, when working with the standard library this is not an issue since most programmers knows it well.]]></description>
		<content:encoded><![CDATA[<p>3. When a function is modified to return a different data type, it may silently cause problems if auto was used. For example, if some return types are changed from integer to float or double:</p>
<pre class="brush: plain; title: ; notranslate">
auto a = c.GetValue();
auto b = d.GetValue();

if( a == b )
{
  // Comparing integers are fine, but should not compare float numbers like this.
}
</pre>
<p>Unit tests might detect this, but anyway you need to be extra careful when using auto.</p>
<p>Declaring a and b as integers should at least cause the compiler to show a warning about the conversion to int.</p>
<p>Also, sometimes readability can suffer because you need to stop and think what the type is, instead of just reading the explicit type. However, when working with the standard library this is not an issue since most programmers knows it well.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11421</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 10:43:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11421</guid>
					<description><![CDATA[@Jeff Harris:
auto always gives you a reference/cv-stripped type. To keep them, you need to use decltype instead. The thing in C++11 is that you have to tell decltype what to deduce the type from:
[code]decltype(getWidget()) w = getWidget(); //w has type const Widget&#038; [/code]
C++14 gives you decltype(auto), and does exactly what you want here:
[code]decltype(auto) w = getWidget(); //w has type const Widget&#038; [/code]]]></description>
		<content:encoded><![CDATA[<p>@Jeff Harris:<br />
auto always gives you a reference/cv-stripped type. To keep them, you need to use decltype instead. The thing in C++11 is that you have to tell decltype what to deduce the type from:</p>
<pre class="brush: plain; title: ; notranslate">decltype(getWidget()) w = getWidget(); //w has type const Widget&amp; </pre>
<p>C++14 gives you decltype(auto), and does exactly what you want here:</p>
<pre class="brush: plain; title: ; notranslate">decltype(auto) w = getWidget(); //w has type const Widget&amp; </pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jeff Harris				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11411</link>
		<dc:creator><![CDATA[Jeff Harris]]></dc:creator>
		<pubDate>Mon, 17 Jun 2013 00:55:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11411</guid>
					<description><![CDATA[@Bret Kuhns
Yes, the examples are symmetric, but not necessarily in the &#039;spirit&#039; of auto.  The guideline in GotW 93 for using auto simply states to use auto w = getWidget() and say the compiler will choose the correct type.  For a getWidget returning a reference, the type likely is not correct as it will either not compile (if type is not copyable) or be slow with a potentially unwanted copy (not move).  Shouldn&#039;t there be more qualifications on the guidelines that they hold for value returning expressions only?  If a reference is returned, then auto&#038; or const auto&#038; is required.]]></description>
		<content:encoded><![CDATA[<p>@Bret Kuhns<br />
Yes, the examples are symmetric, but not necessarily in the &#8216;spirit&#8217; of auto.  The guideline in GotW 93 for using auto simply states to use auto w = getWidget() and say the compiler will choose the correct type.  For a getWidget returning a reference, the type likely is not correct as it will either not compile (if type is not copyable) or be slow with a potentially unwanted copy (not move).  Shouldn&#8217;t there be more qualifications on the guidelines that they hold for value returning expressions only?  If a reference is returned, then auto&amp; or const auto&amp; is required.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: litb1				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11402</link>
		<dc:creator><![CDATA[litb1]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 14:47:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11402</guid>
					<description><![CDATA[@John That is right. It was subject of a recent SO discussion. The solution/workaround for the case where the wished type is an array is to use a reference, which prevents automatic decay

    [code] auto &#038;&#038;x = identity &#060;int []&#062;{a, b, c}; [/code]

But honestly, I am going to continue writing &quot;type var{init}&quot;.]]></description>
		<content:encoded><![CDATA[<p>@John That is right. It was subject of a recent SO discussion. The solution/workaround for the case where the wished type is an array is to use a reference, which prevents automatic decay</p>
<pre class="brush: plain; title: ; notranslate"> auto &amp;&amp;x = identity &lt;int []&gt;{a, b, c}; </pre>
<p>But honestly, I am going to continue writing &#8220;type var{init}&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11401</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 14:32:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11401</guid>
					<description><![CDATA[@Jeff Harris, you first show

[code]auto w = getWidget();[/code]

Then note that it is different than

[code]const Widget&#038; w = getWidget();[/code]

Notice the asymmetry in these examples? Now how do we use `auto` to match the second line?

[code]const auto&#038; w = getWidget();[/code]

Pretty symmetric. We control when we get a copy, or when we get a reference to const, and it&#039;s all documented at the declaration site.]]></description>
		<content:encoded><![CDATA[<p>@Jeff Harris, you first show</p>
<pre class="brush: plain; title: ; notranslate">auto w = getWidget();</pre>
<p>Then note that it is different than</p>
<pre class="brush: plain; title: ; notranslate">const Widget&amp; w = getWidget();</pre>
<p>Notice the asymmetry in these examples? Now how do we use `auto` to match the second line?</p>
<pre class="brush: plain; title: ; notranslate">const auto&amp; w = getWidget();</pre>
<p>Pretty symmetric. We control when we get a copy, or when we get a reference to const, and it&#8217;s all documented at the declaration site.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: John				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11399</link>
		<dc:creator><![CDATA[John]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 13:28:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11399</guid>
					<description><![CDATA[This isn&#039;t compiling for me:
[code]
auto buffer = char[10]{};
[/code]
If it could compile, I think buffer would be a char*, not char[10].
Right?]]></description>
		<content:encoded><![CDATA[<p>This isn&#8217;t compiling for me:</p>
<pre class="brush: plain; title: ; notranslate">
auto buffer = char[10]{};
</pre>
<p>If it could compile, I think buffer would be a char*, not char[10].<br />
Right?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sil				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11398</link>
		<dc:creator><![CDATA[Sil]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 12:58:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11398</guid>
					<description><![CDATA[Herb,
Thanks for answering quickly.

Looking forward to watching your talk at build!]]></description>
		<content:encoded><![CDATA[<p>Herb,<br />
Thanks for answering quickly.</p>
<p>Looking forward to watching your talk at build!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lev				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11396</link>
		<dc:creator><![CDATA[Lev]]></dc:creator>
		<pubDate>Sun, 16 Jun 2013 10:44:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11396</guid>
					<description><![CDATA[1. What&#039;s the point of using emplace_back() if v is not an rvalue reference?]]></description>
		<content:encoded><![CDATA[<p>1. What&#8217;s the point of using emplace_back() if v is not an rvalue reference?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11388</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Sat, 15 Jun 2013 18:14:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11388</guid>
					<description><![CDATA[@Herb: Oh, since you mention rise4fun, I have a related question real quick /* if you&#039;re not the right guy to ask, apologies in advance; perhaps you could pass it on? :-) */.

Is there any chance to extend it to work like the other online compilers linked to from http://isocpp.org/get-started --  in particular Stacked-Crooked or ideone.com -- i.e., to run the program and show the output?

What&#039;s really nice about Stacked-Crooked in particular is that it also supports Boost, which allows to quickly test (and share) code snippets such as this:
http://coliru.stacked-crooked.com/view?id=4af2bf3c771a9413c642dd8e26007df8-3725be9f9ce62f113fc473b4ae69c419

Regardless, another issue is the following:
&quot;testvc.cpp(1) : info : Ignoring directive &#039;#include&#039;, which cannot be used in this online version of the Visual C++ compiler&quot;

This is a problem for verifying the correctness of the code at hand -- for instance, std::size_t ordinarily requires an inclusion of a header like cstddef (there are others), and rise4fun automatically including all the standard headers (which seems to be implied by the support for library constructs such as std::vector) currently leaves simple mistakes like this undiagnosed (I&#039;d also imagine this leads to a heavier strain on the servers supporting rise4fun, so if anything, fixing this should be a win-win).

Pretty please? :-)]]></description>
		<content:encoded><![CDATA[<p>@Herb: Oh, since you mention rise4fun, I have a related question real quick /* if you&#8217;re not the right guy to ask, apologies in advance; perhaps you could pass it on? :-) */.</p>
<p>Is there any chance to extend it to work like the other online compilers linked to from <a href="http://isocpp.org/get-started" rel="nofollow">http://isocpp.org/get-started</a> &#8212;  in particular Stacked-Crooked or ideone.com &#8212; i.e., to run the program and show the output?</p>
<p>What&#8217;s really nice about Stacked-Crooked in particular is that it also supports Boost, which allows to quickly test (and share) code snippets such as this:<br />
<a href="http://coliru.stacked-crooked.com/view?id=4af2bf3c771a9413c642dd8e26007df8-3725be9f9ce62f113fc473b4ae69c419" rel="nofollow">http://coliru.stacked-crooked.com/view?id=4af2bf3c771a9413c642dd8e26007df8-3725be9f9ce62f113fc473b4ae69c419</a></p>
<p>Regardless, another issue is the following:<br />
&#8220;testvc.cpp(1) : info : Ignoring directive &#8216;#include&#8217;, which cannot be used in this online version of the Visual C++ compiler&#8221;</p>
<p>This is a problem for verifying the correctness of the code at hand &#8212; for instance, std::size_t ordinarily requires an inclusion of a header like cstddef (there are others), and rise4fun automatically including all the standard headers (which seems to be implied by the support for library constructs such as std::vector) currently leaves simple mistakes like this undiagnosed (I&#8217;d also imagine this leads to a heavier strain on the servers supporting rise4fun, so if anything, fixing this should be a win-win).</p>
<p>Pretty please? :-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11384</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Sat, 15 Jun 2013 15:35:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11384</guid>
					<description><![CDATA[@Sil: Thanks, and in less than two weeks I&#039;ll be giving a talk at Build that covers this. In the meantime, your example does compile with VC++ Nov 2012 CTP -- here&#039;s a link to where you can try that sample online: http://rise4fun.com/Vcpp/KjO .]]></description>
		<content:encoded><![CDATA[<p>@Sil: Thanks, and in less than two weeks I&#8217;ll be giving a talk at Build that covers this. In the meantime, your example does compile with VC++ Nov 2012 CTP &#8212; here&#8217;s a link to where you can try that sample online: <a href="http://rise4fun.com/Vcpp/KjO" rel="nofollow">http://rise4fun.com/Vcpp/KjO</a> .</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jeff Harris				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11378</link>
		<dc:creator><![CDATA[Jeff Harris]]></dc:creator>
		<pubDate>Sat, 15 Jun 2013 13:28:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11378</guid>
					<description><![CDATA[3: With a standard &#039;getter&#039; function, e.g. const Widget&#038; getWidget(), the use of auto w = getWidget() will deduce a type of Widget for w.  The code will attempt to create a copy of Widget which may be slow or not allowed if Widget is not copyable.  Traditionally, you&#039;d declare const Widget&#038; w = getWidget() which avoids any copies and is fast.

Is there a version of auto that will attempt to preserve the cv and reference qualifications on the deduced type vs. following the template rules of the current auto?  The use of auto&#038; works for the getWidget() case but fails if getWidget returns a Widget by value and not const reference.  const auto&#038; is required in that case.  

It seems as if the caller still needs to be as aware of the exact return type of getWidget when using auto as when not using auto.]]></description>
		<content:encoded><![CDATA[<p>3: With a standard &#8216;getter&#8217; function, e.g. const Widget&amp; getWidget(), the use of auto w = getWidget() will deduce a type of Widget for w.  The code will attempt to create a copy of Widget which may be slow or not allowed if Widget is not copyable.  Traditionally, you&#8217;d declare const Widget&amp; w = getWidget() which avoids any copies and is fast.</p>
<p>Is there a version of auto that will attempt to preserve the cv and reference qualifications on the deduced type vs. following the template rules of the current auto?  The use of auto&amp; works for the getWidget() case but fails if getWidget returns a Widget by value and not const reference.  const auto&amp; is required in that case.  </p>
<p>It seems as if the caller still needs to be as aware of the exact return type of getWidget when using auto as when not using auto.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sil				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11372</link>
		<dc:creator><![CDATA[Sil]]></dc:creator>
		<pubDate>Sat, 15 Jun 2013 06:42:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11372</guid>
					<description><![CDATA[Herb,

Microsoft, and you in particular, has done a tremendous job of supporting the c++ community. 
Still, I am absolutely shocked at the abyssimal support of c++11 in visual studio, it not even supporting initializer lists such as int i { 4 }; (please tell me I&#039;m wrong and some configuration enables 11 support).

Nowadays clang and gcc++ have next to 100% c++ 11 support and beyond.

When can we expect a better support in visual c++?]]></description>
		<content:encoded><![CDATA[<p>Herb,</p>
<p>Microsoft, and you in particular, has done a tremendous job of supporting the c++ community.<br />
Still, I am absolutely shocked at the abyssimal support of c++11 in visual studio, it not even supporting initializer lists such as int i { 4 }; (please tell me I&#8217;m wrong and some configuration enables 11 support).</p>
<p>Nowadays clang and gcc++ have next to 100% c++ 11 support and beyond.</p>
<p>When can we expect a better support in visual c++?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11365</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 23:59:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11365</guid>
					<description><![CDATA[4b: Pleeeeheheheeeeeaaase don&#039;t.

If you want a given type, declare the variable with that type. Don&#039;t declare a type-deduced variable initialized by a value converted to the given type, it&#039;s just dumb.

I know you want to suggest that it is self-documenting that there is a conversion. But it equally documents this if you use type x = init; only when you want conversion, and auto x = init; if you don&#039;t. Or if you really-really want to document it, use type x = type{init}; but that&#039;s redundant.

Using auto x = type{init}; also might involve a move-construction. While copy/move elision can probably optimize it, MSVC in particular is still bad in it, and misses quite a few cases (in the range of 5-10% - not lot, but nothing guarantees this 5% won&#039;t be in your performance-critical code). Also, in debug mode you don&#039;t have copy elision at all, resulting in different behaviour than release mode - noone wants that.

This way feels like Maslow&#039;s hammer: we now have a super new tool since C++11, auto. It is awesome and stuff, but we still don&#039;t need to use everywhere. It should raise the red flag if you need to write something incredibly verbose, that you should not use it after all.]]></description>
		<content:encoded><![CDATA[<p>4b: Pleeeeheheheeeeeaaase don&#8217;t.</p>
<p>If you want a given type, declare the variable with that type. Don&#8217;t declare a type-deduced variable initialized by a value converted to the given type, it&#8217;s just dumb.</p>
<p>I know you want to suggest that it is self-documenting that there is a conversion. But it equally documents this if you use type x = init; only when you want conversion, and auto x = init; if you don&#8217;t. Or if you really-really want to document it, use type x = type{init}; but that&#8217;s redundant.</p>
<p>Using auto x = type{init}; also might involve a move-construction. While copy/move elision can probably optimize it, MSVC in particular is still bad in it, and misses quite a few cases (in the range of 5-10% &#8211; not lot, but nothing guarantees this 5% won&#8217;t be in your performance-critical code). Also, in debug mode you don&#8217;t have copy elision at all, resulting in different behaviour than release mode &#8211; noone wants that.</p>
<p>This way feels like Maslow&#8217;s hammer: we now have a super new tool since C++11, auto. It is awesome and stuff, but we still don&#8217;t need to use everywhere. It should raise the red flag if you need to write something incredibly verbose, that you should not use it after all.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11363</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 22:33:30 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11363</guid>
					<description><![CDATA[@Adrian: I had the assertion outside in my original code, and I agree it&#039;s better there. Lightly edited the question to do that.]]></description>
		<content:encoded><![CDATA[<p>@Adrian: I had the assertion outside in my original code, and I agree it&#8217;s better there. Lightly edited the question to do that.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Johannes Schaub (litb)				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11357</link>
		<dc:creator><![CDATA[Johannes Schaub (litb)]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 21:24:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11357</guid>
					<description><![CDATA[6) There will be a problem with &quot;long long{init}&quot;. If &quot;type&quot; consists of multiple parts like that, &quot;long long x{init}&quot; must be used, or the type name needs to be aliased such as &quot;auto x = std::common_type_t{init}&quot;.]]></description>
		<content:encoded><![CDATA[<p>6) There will be a problem with &#8220;long long{init}&#8221;. If &#8220;type&#8221; consists of multiple parts like that, &#8220;long long x{init}&#8221; must be used, or the type name needs to be aliased such as &#8220;auto x = std::common_type_t{init}&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Adrian				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11354</link>
		<dc:creator><![CDATA[Adrian]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 20:06:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11354</guid>
					<description><![CDATA[In #1, the assertion would be even stronger to put it at the end of the function rather than inside the then clause.  That way it becomes a true post condition--the container must contain something if it contains a value equal to v.

This post condition also works as a form of documentation.  A stronger post condition would be to assert that the container contains the value:

[code]
template &#060;typename Container, typename Value&#062;
bool Contains(const Container &#038; c, const Value &#038; v) {
    using std::begin;
    using std::end;
    return std::find(begin(c), end(c), v) != end(c);
}

template &#060;typename Container, typename Value&#062;
void AppendIfUnique(Container &#038; c, const Value &#038; v) {
    if (!Contains(c, v)) c.emplace_back(v); 
    assert(Contains(c, v));  // Post condition (barring exceptions)
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>In #1, the assertion would be even stronger to put it at the end of the function rather than inside the then clause.  That way it becomes a true post condition&#8211;the container must contain something if it contains a value equal to v.</p>
<p>This post condition also works as a form of documentation.  A stronger post condition would be to assert that the container contains the value:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename Container, typename Value&gt;
bool Contains(const Container &amp; c, const Value &amp; v) {
    using std::begin;
    using std::end;
    return std::find(begin(c), end(c), v) != end(c);
}

template &lt;typename Container, typename Value&gt;
void AppendIfUnique(Container &amp; c, const Value &amp; v) {
    if (!Contains(c, v)) c.emplace_back(v); 
    assert(Contains(c, v));  // Post condition (barring exceptions)
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: bames53				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11344</link>
		<dc:creator><![CDATA[bames53]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 17:56:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11344</guid>
					<description><![CDATA[1. It searches c for an object that compares equal to v and if it does not find one it constructs an element in place at the end of c using v.
2. It means to write code against intentional, public, specified guarantees. It&#039;s beneficial because it means implementations can improve independently as long as the interface is maintained; bugs can be fixed, features can be added, all without unnecessary cascading code changes. Secondly because writing code that just seems to work but isn&#039;t intentionally well specified can result in errors even without changes in the implementation, if the implementation isn&#039;t well understood.
3. That the type won&#039;t be statically specified; no, auto in C++ uses static type deduction. That the type will be hidden, making it difficult to understand code; possibly because interfaces might be specified in terms of specific types and a source editor might lack support for showing correctly deduced types.
4. a) The type of init can change without necessarily requiring the code using it to change in order to operate correctly. The possibility for an erroneous, silent implicit conversion is avoided. The initializer cannot be mistakenly omitted.
   b) I don&#039;t see any particular advantage to auto x = type{init}; vs. type x {init};.
5. a) Heap allocation syntax already explicity specifies types. Using auto x = make_unique(init); avoids duplication.
   b) Literal suffixes also specify type and auto again avoids repeating it.
   c) Lambda types are un-utterable and type deduction is required to get a named lambda.
   d) formal parameters can have their types deduced from default values.
   e) Type alias syntax using X = type; 
6. auto declarations require the use of &#039;inside-out&#039; syntax in order to add cv-qualifiers or to obtain reference types. You cannot use left-to-right type syntax, e.g. template using rref = T&#038;&#038;; rref x = f();. You must write: auto &#038;&#038;x = f();, or use explicit types: rref x = f(); or more verbose syntax using decltype.]]></description>
		<content:encoded><![CDATA[<p>1. It searches c for an object that compares equal to v and if it does not find one it constructs an element in place at the end of c using v.<br />
2. It means to write code against intentional, public, specified guarantees. It&#8217;s beneficial because it means implementations can improve independently as long as the interface is maintained; bugs can be fixed, features can be added, all without unnecessary cascading code changes. Secondly because writing code that just seems to work but isn&#8217;t intentionally well specified can result in errors even without changes in the implementation, if the implementation isn&#8217;t well understood.<br />
3. That the type won&#8217;t be statically specified; no, auto in C++ uses static type deduction. That the type will be hidden, making it difficult to understand code; possibly because interfaces might be specified in terms of specific types and a source editor might lack support for showing correctly deduced types.<br />
4. a) The type of init can change without necessarily requiring the code using it to change in order to operate correctly. The possibility for an erroneous, silent implicit conversion is avoided. The initializer cannot be mistakenly omitted.<br />
   b) I don&#8217;t see any particular advantage to auto x = type{init}; vs. type x {init};.<br />
5. a) Heap allocation syntax already explicity specifies types. Using auto x = make_unique(init); avoids duplication.<br />
   b) Literal suffixes also specify type and auto again avoids repeating it.<br />
   c) Lambda types are un-utterable and type deduction is required to get a named lambda.<br />
   d) formal parameters can have their types deduced from default values.<br />
   e) Type alias syntax using X = type;<br />
6. auto declarations require the use of &#8216;inside-out&#8217; syntax in order to add cv-qualifiers or to obtain reference types. You cannot use left-to-right type syntax, e.g. template using rref = T&amp;&amp;; rref x = f();. You must write: auto &amp;&amp;x = f();, or use explicit types: rref x = f(); or more verbose syntax using decltype.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: cl22333				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11338</link>
		<dc:creator><![CDATA[cl22333]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 16:16:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11338</guid>
					<description><![CDATA[3. Should we use &#039;auto&#039; when the variable is near critical points?(http://stackoverflow.com/questions/14081900/keyword-auto-near-critical-points)]]></description>
		<content:encoded><![CDATA[<p>3. Should we use &#8216;auto&#8217; when the variable is near critical points?(<a href="http://stackoverflow.com/questions/14081900/keyword-auto-near-critical-points" rel="nofollow">http://stackoverflow.com/questions/14081900/keyword-auto-near-critical-points</a>)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Nemanja Trifunovic				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11333</link>
		<dc:creator><![CDATA[Nemanja Trifunovic]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 15:23:48 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11333</guid>
					<description><![CDATA[@pip010 In fact, there is a proposal to allow auto in function declarations as a return type: http://isocpp.org/blog/2013/04/n3638-return-type-deduction-for-normal-functions  After that gets implemented, you will need to hunt not only for the declaration, but also for the implementation of the function.]]></description>
		<content:encoded><![CDATA[<p>@pip010 In fact, there is a proposal to allow auto in function declarations as a return type: <a href="http://isocpp.org/blog/2013/04/n3638-return-type-deduction-for-normal-functions" rel="nofollow">http://isocpp.org/blog/2013/04/n3638-return-type-deduction-for-normal-functions</a>  After that gets implemented, you will need to hunt not only for the declaration, but also for the implementation of the function.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jeffrey Bosboom				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11313</link>
		<dc:creator><![CDATA[Jeffrey Bosboom]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 13:05:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11313</guid>
					<description><![CDATA[Expression templates are one thing you can&#039;t use auto with, unless the proposed &#039;operator auto()&#039; to suggest the type to convert to actually went somewhere.]]></description>
		<content:encoded><![CDATA[<p>Expression templates are one thing you can&#8217;t use auto with, unless the proposed &#8216;operator auto()&#8217; to suggest the type to convert to actually went somewhere.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: pip010 (@ppetrovdotnet)				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11309</link>
		<dc:creator><![CDATA[pip010 (@ppetrovdotnet)]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 09:21:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11309</guid>
					<description><![CDATA[one of the most annoying thin in c# is :
var variable = SomeFunctionCall();

now you have to go hunt in the declaration of the function what type does it return :(

quite disheartened you recommend go all auto :(]]></description>
		<content:encoded><![CDATA[<p>one of the most annoying thin in c# is :<br />
var variable = SomeFunctionCall();</p>
<p>now you have to go hunt in the declaration of the function what type does it return :(</p>
<p>quite disheartened you recommend go all auto :(</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: saul				</title>
				<link>https://herbsutter.com/2013/06/13/gotw-94-special-edition-aaa-style-almost-always-auto/#comment-11299</link>
		<dc:creator><![CDATA[saul]]></dc:creator>
		<pubDate>Fri, 14 Jun 2013 03:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2186#comment-11299</guid>
					<description><![CDATA[3. My only concern on using auto is my IDE doesn&#039;t autocomplete through such variables, making it annoying enough to not use half the time.]]></description>
		<content:encoded><![CDATA[<p>3. My only concern on using auto is my IDE doesn&#8217;t autocomplete through such variables, making it annoying enough to not use half the time.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
