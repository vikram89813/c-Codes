<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #91 Solution: Smart Pointer Parameters	</title>
	<atom:link href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Fixed: C++ &#8211; passing references to std::shared_ptr or boost::shared_ptr #it #answer #dev &#124; SevenNet				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-34404</link>
		<dc:creator><![CDATA[Fixed: C++ &#8211; passing references to std::shared_ptr or boost::shared_ptr #it #answer #dev &#124; SevenNet]]></dc:creator>
		<pubDate>Sat, 27 Dec 2014 11:05:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-34404</guid>
					<description><![CDATA[[&#8230;] Herb has expanded on this here: https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/, although the moral of the story is that you shouldn&#8217;t be passing shared_ptr&#8217;s at all [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Herb has expanded on this here: <a href="https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/" rel="nofollow">https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/</a>, although the moral of the story is that you shouldn&#8217;t be passing shared_ptr&#8217;s at all [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: tohava				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-33772</link>
		<dc:creator><![CDATA[tohava]]></dc:creator>
		<pubDate>Mon, 15 Dec 2014 19:59:36 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-33772</guid>
					<description><![CDATA[It is also useful to pass const shared_ptr &#038; if the function creates a weak pointer from the shared pointer.]]></description>
		<content:encoded><![CDATA[<p>It is also useful to pass const shared_ptr &amp; if the function creates a weak pointer from the shared pointer.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mikef				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-25739</link>
		<dc:creator><![CDATA[mikef]]></dc:creator>
		<pubDate>Tue, 02 Sep 2014 04:35:25 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-25739</guid>
					<description><![CDATA[Why are we making pointers even more complicated to teach and learn?  Somehow we have figured out a way to make this more difficult to properly teach in a consistent manner and this makes learning exponentially harder.

Maybe it&#039;s time for a fundamental change.  Let&#039;s not think about pointers, references, and smart pointers.  Let&#039;s think about what we are really trying to do in these scenarios and bake the solutions into the language using different, more meaningful, names for those scenarios.

I know, I know...  what about legacy code.  Figure it out.  This is supposed to be a means to an end.  I have better things to do.  Don&#039;t you?]]></description>
		<content:encoded><![CDATA[<p>Why are we making pointers even more complicated to teach and learn?  Somehow we have figured out a way to make this more difficult to properly teach in a consistent manner and this makes learning exponentially harder.</p>
<p>Maybe it&#8217;s time for a fundamental change.  Let&#8217;s not think about pointers, references, and smart pointers.  Let&#8217;s think about what we are really trying to do in these scenarios and bake the solutions into the language using different, more meaningful, names for those scenarios.</p>
<p>I know, I know&#8230;  what about legacy code.  Figure it out.  This is supposed to be a means to an end.  I have better things to do.  Don&#8217;t you?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Greg Marr				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-25067</link>
		<dc:creator><![CDATA[Greg Marr]]></dc:creator>
		<pubDate>Fri, 22 Aug 2014 21:06:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-25067</guid>
					<description><![CDATA[Matt, there&#039;s a discussion on this exact topic going on right now over at Scott Meyer&#039;s blog, and Herb&#039;s involved.
http://scottmeyers.blogspot.com/2014/07/should-move-only-types-ever-be-passed.html]]></description>
		<content:encoded><![CDATA[<p>Matt, there&#8217;s a discussion on this exact topic going on right now over at Scott Meyer&#8217;s blog, and Herb&#8217;s involved.<br />
<a href="http://scottmeyers.blogspot.com/2014/07/should-move-only-types-ever-be-passed.html" rel="nofollow">http://scottmeyers.blogspot.com/2014/07/should-move-only-types-ever-be-passed.html</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt B				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-25046</link>
		<dc:creator><![CDATA[Matt B]]></dc:creator>
		<pubDate>Fri, 22 Aug 2014 14:51:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-25046</guid>
					<description><![CDATA[Would defining good_sync() in your example as:

[code]void good_sink( unique_ptr&#060;widget&#062;&#038;&#038; p );[/code]

prevent an extra std::unique_ptr from being generated (upon entry of the method), while enforcing the same semantics as the pass-by-value method declaration?  The std::move() would do nothing to the std::unique_ptr passed into the function until the function itself actually &quot;sunk&quot; :) it, where as pass-by-value moves it immediately into a temporary.

What do you think about that approach?]]></description>
		<content:encoded><![CDATA[<p>Would defining good_sync() in your example as:</p>
<pre class="brush: plain; title: ; notranslate">void good_sink( unique_ptr&lt;widget&gt;&amp;&amp; p );</pre>
<p>prevent an extra std::unique_ptr from being generated (upon entry of the method), while enforcing the same semantics as the pass-by-value method declaration?  The std::move() would do nothing to the std::unique_ptr passed into the function until the function itself actually &#8220;sunk&#8221; :) it, where as pass-by-value moves it immediately into a temporary.</p>
<p>What do you think about that approach?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: kerjasambilandirumah.net				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-19766</link>
		<dc:creator><![CDATA[kerjasambilandirumah.net]]></dc:creator>
		<pubDate>Fri, 09 May 2014 13:18:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-19766</guid>
					<description><![CDATA[It&#039;s an awesome paragraph in favor of all the online people; they will get advantage from it I 
am sure.]]></description>
		<content:encoded><![CDATA[<p>It&#8217;s an awesome paragraph in favor of all the online people; they will get advantage from it I<br />
am sure.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt Wilson				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-14623</link>
		<dc:creator><![CDATA[Matt Wilson]]></dc:creator>
		<pubDate>Thu, 06 Feb 2014 18:53:41 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-14623</guid>
					<description><![CDATA[Please extend this article with the following two examples explained:
void f( weak_ptr );   (e)
void f( weak_ptr&#038; );  (f)

I know some engineers that believe this is the best way to pass widget to methods that don&#039;t take ownership.]]></description>
		<content:encoded><![CDATA[<p>Please extend this article with the following two examples explained:<br />
void f( weak_ptr );   (e)<br />
void f( weak_ptr&amp; );  (f)</p>
<p>I know some engineers that believe this is the best way to pass widget to methods that don&#8217;t take ownership.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bartosz Milewski				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-14060</link>
		<dc:creator><![CDATA[Bartosz Milewski]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 17:36:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-14060</guid>
					<description><![CDATA[If I saw (d) or (f) in a code review I would most likely send it back to the author for a rewrite with this note: 

If these are just out parameters, return them:
[code]unique_ptr&#060;widget&#062; f();  (d)
shared_ptr&#060;widget&#062; f();  (f)[/code]
If you need to return more than the widget, repack the other return values as out parameters. 

If the widgets are in/out, you&#039;re really passing one widget as an in parameter and returning another, so separate them:
[code]unique_ptr&#060;widget&#062; f(widget const * src_widget);  (d)
shared_ptr&#060;widget&#062; f(widget const * src_widget);  (f)[/code]

Using in/out parameters is already confusing enough; combining in and out ownership policies into one parameter is inviting a disaster.]]></description>
		<content:encoded><![CDATA[<p>If I saw (d) or (f) in a code review I would most likely send it back to the author for a rewrite with this note: </p>
<p>If these are just out parameters, return them:</p>
<pre class="brush: plain; title: ; notranslate">unique_ptr&lt;widget&gt; f();  (d)
shared_ptr&lt;widget&gt; f();  (f)</pre>
<p>If you need to return more than the widget, repack the other return values as out parameters. </p>
<p>If the widgets are in/out, you&#8217;re really passing one widget as an in parameter and returning another, so separate them:</p>
<pre class="brush: plain; title: ; notranslate">unique_ptr&lt;widget&gt; f(widget const * src_widget);  (d)
shared_ptr&lt;widget&gt; f(widget const * src_widget);  (f)</pre>
<p>Using in/out parameters is already confusing enough; combining in and out ownership policies into one parameter is inviting a disaster.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-13885</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Thu, 19 Dec 2013 17:56:57 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-13885</guid>
					<description><![CDATA[@CS There was a proposal for this for C++1y, but didn&#039;t make it into the draft. I believe the reasoning was that in the presence of `std::shared_ptr` and `std::unique_ptr`, raw points should always be expressed as observing. Unfortunately, your example of legacy code is exactly the reason why this was a bad decision. I would love to see the &quot;worlds dumbest smart pointer&quot; get revisited in the general library TS coming after C++14...

http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3514.pdf]]></description>
		<content:encoded><![CDATA[<p>@CS There was a proposal for this for C++1y, but didn&#8217;t make it into the draft. I believe the reasoning was that in the presence of `std::shared_ptr` and `std::unique_ptr`, raw points should always be expressed as observing. Unfortunately, your example of legacy code is exactly the reason why this was a bad decision. I would love to see the &#8220;worlds dumbest smart pointer&#8221; get revisited in the general library TS coming after C++14&#8230;</p>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3514.pdf" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3514.pdf</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: CS				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-13800</link>
		<dc:creator><![CDATA[CS]]></dc:creator>
		<pubDate>Thu, 12 Dec 2013 02:11:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-13800</guid>
					<description><![CDATA[I work a large project that has legacy going back to the &#039;80s. Some of the code is Fortran, some C, but a large part is C++ and most of the new code is C++.
Some of the C++ is in an old style and some has been updated to a more modern style.

I come across a function with a pointer parameter:
[code]
void DoSomethingAwesome(double *pVal);
[/code]

Is this a modern &quot;Non-owning raw * pointer&quot;? or is this a legacy &quot;bad_sink&quot; that should be updated?

If I&#039;m lucky there is a comment somewhere that tells me, otherwise I need to search into the .cpp file and decide if this is a bad_sink and perhaps update it. (Of course pVal in this function could actually be used as an iterator with some fun old school pointer math going on.)

It would be very nice if the language had a feature that allowed functions to explicitly state &quot;pass me a non-owning pointer&quot;. As it is now all they can say is &quot;trust me, do I look like I might delete your non-owning raw pointer?&quot;]]></description>
		<content:encoded><![CDATA[<p>I work a large project that has legacy going back to the &#8217;80s. Some of the code is Fortran, some C, but a large part is C++ and most of the new code is C++.<br />
Some of the C++ is in an old style and some has been updated to a more modern style.</p>
<p>I come across a function with a pointer parameter:</p>
<pre class="brush: plain; title: ; notranslate">
void DoSomethingAwesome(double *pVal);
</pre>
<p>Is this a modern &#8220;Non-owning raw * pointer&#8221;? or is this a legacy &#8220;bad_sink&#8221; that should be updated?</p>
<p>If I&#8217;m lucky there is a comment somewhere that tells me, otherwise I need to search into the .cpp file and decide if this is a bad_sink and perhaps update it. (Of course pVal in this function could actually be used as an iterator with some fun old school pointer math going on.)</p>
<p>It would be very nice if the language had a feature that allowed functions to explicitly state &#8220;pass me a non-owning pointer&#8221;. As it is now all they can say is &#8220;trust me, do I look like I might delete your non-owning raw pointer?&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: C&#38;B Background Reading, Part Deux &#124; C++ and Beyond				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-13701</link>
		<dc:creator><![CDATA[C&#38;B Background Reading, Part Deux &#124; C++ and Beyond]]></dc:creator>
		<pubDate>Fri, 06 Dec 2013 18:25:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-13701</guid>
					<description><![CDATA[[&#8230;] Guru of the Week #91: Smart Pointer Parameters [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Guru of the Week #91: Smart Pointer Parameters [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-13626</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Tue, 03 Dec 2013 16:51:04 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-13626</guid>
					<description><![CDATA[Edited 2013-12-03 to implement private feedback from Andrei Alexandrescu: Rewrote parts of the solution to #1 to make a correction (remove the comment about increment being cheap, as there overhead and it does incur a fence on x86/x64) and add the following new explanatory paragraph to drive home an essential point made again later on:

New text: &quot;As we will see, an essential best practice for any reference-counted smart pointer type is to avoid copying it unless you really mean to add a new reference. This cannot be stressed enough. This directly addresses both of these costs and pushes their performance impact down into the noise for most applications, and especially eliminates the second cost because it is an antipattern to add and remove references in tight loops.&quot;

Thanks, Andrei!]]></description>
		<content:encoded><![CDATA[<p>Edited 2013-12-03 to implement private feedback from Andrei Alexandrescu: Rewrote parts of the solution to #1 to make a correction (remove the comment about increment being cheap, as there overhead and it does incur a fence on x86/x64) and add the following new explanatory paragraph to drive home an essential point made again later on:</p>
<p>New text: &#8220;As we will see, an essential best practice for any reference-counted smart pointer type is to avoid copying it unless you really mean to add a new reference. This cannot be stressed enough. This directly addresses both of these costs and pushes their performance impact down into the noise for most applications, and especially eliminates the second cost because it is an antipattern to add and remove references in tight loops.&#8221;</p>
<p>Thanks, Andrei!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: leo_carvalho				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-13302</link>
		<dc:creator><![CDATA[leo_carvalho]]></dc:creator>
		<pubDate>Wed, 20 Nov 2013 00:02:58 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-13302</guid>
					<description><![CDATA[@jlehrer
You can use template alias for that.
[code]
template &#060;class T&#062;
using pointer = T*;
[/code]]]></description>
		<content:encoded><![CDATA[<p>@jlehrer<br />
You can use template alias for that.</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;class T&gt;
using pointer = T*;
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11862</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Sat, 06 Jul 2013 10:13:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11862</guid>
					<description><![CDATA[GregM, i that&#039;s what you took away from my last comment, then obviously I worded it extraordinarily badly. I apologise! Thanks for the effort anyway.

In case anyone else might still be interested, I have an issue with the advice offered in &quot;2. What are the correctness implications…”

- Object is being managed by a shared_ptr
- Advice: we should pass a raw pointer to that object to some function
- Caveat: &quot;Note this assumes the pointer is not aliased&quot;
- The raw pointer we passed to the function is itself an alias of the original pointer.

So we can follow this advice as long as we don&#039;t follow this advice?]]></description>
		<content:encoded><![CDATA[<p>GregM, i that&#8217;s what you took away from my last comment, then obviously I worded it extraordinarily badly. I apologise! Thanks for the effort anyway.</p>
<p>In case anyone else might still be interested, I have an issue with the advice offered in &#8220;2. What are the correctness implications…”</p>
<p>&#8211; Object is being managed by a shared_ptr<br />
&#8211; Advice: we should pass a raw pointer to that object to some function<br />
&#8211; Caveat: &#8220;Note this assumes the pointer is not aliased&#8221;<br />
&#8211; The raw pointer we passed to the function is itself an alias of the original pointer.</p>
<p>So we can follow this advice as long as we don&#8217;t follow this advice?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11859</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Sat, 06 Jul 2013 01:04:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11859</guid>
					<description><![CDATA[Given that what you want is exactly what you get here, then we all agree.  Thanks for your time.  Goodbye.]]></description>
		<content:encoded><![CDATA[<p>Given that what you want is exactly what you get here, then we all agree.  Thanks for your time.  Goodbye.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11857</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Fri, 05 Jul 2013 22:20:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11857</guid>
					<description><![CDATA[And again, refer to Herb&#039;s section that spans &quot;2. What are the correctness implications... but in this respect it’s no different than any other aliased object.)&quot;

He is not talking at all about the internal state of the pointed-to object at all. He&#039;s talking only about &quot;lifetime&quot;, how it seems that &quot;taking a copy of the shared_ptr guarantees that the function itself holds a strong refcount on the owned object, and that therefore the object will remain alive for the duration of the function body, or until the function itself chooses to modify its parameter.&quot;

But he goes on: &quot;However, we already get this for free... (except we don&#039;t)&quot; I elided/paraphrased that last part, but quite adequately.

Hence just as there&#039;s no need to mention threads, there&#039;s also no need to suppose some mutable state of the pointed-to object. The entire point here is purely and only about the lifetime of the object, as controlled by the one-or-more shared_ptrs that point to it.

To make this absolutely concrete: what if the pointed-to object is immutable? Say we read a big map-of-strings-to-strings from a JSON file, and then encapsulate it inside a Config class that only allows read access to the map. This means that once loaded, we can safely share our single Config instance around (between threads or otherwise) and know its contents won&#039;t get mutated. But we want it to be deleted when no longer in use. It&#039;s a perfect application for shared_ptr. Even though the Config is visible from multiple places, no one can modify it, and so the only additional guarantee we need is that it won&#039;t get destroyed at the wrong time.]]></description>
		<content:encoded><![CDATA[<p>And again, refer to Herb&#8217;s section that spans &#8220;2. What are the correctness implications&#8230; but in this respect it’s no different than any other aliased object.)&#8221;</p>
<p>He is not talking at all about the internal state of the pointed-to object at all. He&#8217;s talking only about &#8220;lifetime&#8221;, how it seems that &#8220;taking a copy of the shared_ptr guarantees that the function itself holds a strong refcount on the owned object, and that therefore the object will remain alive for the duration of the function body, or until the function itself chooses to modify its parameter.&#8221;</p>
<p>But he goes on: &#8220;However, we already get this for free&#8230; (except we don&#8217;t)&#8221; I elided/paraphrased that last part, but quite adequately.</p>
<p>Hence just as there&#8217;s no need to mention threads, there&#8217;s also no need to suppose some mutable state of the pointed-to object. The entire point here is purely and only about the lifetime of the object, as controlled by the one-or-more shared_ptrs that point to it.</p>
<p>To make this absolutely concrete: what if the pointed-to object is immutable? Say we read a big map-of-strings-to-strings from a JSON file, and then encapsulate it inside a Config class that only allows read access to the map. This means that once loaded, we can safely share our single Config instance around (between threads or otherwise) and know its contents won&#8217;t get mutated. But we want it to be deleted when no longer in use. It&#8217;s a perfect application for shared_ptr. Even though the Config is visible from multiple places, no one can modify it, and so the only additional guarantee we need is that it won&#8217;t get destroyed at the wrong time.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11832</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Thu, 04 Jul 2013 18:28:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11832</guid>
					<description><![CDATA[Okay, fine, so leave threads out of it.  If you call some other function that does something to the object that you&#039;re working on, then it&#039;s still a problem.  This same problem exists whether you have a copy of the shared_ptr or a reference to the shared_ptr.  The copy of the shared_ptr only gives you additional safety against the object being destroyed if there is someone else that has a non-const reference to the shared_ptr itself.  In that case, however, it still gives you no safety against changes in the object itself.

If you and your caller both have a pointer to the object, but so does someone else, and you call that someone else to do something, and it, unknown to you, changes all the data in that object, how has the copy of the shared_ptr helped you?

Analogies don&#039;t generally work very well, but let me give it a shot with what you used.

Say that you are holding a single red rose between your teeth, and I&#039;m holding your hand.  The other person who is also holding the same single red rose between their teeth can bite through the stem and ruin the rose.  My holding the rose between my teeth in addition to holding your hand doesn&#039;t prevent the other person from biting through the stem.  If you want the other person to not be able to bite through the stem, you better make sure that they don&#039;t have it between their teeth.  It won&#039;t make a bit of difference how I hold the rose.

Since you&#039;re holding the rose between your teeth, and you are frozen until I go away, then I know that you can&#039;t open your mouth and drop the rose.  I can either simply hold your hand, or I can hold your hand and also hold the rose between my teeth, and the rose won&#039;t be dropped on the ground no matter what happens.]]></description>
		<content:encoded><![CDATA[<p>Okay, fine, so leave threads out of it.  If you call some other function that does something to the object that you&#8217;re working on, then it&#8217;s still a problem.  This same problem exists whether you have a copy of the shared_ptr or a reference to the shared_ptr.  The copy of the shared_ptr only gives you additional safety against the object being destroyed if there is someone else that has a non-const reference to the shared_ptr itself.  In that case, however, it still gives you no safety against changes in the object itself.</p>
<p>If you and your caller both have a pointer to the object, but so does someone else, and you call that someone else to do something, and it, unknown to you, changes all the data in that object, how has the copy of the shared_ptr helped you?</p>
<p>Analogies don&#8217;t generally work very well, but let me give it a shot with what you used.</p>
<p>Say that you are holding a single red rose between your teeth, and I&#8217;m holding your hand.  The other person who is also holding the same single red rose between their teeth can bite through the stem and ruin the rose.  My holding the rose between my teeth in addition to holding your hand doesn&#8217;t prevent the other person from biting through the stem.  If you want the other person to not be able to bite through the stem, you better make sure that they don&#8217;t have it between their teeth.  It won&#8217;t make a bit of difference how I hold the rose.</p>
<p>Since you&#8217;re holding the rose between your teeth, and you are frozen until I go away, then I know that you can&#8217;t open your mouth and drop the rose.  I can either simply hold your hand, or I can hold your hand and also hold the rose between my teeth, and the rose won&#8217;t be dropped on the ground no matter what happens.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11825</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Thu, 04 Jul 2013 10:18:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11825</guid>
					<description><![CDATA[@GregM - re: &quot;data races with your smart pointer&quot; - this is about shared_ptr, not any old smart pointer. The standard shared_ptr is in fact thread-safe w.r.t. assignment. This is why it is so slow, which in turn is why Herb is so keen on discouraging patterns where shared_ptr gets copied a lot.

And in any case, re: the part I&#039;m questioning, why bring threads into it? Herb (correctly) does not..His &quot;2. What are the correctness implications...&quot; makes no mention at all of data races or multiple threads, and nor does it need to: it&#039;s about the relationship between variables declared at different places in a single call/variable stack, such as is found in a single-threaded C++ program.

Herb: &quot;Even if we passed the shared_ptr by reference, our function would as good as hold a strong refcount because the caller already has one—he passed us the shared_ptr in the first place, and won’t release it until we return. (Note this assumes the pointer is not aliased... in this respect it’s no different than any other aliased object.)&quot;

That guarantee (including the disclaimer-in-brackets that sadly undermines it) is all about a single thread. 

My point is that it&#039;s about as helpful as:

Me: &quot;If I hold a single red rose between my teeth, you and I can tango into the Room of Poison Gas without dying! (Assuming of course that there&#039;s no poison gas in the room at this particular moment - but hey, poison gas is generally dangerous so why should this little tacked-on caveat be any kind of surprise?)&quot;]]></description>
		<content:encoded><![CDATA[<p>@GregM &#8211; re: &#8220;data races with your smart pointer&#8221; &#8211; this is about shared_ptr, not any old smart pointer. The standard shared_ptr is in fact thread-safe w.r.t. assignment. This is why it is so slow, which in turn is why Herb is so keen on discouraging patterns where shared_ptr gets copied a lot.</p>
<p>And in any case, re: the part I&#8217;m questioning, why bring threads into it? Herb (correctly) does not..His &#8220;2. What are the correctness implications&#8230;&#8221; makes no mention at all of data races or multiple threads, and nor does it need to: it&#8217;s about the relationship between variables declared at different places in a single call/variable stack, such as is found in a single-threaded C++ program.</p>
<p>Herb: &#8220;Even if we passed the shared_ptr by reference, our function would as good as hold a strong refcount because the caller already has one—he passed us the shared_ptr in the first place, and won’t release it until we return. (Note this assumes the pointer is not aliased&#8230; in this respect it’s no different than any other aliased object.)&#8221;</p>
<p>That guarantee (including the disclaimer-in-brackets that sadly undermines it) is all about a single thread. </p>
<p>My point is that it&#8217;s about as helpful as:</p>
<p>Me: &#8220;If I hold a single red rose between my teeth, you and I can tango into the Room of Poison Gas without dying! (Assuming of course that there&#8217;s no poison gas in the room at this particular moment &#8211; but hey, poison gas is generally dangerous so why should this little tacked-on caveat be any kind of surprise?)&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Emmanuel Thivierge				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11792</link>
		<dc:creator><![CDATA[Emmanuel Thivierge]]></dc:creator>
		<pubDate>Wed, 03 Jul 2013 01:27:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11792</guid>
					<description><![CDATA[Hi everybody,
I came back o read again this post because I was in front of a dilema and I was wondering what is the best way to express it.

I had created a std:vector and I was going to pass it to a function 
[code][/code]
std:vector widgetList;
myWidgetManager.addWidgetList(widgetList);
[\code]

To me addWidgetList is a sink, the object will take the ownership of the vector. So I tough, I should pass a std:unique_ptr&#060;std::vector&#062;, first it start to be a mouthful to write and my object is actually on the stack. 

In this guru you don&#039;t only talk about smart pointers but also on when/how to pass argument to functions. To me this situation is like c) the function is a sink but for the stack i would express it as std::vector&#038;&#038;.

Would that be a good practice?
thanks
Mani]]></description>
		<content:encoded><![CDATA[<p>Hi everybody,<br />
I came back o read again this post because I was in front of a dilema and I was wondering what is the best way to express it.</p>
<p>I had created a std:vector and I was going to pass it to a function </p>
<p>std:vector widgetList;<br />
myWidgetManager.addWidgetList(widgetList);<br />
[\code]</p>
<p>To me addWidgetList is a sink, the object will take the ownership of the vector. So I tough, I should pass a std:unique_ptr&lt;std::vector&gt;, first it start to be a mouthful to write and my object is actually on the stack. </p>
<p>In this guru you don&#8217;t only talk about smart pointers but also on when/how to pass argument to functions. To me this situation is like c) the function is a sink but for the stack i would express it as std::vector&amp;&amp;.</p>
<p>Would that be a good practice?<br />
thanks<br />
Mani</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11766</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Mon, 01 Jul 2013 16:05:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11766</guid>
					<description><![CDATA[The point is that if you have data races with your smart pointer or your pointed-to object, then neither by-copy or by-ref is going to help you.]]></description>
		<content:encoded><![CDATA[<p>The point is that if you have data races with your smart pointer or your pointed-to object, then neither by-copy or by-ref is going to help you.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11658</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Tue, 25 Jun 2013 12:06:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11658</guid>
					<description><![CDATA[@GregM

&quot;which is a problem no matter which kind of pointer&quot;

See, Herb made exactly the same kind of observation in his parenthetical caveat: &quot;... but in this respect it’s no different than any other aliased object.&quot;

What difference does it make to whether we need to take care in this situation?

It&#039;s not just a problem for pointers, it&#039;s a problem for any object with mutable internal state, e.g. a string vs. a &#039;const string&#038;&#039;

This doesn&#039;t stop it from being a problem in the case of shared_ptr, does it?

By accepting a parameter that is a const &#038;, you&#039;ve already introduced at least one alias. You&#039;ve said, in effect, &quot;I don&#039;t care if this object stays alive - I assume all my callers will ensure that for me&quot;.

Rather than saying &quot;it&#039;s a guarantee (except it&#039;s not)&quot;, why not instead say we always have the same trade-off to make:

1. copy (slow, but ensures object will survive)
2. ref (fast, doesn&#039;t ensure object will survive)

If you follow 2 by default throughout your code, you are practicing the art of &quot;write fast code, then fix it&quot;. If you follow 1 by default, you&#039;re following &quot;write correct code, then optimize it&quot;. 

Again, choose your poison! Due to the severe performance problem caused by all the ref-counting, optimizing a correct program may be as hard as finding/fixing bugs in a fast program.]]></description>
		<content:encoded><![CDATA[<p>@GregM</p>
<p>&#8220;which is a problem no matter which kind of pointer&#8221;</p>
<p>See, Herb made exactly the same kind of observation in his parenthetical caveat: &#8220;&#8230; but in this respect it’s no different than any other aliased object.&#8221;</p>
<p>What difference does it make to whether we need to take care in this situation?</p>
<p>It&#8217;s not just a problem for pointers, it&#8217;s a problem for any object with mutable internal state, e.g. a string vs. a &#8216;const string&amp;&#8217;</p>
<p>This doesn&#8217;t stop it from being a problem in the case of shared_ptr, does it?</p>
<p>By accepting a parameter that is a const &amp;, you&#8217;ve already introduced at least one alias. You&#8217;ve said, in effect, &#8220;I don&#8217;t care if this object stays alive &#8211; I assume all my callers will ensure that for me&#8221;.</p>
<p>Rather than saying &#8220;it&#8217;s a guarantee (except it&#8217;s not)&#8221;, why not instead say we always have the same trade-off to make:</p>
<p>1. copy (slow, but ensures object will survive)<br />
2. ref (fast, doesn&#8217;t ensure object will survive)</p>
<p>If you follow 2 by default throughout your code, you are practicing the art of &#8220;write fast code, then fix it&#8221;. If you follow 1 by default, you&#8217;re following &#8220;write correct code, then optimize it&#8221;. </p>
<p>Again, choose your poison! Due to the severe performance problem caused by all the ref-counting, optimizing a correct program may be as hard as finding/fixing bugs in a fast program.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11588</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 19:20:39 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11588</guid>
					<description><![CDATA[&quot;What actual firm claim is being made here?&quot;

Absent aliasing, which is a problem no matter which kind of pointer you are using, and can&#039;t be dealt with just by using a different kind of pointer, you can be guaranteed that the object will be alive for as long as the function call.

&quot;When can it be relied on? How can we tell?&quot;

It can be relied on as long as there is no aliasing of the pointer.  As for how you can tell, that&#039;s going to require that you look at your program to see if there is any aliasing going on.]]></description>
		<content:encoded><![CDATA[<p>&#8220;What actual firm claim is being made here?&#8221;</p>
<p>Absent aliasing, which is a problem no matter which kind of pointer you are using, and can&#8217;t be dealt with just by using a different kind of pointer, you can be guaranteed that the object will be alive for as long as the function call.</p>
<p>&#8220;When can it be relied on? How can we tell?&#8221;</p>
<p>It can be relied on as long as there is no aliasing of the pointer.  As for how you can tell, that&#8217;s going to require that you look at your program to see if there is any aliasing going on.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: earwicker				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11582</link>
		<dc:creator><![CDATA[earwicker]]></dc:creator>
		<pubDate>Fri, 21 Jun 2013 13:27:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11582</guid>
					<description><![CDATA[re: Herb&#039;s caveat &quot;(Yes, you have to be careful if the smart pointer parameter can be aliased, but in this respect it’s no different than any other aliased object).&quot;

Reminds me of the guy who was hitting himself with a hammer. When his doctor told him &quot;Stop hitting yourself with a hammer&quot;, he replied &quot;Oh, come on, you can&#039;t blame the hammer. It would be just as bad if I hit myself with a brick or anything else for that matter!&quot;

Yes, if g calls f then as long as f is still running, then g is still running. But g could pass to f a member variable, m, which presently refers to an object, and then some unholy, filthy chain of callbacks set off within f could reach back and cause m to be mutated, all while f - and therefore g - still have not returned.

So Herb&#039;s paragraph &quot;However, we already get this for free...&quot; would seem to be followed by the caveat &quot;... (except when we don&#039;t).&quot; What actual firm claim is being made here? When can it be relied on? How can we tell?]]></description>
		<content:encoded><![CDATA[<p>re: Herb&#8217;s caveat &#8220;(Yes, you have to be careful if the smart pointer parameter can be aliased, but in this respect it’s no different than any other aliased object).&#8221;</p>
<p>Reminds me of the guy who was hitting himself with a hammer. When his doctor told him &#8220;Stop hitting yourself with a hammer&#8221;, he replied &#8220;Oh, come on, you can&#8217;t blame the hammer. It would be just as bad if I hit myself with a brick or anything else for that matter!&#8221;</p>
<p>Yes, if g calls f then as long as f is still running, then g is still running. But g could pass to f a member variable, m, which presently refers to an object, and then some unholy, filthy chain of callbacks set off within f could reach back and cause m to be mutated, all while f &#8211; and therefore g &#8211; still have not returned.</p>
<p>So Herb&#8217;s paragraph &#8220;However, we already get this for free&#8230;&#8221; would seem to be followed by the caveat &#8220;&#8230; (except when we don&#8217;t).&#8221; What actual firm claim is being made here? When can it be relied on? How can we tell?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter GotW91: Smart Pointer parameters &#124; musingstudio				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11265</link>
		<dc:creator><![CDATA[Herb Sutter GotW91: Smart Pointer parameters &#124; musingstudio]]></dc:creator>
		<pubDate>Thu, 13 Jun 2013 07:47:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11265</guid>
					<description><![CDATA[[&#8230;] Sutter&#8217;s guidelines on passing smart pointers as parameters include the [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] Sutter&#8217;s guidelines on passing smart pointers as parameters include the [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mathias Stearn				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11121</link>
		<dc:creator><![CDATA[Mathias Stearn]]></dc:creator>
		<pubDate>Sat, 08 Jun 2013 19:40:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11121</guid>
					<description><![CDATA[What do you think of using something like ptr [1] which is usable like a T* but is implicitly convertible from any smart pointer and clearly marks non-owning semantics? I&#039;ve found that in code that uses smart pointers, functions that take a bare pointer are annoying because you have to call get(), breaking the abstraction. It also has a nice side benefit of less visual ambiguity between const ptr and ptr.

On the related issue of pointer returns, do you know why covariant return support wasn&#039;t added for smart pointers? It seems like a clone() method would have to choose between better type-safety but using a raw owning pointer or returning a smart pointer and requiring casts.

[1] https://gist.github.com/RedBeard0531/5736292 (written for C++98 + boost)]]></description>
		<content:encoded><![CDATA[<p>What do you think of using something like ptr [1] which is usable like a T* but is implicitly convertible from any smart pointer and clearly marks non-owning semantics? I&#8217;ve found that in code that uses smart pointers, functions that take a bare pointer are annoying because you have to call get(), breaking the abstraction. It also has a nice side benefit of less visual ambiguity between const ptr and ptr.</p>
<p>On the related issue of pointer returns, do you know why covariant return support wasn&#8217;t added for smart pointers? It seems like a clone() method would have to choose between better type-safety but using a raw owning pointer or returning a smart pointer and requiring casts.</p>
<p>[1] <a href="https://gist.github.com/RedBeard0531/5736292" rel="nofollow">https://gist.github.com/RedBeard0531/5736292</a> (written for C++98 + boost)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11063</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 13:03:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11063</guid>
					<description><![CDATA[@Jon: That&#039;s probably a rare case but I think you&#039;re right it&#039;s worth calling out. Added, thanks.]]></description>
		<content:encoded><![CDATA[<p>@Jon: That&#8217;s probably a rare case but I think you&#8217;re right it&#8217;s worth calling out. Added, thanks.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11039</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 01:26:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11039</guid>
					<description><![CDATA[@Herb: If a function is going to decide at runtime whether to share ownership or not, should we still pass the shared_ptr by value or is const reference a legitimate choice? It seems to me that if we pass an lvalue by value and the called function decides not to share ownership, we&#039;ve copied a share_ptr for no reason.]]></description>
		<content:encoded><![CDATA[<p>@Herb: If a function is going to decide at runtime whether to share ownership or not, should we still pass the shared_ptr by value or is const reference a legitimate choice? It seems to me that if we pass an lvalue by value and the called function decides not to share ownership, we&#8217;ve copied a share_ptr for no reason.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian Fiete				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11021</link>
		<dc:creator><![CDATA[Brian Fiete]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 14:32:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11021</guid>
					<description><![CDATA[Re: #2 (correctness) - even without changing the state of the calling function, passing a shared_ptr by reference can be hazardous if the function is able to remove the shared_ptr reference that was passed to it.  A trivial case is below (results in a crash), but one can easily imagine a less trivial case -- say, if the function were to run some validation on the data passed to it which could result in a new instantiation of that data...

[code]
struct IntArrayContainer
{	
	shared_ptr&#060;vector&#060;int&#062;&#062; mIntArray;
};

IntArrayContainer* gIntArrayContainer;

int GetFirstValueFrom(shared_ptr&#060;vector&#060;int&#062;&#062;&#038; intArray)
{
	delete gIntArrayContainer;	
	return (*intArray)[0];
}

void main()
{
	gIntArrayContainer = new IntArrayContainer();
	gIntArrayContainer-&#062;mIntArray = shared_ptr&#060;vector&#060;int&#062;&#062;(new vector&#060;int&#062;(1, 1));
	printf(&#034;First: %d\n&#034;, GetFirstValueFrom(gIntArrayContainer-&#062;mIntArray));
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>Re: #2 (correctness) &#8211; even without changing the state of the calling function, passing a shared_ptr by reference can be hazardous if the function is able to remove the shared_ptr reference that was passed to it.  A trivial case is below (results in a crash), but one can easily imagine a less trivial case &#8212; say, if the function were to run some validation on the data passed to it which could result in a new instantiation of that data&#8230;</p>
<pre class="brush: plain; title: ; notranslate">
struct IntArrayContainer
{	
	shared_ptr&lt;vector&lt;int&gt;&gt; mIntArray;
};

IntArrayContainer* gIntArrayContainer;

int GetFirstValueFrom(shared_ptr&lt;vector&lt;int&gt;&gt;&amp; intArray)
{
	delete gIntArrayContainer;	
	return (*intArray)[0];
}

void main()
{
	gIntArrayContainer = new IntArrayContainer();
	gIntArrayContainer-&gt;mIntArray = shared_ptr&lt;vector&lt;int&gt;&gt;(new vector&lt;int&gt;(1, 1));
	printf(&quot;First: %d\n&quot;, GetFirstValueFrom(gIntArrayContainer-&gt;mIntArray));
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Kamil Rojewski				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11007</link>
		<dc:creator><![CDATA[Kamil Rojewski]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 09:53:32 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11007</guid>
					<description><![CDATA[I have a question about example (c). Wouldn&#039;t it be better to use rvalue ref to unique_ptr instead of pass-by-value? It still requires to pass an explicit unique_ptr, but it shows an expcilit move is done, instead of implicit by passing to the parmateter value.]]></description>
		<content:encoded><![CDATA[<p>I have a question about example (c). Wouldn&#8217;t it be better to use rvalue ref to unique_ptr instead of pass-by-value? It still requires to pass an explicit unique_ptr, but it shows an expcilit move is done, instead of implicit by passing to the parmateter value.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Leszek Swirski				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-11005</link>
		<dc:creator><![CDATA[Leszek Swirski]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 09:28:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-11005</guid>
					<description><![CDATA[@Jon: I have considered it, but a similar proposal was rejected in 2003, because (as I understand it), even people who liked the syntax didn&#039;t like the fact that this was essentially optional, rather than a language change (cf. Ada, C#). The argument was that for

[code]f(out(x),y)[/code]

you technically still don&#039;t know if y is mutable or not, because the evil library writer could still be using normal references.

http://lists.boost.org/Archives/boost/2003/04/47180.php]]></description>
		<content:encoded><![CDATA[<p>@Jon: I have considered it, but a similar proposal was rejected in 2003, because (as I understand it), even people who liked the syntax didn&#8217;t like the fact that this was essentially optional, rather than a language change (cf. Ada, C#). The argument was that for</p>
<pre class="brush: plain; title: ; notranslate">f(out(x),y)</pre>
<p>you technically still don&#8217;t know if y is mutable or not, because the evil library writer could still be using normal references.</p>
<p><a href="http://lists.boost.org/Archives/boost/2003/04/47180.php" rel="nofollow">http://lists.boost.org/Archives/boost/2003/04/47180.php</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: decourse				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10998</link>
		<dc:creator><![CDATA[decourse]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 07:34:10 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10998</guid>
					<description><![CDATA[As I noted in a comment on the question, there is another use for (d). Some functions may choose to either take or not take ownership of an object by criteria to be decided at run-time, perhaps by inspecting the object itself. Think of a &quot;chain of responsibility&quot; pattern, for example.]]></description>
		<content:encoded><![CDATA[<p>As I noted in a comment on the question, there is another use for (d). Some functions may choose to either take or not take ownership of an object by criteria to be decided at run-time, perhaps by inspecting the object itself. Think of a &#8220;chain of responsibility&#8221; pattern, for example.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10997</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 05:15:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10997</guid>
					<description><![CDATA[@Jon: This is better in the case where you do get an rvalue, and the default guidance to &quot;pass by value then move as needed&quot; doesn&#039;t apply just to smart pointers but to any type that&#039;s cheaper to move than copy. And yes, my opinion has changed. Basically that came from paranoia about a different optimization that doesn&#039;t apply to standard C++ code (something we encountered designing C++/CX that can apply to the underlying implementation of refcounted ^&#039;s but I now realize doesn&#039;t apply to shared_ptrs in normal C++ code).]]></description>
		<content:encoded><![CDATA[<p>@Jon: This is better in the case where you do get an rvalue, and the default guidance to &#8220;pass by value then move as needed&#8221; doesn&#8217;t apply just to smart pointers but to any type that&#8217;s cheaper to move than copy. And yes, my opinion has changed. Basically that came from paranoia about a different optimization that doesn&#8217;t apply to standard C++ code (something we encountered designing C++/CX that can apply to the underlying implementation of refcounted ^&#8217;s but I now realize doesn&#8217;t apply to shared_ptrs in normal C++ code).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10992</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 02:16:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10992</guid>
					<description><![CDATA[Re: “A Proposal for the World’s Dumbest Smart Pointer”

I&#039;ve always wished the C++ language supported a simpler alternative syntax for pointers:

[code]
pointer&#060;int&#062; &#060;--&#062; int*
pointer&#060;const int&#062; &#060;--&#062; const int *
const pointer&#060;int&#062; &#060;--&#062; int * const
const pointer&#060;const int&#062; &#060;--&#062; const int * const
[/code]

this would make teaching pointer syntax to new developers much easier.

Obviously, we can add this as a language feature using

[code]
template &#060;typename T&#062; struct pointer {
 typedef T* type;
};
pointer&#060;int&#062;::type
[/code]

But this is not the same as a language feature.  For example, the compiler would not be able to compile the following code due to the templated function parameter:

[code]
template &#060;typename T&#062; void func(typename pointer&#060;T&#062;::type);
int x;
func(&#038;x); //fails to compile
[/code]]]></description>
		<content:encoded><![CDATA[<p>Re: “A Proposal for the World’s Dumbest Smart Pointer”</p>
<p>I&#8217;ve always wished the C++ language supported a simpler alternative syntax for pointers:</p>
<pre class="brush: plain; title: ; notranslate">
pointer&lt;int&gt; &lt;--&gt; int*
pointer&lt;const int&gt; &lt;--&gt; const int *
const pointer&lt;int&gt; &lt;--&gt; int * const
const pointer&lt;const int&gt; &lt;--&gt; const int * const
</pre>
<p>this would make teaching pointer syntax to new developers much easier.</p>
<p>Obviously, we can add this as a language feature using</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename T&gt; struct pointer {
 typedef T* type;
};
pointer&lt;int&gt;::type
</pre>
<p>But this is not the same as a language feature.  For example, the compiler would not be able to compile the following code due to the templated function parameter:</p>
<pre class="brush: plain; title: ; notranslate">
template &lt;typename T&gt; void func(typename pointer&lt;T&gt;::type);
int x;
func(&amp;x); //fails to compile
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10991</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 02:00:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10991</guid>
					<description><![CDATA[@Leszek Swirski: Have you considered submitting your header to boost?

Having mutability visible at the call site is useful. 
Eg Bjarne Stroustrup: http://www.stroustrup.com/bs_faq2.html#call-by-reference
&quot;My personal style is to use a pointer when I want to modify an object because in some contexts that makes it easier to spot that a modification is possible.&quot;
@Herb, would it be fair to say you disagree with the above style? :)]]></description>
		<content:encoded><![CDATA[<p>@Leszek Swirski: Have you considered submitting your header to boost?</p>
<p>Having mutability visible at the call site is useful.<br />
Eg Bjarne Stroustrup: <a href="http://www.stroustrup.com/bs_faq2.html#call-by-reference" rel="nofollow">http://www.stroustrup.com/bs_faq2.html#call-by-reference</a><br />
&#8220;My personal style is to use a pointer when I want to modify an object because in some contexts that makes it easier to spot that a modification is possible.&#8221;<br />
@Herb, would it be fair to say you disagree with the above style? :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jon				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10990</link>
		<dc:creator><![CDATA[Jon]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 01:37:28 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10990</guid>
					<description><![CDATA[@Herb: &quot;If the local scope is not the final destination, just std::move the shared_ptr onward to wherever it needs to go.&quot; Why is this better than passing by const shared_ptr&#038; through a chain of functions until we&#039;re ready for the final destination? What if the callee will make a decision about whether to share ownership or not? If it decides not to, then we&#039;ve copied for no reason.

Also I noted that you said &quot;always pass them by reference to const, and very occasionally maybe because you know what you called might modify the thing you got a reference from, maybe then you might pass by value&quot; (http://stackoverflow.com/a/8844924/297451). Can I confirm that your opinion has changed since then?]]></description>
		<content:encoded><![CDATA[<p>@Herb: &#8220;If the local scope is not the final destination, just std::move the shared_ptr onward to wherever it needs to go.&#8221; Why is this better than passing by const shared_ptr&amp; through a chain of functions until we&#8217;re ready for the final destination? What if the callee will make a decision about whether to share ownership or not? If it decides not to, then we&#8217;ve copied for no reason.</p>
<p>Also I noted that you said &#8220;always pass them by reference to const, and very occasionally maybe because you know what you called might modify the thing you got a reference from, maybe then you might pass by value&#8221; (<a href="http://stackoverflow.com/a/8844924/297451" rel="nofollow">http://stackoverflow.com/a/8844924/297451</a>). Can I confirm that your opinion has changed since then?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10989</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 00:49:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10989</guid>
					<description><![CDATA[@Herb, since reference types for `std::optional` was not approved, it makes it all the more unfortunate that N3514 &quot;A Proposal for the World’s Dumbest Smart Pointer&quot; didn&#039;t make it either. A `std::exempt_ptr` would be an obvious answer to explicitly express non-owning pointer semantics.]]></description>
		<content:encoded><![CDATA[<p>@Herb, since reference types for `std::optional` was not approved, it makes it all the more unfortunate that N3514 &#8220;A Proposal for the World’s Dumbest Smart Pointer&#8221; didn&#8217;t make it either. A `std::exempt_ptr` would be an obvious answer to explicitly express non-owning pointer semantics.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10987</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 00:39:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10987</guid>
					<description><![CDATA[@mttpd: I&#039;m using WordPress.com, not a WP.org installation. In return for much less admin hassle, it&#039;s more restrictive -- I can&#039;t install packages, only use what they give me. I&#039;ll poke around and see if there&#039;s something available though.]]></description>
		<content:encoded><![CDATA[<p>@mttpd: I&#8217;m using WordPress.com, not a WP.org installation. In return for much less admin hassle, it&#8217;s more restrictive &#8212; I can&#8217;t install packages, only use what they give me. I&#8217;ll poke around and see if there&#8217;s something available though.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10986</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 00:38:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10986</guid>
					<description><![CDATA[@BrianM: But the Guidelines are simple -- don&#039;t pass by smart pointer unless you want to use/modify the smart pointer itself (like any object). The main thing is that pass by value/*/&#038; are all still good and should still be used primarily. It&#039;s just that we now have a couple of idioms for expressing ownership transfer in function signatures, notably passing a unique_ptr by value means &quot;sink&quot; and passing a shared_ptr by value means &quot;gonna share ownership.&quot; That&#039;s pretty much it.]]></description>
		<content:encoded><![CDATA[<p>@BrianM: But the Guidelines are simple &#8212; don&#8217;t pass by smart pointer unless you want to use/modify the smart pointer itself (like any object). The main thing is that pass by value/*/&amp; are all still good and should still be used primarily. It&#8217;s just that we now have a couple of idioms for expressing ownership transfer in function signatures, notably passing a unique_ptr by value means &#8220;sink&#8221; and passing a shared_ptr by value means &#8220;gonna share ownership.&#8221; That&#8217;s pretty much it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Leszek Swirski				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10985</link>
		<dc:creator><![CDATA[Leszek Swirski]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 00:27:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10985</guid>
					<description><![CDATA[For mutable parameters, I like to use my tiny inout header[1], which provides out and inout parameters in the same style as C#&#039;s out[2] and ref[3]. That way the mutability is visible at the call site, there are no raw pointers in user code, and there is no question as to whether the referenced variable needs to be initialised or not (because it only has to be initialised for an inout variable).

[1] https://gist.github.com/LeszekSwirski/3028820
[2] http://msdn.microsoft.com/en-us/library/ee332485.aspx
[3] http://msdn.microsoft.com/en-us/library/14akc2c7.aspx]]></description>
		<content:encoded><![CDATA[<p>For mutable parameters, I like to use my tiny inout header[1], which provides out and inout parameters in the same style as C#&#8217;s out[2] and ref[3]. That way the mutability is visible at the call site, there are no raw pointers in user code, and there is no question as to whether the referenced variable needs to be initialised or not (because it only has to be initialised for an inout variable).</p>
<p>[1] <a href="https://gist.github.com/LeszekSwirski/3028820" rel="nofollow">https://gist.github.com/LeszekSwirski/3028820</a><br />
[2] <a href="http://msdn.microsoft.com/en-us/library/ee332485.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/ee332485.aspx</a><br />
[3] <a href="http://msdn.microsoft.com/en-us/library/14akc2c7.aspx" rel="nofollow">http://msdn.microsoft.com/en-us/library/14akc2c7.aspx</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10983</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 23:50:11 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10983</guid>
					<description><![CDATA[What worries me here is the number of ways and opinions going on - with real world coders I just wonder what would be used in the average non-guru shop or guru populated shop for that matter! The use of the raw pointer does have its simplicity in this case and the only really good argument against it is in a sink function, even then a suitable name such as ProcessAndDelete might suffice. If a coder can&#039;t pick up on that, then we are probably doomed anyway!

Beginning to think we are now in no-mans land with c++, it&#039;s getting way too complicated, after all its only a tool to achieve an end. Maybe we need a more intelligent compiler that can make a lot of these &#039;guru&#039; decisions for the average coder. It should not beyond the ability of a compiler to have a autoptr mk2 that is compiled into the most efficient type for the job. Be like having Herb or Meyers standing behind you :)]]></description>
		<content:encoded><![CDATA[<p>What worries me here is the number of ways and opinions going on &#8211; with real world coders I just wonder what would be used in the average non-guru shop or guru populated shop for that matter! The use of the raw pointer does have its simplicity in this case and the only really good argument against it is in a sink function, even then a suitable name such as ProcessAndDelete might suffice. If a coder can&#8217;t pick up on that, then we are probably doomed anyway!</p>
<p>Beginning to think we are now in no-mans land with c++, it&#8217;s getting way too complicated, after all its only a tool to achieve an end. Maybe we need a more intelligent compiler that can make a lot of these &#8216;guru&#8217; decisions for the average coder. It should not beyond the ability of a compiler to have a autoptr mk2 that is compiled into the most efficient type for the job. Be like having Herb or Meyers standing behind you :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10981</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 23:27:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10981</guid>
					<description><![CDATA[@Herb: fair enough. I can see you&#039;re using WordPress, how about adding WP-Markdown to enable MarkDown (also mentioned by Bret, it&#039;s what&#039;s used on GitHub, Reddit, StackOverflow, and many others -- and supports the backticks syntax for the inline code formatting): http://wordpress.org/plugins/wp-markdown/

// Here&#039;s the relevant feature: http://daringfireball.net/projects/markdown/syntax#code]]></description>
		<content:encoded><![CDATA[<p>@Herb: fair enough. I can see you&#8217;re using WordPress, how about adding WP-Markdown to enable MarkDown (also mentioned by Bret, it&#8217;s what&#8217;s used on GitHub, Reddit, StackOverflow, and many others &#8212; and supports the backticks syntax for the inline code formatting): <a href="http://wordpress.org/plugins/wp-markdown/" rel="nofollow">http://wordpress.org/plugins/wp-markdown/</a></p>
<p>// Here&#8217;s the relevant feature: <a href="http://daringfireball.net/projects/markdown/syntax#code" rel="nofollow">http://daringfireball.net/projects/markdown/syntax#code</a></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10979</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 22:42:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10979</guid>
					<description><![CDATA[@Herb, Well that&#039;s unfortunate; I assumed std::optional would work like boost&#039;s (plus move semantics). I can see the point that reference types represent a somewhat awkward subset of std::optional T.

Also, I assume your own comment got mangled when you said &quot;std::optional isn&#039;t standrad&quot; ;-)]]></description>
		<content:encoded><![CDATA[<p>@Herb, Well that&#8217;s unfortunate; I assumed std::optional would work like boost&#8217;s (plus move semantics). I can see the point that reference types represent a somewhat awkward subset of std::optional T.</p>
<p>Also, I assume your own comment got mangled when you said &#8220;std::optional isn&#8217;t standrad&#8221; ;-)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10978</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 22:30:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10978</guid>
					<description><![CDATA[@mttpd: Maybe I should allude to this, thanks: Because const shared_ptr&#038; and widget* have the same (nullable) semantics. If you’re being tempted to pass const shared&#038;, widget* doesn’t lose information, whereas switching to widget&#038; can lose information. Sure, use a &#038; if it can’t be null. And re code: All I know of is [code][/code] for code blocks.

@David: Normally you’re right to be very suspicious about claims of no barriers/synchronization. In this case, the key is that because we can guarantee that no action is never taken by another thread because of a refcount increment, it is not really a “publish” operation, so one can apply subtle reasoning and prove that the increment can be memory_order_relaxed; but it’s exceedingly subtle and most experts shouldn’t even try to venture into waters like these. I explain this example toward the end of my “atomic Weapons, Part 2” talk. See pages 50-52 of the slides at http://sdrv.ms/NxDB6u . The talk video is at http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2 . 

@zahirtezcan, Francis: Once you’ve copied the shared_ptr, If you want to move the shared_ptr onward, that’s fine, just std::move it. Constructors aren’t special, this applies to any function. I should mention this to avoid confusion; added, thanks.

@Bret: Alas, std::optional isn’t standard; see that part of Andrzej’s paper at http://isocpp.org/files/papers/N3672.html#optional_ref . I asked Andrzej about it a few days ago and that part wasn’t accepted for C++14 and isn’t likely to be. There is a workaround: std::optional&#060;reference_wrapper&#062;. IMO it’s less clear, less efficient, and more verbose than plain widget*.

@Bret,Arthur: Yes, I intend to eventually write a GotW on parameter passing. Probably not for a couple of months though, if I do get to it. And I may not.]]></description>
		<content:encoded><![CDATA[<p>@mttpd: Maybe I should allude to this, thanks: Because const shared_ptr&amp; and widget* have the same (nullable) semantics. If you’re being tempted to pass const shared&amp;, widget* doesn’t lose information, whereas switching to widget&amp; can lose information. Sure, use a &amp; if it can’t be null. And re code: All I know of is  for code blocks.</p>
<p>@David: Normally you’re right to be very suspicious about claims of no barriers/synchronization. In this case, the key is that because we can guarantee that no action is never taken by another thread because of a refcount increment, it is not really a “publish” operation, so one can apply subtle reasoning and prove that the increment can be memory_order_relaxed; but it’s exceedingly subtle and most experts shouldn’t even try to venture into waters like these. I explain this example toward the end of my “atomic Weapons, Part 2” talk. See pages 50-52 of the slides at <a href="http://sdrv.ms/NxDB6u" rel="nofollow">http://sdrv.ms/NxDB6u</a> . The talk video is at <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2" rel="nofollow">http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2</a> . </p>
<p>@zahirtezcan, Francis: Once you’ve copied the shared_ptr, If you want to move the shared_ptr onward, that’s fine, just std::move it. Constructors aren’t special, this applies to any function. I should mention this to avoid confusion; added, thanks.</p>
<p>@Bret: Alas, std::optional isn’t standard; see that part of Andrzej’s paper at <a href="http://isocpp.org/files/papers/N3672.html#optional_ref" rel="nofollow">http://isocpp.org/files/papers/N3672.html#optional_ref</a> . I asked Andrzej about it a few days ago and that part wasn’t accepted for C++14 and isn’t likely to be. There is a workaround: std::optional&lt;reference_wrapper&gt;. IMO it’s less clear, less efficient, and more verbose than plain widget*.</p>
<p>@Bret,Arthur: Yes, I intend to eventually write a GotW on parameter passing. Probably not for a couple of months though, if I do get to it. And I may not.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Bret Kuhns				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10976</link>
		<dc:creator><![CDATA[Bret Kuhns]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 21:48:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10976</guid>
					<description><![CDATA[@ Róbert Dávid, [code]std::optional&#060;Widget&#038;&#062;[/code] would &quot;own&quot; the reference, not the `Widget` being referenced to. I already use [code]boost::optional&#060;Widget&#038;&#062;[/code] in code to express &quot;non-owning observing reference&quot;.]]></description>
		<content:encoded><![CDATA[<p>@ Róbert Dávid, </p>
<pre class="brush: plain; title: ; notranslate">std::optional&lt;Widget&amp;&gt;</pre>
<p> would &#8220;own&#8221; the reference, not the `Widget` being referenced to. I already use </p>
<pre class="brush: plain; title: ; notranslate">boost::optional&lt;Widget&amp;&gt;</pre>
<p> in code to express &#8220;non-owning observing reference&#8221;.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10973</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 21:06:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10973</guid>
					<description><![CDATA[BTW, it&#039;s better if the function in 3(a) is a pointer constant, not (just) a pointer-to-constant:

f(widget * const);
f(const widget * const);

Doesn&#039;t matter too much (as it&#039;s just a matter of a copy to get a modifiable pointer), but it does document that the function will inspect only the pointed object, and won&#039;t do tricky traversals.]]></description>
		<content:encoded><![CDATA[<p>BTW, it&#8217;s better if the function in 3(a) is a pointer constant, not (just) a pointer-to-constant:</p>
<p>f(widget * const);<br />
f(const widget * const);</p>
<p>Doesn&#8217;t matter too much (as it&#8217;s just a matter of a copy to get a modifiable pointer), but it does document that the function will inspect only the pointed object, and won&#8217;t do tricky traversals.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10972</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 21:01:46 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10972</guid>
					<description><![CDATA[@Francis Rammeloo: If he moves w into the container, then no..]]></description>
		<content:encoded><![CDATA[<p>@Francis Rammeloo: If he moves w into the container, then no..</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10971</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 21:01:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10971</guid>
					<description><![CDATA[@Bret Kuhns: Raw pointers in modern C++ are not good (read: should not be used) for anything else than that!

The problem with optional that it owns the object. The exact idea behind point 3a/b is that the function does not try to manage the lifetime. There you need to have a non-owning reference: You can have reference semantics, use &#038;, or if it can be nullable, use a raw pointer.]]></description>
		<content:encoded><![CDATA[<p>@Bret Kuhns: Raw pointers in modern C++ are not good (read: should not be used) for anything else than that!</p>
<p>The problem with optional that it owns the object. The exact idea behind point 3a/b is that the function does not try to manage the lifetime. There you need to have a non-owning reference: You can have reference semantics, use &amp;, or if it can be nullable, use a raw pointer.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Francis Rammeloo				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10970</link>
		<dc:creator><![CDATA[Francis Rammeloo]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 20:14:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10970</guid>
					<description><![CDATA[Concerning case e:

[code]
void f( shared_ptr&#060;widget&#062; w);
[/code] 

The receiver will likely store the copy in a container. Will this incur the cost of a second copy?]]></description>
		<content:encoded><![CDATA[<p>Concerning case e:</p>
<pre class="brush: plain; title: ; notranslate">
void f( shared_ptr&lt;widget&gt; w);
</pre>
<p>The receiver will likely store the copy in a container. Will this incur the cost of a second copy?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: zenmumbler				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10957</link>
		<dc:creator><![CDATA[zenmumbler]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 17:51:15 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10957</guid>
					<description><![CDATA[That&#039;ll teach me from not refreshing the page before I post a comment. Good thing I&#039;m not the only one thinking happy thoughts about optional.]]></description>
		<content:encoded><![CDATA[<p>That&#8217;ll teach me from not refreshing the page before I post a comment. Good thing I&#8217;m not the only one thinking happy thoughts about optional.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Arthur Langereis				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/#comment-10956</link>
		<dc:creator><![CDATA[Arthur Langereis]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 17:49:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2090#comment-10956</guid>
					<description><![CDATA[Also, given that we&#039;re talking C++14 here:

when you indicate that widget* should be used for optional objects, why not advise to use
std::optional as a parameter instead? In fact, a GotW on optional would be appreciated as I&#039;m sure there are subtleties to it that require a closer look.]]></description>
		<content:encoded><![CDATA[<p>Also, given that we&#8217;re talking C++14 here:</p>
<p>when you indicate that widget* should be used for optional objects, why not advise to use<br />
std::optional as a parameter instead? In fact, a GotW on optional would be appreciated as I&#8217;m sure there are subtleties to it that require a closer look.</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
