<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #92: Auto Variables, Part 1	</title>
	<atom:link href="https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Fish				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11951</link>
		<dc:creator><![CDATA[Fish]]></dc:creator>
		<pubDate>Sun, 14 Jul 2013 18:34:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11951</guid>
					<description><![CDATA[I wonder will the keyword auto be the new bugbear? Making code hard to understand completely without knowing the whole code base and the behavior of the compiler used.

Will auto make it easier for programmers to make mistakes?

Does anyone have any statistics on this yet?]]></description>
		<content:encoded><![CDATA[<p>I wonder will the keyword auto be the new bugbear? Making code hard to understand completely without knowing the whole code base and the behavior of the compiler used.</p>
<p>Will auto make it easier for programmers to make mistakes?</p>
<p>Does anyone have any statistics on this yet?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Voigt (Visual C++ MVP)				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11767</link>
		<dc:creator><![CDATA[Ben Voigt (Visual C++ MVP)]]></dc:creator>
		<pubDate>Mon, 01 Jul 2013 16:07:17 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11767</guid>
					<description><![CDATA[@GregM, in C++03 you&#039;d want to use a type trait to isolate the container-specific type information and leave the main algorithm generic.  But indeed decltype and auto make this much much more convenient.]]></description>
		<content:encoded><![CDATA[<p>@GregM, in C++03 you&#8217;d want to use a type trait to isolate the container-specific type information and leave the main algorithm generic.  But indeed decltype and auto make this much much more convenient.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GregM				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11765</link>
		<dc:creator><![CDATA[GregM]]></dc:creator>
		<pubDate>Mon, 01 Jul 2013 16:02:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11765</guid>
					<description><![CDATA[Ben, that&#039;s a great example of how auto enables you to write much more generic code.  Without auto, or at least decltype, which doesn&#039;t provide any additional information beyond auto, you would have to write that function for each possible T, or at least pass the T down into some other template type such as vector.  The ability to write generic code, of course, does mean that you need to know the types used in the instantiation before the other types that are dependent on it can be determined.]]></description>
		<content:encoded><![CDATA[<p>Ben, that&#8217;s a great example of how auto enables you to write much more generic code.  Without auto, or at least decltype, which doesn&#8217;t provide any additional information beyond auto, you would have to write that function for each possible T, or at least pass the T down into some other template type such as vector.  The ability to write generic code, of course, does mean that you need to know the types used in the instantiation before the other types that are dependent on it can be determined.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11758</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Mon, 01 Jul 2013 01:46:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11758</guid>
					<description><![CDATA[I am not as good as a good IDE, that&#039;s why people like to use IDEs.  It will do the work for you and know the type of &#039;b&#039;.

I can take a guess, though.  With the code you posted, there is not enough information to determine the type.  This is because if the template type &quot;T&quot; is in a namespace then Koenig lookup dicates that the namespace is considered for a method named &quot;begin&quot; and that method&#039;s return type is not shown in this code.

Oh, I think I just figured out your point.  Your point is that the IDE can&#039;t know the type of &quot;b&quot; either because this is templated code.  Why didn&#039;t you just say that?  :)  Good point.]]></description>
		<content:encoded><![CDATA[<p>I am not as good as a good IDE, that&#8217;s why people like to use IDEs.  It will do the work for you and know the type of &#8216;b&#8217;.</p>
<p>I can take a guess, though.  With the code you posted, there is not enough information to determine the type.  This is because if the template type &#8220;T&#8221; is in a namespace then Koenig lookup dicates that the namespace is considered for a method named &#8220;begin&#8221; and that method&#8217;s return type is not shown in this code.</p>
<p>Oh, I think I just figured out your point.  Your point is that the IDE can&#8217;t know the type of &#8220;b&#8221; either because this is templated code.  Why didn&#8217;t you just say that?  :)  Good point.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ben Voigt (Visual C++ MVP)				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11755</link>
		<dc:creator><![CDATA[Ben Voigt (Visual C++ MVP)]]></dc:creator>
		<pubDate>Sun, 30 Jun 2013 20:52:50 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11755</guid>
					<description><![CDATA[@jlehrer: I assume you&#039;re at least as smart as a good IDE.  So what&#039;s the inferred type of b in this code:

[code]
template&#060;typename T&#062;
void frob( const T&#038; t )
{
    using std::begin;
    auto b = begin(t);
    // ...
}
[/code]]]></description>
		<content:encoded><![CDATA[<p>@jlehrer: I assume you&#8217;re at least as smart as a good IDE.  So what&#8217;s the inferred type of b in this code:</p>
<pre class="brush: plain; title: ; notranslate">
template&lt;typename T&gt;
void frob( const T&amp; t )
{
    using std::begin;
    auto b = begin(t);
    // ...
}
</pre>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: auto: il linguaggio non è tutto &#124; Italian C++ Community				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11629</link>
		<dc:creator><![CDATA[auto: il linguaggio non è tutto &#124; Italian C++ Community]]></dc:creator>
		<pubDate>Mon, 24 Jun 2013 09:44:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11629</guid>
					<description><![CDATA[[&#8230;] enfasi di recente è stata posta sul nuovo uso della keyword auto in C++11 (si veda per esempio qui). In sintesi, auto sostituisce un tipo esplicito con una richiesta rivolta al compilatore di [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] enfasi di recente è stata posta sul nuovo uso della keyword auto in C++11 (si veda per esempio qui). In sintesi, auto sostituisce un tipo esplicito con una richiesta rivolta al compilatore di [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: braincode23				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11068</link>
		<dc:creator><![CDATA[braincode23]]></dc:creator>
		<pubDate>Fri, 07 Jun 2013 15:26:51 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11068</guid>
					<description><![CDATA[The oldest functionnality in C++11 is the &quot;auto&quot; and the &quot;decltype&quot;]]></description>
		<content:encoded><![CDATA[<p>The oldest functionnality in C++11 is the &#8220;auto&#8221; and the &#8220;decltype&#8221;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: GonzaloBG				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-11003</link>
		<dc:creator><![CDATA[GonzaloBG]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 08:47:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-11003</guid>
					<description><![CDATA[I think about auto in the same way as I think about TAD, decltype on the other hand...]]></description>
		<content:encoded><![CDATA[<p>I think about auto in the same way as I think about TAD, decltype on the other hand&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: jlehrer				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10996</link>
		<dc:creator><![CDATA[jlehrer]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 04:30:44 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10996</guid>
					<description><![CDATA[@DavidBraun, a good IDE should be able to tell you the type of the auto-declared variable, reducing the reader&#039;s unnecessary work.]]></description>
		<content:encoded><![CDATA[<p>@DavidBraun, a good IDE should be able to tell you the type of the auto-declared variable, reducing the reader&#8217;s unnecessary work.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: David H. Braun				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10995</link>
		<dc:creator><![CDATA[David H. Braun]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 03:47:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10995</guid>
					<description><![CDATA[I&#039;m thrilled having the new &quot;auto&quot; semantic, which is wonderful when a type specification is verbose and complex, and essential when the type is ineffable. However, one thing that is illustrated here is that, except for ineffable types, there is always *some* trade-off being made. In many cases the trade-off is so overwhelmingly positive that the negatives are negligible, however real. The negatives are rooted in loss of visibility of type information.

The examples in problem #3 illustrate the need for clear understanding of typing rules to retrieve information that auto makes less apparent. The more simple the type specification (e.g. a built-in or an ordinary class) the less is gained by using auto and the greater the proportionate significance of diminishment of type visibility. A chained use of auto reduces type visibility even more, necessitating a bit of detective work just to figure out what *it* is one is looking at, and consequently what one can do with &quot;it&quot;. If, as has been advocated, auto should be used pervasively, doesn&#039;t this make *some* code less comprehensible and give unnecessary work to the reader? Isn&#039;t there a cumulative cognitive drain imposed by pervasive &quot;type indirection&quot;?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m thrilled having the new &#8220;auto&#8221; semantic, which is wonderful when a type specification is verbose and complex, and essential when the type is ineffable. However, one thing that is illustrated here is that, except for ineffable types, there is always *some* trade-off being made. In many cases the trade-off is so overwhelmingly positive that the negatives are negligible, however real. The negatives are rooted in loss of visibility of type information.</p>
<p>The examples in problem #3 illustrate the need for clear understanding of typing rules to retrieve information that auto makes less apparent. The more simple the type specification (e.g. a built-in or an ordinary class) the less is gained by using auto and the greater the proportionate significance of diminishment of type visibility. A chained use of auto reduces type visibility even more, necessitating a bit of detective work just to figure out what *it* is one is looking at, and consequently what one can do with &#8220;it&#8221;. If, as has been advocated, auto should be used pervasively, doesn&#8217;t this make *some* code less comprehensible and give unnecessary work to the reader? Isn&#8217;t there a cumulative cognitive drain imposed by pervasive &#8220;type indirection&#8221;?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jeffrey Bosboom				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10993</link>
		<dc:creator><![CDATA[Jeffrey Bosboom]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 02:28:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10993</guid>
					<description><![CDATA[auto comes from B, so it&#039;s old in that way too.]]></description>
		<content:encoded><![CDATA[<p>auto comes from B, so it&#8217;s old in that way too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Brian M				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10984</link>
		<dc:creator><![CDATA[Brian M]]></dc:creator>
		<pubDate>Thu, 06 Jun 2013 00:11:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10984</guid>
					<description><![CDATA[What is the oldest feature, by topic guess its auto, and probably the best and most welcomed feature ever after =.
What does it mean, it means happy coders :)

@Ralph think you are right about Bjarne Stroustroup. It&#039;s always been the &#039;missing&#039; elephant in the room for c++ compared to other languages, and c++ is the language that can really make best use of it.]]></description>
		<content:encoded><![CDATA[<p>What is the oldest feature, by topic guess its auto, and probably the best and most welcomed feature ever after =.<br />
What does it mean, it means happy coders :)</p>
<p>@Ralph think you are right about Bjarne Stroustroup. It&#8217;s always been the &#8216;missing&#8217; elephant in the room for c++ compared to other languages, and c++ is the language that can really make best use of it.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Róbert Dávid				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10974</link>
		<dc:creator><![CDATA[Róbert Dávid]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 21:13:27 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10974</guid>
					<description><![CDATA[1, I would dig around at http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/ to check what was the first proposal after the 03 standard :)]]></description>
		<content:encoded><![CDATA[<p>1, I would dig around at <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/" rel="nofollow">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/</a> to check what was the first proposal after the 03 standard :)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Andy Prowl				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10961</link>
		<dc:creator><![CDATA[Andy Prowl]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 18:16:52 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10961</guid>
					<description><![CDATA[Nice one. It would be interesting to discuss also decltype(auto), which will be available in C++14]]></description>
		<content:encoded><![CDATA[<p>Nice one. It would be interesting to discuss also decltype(auto), which will be available in C++14</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10955</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 17:49:22 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10955</guid>
					<description><![CDATA[auto is the oldest feature... Herb said something like &quot;they&quot; made bjarne take it out. :D]]></description>
		<content:encoded><![CDATA[<p>auto is the oldest feature&#8230; Herb said something like &#8220;they&#8221; made bjarne take it out. :D</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: innochenti				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10948</link>
		<dc:creator><![CDATA[innochenti]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 16:46:56 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10948</guid>
					<description><![CDATA[4:
a: std::initializer_list
b: std::initializer_list]]></description>
		<content:encoded><![CDATA[<p>4:<br />
a: std::initializer_list<br />
b: std::initializer_list</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Alex Sinyakov				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10947</link>
		<dc:creator><![CDATA[Alex Sinyakov]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 16:44:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10947</guid>
					<description><![CDATA[3.
a: int
b: int&#038;
c: const int
d: const int&#038;
e: int
f: int*
g: int
h: int
i: const int*
j: int*
k: const int*]]></description>
		<content:encoded><![CDATA[<p>3.<br />
a: int<br />
b: int&amp;<br />
c: const int<br />
d: const int&amp;<br />
e: int<br />
f: int*<br />
g: int<br />
h: int<br />
i: const int*<br />
j: int*<br />
k: const int*</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10945</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 16:36:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10945</guid>
					<description><![CDATA[1. I believe I heard Bjarne Stroustroup say that the idea of making auto do type inferrence was around back in the late 80s or early 90s, but that AT&#038;T didn&#039;t like it, since it would be too radical. 

2. auto finds the type of an expression and removes top-level const, volatile and references. 

3. 
[code]
int         val = 0;
auto        a   = val;
auto&#038;       b   = val;
const auto  c   = val;
const auto&#038; d   = val;
int&#038;        ir  = val;
auto        e   = ir;
[/code]
Up to here you can replace auto with int and get the correct types. 
[code]
int*        ip  = &#038;val; 
auto        f   = ip;
[/code]
In this case auto is inferred as int*. 
[code]
const int   ci  = val;
auto        g   = ci;
const int&#038;  cir = val;
auto        h   = cir;
[/code]
Again constness and the references will simply be removed and int remains. 
[code]
const int*  cip = &#038;val;
auto        i   = cip;
[/code]
Now this will be infered to const int *, since it&#039;s a pointer to a constant int and not a constant pointer to a mutable int. The const is not on the top level and hence will remain. 
[code]
int* const  ipc = &#038;val;
auto        j   = ipc;
[/code]
The j variable will be int*. 
[code]
const int* const cipc = &#038;val;
auto             k    = cipc;
[/code]
Again this will be a const int *.

4.
[code]
int val = 0;
auto a { val };
auto b = { val };
[/code]
This one I&#039;m not 100% sure about, but I believe that a will be an int and b will be an std::initializer_list.]]></description>
		<content:encoded><![CDATA[<p>1. I believe I heard Bjarne Stroustroup say that the idea of making auto do type inferrence was around back in the late 80s or early 90s, but that AT&amp;T didn&#8217;t like it, since it would be too radical. </p>
<p>2. auto finds the type of an expression and removes top-level const, volatile and references. </p>
<p>3. </p>
<pre class="brush: plain; title: ; notranslate">
int         val = 0;
auto        a   = val;
auto&amp;       b   = val;
const auto  c   = val;
const auto&amp; d   = val;
int&amp;        ir  = val;
auto        e   = ir;
</pre>
<p>Up to here you can replace auto with int and get the correct types. </p>
<pre class="brush: plain; title: ; notranslate">
int*        ip  = &amp;val; 
auto        f   = ip;
</pre>
<p>In this case auto is inferred as int*. </p>
<pre class="brush: plain; title: ; notranslate">
const int   ci  = val;
auto        g   = ci;
const int&amp;  cir = val;
auto        h   = cir;
</pre>
<p>Again constness and the references will simply be removed and int remains. </p>
<pre class="brush: plain; title: ; notranslate">
const int*  cip = &amp;val;
auto        i   = cip;
</pre>
<p>Now this will be infered to const int *, since it&#8217;s a pointer to a constant int and not a constant pointer to a mutable int. The const is not on the top level and hence will remain. </p>
<pre class="brush: plain; title: ; notranslate">
int* const  ipc = &amp;val;
auto        j   = ipc;
</pre>
<p>The j variable will be int*. </p>
<pre class="brush: plain; title: ; notranslate">
const int* const cipc = &amp;val;
auto             k    = cipc;
</pre>
<p>Again this will be a const int *.</p>
<p>4.</p>
<pre class="brush: plain; title: ; notranslate">
int val = 0;
auto a { val };
auto b = { val };
</pre>
<p>This one I&#8217;m not 100% sure about, but I believe that a will be an int and b will be an std::initializer_list.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Nils (@NightLifeLover)				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10941</link>
		<dc:creator><![CDATA[Nils (@NightLifeLover)]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 16:23:24 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10941</guid>
					<description><![CDATA[Humm the first question seems interesting, but where should I know from. My guess: concepts, since templates do not seem to &quot;fit-in&quot; with static type checking. Or maybe also lambdas if you go back to lambda calculus..]]></description>
		<content:encoded><![CDATA[<p>Humm the first question seems interesting, but where should I know from. My guess: concepts, since templates do not seem to &#8220;fit-in&#8221; with static type checking. Or maybe also lambdas if you go back to lambda calculus..</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: j				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10940</link>
		<dc:creator><![CDATA[j]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 16:11:12 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10940</guid>
					<description><![CDATA[1. Type deduction, it&#039;s been around since templates only now can it be use intuitively.]]></description>
		<content:encoded><![CDATA[<p>1. Type deduction, it&#8217;s been around since templates only now can it be use intuitively.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Sky				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10937</link>
		<dc:creator><![CDATA[Sky]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 15:55:23 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10937</guid>
					<description><![CDATA[Okay... here are my guesses:

1. auto?

2. auto declares a variable on the stack of type that is deduced by the compiler.

3.
a: int
b: int&#038;
c: const int
d: const int&#038;
e: int&#038;
f: int*
g: int
h: const int&#038;
i: const int*
j: int*
k: const int*

4:
a: int
b: std::initializer_list

Now to see if I&#039;m right...]]></description>
		<content:encoded><![CDATA[<p>Okay&#8230; here are my guesses:</p>
<p>1. auto?</p>
<p>2. auto declares a variable on the stack of type that is deduced by the compiler.</p>
<p>3.<br />
a: int<br />
b: int&amp;<br />
c: const int<br />
d: const int&amp;<br />
e: int&amp;<br />
f: int*<br />
g: int<br />
h: const int&amp;<br />
i: const int*<br />
j: int*<br />
k: const int*</p>
<p>4:<br />
a: int<br />
b: std::initializer_list</p>
<p>Now to see if I&#8217;m right&#8230;</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jason S. Moore				</title>
				<link>https://herbsutter.com/2013/06/05/gotw-92-auto-variables-part-1/#comment-10932</link>
		<dc:creator><![CDATA[Jason S. Moore]]></dc:creator>
		<pubDate>Wed, 05 Jun 2013 15:07:20 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2100#comment-10932</guid>
					<description><![CDATA[&#039;C++ auto and decltype Explained&#039; by Thomas Becker:
http://thbecker.net/articles/auto_and_decltype/section_01.html]]></description>
		<content:encoded><![CDATA[<p>&#8216;C++ auto and decltype Explained&#8217; by Thomas Becker:<br />
<a href="http://thbecker.net/articles/auto_and_decltype/section_01.html" rel="nofollow">http://thbecker.net/articles/auto_and_decltype/section_01.html</a></p>
]]></content:encoded>
					</item>
			</channel>
</rss>
