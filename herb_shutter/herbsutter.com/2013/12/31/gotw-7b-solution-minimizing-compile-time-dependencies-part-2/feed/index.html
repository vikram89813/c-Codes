<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #7b Solution: Minimizing Compile-Time Dependencies, Part 2	</title>
	<atom:link href="https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Rob Stewart				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14112</link>
		<dc:creator><![CDATA[Rob Stewart]]></dc:creator>
		<pubDate>Tue, 14 Jan 2014 13:04:08 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14112</guid>
					<description><![CDATA[@mttpd

I regularly do what you argue against. I wish there was a file-scope using directive so I could make the header consistent with the implementation file. I do find the need to be explicit, in headers, frustrating, because I&#039;d much rather use shorter names when there&#039;s no ambiguity.

I use typedefs in headers (mostly in class definitions), namespace aliases, and using declarations along with using directives, so you&#039;d probably dislike my code as a result. Despite all of that, however, I don&#039;t see that this approach increases complexity. I&#039;ll grant that one must examine context to know, with certainly, which vector some code means when it isn&#039;t scope resolved, and I do find myself forgetting to switch to fully qualified names in headers when I copy a type from the implementation file. Nevertheless, I&#039;d hate to encourage or, worse still, require full qualification in all or most contexts. After all, namespaces are given long names, in many cases, specifically to reduce conflicts and because there are tools to obviate the line noise.

Speaking of line noise, you noted that code is read more than written, so one shouldn&#039;t be concerned with typing extra characters. That isn&#039;t my reason for avoiding the fully qualified names. The extra characters on a line are usually not needed to increase code clarity. Indeed, I find that they normally detract from readability. You invoked Boost as disclaiming Herb&#039;s assertion that &quot;people just won’t put up with&quot; the long names. The problem is that Boost must use fully qualified names in its headers, but in no way does that impose the same on Boost users. (I use many Boost libraries and use all of the tools at my disposal to shorten names when possible.)]]></description>
		<content:encoded><![CDATA[<p>@mttpd</p>
<p>I regularly do what you argue against. I wish there was a file-scope using directive so I could make the header consistent with the implementation file. I do find the need to be explicit, in headers, frustrating, because I&#8217;d much rather use shorter names when there&#8217;s no ambiguity.</p>
<p>I use typedefs in headers (mostly in class definitions), namespace aliases, and using declarations along with using directives, so you&#8217;d probably dislike my code as a result. Despite all of that, however, I don&#8217;t see that this approach increases complexity. I&#8217;ll grant that one must examine context to know, with certainly, which vector some code means when it isn&#8217;t scope resolved, and I do find myself forgetting to switch to fully qualified names in headers when I copy a type from the implementation file. Nevertheless, I&#8217;d hate to encourage or, worse still, require full qualification in all or most contexts. After all, namespaces are given long names, in many cases, specifically to reduce conflicts and because there are tools to obviate the line noise.</p>
<p>Speaking of line noise, you noted that code is read more than written, so one shouldn&#8217;t be concerned with typing extra characters. That isn&#8217;t my reason for avoiding the fully qualified names. The extra characters on a line are usually not needed to increase code clarity. Indeed, I find that they normally detract from readability. You invoked Boost as disclaiming Herb&#8217;s assertion that &#8220;people just won’t put up with&#8221; the long names. The problem is that Boost must use fully qualified names in its headers, but in no way does that impose the same on Boost users. (I use many Boost libraries and use all of the tools at my disposal to shorten names when possible.)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Guru of the week 7 &#124; C++, Qt, OpenGL, CUDA				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14056</link>
		<dc:creator><![CDATA[Guru of the week 7 &#124; C++, Qt, OpenGL, CUDA]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 17:21:01 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14056</guid>
					<description><![CDATA[[&#8230;] GotW #7b Solution: Minimizing Compile-Time Dependencies, Part 2 [&#8230;]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] GotW #7b Solution: Minimizing Compile-Time Dependencies, Part 2 [&#8230;]</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14038</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 11:54:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14038</guid>
					<description><![CDATA[@mttpd In most of my production code I don&#039;t use &lt;code&gt;using namespace&lt;/code&gt;. However, sometimes I do and I find my code more readable because of it. Examples are &lt;code&gt;using namespace std::chrono&lt;/code&gt; or some Boost namespaces which are tedious to spell out all the time. Sometimes it is idiomatic to write 
[code]
using namespace std;
swap( x, y );
[/code]
or similar code as you already noted yourself. Name clashes can be avoided because it&#039;s YOUR code and you can change it if it becomes necessary. I don&#039;t believe it makes sense to produce another guideline to avoid &lt;code&gt;using namespace&lt;/code&gt; in cpp files. Sometimes it is better to do so, sometimes it is not. Use your programmer gut feeling and don&#039;t sweat the small stuff. After all it&#039;s a matter of taste.]]></description>
		<content:encoded><![CDATA[<p>@mttpd In most of my production code I don&#8217;t use <code>using namespace</code>. However, sometimes I do and I find my code more readable because of it. Examples are <code>using namespace std::chrono</code> or some Boost namespaces which are tedious to spell out all the time. Sometimes it is idiomatic to write </p>
<pre class="brush: plain; title: ; notranslate">
using namespace std;
swap( x, y );
</pre>
<p>or similar code as you already noted yourself. Name clashes can be avoided because it&#8217;s YOUR code and you can change it if it becomes necessary. I don&#8217;t believe it makes sense to produce another guideline to avoid <code>using namespace</code> in cpp files. Sometimes it is better to do so, sometimes it is not. Use your programmer gut feeling and don&#8217;t sweat the small stuff. After all it&#8217;s a matter of taste.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mttpd				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14024</link>
		<dc:creator><![CDATA[mttpd]]></dc:creator>
		<pubDate>Sat, 04 Jan 2014 09:30:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14024</guid>
					<description><![CDATA[@Herb: regarding the using-directive -- unless we&#039;re talking about strictly scoped uses (e.g., within a function scope; but not within (still dangerous) namespace level), with time I&#039;m becoming less and less inclined to agree with this. If anything, nowadays I find myself more inclined toward using-declaration -- and even that only under extremely limited, specific circumstances (i.e., strictly for the idiomatic ADL pull-in technique: as in std::swap, std::begin, std::end, etc.).

I&#039;m talking here not solely from the legalistic perspective (&quot;what is legal&quot; / allowed by the standard -- sure, no problems here), but also from the good software engineering principles perspective (what is right/maintainable/extensible -- and I do see some problems here; let me know what you think about these).

For instance, we all agree that it has no place in the header files. However, if we do, then this itself has implications that (IMHO) go further:

1. Readability -- this may vary depending on a domain, etc., I&#039;m a heavy user of Boost libraries, which use the same naming convention as the C++ Standard Library. In practice, symbol named &quot;vector&quot; may correspond to around dozen different names (and it&#039;s not unusual at all to use standard C++ vector, Boost.MPL vector and, say, Boost.uBLAS vector, in one codebase). A single misplaced using-directive will make name clashes unavoidable and not always trivial to track down (diagnostic messages for this can be &quot;funny&quot; at times).

Yes, I&#039;m very careful about coming up with distinct, maximally self-explanatory variable (and typedefs!) names (some would perhaps say to the point of being obsessive about it), yes, the context helps, no, I don&#039;t think that&#039;s enough (especially given that programming is primarily a social activity and we have to take into account that other team members coming from different domains may find different contexts &quot;obvious&quot; -- and other &quot;arcane&quot;).

If taken to extreme, this may imply having to define (sub)library-specific prefixed names, as in pre-namespaces Qt (e.g., QVector) -- isn&#039;t that a problem that namespaces are precisely aiming to solve?

2. Complexity -- effectively, encouraging using-directive for implementation files amounts to encouraging to have two different naming conventions for cpp and hpp/ipp files -- multiple naming conventions raise overall coding style complexity, while one naming convention brings the advantage of a consistent, uniform style that can be used throughout the entire team/organization (independently of member/team-specific domains).

3. Maintenance &#038; refactoring -- again, maintaining different naming conventions for cpp and hpp/ipp files means having to change (rename) the unqualified names each time we&#039;re moving code from implementation (or specific application) to the interface (or general library); this makes the code less refactoring-friendly (again, YMMV, but another reason I may be biased here is that I routinely see &quot;write a reusable library&quot; as the preferred way to solve programming problems; anything that distracts from this ultimately does more harm than good).

I do recall Item 59 stating &quot;which would be onerous, and frankly people just won&#039;t put up with it.&quot; However, it seems that (mostly) header-only libraries, like Boost, have empirically demonstrated that people do put up with it after all. Yes, it is a few extra keystrokes, but personally I find the using-directive readability, complexity, maintenance, and refactoring costs to be more onerous. Given that most code is read/maintained more often that it&#039;s written from the scratch, isn&#039;t optimizing the no. of keystrokes a classic case of premature optimization (on the suboptimal metric at that)?

Let me know if I&#039;m wrong, perhaps I am missing something?]]></description>
		<content:encoded><![CDATA[<p>@Herb: regarding the using-directive &#8212; unless we&#8217;re talking about strictly scoped uses (e.g., within a function scope; but not within (still dangerous) namespace level), with time I&#8217;m becoming less and less inclined to agree with this. If anything, nowadays I find myself more inclined toward using-declaration &#8212; and even that only under extremely limited, specific circumstances (i.e., strictly for the idiomatic ADL pull-in technique: as in std::swap, std::begin, std::end, etc.).</p>
<p>I&#8217;m talking here not solely from the legalistic perspective (&#8220;what is legal&#8221; / allowed by the standard &#8212; sure, no problems here), but also from the good software engineering principles perspective (what is right/maintainable/extensible &#8212; and I do see some problems here; let me know what you think about these).</p>
<p>For instance, we all agree that it has no place in the header files. However, if we do, then this itself has implications that (IMHO) go further:</p>
<p>1. Readability &#8212; this may vary depending on a domain, etc., I&#8217;m a heavy user of Boost libraries, which use the same naming convention as the C++ Standard Library. In practice, symbol named &#8220;vector&#8221; may correspond to around dozen different names (and it&#8217;s not unusual at all to use standard C++ vector, Boost.MPL vector and, say, Boost.uBLAS vector, in one codebase). A single misplaced using-directive will make name clashes unavoidable and not always trivial to track down (diagnostic messages for this can be &#8220;funny&#8221; at times).</p>
<p>Yes, I&#8217;m very careful about coming up with distinct, maximally self-explanatory variable (and typedefs!) names (some would perhaps say to the point of being obsessive about it), yes, the context helps, no, I don&#8217;t think that&#8217;s enough (especially given that programming is primarily a social activity and we have to take into account that other team members coming from different domains may find different contexts &#8220;obvious&#8221; &#8212; and other &#8220;arcane&#8221;).</p>
<p>If taken to extreme, this may imply having to define (sub)library-specific prefixed names, as in pre-namespaces Qt (e.g., QVector) &#8212; isn&#8217;t that a problem that namespaces are precisely aiming to solve?</p>
<p>2. Complexity &#8212; effectively, encouraging using-directive for implementation files amounts to encouraging to have two different naming conventions for cpp and hpp/ipp files &#8212; multiple naming conventions raise overall coding style complexity, while one naming convention brings the advantage of a consistent, uniform style that can be used throughout the entire team/organization (independently of member/team-specific domains).</p>
<p>3. Maintenance &amp; refactoring &#8212; again, maintaining different naming conventions for cpp and hpp/ipp files means having to change (rename) the unqualified names each time we&#8217;re moving code from implementation (or specific application) to the interface (or general library); this makes the code less refactoring-friendly (again, YMMV, but another reason I may be biased here is that I routinely see &#8220;write a reusable library&#8221; as the preferred way to solve programming problems; anything that distracts from this ultimately does more harm than good).</p>
<p>I do recall Item 59 stating &#8220;which would be onerous, and frankly people just won&#8217;t put up with it.&#8221; However, it seems that (mostly) header-only libraries, like Boost, have empirically demonstrated that people do put up with it after all. Yes, it is a few extra keystrokes, but personally I find the using-directive readability, complexity, maintenance, and refactoring costs to be more onerous. Given that most code is read/maintained more often that it&#8217;s written from the scratch, isn&#8217;t optimizing the no. of keystrokes a classic case of premature optimization (on the suboptimal metric at that)?</p>
<p>Let me know if I&#8217;m wrong, perhaps I am missing something?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14010</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Thu, 02 Jan 2014 17:53:49 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14010</guid>
					<description><![CDATA[@Mike: For polymorphic classes your approach is an alternative. But for value classes (types being copyable and movable) a base class could introduce slicing problems. Instead of copying you would have to clone your value type. Hence normal copy semantics are impossible because of this implementation detail. The idea is to preserve the semantics of the class and only touch the internals in the private section of the class. Even in the case of a class hierarchy pimpling is sometimes preferred since it&#039;s less code to write. Think about it: You have to create an interface class and mirror the functions there in the implementation class. This is not necessary when pimpling and only those functions are virtual which really need to be virtual giving the reader of your code an idea of intent.  He or she can then know which functions may be customized.]]></description>
		<content:encoded><![CDATA[<p>@Mike: For polymorphic classes your approach is an alternative. But for value classes (types being copyable and movable) a base class could introduce slicing problems. Instead of copying you would have to clone your value type. Hence normal copy semantics are impossible because of this implementation detail. The idea is to preserve the semantics of the class and only touch the internals in the private section of the class. Even in the case of a class hierarchy pimpling is sometimes preferred since it&#8217;s less code to write. Think about it: You have to create an interface class and mirror the functions there in the implementation class. This is not necessary when pimpling and only those functions are virtual which really need to be virtual giving the reader of your code an idea of intent.  He or she can then know which functions may be customized.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Mike Capp				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14008</link>
		<dc:creator><![CDATA[Mike Capp]]></dc:creator>
		<pubDate>Thu, 02 Jan 2014 16:12:26 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14008</guid>
					<description><![CDATA[Given that pimpl introduces an allocation anyway, I&#039;ve never really seen what benefits it offers that couldn&#039;t be provided more cleanly and flexibly by a factory returning a unique_ptr to a (probably abstract) base class. Pimpl trades vtable indirection for data-access indirection, which isn&#039;t an obvious win, and makes subclassing a good deal uglier since you need to subclass both handle and body types.

Could you expand on where you see the relative merits here?]]></description>
		<content:encoded><![CDATA[<p>Given that pimpl introduces an allocation anyway, I&#8217;ve never really seen what benefits it offers that couldn&#8217;t be provided more cleanly and flexibly by a factory returning a unique_ptr to a (probably abstract) base class. Pimpl trades vtable indirection for data-access indirection, which isn&#8217;t an obvious win, and makes subclassing a good deal uglier since you need to subclass both handle and body types.</p>
<p>Could you expand on where you see the relative merits here?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-14000</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Thu, 02 Jan 2014 07:52:45 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-14000</guid>
					<description><![CDATA[@herb:
&quot;Note that not only does the move-only unique_ptr member disable compiler-generated copying by default, but the explicitly user-declared destructor also disables compiler-generated move by default. Thanks for the note!&quot;
I had no idea about this, if you dont consider it way tooo basic for gotw maybe you could write about that. also since it is 2014 if i could have one wish it is gotw on emplace_back vs push_back(for vector, i guess same conclusions apply to the other containers)]]></description>
		<content:encoded><![CDATA[<p>@herb:<br />
&#8220;Note that not only does the move-only unique_ptr member disable compiler-generated copying by default, but the explicitly user-declared destructor also disables compiler-generated move by default. Thanks for the note!&#8221;<br />
I had no idea about this, if you dont consider it way tooo basic for gotw maybe you could write about that. also since it is 2014 if i could have one wish it is gotw on emplace_back vs push_back(for vector, i guess same conclusions apply to the other containers)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13995</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 23:12:34 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13995</guid>
					<description><![CDATA[@Marcelo: using namespace std; is perfectly fine (and should be encouraged) in an implementation file after all #includes. See C++ Coding Standards Item 59: &quot;Don&#039;t write namespace usings in a header file or before an #include.&quot;

However, you&#039;re right that saying &quot;std::&quot; in front of the list member is now redundant. Removed, with credit. Thanks!]]></description>
		<content:encoded><![CDATA[<p>@Marcelo: using namespace std; is perfectly fine (and should be encouraged) in an implementation file after all #includes. See C++ Coding Standards Item 59: &#8220;Don&#8217;t write namespace usings in a header file or before an #include.&#8221;</p>
<p>However, you&#8217;re right that saying &#8220;std::&#8221; in front of the list member is now redundant. Removed, with credit. Thanks!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Marcelo Pinto				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13994</link>
		<dc:creator><![CDATA[Marcelo Pinto]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 22:29:59 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13994</guid>
					<description><![CDATA[Shouldn&#039;t the standard headers come after our own header to avoid hiding some including errors in our own headers?

And in the last code snippet you have &quot;using namespace std&quot; (that I don&#039;t like very much) and then you have &quot;std::list...&quot;. Don&#039;t you think you should avoid &quot;using namespace std&quot; in such a short code?

Best regards]]></description>
		<content:encoded><![CDATA[<p>Shouldn&#8217;t the standard headers come after our own header to avoid hiding some including errors in our own headers?</p>
<p>And in the last code snippet you have &#8220;using namespace std&#8221; (that I don&#8217;t like very much) and then you have &#8220;std::list&#8230;&#8221;. Don&#8217;t you think you should avoid &#8220;using namespace std&#8221; in such a short code?</p>
<p>Best regards</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13991</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 22:08:07 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13991</guid>
					<description><![CDATA[I just looked at the next question and figured out that it asks for what I already noticed. Sorry, I should have read on first. But here&#039;s one more note: If both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; inherit virtually from a common base (directly or indirectly) then the above change might not be as trivial. However, this is highly unlikely since &lt;code&gt;B&lt;/code&gt; doesn&#039;t have any virtual functions.]]></description>
		<content:encoded><![CDATA[<p>I just looked at the next question and figured out that it asks for what I already noticed. Sorry, I should have read on first. But here&#8217;s one more note: If both <code>A</code> and <code>B</code> inherit virtually from a common base (directly or indirectly) then the above change might not be as trivial. However, this is highly unlikely since <code>B</code> doesn&#8217;t have any virtual functions.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Ralph Tandetzky				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13990</link>
		<dc:creator><![CDATA[Ralph Tandetzky]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 21:51:19 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13990</guid>
					<description><![CDATA[You can still remove one more header which is &lt;code&gt; b.h &lt;/code&gt;. Just let the pimpl class &lt;code&gt; X::impl &lt;/code&gt; inherit publicly from &lt;code&gt; B &lt;/code&gt; and remove &lt;code&gt; B &lt;/code&gt; as a private base of &lt;code&gt; X &lt;/code&gt;. This would even work perfectly fine, if &lt;code&gt; B &lt;/code&gt; had virtual functions which is excluded in the exercise.]]></description>
		<content:encoded><![CDATA[<p>You can still remove one more header which is <code> b.h </code>. Just let the pimpl class <code> X::impl </code> inherit publicly from <code> B </code> and remove <code> B </code> as a private base of <code> X </code>. This would even work perfectly fine, if <code> B </code> had virtual functions which is excluded in the exercise.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13987</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 15:20:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13987</guid>
					<description><![CDATA[@Motti: I did mention earlier in the article that &quot;If copy and move are appropriate for your type, write those four operations to perform a deep copy that clones the impl state.&quot; but I agree it bears repeating. I&#039;ve added an extra paragraph and an extra comment line in the code. Note that not only does the move-only unique_ptr member disable compiler-generated copying by default, but the explicitly user-declared destructor also disables compiler-generated move by default. Thanks for the note!]]></description>
		<content:encoded><![CDATA[<p>@Motti: I did mention earlier in the article that &#8220;If copy and move are appropriate for your type, write those four operations to perform a deep copy that clones the impl state.&#8221; but I agree it bears repeating. I&#8217;ve added an extra paragraph and an extra comment line in the code. Note that not only does the move-only unique_ptr member disable compiler-generated copying by default, but the explicitly user-declared destructor also disables compiler-generated move by default. Thanks for the note!</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Motti Lanzkron				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13984</link>
		<dc:creator><![CDATA[Motti Lanzkron]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 12:10:29 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13984</guid>
					<description><![CDATA[In the requirements for #3 you say:
* any current code that already uses X should not be affected beyond requiring a simple recompilation.

However introducing a &lt;code&gt;unique_ptr&lt;/code&gt; into &lt;code&gt;X&lt;/code&gt; means that &lt;code&gt;X&lt;/code&gt; no longer has value semantics, its copy constructor (as well as &lt;code&gt;operator=&lt;/code&gt;) are disabled, this may affect &lt;i&gt;current code that uses X&lt;/i&gt;]]></description>
		<content:encoded><![CDATA[<p>In the requirements for #3 you say:<br />
* any current code that already uses X should not be affected beyond requiring a simple recompilation.</p>
<p>However introducing a <code>unique_ptr</code> into <code>X</code> means that <code>X</code> no longer has value semantics, its copy constructor (as well as <code>operator=</code>) are disabled, this may affect <i>current code that uses X</i></p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: nosenseetal				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7b-solution-minimizing-compile-time-dependencies-part-2/#comment-13982</link>
		<dc:creator><![CDATA[nosenseetal]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 05:27:06 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2384#comment-13982</guid>
					<description><![CDATA[Herb I guess you dont take wishlist requirements since you are not Santa, but it would be nice if VC++ compiler would support pimpl switch so people dont need to rewrite their code for daily hackery :)  but still get the productivity boost and still get the perf in release mode without pimpling :) .]]></description>
		<content:encoded><![CDATA[<p>Herb I guess you dont take wishlist requirements since you are not Santa, but it would be nice if VC++ compiler would support pimpl switch so people dont need to rewrite their code for daily hackery :)  but still get the productivity boost and still get the perf in release mode without pimpling :) .</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
