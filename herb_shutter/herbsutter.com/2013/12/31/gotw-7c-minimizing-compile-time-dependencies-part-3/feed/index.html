<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:media="http://search.yahoo.com/mrss/"
	
	>
<channel>
	<title>
	Comments on: GotW #7c: Minimizing Compile-Time Dependencies, Part 3	</title>
	<atom:link href="https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/feed/" rel="self" type="application/rss+xml" />
	<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/</link>
	<description>Herb Sutter on software development</description>
	<lastBuildDate>
	Mon, 19 Nov 2018 23:08:15 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>http://wordpress.com/</generator>
			<item>
				<title>
				By: Klimax				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14037</link>
		<dc:creator><![CDATA[Klimax]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 11:46:47 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14037</guid>
					<description><![CDATA[@Roman M:
Timing can be enabled by setting:
Tools-&#062;Options-&#062;Projects and Solutions-&#062;VC++ Project Settings-&#062;Build Timing
(IIRC at least since VS 2010, but might be even earlier)

Output looks like
[code]
12&#062;Project Performance Summary:
12&#062;    326932 ms  C:\Dan\Klimax-tools\tools\net\EmuleMorphXT\MorphXT\emule100.vcxproj   1 calls
12&#062;              326932 ms  Rebuild                                    1 calls

12&#062;Target Performance Summary:
12&#062;        0 ms  AfterRebuild                               1 calls
12&#062;        0 ms  ResolveReferences                          1 calls
12&#062;        0 ms  SelectClCompile                            1 calls
12&#062;        0 ms  _CheckForCompileOutputs                    1 calls
12&#062;        0 ms  GetResolvedWinMD                           1 calls
12&#062;        0 ms  CleanPublishFolder                         1 calls
12&#062;        0 ms  CleanReferencedProjects                    1 calls
12&#062;        0 ms  _PrepareForBuild                           1 calls
12&#062;        0 ms  _Midl                                      1 calls
12&#062;        0 ms  BuildCompile                               1 calls
12&#062;        0 ms  ComputeManifestGeneratedLinkerInputs       1 calls
12&#062;        0 ms  BeforeClean                                1 calls
12&#062;        0 ms  CreateCustomManifestResourceNames          1 calls
12&#062;        0 ms  AfterCppClean                              1 calls
12&#062;        0 ms  BeforeLink                                 1 calls
12&#062;        0 ms  AfterBuild                                 1 calls
12&#062;        0 ms  AfterBuildCompileEvent                     1 calls
12&#062;        0 ms  _BuildLinkAction                           1 calls
12&#062;        0 ms  BeforeResourceCompile                      1 calls
12&#062;        0 ms  AfterMidl                                  1 calls
12&#062;        0 ms  PreLinkEvent                               1 calls
12&#062;        0 ms  _ClCompile                                 1 calls
12&#062;        0 ms  AfterClean                                 1 calls
12&#062;        0 ms  SelectCustomBuild                          1 calls
12&#062;        0 ms  AfterClCompile                             1 calls
12&#062;        0 ms  _CopySourceItemsToOutputDirectory          1 calls
12&#062;        0 ms  AfterResourceCompile                       1 calls
12&#062;        0 ms  ComputeCustomBuildOutput                   1 calls
12&#062;        0 ms  _Xsd                                       1 calls
12&#062;        0 ms  AfterBuildGenerateSources                  1 calls
12&#062;        0 ms  Rebuild                                    1 calls
12&#062;        0 ms  MakeDirsForBscMake                         1 calls
12&#062;        0 ms  BeforeRebuild                              1 calls
12&#062;        0 ms  MakeDirsForResourceCompile                 1 calls
12&#062;        0 ms  _ResourceCompile                           1 calls
12&#062;        0 ms  ComputeLinkInputsFromProject               1 calls
12&#062;        0 ms  BeforeCppClean                             1 calls
12&#062;        0 ms  _Link                                      1 calls
12&#062;        0 ms  BuildLinkTraverse                          1 calls
12&#062;        0 ms  PrepareForRun                              1 calls
12&#062;        0 ms  _XdcMake                                   1 calls
12&#062;        0 ms  CreateSatelliteAssemblies                  1 calls
12&#062;        0 ms  MakeDirsForManifest                        1 calls
12&#062;        0 ms  SelectResourceCompile                      1 calls
12&#062;        0 ms  ExpandSDKReferences                        1 calls
12&#062;        0 ms  BuildCompileTraverse                       1 calls
12&#062;        0 ms  _GenerateSatelliteAssemblyInputs           1 calls
12&#062;        0 ms  _Deploy                                    1 calls
12&#062;        0 ms  ComputeMIDLGeneratedCompileInputs          1 calls
12&#062;        0 ms  CppClean                                   1 calls
12&#062;        0 ms  PrepareResourceNames                       1 calls
12&#062;        0 ms  AfterBuildGenerateSourcesEvent             1 calls
12&#062;        0 ms  _SplitProjectReferencesByFileExistence     1 calls
12&#062;        0 ms  BeforeClCompile                            1 calls
12&#062;        0 ms  _SelectedFiles                             1 calls
12&#062;        0 ms  AfterResolveReferences                     1 calls
12&#062;        0 ms  BeforeResolveReferences                    1 calls
12&#062;        0 ms  AfterLink                                  1 calls
12&#062;        0 ms  _ALink                                     1 calls
12&#062;        0 ms  PreBuildEvent                              1 calls
12&#062;        0 ms  MakeDirsForMidl                            1 calls
12&#062;        0 ms  _BscMake                                   1 calls
12&#062;        0 ms  ResolveSDKReferences                       1 calls
12&#062;        0 ms  _BuildGenerateSourcesAction                1 calls
12&#062;        0 ms  _Appverifier                               1 calls
12&#062;        0 ms  ComputeMASMOutput                          1 calls
12&#062;        0 ms  Clean                                      1 calls
12&#062;        0 ms  ComputeRCGeneratedLinkInputs               1 calls
12&#062;        0 ms  BuildGenerateSourcesTraverse               1 calls
12&#062;        0 ms  MakeDirsForXdcMake                         1 calls
12&#062;        0 ms  Build                                      1 calls
12&#062;        0 ms  BeforeBuildGenerateSources                 1 calls
12&#062;        0 ms  ResolvedXDCMake                            1 calls
12&#062;        0 ms  _PrepareForRebuild                         1 calls
12&#062;        0 ms  GetInstalledSDKLocations                   1 calls
12&#062;        0 ms  _BuildCompileAction                        1 calls
12&#062;        0 ms  BuildLink                                  1 calls
12&#062;        0 ms  ComputeLegacyManifestEmbedding             1 calls
12&#062;        0 ms  BuildGenerateSources                       1 calls
12&#062;        1 ms  PGInstrumentedClean                        1 calls
12&#062;        1 ms  ResolveAssemblyReferences                  1 calls
12&#062;        1 ms  CoreClean                                  1 calls
12&#062;        1 ms  ComputeLinkSwitches                        1 calls
12&#062;        1 ms  FinalizeBuildStatus                        1 calls
12&#062;        1 ms  CopyFilesToOutputDirectory                 1 calls
12&#062;        1 ms  AssignProjectConfiguration                 1 calls
12&#062;        1 ms  ComputeRCOutputs                           1 calls
12&#062;        1 ms  ResolveProjectReferences                   1 calls
12&#062;        1 ms  ComputeReferenceCLInput                    1 calls
12&#062;        1 ms  ComputeCLCompileGeneratedSbrFiles          1 calls
12&#062;        1 ms  GetCopyToOutputDirectoryXamlAppDefs        1 calls
12&#062;        1 ms  _PrepareForClean                           1 calls
12&#062;        1 ms  _CheckForInvalidConfigurationAndPlatform   1 calls
12&#062;        1 ms  ComputeManifestInputsTargets               1 calls
12&#062;        1 ms  GetFrameworkPaths                          1 calls
12&#062;        1 ms  GetReferenceAssemblyPaths                  1 calls
12&#062;        1 ms  GetCopyToOutputDirectoryItems              1 calls
12&#062;        1 ms  PlatformPrepareForBuild                    1 calls
12&#062;        1 ms  SplitResourcesByCulture                    1 calls
12&#062;        2 ms  _PrepareForReferenceResolution             1 calls
12&#062;        2 ms  MakeDirsForCl                              1 calls
12&#062;        2 ms  ComputeCLInputPDBName                      1 calls
12&#062;        2 ms  DoLinkOutputFilesMatch                     1 calls
12&#062;        2 ms  MakeDirsForLink                            1 calls
12&#062;        3 ms  ComputeCLGeneratedLinkInputs               1 calls
12&#062;        3 ms  ComputeCLCompileGeneratedXDCFiles          1 calls
12&#062;        3 ms  CheckInstalledVCLibsIPP                    1 calls
12&#062;        3 ms  SetBuildDefaultEnvironmentVariables        1 calls
12&#062;        3 ms  InitializeBuildStatus                      1 calls
12&#062;        4 ms  ComputeLinkImportLibraryOutputsForClean    1 calls
12&#062;        5 ms  RegisterOutput                             1 calls
12&#062;        5 ms  AssignTargetPaths                          1 calls
12&#062;        8 ms  SetCABuildNativeEnvironmentVariables       1 calls
12&#062;       10 ms  ComputeCLOutputs                           1 calls
12&#062;       16 ms  PrepareForBuild                            1 calls
12&#062;       53 ms  WarnCompileDuplicatedFilename              1 calls
12&#062;      154 ms  PostBuildEvent                             1 calls
12&#062;      295 ms  CoreCppClean                               1 calls
12&#062;      301 ms  Manifest                                   1 calls
12&#062;      302 ms  _Manifest                                  1 calls
12&#062;      565 ms  ResourceCompile                            1 calls
12&#062;      651 ms  _MASM                                      2 calls
12&#062;     4252 ms  Link                                       1 calls
12&#062;    320559 ms  ClCompile                                  1 calls
[/code]
Output is per-project.]]></description>
		<content:encoded><![CDATA[<p>@Roman M:<br />
Timing can be enabled by setting:<br />
Tools-&gt;Options-&gt;Projects and Solutions-&gt;VC++ Project Settings-&gt;Build Timing<br />
(IIRC at least since VS 2010, but might be even earlier)</p>
<p>Output looks like</p>
<pre class="brush: plain; title: ; notranslate">
12&gt;Project Performance Summary:
12&gt;    326932 ms  C:\Dan\Klimax-tools\tools\net\EmuleMorphXT\MorphXT\emule100.vcxproj   1 calls
12&gt;              326932 ms  Rebuild                                    1 calls

12&gt;Target Performance Summary:
12&gt;        0 ms  AfterRebuild                               1 calls
12&gt;        0 ms  ResolveReferences                          1 calls
12&gt;        0 ms  SelectClCompile                            1 calls
12&gt;        0 ms  _CheckForCompileOutputs                    1 calls
12&gt;        0 ms  GetResolvedWinMD                           1 calls
12&gt;        0 ms  CleanPublishFolder                         1 calls
12&gt;        0 ms  CleanReferencedProjects                    1 calls
12&gt;        0 ms  _PrepareForBuild                           1 calls
12&gt;        0 ms  _Midl                                      1 calls
12&gt;        0 ms  BuildCompile                               1 calls
12&gt;        0 ms  ComputeManifestGeneratedLinkerInputs       1 calls
12&gt;        0 ms  BeforeClean                                1 calls
12&gt;        0 ms  CreateCustomManifestResourceNames          1 calls
12&gt;        0 ms  AfterCppClean                              1 calls
12&gt;        0 ms  BeforeLink                                 1 calls
12&gt;        0 ms  AfterBuild                                 1 calls
12&gt;        0 ms  AfterBuildCompileEvent                     1 calls
12&gt;        0 ms  _BuildLinkAction                           1 calls
12&gt;        0 ms  BeforeResourceCompile                      1 calls
12&gt;        0 ms  AfterMidl                                  1 calls
12&gt;        0 ms  PreLinkEvent                               1 calls
12&gt;        0 ms  _ClCompile                                 1 calls
12&gt;        0 ms  AfterClean                                 1 calls
12&gt;        0 ms  SelectCustomBuild                          1 calls
12&gt;        0 ms  AfterClCompile                             1 calls
12&gt;        0 ms  _CopySourceItemsToOutputDirectory          1 calls
12&gt;        0 ms  AfterResourceCompile                       1 calls
12&gt;        0 ms  ComputeCustomBuildOutput                   1 calls
12&gt;        0 ms  _Xsd                                       1 calls
12&gt;        0 ms  AfterBuildGenerateSources                  1 calls
12&gt;        0 ms  Rebuild                                    1 calls
12&gt;        0 ms  MakeDirsForBscMake                         1 calls
12&gt;        0 ms  BeforeRebuild                              1 calls
12&gt;        0 ms  MakeDirsForResourceCompile                 1 calls
12&gt;        0 ms  _ResourceCompile                           1 calls
12&gt;        0 ms  ComputeLinkInputsFromProject               1 calls
12&gt;        0 ms  BeforeCppClean                             1 calls
12&gt;        0 ms  _Link                                      1 calls
12&gt;        0 ms  BuildLinkTraverse                          1 calls
12&gt;        0 ms  PrepareForRun                              1 calls
12&gt;        0 ms  _XdcMake                                   1 calls
12&gt;        0 ms  CreateSatelliteAssemblies                  1 calls
12&gt;        0 ms  MakeDirsForManifest                        1 calls
12&gt;        0 ms  SelectResourceCompile                      1 calls
12&gt;        0 ms  ExpandSDKReferences                        1 calls
12&gt;        0 ms  BuildCompileTraverse                       1 calls
12&gt;        0 ms  _GenerateSatelliteAssemblyInputs           1 calls
12&gt;        0 ms  _Deploy                                    1 calls
12&gt;        0 ms  ComputeMIDLGeneratedCompileInputs          1 calls
12&gt;        0 ms  CppClean                                   1 calls
12&gt;        0 ms  PrepareResourceNames                       1 calls
12&gt;        0 ms  AfterBuildGenerateSourcesEvent             1 calls
12&gt;        0 ms  _SplitProjectReferencesByFileExistence     1 calls
12&gt;        0 ms  BeforeClCompile                            1 calls
12&gt;        0 ms  _SelectedFiles                             1 calls
12&gt;        0 ms  AfterResolveReferences                     1 calls
12&gt;        0 ms  BeforeResolveReferences                    1 calls
12&gt;        0 ms  AfterLink                                  1 calls
12&gt;        0 ms  _ALink                                     1 calls
12&gt;        0 ms  PreBuildEvent                              1 calls
12&gt;        0 ms  MakeDirsForMidl                            1 calls
12&gt;        0 ms  _BscMake                                   1 calls
12&gt;        0 ms  ResolveSDKReferences                       1 calls
12&gt;        0 ms  _BuildGenerateSourcesAction                1 calls
12&gt;        0 ms  _Appverifier                               1 calls
12&gt;        0 ms  ComputeMASMOutput                          1 calls
12&gt;        0 ms  Clean                                      1 calls
12&gt;        0 ms  ComputeRCGeneratedLinkInputs               1 calls
12&gt;        0 ms  BuildGenerateSourcesTraverse               1 calls
12&gt;        0 ms  MakeDirsForXdcMake                         1 calls
12&gt;        0 ms  Build                                      1 calls
12&gt;        0 ms  BeforeBuildGenerateSources                 1 calls
12&gt;        0 ms  ResolvedXDCMake                            1 calls
12&gt;        0 ms  _PrepareForRebuild                         1 calls
12&gt;        0 ms  GetInstalledSDKLocations                   1 calls
12&gt;        0 ms  _BuildCompileAction                        1 calls
12&gt;        0 ms  BuildLink                                  1 calls
12&gt;        0 ms  ComputeLegacyManifestEmbedding             1 calls
12&gt;        0 ms  BuildGenerateSources                       1 calls
12&gt;        1 ms  PGInstrumentedClean                        1 calls
12&gt;        1 ms  ResolveAssemblyReferences                  1 calls
12&gt;        1 ms  CoreClean                                  1 calls
12&gt;        1 ms  ComputeLinkSwitches                        1 calls
12&gt;        1 ms  FinalizeBuildStatus                        1 calls
12&gt;        1 ms  CopyFilesToOutputDirectory                 1 calls
12&gt;        1 ms  AssignProjectConfiguration                 1 calls
12&gt;        1 ms  ComputeRCOutputs                           1 calls
12&gt;        1 ms  ResolveProjectReferences                   1 calls
12&gt;        1 ms  ComputeReferenceCLInput                    1 calls
12&gt;        1 ms  ComputeCLCompileGeneratedSbrFiles          1 calls
12&gt;        1 ms  GetCopyToOutputDirectoryXamlAppDefs        1 calls
12&gt;        1 ms  _PrepareForClean                           1 calls
12&gt;        1 ms  _CheckForInvalidConfigurationAndPlatform   1 calls
12&gt;        1 ms  ComputeManifestInputsTargets               1 calls
12&gt;        1 ms  GetFrameworkPaths                          1 calls
12&gt;        1 ms  GetReferenceAssemblyPaths                  1 calls
12&gt;        1 ms  GetCopyToOutputDirectoryItems              1 calls
12&gt;        1 ms  PlatformPrepareForBuild                    1 calls
12&gt;        1 ms  SplitResourcesByCulture                    1 calls
12&gt;        2 ms  _PrepareForReferenceResolution             1 calls
12&gt;        2 ms  MakeDirsForCl                              1 calls
12&gt;        2 ms  ComputeCLInputPDBName                      1 calls
12&gt;        2 ms  DoLinkOutputFilesMatch                     1 calls
12&gt;        2 ms  MakeDirsForLink                            1 calls
12&gt;        3 ms  ComputeCLGeneratedLinkInputs               1 calls
12&gt;        3 ms  ComputeCLCompileGeneratedXDCFiles          1 calls
12&gt;        3 ms  CheckInstalledVCLibsIPP                    1 calls
12&gt;        3 ms  SetBuildDefaultEnvironmentVariables        1 calls
12&gt;        3 ms  InitializeBuildStatus                      1 calls
12&gt;        4 ms  ComputeLinkImportLibraryOutputsForClean    1 calls
12&gt;        5 ms  RegisterOutput                             1 calls
12&gt;        5 ms  AssignTargetPaths                          1 calls
12&gt;        8 ms  SetCABuildNativeEnvironmentVariables       1 calls
12&gt;       10 ms  ComputeCLOutputs                           1 calls
12&gt;       16 ms  PrepareForBuild                            1 calls
12&gt;       53 ms  WarnCompileDuplicatedFilename              1 calls
12&gt;      154 ms  PostBuildEvent                             1 calls
12&gt;      295 ms  CoreCppClean                               1 calls
12&gt;      301 ms  Manifest                                   1 calls
12&gt;      302 ms  _Manifest                                  1 calls
12&gt;      565 ms  ResourceCompile                            1 calls
12&gt;      651 ms  _MASM                                      2 calls
12&gt;     4252 ms  Link                                       1 calls
12&gt;    320559 ms  ClCompile                                  1 calls
</pre>
<p>Output is per-project.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roman M.				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14036</link>
		<dc:creator><![CDATA[Roman M.]]></dc:creator>
		<pubDate>Mon, 06 Jan 2014 11:43:14 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14036</guid>
					<description><![CDATA[@Lo誰c Joly: I am aware of the tool you&#039;ve mentioned. Our codebase is Visual Studio C++ - only. Some time ago I tried it and couldn&#039;t get it running because of Microsoft&#039;s implementation of STL. Current &quot;README.txt&quot; of &quot;Include What You Use&quot;-Project  states:

&quot;IWYU, like Clang, does not yet handle some of the non-standard constructs in Microsoft&#039;s STL headers.&quot;

On the other hand, I found recent message: http://lists.cs.uiuc.edu/pipermail/cfe-dev/2013-October/032629.html in CLANG mailing list that states that support for MS-STL has improved, so maybe now it the time to give it another try. I just wish I had something similar from Microsoft.]]></description>
		<content:encoded><![CDATA[<p>@Lo誰c Joly: I am aware of the tool you&#8217;ve mentioned. Our codebase is Visual Studio C++ &#8211; only. Some time ago I tried it and couldn&#8217;t get it running because of Microsoft&#8217;s implementation of STL. Current &#8220;README.txt&#8221; of &#8220;Include What You Use&#8221;-Project  states:</p>
<p>&#8220;IWYU, like Clang, does not yet handle some of the non-standard constructs in Microsoft&#8217;s STL headers.&#8221;</p>
<p>On the other hand, I found recent message: <a href="http://lists.cs.uiuc.edu/pipermail/cfe-dev/2013-October/032629.html" rel="nofollow">http://lists.cs.uiuc.edu/pipermail/cfe-dev/2013-October/032629.html</a> in CLANG mailing list that states that support for MS-STL has improved, so maybe now it the time to give it another try. I just wish I had something similar from Microsoft.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Lo誰c Joly				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14035</link>
		<dc:creator><![CDATA[Lo誰c Joly]]></dc:creator>
		<pubDate>Sun, 05 Jan 2014 21:41:03 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14035</guid>
					<description><![CDATA[@Roman &quot;- we have absolutely _no_ tool support, so a developer have to _guess_ which header has greatest impact and is worth her time;&quot;

There is a tool whose puspose is to automate someway header files removal: http://code.google.com/p/include-what-you-use/ I&#039;ve not used it myself, so I cannot say how good I think it is. It has some quite complex heuristics to select which files should be included, and which fiels should not (it does not try to get to the absolute minimal). This article describes some of them: http://code.google.com/p/include-what-you-use/wiki/WhyIWYUIsDifficult.]]></description>
		<content:encoded><![CDATA[<p>@Roman &#8220;- we have absolutely _no_ tool support, so a developer have to _guess_ which header has greatest impact and is worth her time;&#8221;</p>
<p>There is a tool whose puspose is to automate someway header files removal: <a href="http://code.google.com/p/include-what-you-use/" rel="nofollow">http://code.google.com/p/include-what-you-use/</a> I&#8217;ve not used it myself, so I cannot say how good I think it is. It has some quite complex heuristics to select which files should be included, and which fiels should not (it does not try to get to the absolute minimal). This article describes some of them: <a href="http://code.google.com/p/include-what-you-use/wiki/WhyIWYUIsDifficult" rel="nofollow">http://code.google.com/p/include-what-you-use/wiki/WhyIWYUIsDifficult</a>.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roman M.				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14026</link>
		<dc:creator><![CDATA[Roman M.]]></dc:creator>
		<pubDate>Sat, 04 Jan 2014 13:30:38 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14026</guid>
					<description><![CDATA[@Jussi: nice script you have there! I am not aware of something similar Visual C++. Unfortunately your blog-post didn&#039;t reveal whether good compilation throughput is due to PIMPL or just because those CPPs define base classes and naturally have no or small dependencies. the mere fact of such big compile throughput variation in diverse projects suggests that solving compile time issues is hard. Your measurement, while offering interesting insights, lacks information where is make sense to introduce Pimpl - the closer to class hierarchy root we get, the bigger impact can be expected. One would need some kind of directed header include graph weighted by compilation time of corresponding CPP.

On the side note: in my projects about 60% of build time is spent by the linker, but thats another story ;)]]></description>
		<content:encoded><![CDATA[<p>@Jussi: nice script you have there! I am not aware of something similar Visual C++. Unfortunately your blog-post didn&#8217;t reveal whether good compilation throughput is due to PIMPL or just because those CPPs define base classes and naturally have no or small dependencies. the mere fact of such big compile throughput variation in diverse projects suggests that solving compile time issues is hard. Your measurement, while offering interesting insights, lacks information where is make sense to introduce Pimpl &#8211; the closer to class hierarchy root we get, the bigger impact can be expected. One would need some kind of directed header include graph weighted by compilation time of corresponding CPP.</p>
<p>On the side note: in my projects about 60% of build time is spent by the linker, but thats another story ;)</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Jussi Pakkanen				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14022</link>
		<dc:creator><![CDATA[Jussi Pakkanen]]></dc:creator>
		<pubDate>Fri, 03 Jan 2014 13:47:09 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14022</guid>
					<description><![CDATA[@roman, the difference in compile speeds between pimpl&#039;d and non-pimpl&#039;d code bases can be huge. Not 10%. Not even 50%. The difference can be an order of magnitude. I made a measurement of different code bases a while ago:

http://voices.canonical.com/jussi.pakkanen/2013/08/23/comparing-build-speeds-of-different-code-bases/

This speed increase alone has massive customer value: programmers can get stuff done faster so you can create better products faster, fix bugs faster and so on. Once you have experienced near-instantaneous incremental build times in C++ you never want to go back to spending minutes at a time watching scrolling text in a terminal.]]></description>
		<content:encoded><![CDATA[<p>@roman, the difference in compile speeds between pimpl&#8217;d and non-pimpl&#8217;d code bases can be huge. Not 10%. Not even 50%. The difference can be an order of magnitude. I made a measurement of different code bases a while ago:</p>
<p><a href="http://voices.canonical.com/jussi.pakkanen/2013/08/23/comparing-build-speeds-of-different-code-bases/" rel="nofollow">http://voices.canonical.com/jussi.pakkanen/2013/08/23/comparing-build-speeds-of-different-code-bases/</a></p>
<p>This speed increase alone has massive customer value: programmers can get stuff done faster so you can create better products faster, fix bugs faster and so on. Once you have experienced near-instantaneous incremental build times in C++ you never want to go back to spending minutes at a time watching scrolling text in a terminal.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Roman M.				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14007</link>
		<dc:creator><![CDATA[Roman M.]]></dc:creator>
		<pubDate>Thu, 02 Jan 2014 15:50:40 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14007</guid>
					<description><![CDATA[Hello Herb, 
in my experience, using your advice at the current language state in large projects is unfortunately utopical and rarely pays off:

- dependency rules are often not obvious, so a conservative developer will rather include too much instead of risking a broken build;
- we have to sacrifice performance for a compile-time issue which has arguably zero customer value;
- we have absolutely _no_ tool support, so a developer have to _guess_ which header has greatest impact and is worth her time; 
- even if some issues were somehow located and fixed using PIMPL, a regression is just a matter of time;
- templates make sutuation much worse;

Some time ago I&#039;ve create an issue on User-Voice (http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2680137-make-header-include-refactoring-possible). I understand that creating good solution for compile-time issues is far from trivial, but currently I would probably invest in better hardware instead of wasting my time on PIMPL]]></description>
		<content:encoded><![CDATA[<p>Hello Herb,<br />
in my experience, using your advice at the current language state in large projects is unfortunately utopical and rarely pays off:</p>
<p>&#8211; dependency rules are often not obvious, so a conservative developer will rather include too much instead of risking a broken build;<br />
&#8211; we have to sacrifice performance for a compile-time issue which has arguably zero customer value;<br />
&#8211; we have absolutely _no_ tool support, so a developer have to _guess_ which header has greatest impact and is worth her time;<br />
&#8211; even if some issues were somehow located and fixed using PIMPL, a regression is just a matter of time;<br />
&#8211; templates make sutuation much worse;</p>
<p>Some time ago I&#8217;ve create an issue on User-Voice (<a href="http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2680137-make-header-include-refactoring-possible" rel="nofollow">http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2680137-make-header-include-refactoring-possible</a>). I understand that creating good solution for compile-time issues is far from trivial, but currently I would probably invest in better hardware instead of wasting my time on PIMPL</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Phil Nash				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14005</link>
		<dc:creator><![CDATA[Phil Nash]]></dc:creator>
		<pubDate>Thu, 02 Jan 2014 12:47:16 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14005</guid>
					<description><![CDATA[@Herb. This is not a response to your questions, but is pertinent to the topic.

I&#039;ve been following this series with interest to see if I can pick up any more tips in my war against build-time sapping dependencies. While it&#039;s all been good stuff and covered well I&#039;ve not seen anything new - yet I still suffer from productivity killing compile times in several projects I&#039;m working on (to be clear, these are mostly legacy code bases where it&#039;s too late for the large scale refactoring necessary to take advantage of some of these techniques on enough of the code-base - or the runtime cost is too high - e.g. with the pImpl idiom).
We&#039;ve had some success with pre-compiled headers - but also constantly have problems with them (VS2008 - has it finally got any better in more recent incarnations?).

In the first post you alluded to modules - which I think should be a huge win in this area. But when I asked Bjarne about it earlier this year he seemed to think they weren&#039;t even on the radar for C++17 at this point. Is that still the case? Can you give any more insight here? Will you really be covering it in an upcoming post?]]></description>
		<content:encoded><![CDATA[<p>@Herb. This is not a response to your questions, but is pertinent to the topic.</p>
<p>I&#8217;ve been following this series with interest to see if I can pick up any more tips in my war against build-time sapping dependencies. While it&#8217;s all been good stuff and covered well I&#8217;ve not seen anything new &#8211; yet I still suffer from productivity killing compile times in several projects I&#8217;m working on (to be clear, these are mostly legacy code bases where it&#8217;s too late for the large scale refactoring necessary to take advantage of some of these techniques on enough of the code-base &#8211; or the runtime cost is too high &#8211; e.g. with the pImpl idiom).<br />
We&#8217;ve had some success with pre-compiled headers &#8211; but also constantly have problems with them (VS2008 &#8211; has it finally got any better in more recent incarnations?).</p>
<p>In the first post you alluded to modules &#8211; which I think should be a huge win in this area. But when I asked Bjarne about it earlier this year he seemed to think they weren&#8217;t even on the radar for C++17 at this point. Is that still the case? Can you give any more insight here? Will you really be covering it in an upcoming post?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Phil Nash				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-14004</link>
		<dc:creator><![CDATA[Phil Nash]]></dc:creator>
		<pubDate>Thu, 02 Jan 2014 12:39:02 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-14004</guid>
					<description><![CDATA[@Matthieu (&#038; @herb) the fixed sized block of storage with placement new (and explicit destructor) is the usual solution. As Herb says adding a bit of extra headroom is usually a good idea.
Another good idea is to put a static assert in the implementation to make sure the compiler tells you if that size ever becomes too small.

However, it may also be worth considering using a pool allocator, or some other more efficient allocator (I&#039;ve found tbb&#039;s scalable_allocator to be a very good general purpose allocator) to keep the size dynamic (and thus always correct), but with a much smaller overhead. You can&#039;t beat the near zero overhead of the obtrusive storage block but a decent allocator may be good enough for a lot of cases where the std allocator isn&#039;t.]]></description>
		<content:encoded><![CDATA[<p>@Matthieu (&amp; @herb) the fixed sized block of storage with placement new (and explicit destructor) is the usual solution. As Herb says adding a bit of extra headroom is usually a good idea.<br />
Another good idea is to put a static assert in the implementation to make sure the compiler tells you if that size ever becomes too small.</p>
<p>However, it may also be worth considering using a pool allocator, or some other more efficient allocator (I&#8217;ve found tbb&#8217;s scalable_allocator to be a very good general purpose allocator) to keep the size dynamic (and thus always correct), but with a much smaller overhead. You can&#8217;t beat the near zero overhead of the obtrusive storage block but a decent allocator may be good enough for a lot of cases where the std allocator isn&#8217;t.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: PiotrP				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-13989</link>
		<dc:creator><![CDATA[PiotrP]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 17:45:42 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-13989</guid>
					<description><![CDATA[1) I think tightest coupling in cpp is friendship(it gives private members access to non related class/methods). Inheritance is second.

2) Relationship with B can be moved to impl, since B has no virtual functions and it&#039;s private base class of X.
This modification doesn&#039;t change public interface of X.

[code]
//x.h

#include &#034;a.h&#034;  // class A (has virtual functions)
class B;  // class B (has no virtual functions) - forward declared
class C;
class E;

class X : public A{
public:
       X( const C&#038; );
    B  f( int, char* );
    C  f( int, C );
    C&#038; g( B );
    E  h( E );
    ~X();
    virtual std::ostream&#038; print( std::ostream&#038; ) const;

private:
    struct impl;
    std::unique_ptr&#060;impl&#062; pimpl;   // ptr to a forward-declared class
};
[/code]

[code]
//x.cpp
#include &#034;b.h&#034;
struct X::impl: public B{
    /* ... */
}
X::X( const C&#038; ) : pimpl{ make_unique&#060;X::impl&#062;(/*...*/) } { }
X::~X() = default;

[/code]

After changes all calls of B methods in X should be redirected to impl. 
To make it work B should be public base of X::impl. If B has protected members, such calls should be enclosed by public functions to allow access from X. Another way to do it is to add friendship between X::impl and X (B can remain private base of X::impl).]]></description>
		<content:encoded><![CDATA[<p>1) I think tightest coupling in cpp is friendship(it gives private members access to non related class/methods). Inheritance is second.</p>
<p>2) Relationship with B can be moved to impl, since B has no virtual functions and it&#8217;s private base class of X.<br />
This modification doesn&#8217;t change public interface of X.</p>
<pre class="brush: plain; title: ; notranslate">
//x.h

#include &quot;a.h&quot;  // class A (has virtual functions)
class B;  // class B (has no virtual functions) - forward declared
class C;
class E;

class X : public A{
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    ~X();
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

private:
    struct impl;
    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class
};
</pre>
<pre class="brush: plain; title: ; notranslate">
//x.cpp
#include &quot;b.h&quot;
struct X::impl: public B{
    /* ... */
}
X::X( const C&amp; ) : pimpl{ make_unique&lt;X::impl&gt;(/*...*/) } { }
X::~X() = default;

</pre>
<p>After changes all calls of B methods in X should be redirected to impl.<br />
To make it work B should be public base of X::impl. If B has protected members, such calls should be enclosed by public functions to allow access from X. Another way to do it is to add friendship between X::impl and X (B can remain private base of X::impl).</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Herb Sutter				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-13988</link>
		<dc:creator><![CDATA[Herb Sutter]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 15:31:18 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-13988</guid>
					<description><![CDATA[@Matthieu: Yes, that&#039;s basically what you&#039;d need to do to avoid the allocation overhead in Pimpl -- have a block of storage in the class of sufficient size, perhaps with extra space so that you can add some extra members in the future without causing an ABI breakage or recompilation.

Edited to add: BTW, I covered this topic in GotW #28 back in 1997. That one will (eventually) get updated too.]]></description>
		<content:encoded><![CDATA[<p>@Matthieu: Yes, that&#8217;s basically what you&#8217;d need to do to avoid the allocation overhead in Pimpl &#8212; have a block of storage in the class of sufficient size, perhaps with extra space so that you can add some extra members in the future without causing an ABI breakage or recompilation.</p>
<p>Edited to add: BTW, I covered this topic in GotW #28 back in 1997. That one will (eventually) get updated too.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: mjklaim				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-13986</link>
		<dc:creator><![CDATA[mjklaim]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 13:55:00 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-13986</guid>
					<description><![CDATA[1. Inheritance.
2. X::impl could inherit from B, in the cpp file, which would allow us to move  #include &quot;b.h&quot;  in the cpp file.
This is because B is not part of the public interface, so it&#039;s an implementation detail, AND it don&#039;t have virtual functions, which is a kind of externally available interface.
For the same reasons, we can&#039;t remove A from the interface so it&#039;s include needs to stay here.]]></description>
		<content:encoded><![CDATA[<p>1. Inheritance.<br />
2. X::impl could inherit from B, in the cpp file, which would allow us to move  #include &#8220;b.h&#8221;  in the cpp file.<br />
This is because B is not part of the public interface, so it&#8217;s an implementation detail, AND it don&#8217;t have virtual functions, which is a kind of externally available interface.<br />
For the same reasons, we can&#8217;t remove A from the interface so it&#8217;s include needs to stay here.</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matthieu M.				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-13985</link>
		<dc:creator><![CDATA[Matthieu M.]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 13:45:55 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-13985</guid>
					<description><![CDATA[JG: Friendship is the tightest coupling, followed by inheritance; thus the guideline, prefer composition over inheritance.

Guru: Given the big clue (read the comments) and the previous appetizer, it seems obvious that X need not inherit from B. Since we are already using PIMPL, all uses of B should thus move to the source file and therefore the include of B can be removed. B will still need to be forward declared since it is mentioned in the interface.

Question: I see here the use of unique_ptr, which requires a separate allocation. I have wondered a couple times how to get rid of this separate allocation (it slows down the construction and hurts cache friendliness) and I could only come up with the use of aligned_storage for a raw block of memory (of predetermined size) in X. However the need to suitably size this block implies the issue of ABI breakage if the size need ever change, so this is less stable ABI wise (but still insulates the client from most headers). Any thoughts ?]]></description>
		<content:encoded><![CDATA[<p>JG: Friendship is the tightest coupling, followed by inheritance; thus the guideline, prefer composition over inheritance.</p>
<p>Guru: Given the big clue (read the comments) and the previous appetizer, it seems obvious that X need not inherit from B. Since we are already using PIMPL, all uses of B should thus move to the source file and therefore the include of B can be removed. B will still need to be forward declared since it is mentioned in the interface.</p>
<p>Question: I see here the use of unique_ptr, which requires a separate allocation. I have wondered a couple times how to get rid of this separate allocation (it slows down the construction and hurts cache friendliness) and I could only come up with the use of aligned_storage for a raw block of memory (of predetermined size) in X. However the need to suitably size this block implies the issue of ABI breakage if the size need ever change, so this is less stable ABI wise (but still insulates the client from most headers). Any thoughts ?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: Matt Fioravante				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-13983</link>
		<dc:creator><![CDATA[Matt Fioravante]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 06:00:33 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-13983</guid>
					<description><![CDATA[Hi Herb, this is a great topic. I&#039;ve submitted a proposal to further reduce compile times and increase encapsulation by allowing the programmer to define additional non-virtual private methods outside of class scope. It&#039;s an artificial limit that just makes class design less flexible and requires unnecessary recompilation. 

https://github.com/fmatthew5876/stdcxx-privext

Do you have any opinion about this idea?]]></description>
		<content:encoded><![CDATA[<p>Hi Herb, this is a great topic. I&#8217;ve submitted a proposal to further reduce compile times and increase encapsulation by allowing the programmer to define additional non-virtual private methods outside of class scope. It&#8217;s an artificial limit that just makes class design less flexible and requires unnecessary recompilation. </p>
<p><a href="https://github.com/fmatthew5876/stdcxx-privext" rel="nofollow">https://github.com/fmatthew5876/stdcxx-privext</a></p>
<p>Do you have any opinion about this idea?</p>
]]></content:encoded>
					</item>
						<item>
				<title>
				By: germinolegrand				</title>
				<link>https://herbsutter.com/2013/12/31/gotw-7c-minimizing-compile-time-dependencies-part-3/#comment-13981</link>
		<dc:creator><![CDATA[germinolegrand]]></dc:creator>
		<pubDate>Wed, 01 Jan 2014 03:23:53 +0000</pubDate>
		<guid isPermaLink="false">http://herbsutter.com/?p=2387#comment-13981</guid>
					<description><![CDATA[1) Inheritance is the tightest coupling you can ever find in C++ (inheritance with virtual overriding really is the most complicated dependency to hide).
The sencond-tightest is membership. But you already talked about it in part #7b, we can get rid of it with pimpl idiom if it&#039;s private.

These are the ones that determine the size of the class, which is what the compiler always need. Interestingly, these also are the ones that can&#039;t be recursive, thus it makes it a solvable problem (no cyclic inclusion) without any indirection.

2) The private inheritance to class B, that has no virtual functions, can be transformed into a private member. It has no consequence on the size, unless sizeof B is zero (as a member it is required to be at least 1 if i make no mistake). Anyway, if it is private member, it can become a member of the pimpl and simply disappear from class X.

Another way of having class B disappear from class X, but keeping inheriting from class B (perhaps to access some protected things, or to keep its zero size), is to simply make struct impl publicly inherit from class B (so that it can be accessed from class X, but needing some proxy functions in struct impl to access the protected part of class B).

Once any of those two solutions are applied, the #include &quot;B.h&quot; can be removed from x.h and added in x.cpp.

It&#039;s worth mentionning that the order in which class X inherits from class A then from class B permits to preserve construction order while sending class B to the pimpl. If class B really needed to be constructed before (or deleted after) class A, this wouldn&#039;t be possible. It&#039;s so easy to mess up the construction/destruction order by playing with dependancies.

The code for x.h now looks like this (a forward-declaration to class B is needed for the f function):
[code]
//  x.h: after converting to use a Pimpl to hide implementation details
//
#include &#060;iosfwd&#062;
#include &#060;memory&#062;
#include &#034;a.h&#034;  // class A (has virtual functions)
class B;
class C;
class E;

class X : public A {
public:
       X( const C&#038; );
    B  f( int, char* );
    C  f( int, C );
    C&#038; g( B );
    E  h( E );
    virtual std::ostream&#038; print( std::ostream&#038; ) const;

private:
    struct impl;
    std::unique_ptr&#060;impl&#062; pimpl;   // ptr to a forward-declared class
};

std::ostream&#038; operator&#060;&#060;( std::ostream&#038; os, const X&#038; x ) {
    return x.print(os);
}
[/code]
and the x.cpp like that :
[code]
//  Implementation file x.cpp
//
#include &#060;list&#062;
#include &#034;b.h&#034;  // class B (has no virtual functions)
#include &#034;c.h&#034;  // class C
#include &#034;d.h&#034;  // class D
using namespace std;

struct X::impl: public B {
    std::list&#060;C&#062; clist;
    D            d;
};

X::X() : pimpl{ make_unique&#060;X::impl&#062;(/*...*/) } { }
X::~X() =default;
[/code]


The last trick is not needed in the GotW question, but might be interesting. What if class B had virtual functions overrided in class X ? The solution may have an extra cost, with crossed dependancies between class X and struct impl.

First, the inheritance is changed, same as before, instead of class X, struct impl will inherit from class B. The overriding functions will be located in struct impl.

Then, everything depends on what is in the overriding functions. If the scope of struct impl is enough to implement them (for example it only needs to play with the members of the pimpl idiom), all is fine, nothing to do, no extra cost.

On the contrary, if it needs some access to class A or class X (eg. call a function in the (virtual) interface, or access to a member not in struct impl), there will come the necessary dependancy to class X. An extra member of impl will have to be added : a reference to an X (the X constructor will pass *this to the impl constructor). If needed, class X will be added a friend class impl; declaration so that class impl can access private things of class X it needs.

One of the drawbacks (not often a problem) is that a reference to a B can no longer be dynamicly casted into a reference to an A or an X.

I wish you all a happy new year =).]]></description>
		<content:encoded><![CDATA[<p>1) Inheritance is the tightest coupling you can ever find in C++ (inheritance with virtual overriding really is the most complicated dependency to hide).<br />
The sencond-tightest is membership. But you already talked about it in part #7b, we can get rid of it with pimpl idiom if it&#8217;s private.</p>
<p>These are the ones that determine the size of the class, which is what the compiler always need. Interestingly, these also are the ones that can&#8217;t be recursive, thus it makes it a solvable problem (no cyclic inclusion) without any indirection.</p>
<p>2) The private inheritance to class B, that has no virtual functions, can be transformed into a private member. It has no consequence on the size, unless sizeof B is zero (as a member it is required to be at least 1 if i make no mistake). Anyway, if it is private member, it can become a member of the pimpl and simply disappear from class X.</p>
<p>Another way of having class B disappear from class X, but keeping inheriting from class B (perhaps to access some protected things, or to keep its zero size), is to simply make struct impl publicly inherit from class B (so that it can be accessed from class X, but needing some proxy functions in struct impl to access the protected part of class B).</p>
<p>Once any of those two solutions are applied, the #include &#8220;B.h&#8221; can be removed from x.h and added in x.cpp.</p>
<p>It&#8217;s worth mentionning that the order in which class X inherits from class A then from class B permits to preserve construction order while sending class B to the pimpl. If class B really needed to be constructed before (or deleted after) class A, this wouldn&#8217;t be possible. It&#8217;s so easy to mess up the construction/destruction order by playing with dependancies.</p>
<p>The code for x.h now looks like this (a forward-declaration to class B is needed for the f function):</p>
<pre class="brush: plain; title: ; notranslate">
//  x.h: after converting to use a Pimpl to hide implementation details
//
#include &lt;iosfwd&gt;
#include &lt;memory&gt;
#include &quot;a.h&quot;  // class A (has virtual functions)
class B;
class C;
class E;

class X : public A {
public:
       X( const C&amp; );
    B  f( int, char* );
    C  f( int, C );
    C&amp; g( B );
    E  h( E );
    virtual std::ostream&amp; print( std::ostream&amp; ) const;

private:
    struct impl;
    std::unique_ptr&lt;impl&gt; pimpl;   // ptr to a forward-declared class
};

std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const X&amp; x ) {
    return x.print(os);
}
</pre>
<p>and the x.cpp like that :</p>
<pre class="brush: plain; title: ; notranslate">
//  Implementation file x.cpp
//
#include &lt;list&gt;
#include &quot;b.h&quot;  // class B (has no virtual functions)
#include &quot;c.h&quot;  // class C
#include &quot;d.h&quot;  // class D
using namespace std;

struct X::impl: public B {
    std::list&lt;C&gt; clist;
    D            d;
};

X::X() : pimpl{ make_unique&lt;X::impl&gt;(/*...*/) } { }
X::~X() =default;
</pre>
<p>The last trick is not needed in the GotW question, but might be interesting. What if class B had virtual functions overrided in class X ? The solution may have an extra cost, with crossed dependancies between class X and struct impl.</p>
<p>First, the inheritance is changed, same as before, instead of class X, struct impl will inherit from class B. The overriding functions will be located in struct impl.</p>
<p>Then, everything depends on what is in the overriding functions. If the scope of struct impl is enough to implement them (for example it only needs to play with the members of the pimpl idiom), all is fine, nothing to do, no extra cost.</p>
<p>On the contrary, if it needs some access to class A or class X (eg. call a function in the (virtual) interface, or access to a member not in struct impl), there will come the necessary dependancy to class X. An extra member of impl will have to be added : a reference to an X (the X constructor will pass *this to the impl constructor). If needed, class X will be added a friend class impl; declaration so that class impl can access private things of class X it needs.</p>
<p>One of the drawbacks (not often a problem) is that a reference to a B can no longer be dynamicly casted into a reference to an A or an X.</p>
<p>I wish you all a happy new year =).</p>
]]></content:encoded>
					</item>
			</channel>
</rss>
